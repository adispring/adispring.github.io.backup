{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/favicon.ico","path":"favicon.ico","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.editorconfig","hash":"8570735a8d8d034a3a175afd1dd40b39140b3e6a","modified":1591401281312},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1591401281313},{"_id":"themes/next/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1591401281314},{"_id":"themes/next/.gitignore","hash":"56f3470755c20311ddd30d421b377697a6e5e68b","modified":1591401281319},{"_id":"themes/next/.stylintrc","hash":"2cf4d637b56d8eb423f59656a11f6403aa90f550","modified":1591401281320},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1591401281320},{"_id":"themes/next/.travis.yml","hash":"ecca3b919a5b15886e3eca58aa84aafc395590da","modified":1591401281320},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1591401281321},{"_id":"themes/next/README.md","hash":"9b4b7d66aca47f9c65d6321b14eef48d95c4dff1","modified":1591401281320},{"_id":"themes/next/_config.yml","hash":"06ce82ef29a5b1a3c7e3cbf4b0dc6e6bdedccd50","modified":1591401281320},{"_id":"themes/next/gulpfile.js","hash":"1b4fc262b89948937b9e3794de812a7c1f2f3592","modified":1591401281325},{"_id":"themes/next/package.json","hash":"62fad6de02adbbba9fb096cbe2dcc15fe25f2435","modified":1591401281342},{"_id":"source/favicon.ico","hash":"9d57c18f966349a241ef4c055ceac738dbce77da","modified":1591454644101},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1591401281299},{"_id":"themes/next/.git/config","hash":"e2ca9fa6f115d4406d24bf0df53fc26ce13e0c9b","modified":1591401281302},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1591401262984},{"_id":"themes/next/.git/index","hash":"f92a6ae88e58ddff018bba85b654ed7832029b97","modified":1591401322425},{"_id":"themes/next/.git/packed-refs","hash":"777eb68281fa87635f58dbe00e0280a37128a464","modified":1591401281297},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"e554931b98f251fd49ff1d2443006d9ea2c20461","modified":1591401281315},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"aa4cb7aff595ca628cb58160ee1eee117989ec4e","modified":1591401281315},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1a435c20ae8fa183d49bbf96ac956f7c6c25c8af","modified":1591401281317},{"_id":"themes/next/.github/config.yml","hash":"1d3f4e8794986817c0fead095c74f756d45f91ed","modified":1591401281318},{"_id":"themes/next/.github/issue-close-app.yml","hash":"7cba457eec47dbfcfd4086acd1c69eaafca2f0cd","modified":1591401281318},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"fca600ddef6f80c5e61aeed21722d191e5606e5b","modified":1591401281318},{"_id":"themes/next/.github/lock.yml","hash":"61173b9522ebac13db2c544e138808295624f7fd","modified":1591401281318},{"_id":"themes/next/.github/release-drafter.yml","hash":"3cc10ce75ecc03a5ce86b00363e2a17eb65d15ea","modified":1591401281319},{"_id":"themes/next/.github/mergeable.yml","hash":"0ee56e23bbc71e1e76427d2bd255a9879bd36e22","modified":1591401281319},{"_id":"themes/next/.github/stale.yml","hash":"fdf82de9284f8bc8e0b0712b4cc1cb081a94de59","modified":1591401281319},{"_id":"themes/next/.github/support.yml","hash":"d75db6ffa7b4ca3b865a925f9de9aef3fc51925c","modified":1591401281319},{"_id":"themes/next/docs/AUTHORS.md","hash":"10135a2f78ac40e9f46b3add3e360c025400752f","modified":1591401281322},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"c7a994b9542040317d8f99affa1405c143a94a38","modified":1591401281321},{"_id":"themes/next/docs/DATA-FILES.md","hash":"cddbdc91ee9e65c37a50bec12194f93d36161616","modified":1591401281322},{"_id":"themes/next/docs/INSTALLATION.md","hash":"af88bcce035780aaa061261ed9d0d6c697678618","modified":1591401281322},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1591401281322},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"8b6e4b2c9cfcb969833092bdeaed78534082e3e6","modified":1591401281323},{"_id":"themes/next/docs/MATH.md","hash":"d645b025ec7fb9fbf799b9bb76af33b9f5b9ed93","modified":1591401281323},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"94dc3404ccb0e5f663af2aa883c1af1d6eae553d","modified":1591401281322},{"_id":"themes/next/languages/de.yml","hash":"74c59f2744217003b717b59d96e275b54635abf5","modified":1591401281326},{"_id":"themes/next/languages/ar.yml","hash":"9815e84e53d750c8bcbd9193c2d44d8d910e3444","modified":1591401281326},{"_id":"themes/next/languages/es.yml","hash":"c64cf05f356096f1464b4b1439da3c6c9b941062","modified":1591401281327},{"_id":"themes/next/languages/en.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1591401281326},{"_id":"themes/next/languages/fa.yml","hash":"3676b32fda37e122f3c1a655085a1868fb6ad66b","modified":1591401281327},{"_id":"themes/next/languages/default.yml","hash":"45bc5118828bdc72dcaa25282cd367c8622758cb","modified":1591401281326},{"_id":"themes/next/languages/fr.yml","hash":"752bf309f46a2cd43890b82300b342d7218d625f","modified":1591401281327},{"_id":"themes/next/languages/id.yml","hash":"572ed855d47aafe26f58c73b1394530754881ec2","modified":1591401281327},{"_id":"themes/next/languages/hu.yml","hash":"b1ebb77a5fd101195b79f94de293bcf9001d996f","modified":1591401281327},{"_id":"themes/next/languages/ja.yml","hash":"0cf0baa663d530f22ff380a051881216d6adcdd8","modified":1591401281328},{"_id":"themes/next/languages/it.yml","hash":"44759f779ce9c260b895532de1d209ad4bd144bf","modified":1591401281328},{"_id":"themes/next/languages/ko.yml","hash":"0feea9e43cd399f3610b94d755a39fff1d371e97","modified":1591401281328},{"_id":"themes/next/languages/nl.yml","hash":"5af3473d9f22897204afabc08bb984b247493330","modified":1591401281328},{"_id":"themes/next/languages/pt-BR.yml","hash":"67555b1ba31a0242b12fc6ce3add28531160e35b","modified":1591401281328},{"_id":"themes/next/languages/pt.yml","hash":"718d131f42f214842337776e1eaddd1e9a584054","modified":1591401281329},{"_id":"themes/next/languages/ru.yml","hash":"e993d5ca072f7f6887e30fc0c19b4da791ca7a88","modified":1591401281329},{"_id":"themes/next/languages/tr.yml","hash":"fe793f4c2608e3f85f0b872fd0ac1fb93e6155e2","modified":1591401281329},{"_id":"themes/next/languages/uk.yml","hash":"3a6d635b1035423b22fc86d9455dba9003724de9","modified":1591401281329},{"_id":"themes/next/languages/zh-HK.yml","hash":"3789f94010f948e9f23e21235ef422a191753c65","modified":1591401281330},{"_id":"themes/next/languages/zh-CN.yml","hash":"a1f15571ee7e1e84e3cc0985c3ec4ba1a113f6f8","modified":1591401281329},{"_id":"themes/next/languages/vi.yml","hash":"93393b01df148dcbf0863f6eee8e404e2d94ef9e","modified":1591401281329},{"_id":"themes/next/languages/zh-TW.yml","hash":"8c09da7c4ec3fca2c6ee897b2eea260596a2baa1","modified":1591401281330},{"_id":"themes/next/layout/_layout.swig","hash":"6a6e92a4664cdb981890a27ac11fd057f44de1d5","modified":1591401281330},{"_id":"themes/next/layout/archive.swig","hash":"e4e31317a8df68f23156cfc49e9b1aa9a12ad2ed","modified":1591401281341},{"_id":"themes/next/layout/category.swig","hash":"1bde61cf4d2d171647311a0ac2c5c7933f6a53b0","modified":1591401281341},{"_id":"themes/next/layout/index.swig","hash":"7f403a18a68e6d662ae3e154b2c1d3bbe0801a23","modified":1591401281342},{"_id":"themes/next/layout/tag.swig","hash":"0dfb653bd5de980426d55a0606d1ab122bd8c017","modified":1591401281342},{"_id":"themes/next/layout/post.swig","hash":"2f6d992ced7e067521fdce05ffe4fd75481f41c5","modified":1591401281342},{"_id":"themes/next/layout/page.swig","hash":"db581bdeac5c75fabb0f17d7c5e746e47f2a9168","modified":1591401281342},{"_id":"themes/next/scripts/renderer.js","hash":"49a65df2028a1bc24814dc72fa50d52231ca4f05","modified":1591401281347},{"_id":"source/_posts/Debug-nodejs-in-Spacemacs.md","hash":"3f1cc954c8cf8070ff0a7a59d34da6d08770b20b","modified":1591454644042},{"_id":"source/categories/index.md","hash":"931766ef47014746752f2f7ba26b8bd51c447f1c","modified":1591454644100},{"_id":"source/_posts/.DS_Store","hash":"99ef528e6790235b3836c71c2c52a484b6998604","modified":1536480475785},{"_id":"source/_posts/Favoring-Curry.md","hash":"8da67418ff0f086cb8a65506d5cebdada81c94a3","modified":1591454644051},{"_id":"source/_posts/Functional-Programming-Abstract-and-Composition.md","hash":"7eda6152c7a7753f20447aac5585d3e5af9d89f1","modified":1591454644051},{"_id":"source/_posts/Fantasy-Land-Specification.md","hash":"23ec5cdd995790791b65debe7940007eb0f9a2db","modified":1591454644050},{"_id":"source/_posts/Haskell-Type-and-TypeClass.md","hash":"8656df2678d0e0df3b0c99a3b02a6c3096208c83","modified":1591454644086},{"_id":"source/_posts/Functor-Applicative-Monoid-Monad.md","hash":"b8daef9c851a476d371307dc7348ac79c886c30a","modified":1591454644085},{"_id":"source/_posts/Functions-in-Functional-Programming.md","hash":"124369b831a392cd43cbb70743d70902bcef23d4","modified":1591454644051},{"_id":"source/_posts/Hexo-Workflow.md","hash":"1e4d3e6c3329fcc707d5d63f3a0676da94289cd0","modified":1591454644086},{"_id":"source/_posts/Introducing-Ramda.md","hash":"090f1e8954763ffbd855f135cfb169bb183cea23","modified":1591454644086},{"_id":"source/_posts/Hexo-Init.md","hash":"55fd535eb677eda754097d5ad4c3c2bca30ecfc2","modified":1591454644086},{"_id":"source/_posts/Practical-Ramda-Recursion.md","hash":"611e8130023fb24d4058ecd371b410b502e15196","modified":1591454644087},{"_id":"source/_posts/Product-Softwares-in-nix.md","hash":"b1689482529f55427a22c8e9db02794509a6a2ac","modified":1591454644088},{"_id":"source/_posts/Ramda-SourceCode-Analyze.md","hash":"2ccfd56973956ce64df361d76decf5100b7e3125","modified":1591454644088},{"_id":"source/_posts/Ramda-map-filter-reduce-transduce.md","hash":"e9917f5388992e039b51350f25feace4f50d9981","modified":1591454644089},{"_id":"source/_posts/The-Philosophy-of-Ramda.md","hash":"860316e658aed05aa1730240c1852e6f88a4146f","modified":1591454644090},{"_id":"source/_posts/Thinking-in-Ramda-Declarative-Programming.md","hash":"b61ffeb796e49c8198f13011f931c0eab50b9f34","modified":1591454644090},{"_id":"source/_posts/Thinking-in-Ramda-Immutability-and-Arrays.md","hash":"e2845a4db452e0c4a37373dc3226762a7793f237","modified":1591454644091},{"_id":"source/_posts/Thinking-in-Ramda-Immutability-and-Objects.md","hash":"358d70eb114f8e48538b9eb77fde8a3a3a07e48d","modified":1591454644091},{"_id":"source/_posts/Thinking-in-Ramda-Combining-Functions.md","hash":"4ec866f82de9d8184093d91d2e793290b7ee309f","modified":1591454644090},{"_id":"source/_posts/Thinking-in-Ramda-Partial-Application.md","hash":"f5c42bb71fda4f4017e216e507d2fb337ed10760","modified":1591454644092},{"_id":"source/_posts/Thinking-in-Ramda-Lenses.md","hash":"aa13ca9be90702f05d9bb2b65ec31c695adbdee5","modified":1591454644091},{"_id":"source/_posts/Thinking-in-Ramda-Pointfree-Style.md","hash":"5f0d265893d7f8a76fcc705f08f43b65b700ccc2","modified":1591454644092},{"_id":"source/_posts/Thinking-in-Ramda-Wrap-Up.md","hash":"9927af2c704e581a8efa730ddbc979a229017892","modified":1591454644092},{"_id":"source/_posts/Thinking-in-Ramda-入门.md","hash":"7585d572a3c3aa2592541ccd54c6bf2ecf705084","modified":1591454644092},{"_id":"source/_posts/Transducers-Explained-Part-1.md","hash":"61920440e9d470b5577235c9a00615c11256371c","modified":1591454644092},{"_id":"source/_posts/Transducers-Explained-Pipelines.md","hash":"df1a1ead1f7af55458f62837c878dc7f738331ba","modified":1591454644099},{"_id":"source/_posts/What-Function-Should-I-Use.md","hash":"548cc2d7ccfc556d94c856b03b403ab910e9f79a","modified":1591454644099},{"_id":"source/_posts/Why-Curry-Helps.md","hash":"c33b6e585dd316830c81fc33cf6022a9b28e2a89","modified":1591454644100},{"_id":"source/_posts/Why-Ramda.md","hash":"20b936f0dacca948287525da16b5ff17d4a9de92","modified":1591454644100},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1591401281321},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1591401262987},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1591401262985},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1591401262988},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1591401262989},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1591401262986},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1591401262989},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1591401262986},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1591401262987},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1591401262984},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1591401262987},{"_id":"themes/next/.git/logs/HEAD","hash":"2a21a2ff7586c7c5e8c0359f902f8874e5680b0b","modified":1591401281301},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1591401262990},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"c3e6b8196c983c40fd140bdeca012d03e6e86967","modified":1591401281316},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d3efc0df0275c98440e69476f733097916a2d579","modified":1591401281317},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"12d99fb8b62bd9e34d9672f306c9ae4ace7e053e","modified":1591401281316},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"53df7d537e26aaf062d70d86835c5fd8f81412f3","modified":1591401281317},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"0bd2d696f62a997a11a7d84fec0130122234174e","modified":1591401281323},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"9c4fe2873123bf9ceacab5c50d17d8a0f1baef27","modified":1591401281323},{"_id":"themes/next/docs/ru/README.md","hash":"85dd68ed1250897a8e4a444a53a68c1d49eb7e11","modified":1591401281323},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"34b88784ec120dfdc20fa82aadeb5f64ef614d14","modified":1591401281324},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"5237a368ab99123749d724b6c379415f2c142a96","modified":1591401281323},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"fb23b85db6f7d8279d73ae1f41631f92f64fc864","modified":1591401281324},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"d3f03be036b75dc71cf3c366cd75aee7c127c874","modified":1591401281324},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"ca1030efdfca5e20f9db2e7a428998e66a24c0d0","modified":1591401281324},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"579c7bd8341873fb8be4732476d412814f1a3df7","modified":1591401281324},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"8b18f84503a361fc712b0fe4d4568e2f086ca97d","modified":1591401281325},{"_id":"themes/next/docs/zh-CN/README.md","hash":"c038629ff8f3f24e8593c4c8ecf0bef3a35c750d","modified":1591401281325},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b92585d251f1f9ebe401abb5d932cb920f9b8b10","modified":1591401281325},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"d9ce7331c1236bbe0a551d56cef2405e47e65325","modified":1591401281325},{"_id":"themes/next/layout/_partials/comments.swig","hash":"db6ab5421b5f4b7cb32ac73ad0e053fdf065f83e","modified":1591401281331},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"71655ca21907e9061b6e8ac52d0d8fbf54d0062b","modified":1591401281330},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"9c8dc0b8170679cdc1ee9ee8dbcbaebf3f42897b","modified":1591401281330},{"_id":"themes/next/layout/_macro/post.swig","hash":"090b5a9b6fca8e968178004cbd6cff205b7eba57","modified":1591401281330},{"_id":"themes/next/layout/_partials/footer.swig","hash":"700c3e7bd449bce51f6faee42c052e13ed5f8b3e","modified":1591401281331},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9876dbfc15713c7a47d4bcaa301f4757bd978269","modified":1591401281332},{"_id":"themes/next/layout/_partials/languages.swig","hash":"ba9e272f1065b8f0e8848648caa7dea3f02c6be1","modified":1591401281332},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"d1f2bfde6f1da51a2b35a7ab9e7e8eb6eefd1c6b","modified":1591401281334},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"83a40ce83dfd5cada417444fb2d6f5470aae6bb0","modified":1591401281334},{"_id":"themes/next/layout/_scripts/index.swig","hash":"cea942b450bcb0f352da78d76dc6d6f1d23d5029","modified":1591401281334},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"4d2c93c66e069852bb0e3ea2e268d213d07bfa3f","modified":1591401281335},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"b782eb2e34c0c15440837040b5d65b093ab6ec04","modified":1591401281337},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"ef38c213679e7b6d2a4116f56c9e55d678446069","modified":1591401281336},{"_id":"themes/next/layout/_scripts/three.swig","hash":"a4f42f2301866bd25a784a2281069d8b66836d0b","modified":1591401281336},{"_id":"themes/next/layout/_third-party/index.swig","hash":"70c3c01dd181de81270c57f3d99b6d8f4c723404","modified":1591401281338},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"311e5eceec9e949f1ea8d623b083cec0b8700ff2","modified":1591401281339},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"2731e262a6b88eaee2a3ca61e6a3583a7f594702","modified":1591401281339},{"_id":"themes/next/scripts/events/index.js","hash":"5743cde07f3d2aa11532a168a652e52ec28514fd","modified":1591401281343},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"aec50ed57b9d5d3faf2db3c88374f107203617e0","modified":1591401281345},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"703bdd142a671b4b67d3d9dfb4a19d1dd7e7e8f7","modified":1591401281345},{"_id":"themes/next/scripts/filters/locals.js","hash":"b193a936ee63451f09f8886343dcfdca577c0141","modified":1591401281346},{"_id":"themes/next/scripts/filters/minify.js","hash":"19985723b9f677ff775f3b17dcebf314819a76ac","modified":1591401281346},{"_id":"themes/next/scripts/filters/post.js","hash":"44ba9b1c0bdda57590b53141306bb90adf0678db","modified":1591401281346},{"_id":"themes/next/scripts/helpers/engine.js","hash":"bdb424c3cc0d145bd0c6015bb1d2443c8a9c6cda","modified":1591401281346},{"_id":"themes/next/scripts/helpers/font.js","hash":"40cf00e9f2b7aa6e5f33d412e03ed10304b15fd7","modified":1591401281347},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"5e11f30ddb5093a88a687446617a46b048fa02e5","modified":1591401281347},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"958e86b2bd24e4fdfcbf9ce73e998efe3491a71f","modified":1591401281347},{"_id":"themes/next/scripts/tags/button.js","hash":"8c6b45f36e324820c919a822674703769e6da32c","modified":1591401281347},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"94e0bbc7999b359baa42fa3731bdcf89c79ae2b3","modified":1591401281347},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f1826ade2d135e2f60e2d95cb035383685b3370c","modified":1591401281348},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"d902fd313e8d35c3cc36f237607c2a0536c9edf1","modified":1591401281348},{"_id":"themes/next/scripts/tags/label.js","hash":"fc5b267d903facb7a35001792db28b801cccb1f8","modified":1591401281348},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"983c6c4adea86160ecc0ba2204bc312aa338121d","modified":1591401281348},{"_id":"themes/next/scripts/tags/note.js","hash":"0a02bb4c15aec41f6d5f1271cdb5c65889e265d9","modified":1591401281348},{"_id":"themes/next/scripts/tags/pdf.js","hash":"8c613b39e7bff735473e35244b5629d02ee20618","modified":1591401281348},{"_id":"themes/next/scripts/tags/tabs.js","hash":"93d8a734a3035c1d3f04933167b500517557ba3e","modified":1591401281349},{"_id":"themes/next/scripts/tags/video.js","hash":"e5ff4c44faee604dd3ea9db6b222828c4750c227","modified":1591401281349},{"_id":"themes/next/source/css/_colors.styl","hash":"a8442520f719d3d7a19811cb3b85bcfd4a596e1f","modified":1591401281349},{"_id":"themes/next/source/css/_mixins.styl","hash":"e31a557f8879c2f4d8d5567ee1800b3e03f91f6e","modified":1591401281364},{"_id":"themes/next/source/css/main.styl","hash":"a3a3bbb5a973052f0186b3523911cb2539ff7b88","modified":1591401281369},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1591401281369},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1591401281369},{"_id":"themes/next/source/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1591401281369},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1591401281370},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1591401281370},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1591401281370},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1591401281370},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1591401281370},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1591401281370},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1591401281371},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1591401281371},{"_id":"themes/next/source/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1591401281371},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1591401281371},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1591401281371},{"_id":"themes/next/source/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1591401281371},{"_id":"themes/next/source/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1591401281372},{"_id":"themes/next/source/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1591401281372},{"_id":"themes/next/source/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1591401281372},{"_id":"themes/next/source/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1591401281373},{"_id":"themes/next/source/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1591401281373},{"_id":"source/_posts/Fantasy-Land-Specification/dependencies.png","hash":"1164059c4203741c9d5380574a604d944d947dab","modified":1591454644050},{"_id":"source/_posts/Fantasy-Land-Specification/logo.png","hash":"035120f812dbe84b3cfeedffdcf330f0d433d18d","modified":1591454644050},{"_id":"source/_posts/Functions-in-Functional-Programming/function.png","hash":"7c2940e61daa7067c85394ebaf95d3caf8e3fbe9","modified":1591454644053},{"_id":"source/_posts/Functions-in-Functional-Programming/function_composition.png","hash":"4676744ec4106362ad0c7cb41ef40030071a6455","modified":1591454644053},{"_id":"source/_posts/Functions-in-Functional-Programming/functions_composition.png","hash":"0968910a5b21509364c56d99d80b5d51921a3e8a","modified":1591454644055},{"_id":"source/_posts/Practical-Ramda-Recursion/quicksort.png","hash":"9d51e64433751c51201bf2097f140b261638c475","modified":1591454644088},{"_id":"source/_posts/Practical-Ramda-Recursion/fibonacci.jpg","hash":"ee089a4895e8c7139379bf98f5bdb65f3d5d5ad1","modified":1591454644087},{"_id":"source/_posts/Ramda-map-filter-reduce-transduce/mapFilterReduce.jpg","hash":"d823673b20964717e288c868bc9244058627b649","modified":1591454644089},{"_id":"source/_posts/Why-Ramda/rbudiharso_tweet-2.png","hash":"5ad8cd6d11df397dab08e4656efa524f86da06c8","modified":1591454644100},{"_id":"themes/next/.git/refs/heads/master","hash":"8df4d68e6c89f5df6e79d0c664e9003b2f945089","modified":1591401281300},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"000bad572d76ee95d9c0a78f9ccdc8d97cc7d4b4","modified":1591401281331},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"c70f8e71e026e878a4e9d5ab3bbbf9b0b23c240c","modified":1591401281331},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"9440d8a3a181698b80e1fa47f5104f4565d8cdf3","modified":1591401281331},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"810d544019e4a8651b756dd23e5592ee851eda71","modified":1591401281331},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"7dbe93b8297b746afb89700b4d29289556e85267","modified":1591401281331},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"ae2261bea836581918a1c2b0d1028a78718434e0","modified":1591401281332},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"d31f896680a6c2f2c3f5128b4d4dd46c87ce2130","modified":1591401281332},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"c851717497ca64789f2176c9ecd1dedab237b752","modified":1591401281332},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"9b7a66791d7822c52117fe167612265356512477","modified":1591401281332},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"954ad71536b6eb08bd1f30ac6e2f5493b69d1c04","modified":1591401281332},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"f79c44692451db26efce704813f7a8872b7e63a0","modified":1591401281333},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"8f14f3f8a1b2998d5114cc56b680fb5c419a6b07","modified":1591401281333},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"2b1a73556595c37951e39574df5a3f20b2edeaef","modified":1591401281333},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"ceba16b9bd3a0c5c8811af7e7e49d0f9dcb2f41e","modified":1591401281333},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"48430bd03b8f19c9b8cdb2642005ed67d56c6e0b","modified":1591401281333},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"f48a6a8eba04eb962470ce76dd731e13074d4c45","modified":1591401281333},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"c46849e0af8f8fb78baccd40d2af14df04a074af","modified":1591401281334},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"2be50f9bfb1c56b85b3b6910a7df27f51143632c","modified":1591401281333},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1591401281335},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1591401281335},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"077b5d66f6309f2e7dcf08645058ff2e03143e6c","modified":1591401281335},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"7f14ef43d9e82bc1efc204c5adf0b1dbfc919a9f","modified":1591401281335},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"1c910fc066c06d5fbbe9f2b0c47447539e029af7","modified":1591401281335},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"4790058691b7d36cf6d2d6b4e93795a7b8d608ad","modified":1591401281336},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"1472cabb0181f60a6a0b7fec8899a4d03dfb2040","modified":1591401281337},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"2fa2b51d56bfac6a1ea76d651c93b9c20b01c09b","modified":1591401281336},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"f910618292c63871ca2e6c6e66c491f344fa7b1f","modified":1591401281337},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"cba0e6e0fad08568a9e74ba9a5bee5341cfc04c1","modified":1591401281337},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"5adea065641e8c55994dd2328ddae53215604928","modified":1591401281336},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"f39a5bf3ce9ee9adad282501235e0c588e4356ec","modified":1591401281337},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b14908644225d78c864cd0a9b60c52407de56183","modified":1591401281338},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"d6ceb70648555338a80ae5724b778c8c58d7060d","modified":1591401281338},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"f7a9eca599a682479e8ca863db59be7c9c7508c8","modified":1591401281338},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"82f5b6822aa5ec958aa987b101ef860494c6cf1f","modified":1591401281338},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"be0a8eccf1f6dc21154af297fc79555343031277","modified":1591401281338},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"6c5976621efd5db5f7c4c6b4f11bc79d6554885f","modified":1591401281339},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"4791c977a730f29c846efcf6c9c15131b9400ead","modified":1591401281339},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"ecf751321e799f0fb3bf94d049e535130e2547aa","modified":1591401281339},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"4b1986e43d6abce13450d2b41a736dd6a5620a10","modified":1591401281340},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"d35a999d67f4c302f76fdf13744ceef3c6506481","modified":1591401281340},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"767b6c714c22588bcd26ba70b0fc19b6810cbacd","modified":1591401281340},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"ba0dbc06b9d244073a1c681ff7a722dcbf920b51","modified":1591401281340},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"b26ac2bfbe91dd88267f8b96aee6bb222b265b7a","modified":1591401281340},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"a17ace37876822327a2f9306a472974442c9005d","modified":1591401281340},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"f3c43664a071ff3c0b28bd7e59b5523446829576","modified":1591401281341},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"d56d5af427cdfecc33a0f62ee62c056b4e33d095","modified":1591401281340},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"5f6a966c509680dbfa70433f9d658cee59c304d7","modified":1591401281340},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"d30b0e255a8092043bac46441243f943ed6fb09b","modified":1591401281341},{"_id":"themes/next/scripts/events/lib/config.js","hash":"d34c6040b13649714939f59be5175e137de65ede","modified":1591401281343},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"6661c1c91c7cbdefc6a5e6a034b443b8811235a1","modified":1591401281343},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"f233d8d0103ae7f9b861344aa65c1a3c1de8a845","modified":1591401281344},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"a54708fd9309b4357c423a3730eb67f395344a5e","modified":1591401281344},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"2486f3e0150c753e5f3af1a3665d074704b8ee2c","modified":1591401281344},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"7f2d93af012c1e14b8596fecbfc7febb43d9b7f5","modified":1591401281344},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"4c0c99c7e0f00849003dfce02a131104fb671137","modified":1591401281344},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"7f8b92913d21070b489457fa5ed996d2a55f2c32","modified":1591401281344},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"e51dc3072c1ba0ea3008f09ecae8b46242ec6021","modified":1591401281345},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"d5fefc31fba4ab0188305b1af1feb61da49fdeb0","modified":1591401281345},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"6cbd85f9433c06bae22225ccf75ac55e04f2d106","modified":1591401281345},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"f4e694e5db81e57442c7e34505a416d818b3044a","modified":1591401281368},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"f70be8e229da7e1715c11dd0e975a2e71e453ac8","modified":1591401281368},{"_id":"themes/next/source/css/_variables/base.styl","hash":"818508748b7a62e02035e87fe58e75b603ed56dc","modified":1591401281369},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"62df49459d552bbf73841753da8011a1f5e875c8","modified":1591401281368},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"612ec843372dae709acb17112c1145a53450cc59","modified":1591401281368},{"_id":"themes/next/source/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1591401281372},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1591401281372},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1591401281376},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1591401281376},{"_id":"source/_posts/Debug-nodejs-in-Spacemacs/open-nodejs-repl.png","hash":"5203a6de75c04b7ebdc1dbe794910942a4403c37","modified":1591454644049},{"_id":"source/_posts/Functions-in-Functional-Programming/functions-in-memoize.png","hash":"dcf505dc228fa3c1e3f8185280cd3926e1af5071","modified":1591454644055},{"_id":"source/_posts/Transducers-Explained-Part-1/compose_transducers.png","hash":"b41daff12ec79f0cb8c551943602c22dbc20efbe","modified":1591454644094},{"_id":"source/_posts/Transducers-Explained-Part-1/reduce.png","hash":"98e9b9be0906b03c4e1e5d2373929bc757588884","modified":1591454644096},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"2a21a2ff7586c7c5e8c0359f902f8874e5680b0b","modified":1591401281301},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1591401281299},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"ca5e70662dcfb261c25191cc5db5084dcf661c76","modified":1591401281350},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"8e7b57a72e757cf95278239641726bb2d5b869d1","modified":1591401281350},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"2e3bf7baf383c9073ec5e67f157d3cb3823c0957","modified":1591401281355},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"a47725574e1bee3bc3b63b0ff2039cc982b17eff","modified":1591401281350},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"a1690e035b505d28bdef2b4424c13fc6312ab049","modified":1591401281358},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"7785bd756e0c4acede3a47fec1ed7b55988385a5","modified":1591401281364},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"681d33e3bc85bdca407d93b134c089264837378c","modified":1591401281358},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"0b2c4b78eead410020d7c4ded59c75592a648df8","modified":1591401281361},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"8f58570a1bbc34c4989a47a1b7d42a8030f38b06","modified":1591401281362},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"a2e9e00962e43e98ec2614d6d248ef1773bb9b78","modified":1591401281361},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"18ce72d90459c9aa66910ac64eae115f2dde3767","modified":1591401281362},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"b56367ea676ea8e8783ea89cd4ab150c7da7a060","modified":1591401281362},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"523fb7b653b87ae37fc91fc8813e4ffad87b0d7e","modified":1591401281362},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"b1f0fab7344a20ed6748b04065b141ad423cf4d9","modified":1591401281361},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"f6516d0f7d89dc7b6c6e143a5af54b926f585d82","modified":1591401281364},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"bb7ace23345364eb14983e860a7172e1683a4c94","modified":1591401281365},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"179e33b8ac7f4d8a8e76736a7e4f965fe9ab8b42","modified":1591401281364},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"6136da4bbb7e70cec99f5c7ae8c7e74f5e7c261a","modified":1591401281365},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"a717969829fa6ef88225095737df3f8ee86c286b","modified":1591401281365},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"7104b9cef90ca3b140d7a7afcf15540a250218fc","modified":1591401281365},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"e282df938bd029f391c466168d0e68389978f120","modified":1591401281367},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"e740deadcfc4f29c5cb01e40f9df6277262ba4e3","modified":1591401281368},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"70a4324b70501132855b5e59029acfc5d3da1ebd","modified":1591401281367},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"85da2f3006f4bef9a2199416ecfab4d288f848c4","modified":1591401281367},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"4d1c17345d2d39ef7698f7acf82dfc0f59308c34","modified":1591401281365},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"f0131db6275ceaecae7e1a6a3798b8f89f6c850d","modified":1591401281365},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"44f47c88c06d89d06f220f102649057118715828","modified":1591401281367},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"93db5dafe9294542a6b5f647643cb9deaced8e06","modified":1591401281366},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1591401281368},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"6ad168288b213cec357e9b5a97674ff2ef3a910c","modified":1591401281366},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"c48ccd8d6651fe1a01faff8f01179456d39ba9b1","modified":1591401281366},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"2b2e7b5cea7783c9c8bb92655e26a67c266886f0","modified":1591401281366},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1591401281374},{"_id":"source/_posts/Debug-nodejs-in-Spacemacs/import-lib.png","hash":"eec6ecd8d41b7282c158f71a7905b4c3d2f4897d","modified":1591454644047},{"_id":"source/_posts/Functions-in-Functional-Programming/closure.png","hash":"2e9629a47ac6c1cf570b6b4c984e232ca288e753","modified":1591454644053},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1591401281375},{"_id":"source/_posts/Transducers-Explained-Part-1/transduce.png","hash":"3e35bfb17c087708dd87808e66725640944077d2","modified":1591454644098},{"_id":"source/_posts/Debug-nodejs-in-Spacemacs/eval.png","hash":"7ac330a8094503408baaddec13cf1ca905c05912","modified":1591454644045},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1591401281375},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1591401281375},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"e771dcb0b4673e063c0f3e2d73e7336ac05bcd57","modified":1591401281352},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"2bd0eb1512415325653b26d62a4463e6de83c5ac","modified":1591401281351},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"2a21a2ff7586c7c5e8c0359f902f8874e5680b0b","modified":1591401281299},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"7504dbc5c70262b048143b2c37d2b5aa2809afa2","modified":1591401281351},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"d21d4ac1982c13d02f125a67c065412085a92ff2","modified":1591401281352},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"e75693f33dbc92afc55489438267869ae2f3db54","modified":1591401281353},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"fafc96c86926b22afba8bb9418c05e6afbc05a57","modified":1591401281350},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f49ca072b5a800f735e8f01fc3518f885951dd8e","modified":1591401281353},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"902569a9dea90548bec21a823dd3efd94ff7c133","modified":1591401281353},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"ded41fd9d20a5e8db66aaff7cc50f105f5ef2952","modified":1591401281353},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"72d495a88f7d6515af425c12cbc67308a57d88ea","modified":1591401281354},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"1e4190c10c9e0c9ce92653b0dbcec21754b0b69d","modified":1591401281354},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"6a97bcfa635d637dc59005be3b931109e0d1ead5","modified":1591401281354},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"d114b2a531129e739a27ba6271cfe6857aa9a865","modified":1591401281354},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"99e12c9ce3d14d4837e3d3f12fc867ba9c565317","modified":1591401281355},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"f5c2788a78790aca1a2f37f7149d6058afb539e0","modified":1591401281354},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"5b5649b9749e3fd8b63aef22ceeece0a6e1df605","modified":1591401281355},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"a760ee83ba6216871a9f14c5e56dc9bd0d9e2103","modified":1591401281355},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"65cb6edb69e94e70e3291e9132408361148d41d5","modified":1591401281354},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"8a7fc03a568b95be8d3337195e38bc7ec5ba2b23","modified":1591401281355},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"9f0b93d109c9aec79450c8a0cf4a4eab717d674d","modified":1591401281356},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"e2992846b39bf3857b5104675af02ba73e72eed5","modified":1591401281356},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"b49e9fbd3c182b8fc066b8c2caf248e3eb748619","modified":1591401281356},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9a878d0119785a2316f42aebcceaa05a120b9a7a","modified":1591401281356},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"454a4aebfabb4469b92a8cbb49f46c49ac9bf165","modified":1591401281356},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"e2d606f1ac343e9be4f15dbbaf3464bc4df8bf81","modified":1591401281357},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"0caf32492692ba8e854da43697a2ec8a41612194","modified":1591401281357},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"5f432a6ed9ca80a413c68b00e93d4a411abf280a","modified":1591401281357},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"e7a9fdb6478b8674b1cdf94de4f8052843fb71d9","modified":1591401281357},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b2fc519828fe89a1f8f03ff7b809ad68cd46f3d7","modified":1591401281358},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"44487d9ab290dc97871fa8dd4487016deb56e123","modified":1591401281359},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"45a239edca44acecf971d99b04f30a1aafbf6906","modified":1591401281357},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"1f0e7fbe80956f47087c2458ea880acf7a83078b","modified":1591401281359},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"2cb1876e9e0c9ac32160888af27b1178dbcb0616","modified":1591401281359},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"a793cfff86ad4af818faef04c18013077873f8f0","modified":1591401281357},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"fa0222197b5eee47e18ac864cdc6eac75678b8fe","modified":1591401281359},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"a05a4031e799bc864a4536f9ef61fe643cd421af","modified":1591401281360},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"a960a2dd587b15d3b3fe1b59525d6fa971c6a6ec","modified":1591401281360},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"9b479c2f9a9bfed77885e5093b8245cc5d768ec7","modified":1591401281360},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"a9cd93c36bae5af9223e7804963096274e8a4f03","modified":1591401281360},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"b3220db827e1adbca7880c2bb23e78fa7cbe95cb","modified":1591401281360},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"2a47f8a6bb589c2fb635e6c1e4a2563c7f63c407","modified":1591401281360},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"f71a3e86c05ea668b008cf05a81f67d92b6d65e4","modified":1591401281361},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"d3f73688bb7423e3ab0de1efdf6db46db5e34f80","modified":1591401281361},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"709d10f763e357e1472d6471f8be384ec9e2d983","modified":1591401281363},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"3b3acc5caa0b95a2598bef4eeacb21bab21bea56","modified":1591401281362},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"d7fce4b51b5f4b7c31d93a9edb6c6ce740aa0d6b","modified":1591401281363},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"35c871a809afa8306c8cde13651010e282548bc6","modified":1591401281362},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"e4d9a77ffe98e851c1202676940097ba28253313","modified":1591401281363},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"1d2778ca5aeeeafaa690dc2766b01b352ab76a02","modified":1591401281363},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"f23670f1d8e749f3e83766d446790d8fd9620278","modified":1591401281364},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"b49c64f8e9a6ca1c45c0ba98febf1974fdd03616","modified":1591401281363},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"9e4c0653cfd3cc6908fa0d97581bcf80861fb1e7","modified":1591401281364},{"_id":"themes/next/.git/objects/pack/pack-e1441db88d34c1162b8c40cb639e5b1bfae8bbbd.idx","hash":"155b79e2c7bbc8157daee71d5b9213964dbedf96","modified":1591401281284},{"_id":"source/_posts/Functions-in-Functional-Programming/pipeline-leaking.png","hash":"9b26533fadfa06b6996d0dddc324835972d09b80","modified":1591454644067},{"_id":"source/_posts/Functions-in-Functional-Programming/pipeline.png","hash":"aa689ce614b9d1a21ab76cd20f93a3ca4a761cf6","modified":1591454644084},{"_id":"themes/next/.git/objects/pack/pack-e1441db88d34c1162b8c40cb639e5b1bfae8bbbd.pack","hash":"364b89be4abafaa5e36c03dae005d0129b7dab54","modified":1591401281271},{"_id":"public/categories/index.html","hash":"1d1476a36dd3f0c4cefbdb53de5010cf48fa71bc","modified":1591455361539},{"_id":"public/2020/06/06/Hexo-Workflow/index.html","hash":"e5490d3fe606f8cb7687cc8106623e7a2178f002","modified":1591455361539},{"_id":"public/2017/10/15/Haskell-Type-and-TypeClass/index.html","hash":"62d4b624561495668803e46c418730c601c798b2","modified":1591455361539},{"_id":"public/2017/09/29/Functional-Programming-Abstract-and-Composition/index.html","hash":"6aa75615861cf02d72ff9ac67ad50ea21940a76d","modified":1591455361539},{"_id":"public/2017/07/29/Product-Softwares-in-nix/index.html","hash":"2e18f1227ba598c356d91b275017c0a97bd6e439","modified":1591455361539},{"_id":"public/2016/10/23/Ramda-map-filter-reduce-transduce/index.html","hash":"b63c780b1475152333bb1f4239abdc33f01923b1","modified":1591455361539},{"_id":"public/archives/index.html","hash":"c2ab3ec5d8603a2226f4a3a3746ec791fa33f515","modified":1591455361539},{"_id":"public/archives/page/2/index.html","hash":"30a868ac726463a2511636762372b8b5e971aafb","modified":1591455361539},{"_id":"public/archives/page/3/index.html","hash":"7099177eff428c60e77392abffbed88babf02000","modified":1591455361539},{"_id":"public/archives/2016/index.html","hash":"7c2bc6c76fc366e5932cd107431a1892901085c8","modified":1591455361540},{"_id":"public/archives/2016/10/index.html","hash":"7ec5777af8207bb6dfbc0e3e637b0c4c23ee071a","modified":1591455361540},{"_id":"public/archives/2016/11/index.html","hash":"16b76b84d199291086ec0e2e0eb161235c78ae3b","modified":1591455361540},{"_id":"public/archives/2017/index.html","hash":"ef8ac9650931f049890ebe603b88db6074099d66","modified":1591455361540},{"_id":"public/archives/2017/page/2/index.html","hash":"9fea26711056b55781ed06274bcdd3f090782b4d","modified":1591455361540},{"_id":"public/archives/2017/page/3/index.html","hash":"a29c7f23f7456ecc3570336d7c6be13e2b9adcaf","modified":1591455361540},{"_id":"public/archives/2017/06/index.html","hash":"39437d4e1392b4c5ac5b60cff9a082b1c64a6b07","modified":1591455361540},{"_id":"public/archives/2017/06/page/2/index.html","hash":"5205c24e11f15e257e746dc3701c5e9c02202853","modified":1591455361540},{"_id":"public/archives/2017/07/index.html","hash":"41cc572ff1276a0a77f65c122d0eb8cd1e761e26","modified":1591455361540},{"_id":"public/archives/2017/09/index.html","hash":"c2720dbf084dfbff8b58c59c2aab377676f80c84","modified":1591455361540},{"_id":"public/archives/2017/10/index.html","hash":"5375592d5ad490dec6fc140a7fc2fb4c05ebf4cd","modified":1591455361540},{"_id":"public/archives/2017/11/index.html","hash":"463a0a1679ae4b4686401472ad4217b3c6633bee","modified":1591455361540},{"_id":"public/archives/2017/12/index.html","hash":"2e7f3baecb13907dee8dc9823989de8a42863b64","modified":1591455361540},{"_id":"public/archives/2018/index.html","hash":"99a881d0ff356e43de7c30af00e53ccea1ad64ba","modified":1591455361540},{"_id":"public/archives/2018/09/index.html","hash":"4da2bf0c71ac1bf33e5d11497af2aa82cc1be0ed","modified":1591455361540},{"_id":"public/archives/2020/index.html","hash":"41c3f76043b14f8a17c8402acdd0b01b0679605c","modified":1591455361540},{"_id":"public/archives/2020/06/index.html","hash":"a840bbbcdb091097d160a2e3fcd3d2d879944256","modified":1591455361540},{"_id":"public/categories/Emacs/index.html","hash":"411e4a289b0f59deedda420b360bb38ad3cd9e3a","modified":1591455361540},{"_id":"public/categories/Ramda/index.html","hash":"036e2f63ac59717d0ebbf071bebff2b3d928193f","modified":1591455361540},{"_id":"public/categories/Functional-Programming/index.html","hash":"4e67a809f65918b5218c24ca4788b6cebd10f5f1","modified":1591455361541},{"_id":"public/categories/Haskell/index.html","hash":"5550592d8992b2a98a5fcb52f4be3830e0b98d64","modified":1591455361541},{"_id":"public/categories/Practical-Ramda/index.html","hash":"f548d790be23afa1182399abb5c595252bfbcd93","modified":1591455361541},{"_id":"public/categories/Thinking-in-Ramda/index.html","hash":"855bb6c260168122786b925ac1c066d601e37f89","modified":1591455361541},{"_id":"public/tags/Ramda/index.html","hash":"3ce136eec5e6482c5413cb36607c8145f4bac20f","modified":1591455361541},{"_id":"public/2018/09/09/Hexo-Init/index.html","hash":"bd2fb8fb1612272497dd716352b0a7e847777ed0","modified":1591455361541},{"_id":"public/2018/09/08/Fantasy-Land-Specification/index.html","hash":"4a07a2be87e3513c89ff56d6058cb6cb9b2267c2","modified":1591455361541},{"_id":"public/2017/12/16/The-Philosophy-of-Ramda/index.html","hash":"fb7147325faa238ccb440a09ab0a754fbf8ce2ee","modified":1591455361541},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/index.html","hash":"21196006f0c10e18725c81db109223e04507f277","modified":1591455361541},{"_id":"public/2017/11/11/Practical-Ramda-Recursion/index.html","hash":"de696c5c68f303f83c8292f60132df88eb56d19b","modified":1591455361541},{"_id":"public/2017/10/21/What-Function-Should-I-Use/index.html","hash":"4a5f72e3a679bd57dc39e8b5987f682d453c082f","modified":1591455361541},{"_id":"public/2017/07/22/Debug-nodejs-in-Spacemacs/index.html","hash":"3df24ae2fe7db71c030c83878f5c8fe4635a4292","modified":1591455361541},{"_id":"public/2017/06/28/Why-Curry-Helps/index.html","hash":"21a7f1ca8ddb497970631a76c6329852d105ef26","modified":1591455361541},{"_id":"public/2017/06/27/Favoring-Curry/index.html","hash":"7b567c1d68fe9d4df25636c6af86968841fa7171","modified":1591455361541},{"_id":"public/2017/06/25/Why-Ramda/index.html","hash":"6144071f7a071d0f1d4eda8c2825ff0bbec92090","modified":1591455361541},{"_id":"public/2017/06/25/Introducing-Ramda/index.html","hash":"a15748bed6369ec2eb7fb7a3a4573bd426841597","modified":1591455361541},{"_id":"public/2017/06/18/Thinking-in-Ramda-Wrap-Up/index.html","hash":"ea87744cf6fa515bb1028959918c4e5c688f3aab","modified":1591455361541},{"_id":"public/2017/06/18/Thinking-in-Ramda-Lenses/index.html","hash":"79f6c7f6dc71e322c2612fa31c0c8c0d764e2248","modified":1591455361541},{"_id":"public/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/index.html","hash":"42683c233303b26cfc94a19c49511eba3677886a","modified":1591455361541},{"_id":"public/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/index.html","hash":"1d7b3376ca73bba901524e2120694d094670a1c3","modified":1591455361541},{"_id":"public/2017/06/13/Thinking-in-Ramda-Pointfree-Style/index.html","hash":"69fd2b743811106e0cd7b20be31b7c5fce0867f6","modified":1591455361542},{"_id":"public/2017/06/11/Thinking-in-Ramda-Declarative-Programming/index.html","hash":"df495dcfecf0320c185231e1f041f56d2aae82c1","modified":1591455361542},{"_id":"public/2017/06/11/Thinking-in-Ramda-Partial-Application/index.html","hash":"aaeb3969bb1edf8d21353f8da8ffe2f770b4abcc","modified":1591455361542},{"_id":"public/2017/06/10/Thinking-in-Ramda-Combining-Functions/index.html","hash":"e0fdd6d04253f2c7854455242dc78ace741a738d","modified":1591455361542},{"_id":"public/2017/06/09/Thinking-in-Ramda-入门/index.html","hash":"4f9eef7b0ea1a41a55107f14b2b25b813bb0b4e3","modified":1591455361542},{"_id":"public/2016/11/19/Functor-Applicative-Monoid-Monad/index.html","hash":"21ea274bc56684f36e0828a29812516dad9d05d0","modified":1591455361542},{"_id":"public/2016/11/01/Transducers-Explained-Pipelines/index.html","hash":"a2688bd6bb798e849bdd59e4d4b7ee6b49384ee9","modified":1591455361542},{"_id":"public/2016/10/24/Transducers-Explained-Part-1/index.html","hash":"a8951d40c958e6a680bf0fe13cc98d9c5fe11da5","modified":1591455361542},{"_id":"public/2016/10/21/Ramda-SourceCode-Analyze/index.html","hash":"9eb13467db8e7181a6f7ffc858565eb3984ddf83","modified":1591455361542},{"_id":"public/index.html","hash":"cf5baa897c8869de4729fb9e8623972028b8ed7b","modified":1591455361542},{"_id":"public/page/2/index.html","hash":"c7d8ad1c8f13a75e50ddf700863d6c6ac1feeabe","modified":1591455361542},{"_id":"public/page/3/index.html","hash":"ae4edf996b15f3ae0472b68512c8d3c6fc46b041","modified":1591455361542},{"_id":"public/favicon.ico","hash":"9d57c18f966349a241ef4c055ceac738dbce77da","modified":1591455361548},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1591455361548},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1591455361549},{"_id":"public/images/avatar.gif","hash":"18c53e15eb0c84b139995f9334ed8522b40aeaf6","modified":1591455361549},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1591455361549},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1591455361549},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1591455361549},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1591455361549},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1591455361549},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1591455361549},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1591455361549},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1591455361549},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1591455361549},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1591455361549},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1591455361549},{"_id":"public/2016/10/23/Ramda-map-filter-reduce-transduce/mapFilterReduce.jpg","hash":"d823673b20964717e288c868bc9244058627b649","modified":1591455361549},{"_id":"public/2017/06/25/Why-Ramda/rbudiharso_tweet-2.png","hash":"5ad8cd6d11df397dab08e4656efa524f86da06c8","modified":1591455361549},{"_id":"public/2018/09/08/Fantasy-Land-Specification/dependencies.png","hash":"1164059c4203741c9d5380574a604d944d947dab","modified":1591455361550},{"_id":"public/2018/09/08/Fantasy-Land-Specification/logo.png","hash":"035120f812dbe84b3cfeedffdcf330f0d433d18d","modified":1591455361550},{"_id":"public/2017/11/11/Practical-Ramda-Recursion/quicksort.png","hash":"9d51e64433751c51201bf2097f140b261638c475","modified":1591455361550},{"_id":"public/2017/11/11/Practical-Ramda-Recursion/fibonacci.jpg","hash":"ee089a4895e8c7139379bf98f5bdb65f3d5d5ad1","modified":1591455361550},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/function.png","hash":"7c2940e61daa7067c85394ebaf95d3caf8e3fbe9","modified":1591455361550},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/function_composition.png","hash":"4676744ec4106362ad0c7cb41ef40030071a6455","modified":1591455361551},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/functions_composition.png","hash":"0968910a5b21509364c56d99d80b5d51921a3e8a","modified":1591455361551},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1591455362115},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1591455362116},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1591455362123},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1591455362123},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1591455362123},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1591455362123},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1591455362123},{"_id":"public/js/utils.js","hash":"2c6e6b4d9a592fbb4bf04689524db2cdfcd94ca7","modified":1591455362123},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1591455362123},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1591455362123},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1591455362123},{"_id":"public/css/main.css","hash":"994b6cbd57cfbf2a899cab61ef6c3dc19789143f","modified":1591455362123},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1591455362123},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1591455362123},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1591455362123},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/functions-in-memoize.png","hash":"dcf505dc228fa3c1e3f8185280cd3926e1af5071","modified":1591455362124},{"_id":"public/2016/10/24/Transducers-Explained-Part-1/compose_transducers.png","hash":"b41daff12ec79f0cb8c551943602c22dbc20efbe","modified":1591455362124},{"_id":"public/2016/10/24/Transducers-Explained-Part-1/reduce.png","hash":"98e9b9be0906b03c4e1e5d2373929bc757588884","modified":1591455362124},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/closure.png","hash":"2e9629a47ac6c1cf570b6b4c984e232ca288e753","modified":1591455362124},{"_id":"public/2017/07/22/Debug-nodejs-in-Spacemacs/open-nodejs-repl.png","hash":"5203a6de75c04b7ebdc1dbe794910942a4403c37","modified":1591455362136},{"_id":"public/2016/10/24/Transducers-Explained-Part-1/transduce.png","hash":"3e35bfb17c087708dd87808e66725640944077d2","modified":1591455362149},{"_id":"public/2017/07/22/Debug-nodejs-in-Spacemacs/import-lib.png","hash":"eec6ecd8d41b7282c158f71a7905b4c3d2f4897d","modified":1591455362158},{"_id":"public/2017/07/22/Debug-nodejs-in-Spacemacs/eval.png","hash":"7ac330a8094503408baaddec13cf1ca905c05912","modified":1591455362158},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/pipeline-leaking.png","hash":"9b26533fadfa06b6996d0dddc324835972d09b80","modified":1591455362210},{"_id":"public/2017/12/04/Functions-in-Functional-Programming/pipeline.png","hash":"aa689ce614b9d1a21ab76cd20f93a3ca4a761cf6","modified":1591455362214}],"Category":[{"name":"Emacs","_id":"ckb3rfit70003f6mj4pb4pjl0"},{"name":"Ramda","_id":"ckb3rfitc0007f6mjuhtqiei6"},{"name":"Functional Programming","_id":"ckb3rfitg000bf6mjnfh6gq9g"},{"name":"Haskell","_id":"ckb3rfitj000ff6mj8wy82ziz"},{"name":"Practical Ramda","_id":"ckb3rfits000nf6mj66a15cgf"},{"name":"Thinking in Ramda","_id":"ckb3rfitw000vf6mjlnn7spyc"}],"Data":[],"Page":[{"title":"categories","date":"2017-06-10T04:51:37.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-06-10 12:51:37\ntype: \"categories\"\ncomments: false\n---\n","updated":"2020-06-06T14:44:04.100Z","path":"categories/index.html","layout":"page","_id":"ckb3rfisz0000f6mjkb6wdczy","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Debug Nodejs in Spacemacs","date":"2017-07-22T07:04:44.000Z","_content":"\n在调试代码时，往往会开两个窗口进行操作，一个用来编写代码（代码文件如 `index.js`），另一个用来调试（如运行 `node index.js`），这样会频繁的在编辑器和调试窗口之间切换；而且使用 node cli 会运行整个文件，而往往我们只想看文件中的部分内容。\n\nnodejs-repl 库相当于在编辑器和 repl 之间做了桥接，类似于 tmux。\n\n这里有两条命令比较重要：\n\n```elisp\nnodejs-repl-send-region ;; 用于将选中的区域发送至 repl 中，但不求值，在引入库时比较有用\nnodejs-repl-send-last-sexp ;; 将当前行光标前面的内容发送至 repl，并进行运算\n```\n\n具体步骤：\n\n## 一、配置\n\n1. 在 `~/.spacemacs` `dotspacemacs-additional-packages '(nodejs-repl)` 中添加 `nodejs-repl`\n\n2. 在 `dotspacemacs/user-config ()` 中添加快捷键\n\n```elisp\n  (add-hook 'js-mode-hook\n            (lambda ()\n              (define-key js-mode-map (kbd \"C-x C-e\") 'nodejs-repl-send-last-sexp)\n              (define-key js-mode-map (kbd \"C-c C-r\") 'nodejs-repl-send-region)\n              (define-key js-mode-map (kbd \"C-c C-l\") 'nodejs-repl-load-file)\n              (define-key js-mode-map (kbd \"C-c C-z\") 'nodejs-repl-switch-to-repl)))\n```\n\n3. 运行 `M-m f e R`，安装 nodejs-repl\n\n## 二、调试\n\n1. 使用 emacs 打开待调试文件；使用 `M-x` 运行命令 `nodejs-repl`，便会在编辑窗口相同 frame 里打开 nodejs 的 repl：\n\n![open-nodejs-repl](./open-nodejs-repl.png)\n\n2. 选中文中的第三方库，使用 `nodejs-repl-send-region` 命令将其引入 repl 中。（注意，不能使用 `nodejs-repl-send-last-sexp`！）\n\n![import-lib](./import-lib.png)\n\n3. 对于需要调试的代码行，运行 `nodejs-repl-send-last-sexp` ，便会将代码加入 repl 中，并进行运算：\n\n![eval](./eval.png)\n\n\n## 三、TODO\n\n1. 快捷键配置在 js2-mode 中只能部分起作用，js-mode 中都可以。需要研究一下 emacs 快捷键配置和优先级。\n","source":"_posts/Debug-nodejs-in-Spacemacs.md","raw":"---\ntitle: Debug Nodejs in Spacemacs\ndate: 2017-07-22 15:04:44\ncategories: 'Emacs'\n---\n\n在调试代码时，往往会开两个窗口进行操作，一个用来编写代码（代码文件如 `index.js`），另一个用来调试（如运行 `node index.js`），这样会频繁的在编辑器和调试窗口之间切换；而且使用 node cli 会运行整个文件，而往往我们只想看文件中的部分内容。\n\nnodejs-repl 库相当于在编辑器和 repl 之间做了桥接，类似于 tmux。\n\n这里有两条命令比较重要：\n\n```elisp\nnodejs-repl-send-region ;; 用于将选中的区域发送至 repl 中，但不求值，在引入库时比较有用\nnodejs-repl-send-last-sexp ;; 将当前行光标前面的内容发送至 repl，并进行运算\n```\n\n具体步骤：\n\n## 一、配置\n\n1. 在 `~/.spacemacs` `dotspacemacs-additional-packages '(nodejs-repl)` 中添加 `nodejs-repl`\n\n2. 在 `dotspacemacs/user-config ()` 中添加快捷键\n\n```elisp\n  (add-hook 'js-mode-hook\n            (lambda ()\n              (define-key js-mode-map (kbd \"C-x C-e\") 'nodejs-repl-send-last-sexp)\n              (define-key js-mode-map (kbd \"C-c C-r\") 'nodejs-repl-send-region)\n              (define-key js-mode-map (kbd \"C-c C-l\") 'nodejs-repl-load-file)\n              (define-key js-mode-map (kbd \"C-c C-z\") 'nodejs-repl-switch-to-repl)))\n```\n\n3. 运行 `M-m f e R`，安装 nodejs-repl\n\n## 二、调试\n\n1. 使用 emacs 打开待调试文件；使用 `M-x` 运行命令 `nodejs-repl`，便会在编辑窗口相同 frame 里打开 nodejs 的 repl：\n\n![open-nodejs-repl](./open-nodejs-repl.png)\n\n2. 选中文中的第三方库，使用 `nodejs-repl-send-region` 命令将其引入 repl 中。（注意，不能使用 `nodejs-repl-send-last-sexp`！）\n\n![import-lib](./import-lib.png)\n\n3. 对于需要调试的代码行，运行 `nodejs-repl-send-last-sexp` ，便会将代码加入 repl 中，并进行运算：\n\n![eval](./eval.png)\n\n\n## 三、TODO\n\n1. 快捷键配置在 js2-mode 中只能部分起作用，js-mode 中都可以。需要研究一下 emacs 快捷键配置和优先级。\n","slug":"Debug-nodejs-in-Spacemacs","published":1,"updated":"2020-06-06T14:44:04.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfit10001f6mjb9g95wmk","content":"<p>在调试代码时，往往会开两个窗口进行操作，一个用来编写代码（代码文件如 <code>index.js</code>），另一个用来调试（如运行 <code>node index.js</code>），这样会频繁的在编辑器和调试窗口之间切换；而且使用 node cli 会运行整个文件，而往往我们只想看文件中的部分内容。</p>\n<p>nodejs-repl 库相当于在编辑器和 repl 之间做了桥接，类似于 tmux。</p>\n<p>这里有两条命令比较重要：</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nodejs-repl-send-region ;; 用于将选中的区域发送至 repl 中，但不求值，在引入库时比较有用</span><br><span class=\"line\">nodejs-repl-send-last-sexp ;; 将当前行光标前面的内容发送至 repl，并进行运算</span><br></pre></td></tr></table></figure></p>\n<p>具体步骤：</p>\n<h2>一、配置</h2>\n<ol>\n<li>\n<p>在 <code>~/.spacemacs</code> <code>dotspacemacs-additional-packages '(nodejs-repl)</code> 中添加 <code>nodejs-repl</code></p>\n</li>\n<li>\n<p>在 <code>dotspacemacs/user-config ()</code> 中添加快捷键</p>\n</li>\n</ol>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(add-hook &apos;js-mode-hook</span><br><span class=\"line\">          (lambda ()</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-x C-e&quot;) &apos;nodejs-repl-send-last-sexp)</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-c C-r&quot;) &apos;nodejs-repl-send-region)</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-c C-l&quot;) &apos;nodejs-repl-load-file)</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-c C-z&quot;) &apos;nodejs-repl-switch-to-repl)))</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>运行 <code>M-m f e R</code>，安装 nodejs-repl</li>\n</ol>\n<h2>二、调试</h2>\n<ol>\n<li>使用 emacs 打开待调试文件；使用 <code>M-x</code> 运行命令 <code>nodejs-repl</code>，便会在编辑窗口相同 frame 里打开 nodejs 的 repl：</li>\n</ol>\n<p><img src=\"./open-nodejs-repl.png\" alt=\"open-nodejs-repl\"></p>\n<ol start=\"2\">\n<li>选中文中的第三方库，使用 <code>nodejs-repl-send-region</code> 命令将其引入 repl 中。（注意，不能使用 <code>nodejs-repl-send-last-sexp</code>！）</li>\n</ol>\n<p><img src=\"./import-lib.png\" alt=\"import-lib\"></p>\n<ol start=\"3\">\n<li>对于需要调试的代码行，运行 <code>nodejs-repl-send-last-sexp</code> ，便会将代码加入 repl 中，并进行运算：</li>\n</ol>\n<p><img src=\"./eval.png\" alt=\"eval\"></p>\n<h2>三、TODO</h2>\n<ol>\n<li>快捷键配置在 js2-mode 中只能部分起作用，js-mode 中都可以。需要研究一下 emacs 快捷键配置和优先级。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>在调试代码时，往往会开两个窗口进行操作，一个用来编写代码（代码文件如 <code>index.js</code>），另一个用来调试（如运行 <code>node index.js</code>），这样会频繁的在编辑器和调试窗口之间切换；而且使用 node cli 会运行整个文件，而往往我们只想看文件中的部分内容。</p>\n<p>nodejs-repl 库相当于在编辑器和 repl 之间做了桥接，类似于 tmux。</p>\n<p>这里有两条命令比较重要：</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nodejs-repl-send-region ;; 用于将选中的区域发送至 repl 中，但不求值，在引入库时比较有用</span><br><span class=\"line\">nodejs-repl-send-last-sexp ;; 将当前行光标前面的内容发送至 repl，并进行运算</span><br></pre></td></tr></table></figure></p>\n<p>具体步骤：</p>\n<h2>一、配置</h2>\n<ol>\n<li>\n<p>在 <code>~/.spacemacs</code> <code>dotspacemacs-additional-packages '(nodejs-repl)</code> 中添加 <code>nodejs-repl</code></p>\n</li>\n<li>\n<p>在 <code>dotspacemacs/user-config ()</code> 中添加快捷键</p>\n</li>\n</ol>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(add-hook &apos;js-mode-hook</span><br><span class=\"line\">          (lambda ()</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-x C-e&quot;) &apos;nodejs-repl-send-last-sexp)</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-c C-r&quot;) &apos;nodejs-repl-send-region)</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-c C-l&quot;) &apos;nodejs-repl-load-file)</span><br><span class=\"line\">            (define-key js-mode-map (kbd &quot;C-c C-z&quot;) &apos;nodejs-repl-switch-to-repl)))</span><br></pre></td></tr></table></figure></p>\n<ol start=\"3\">\n<li>运行 <code>M-m f e R</code>，安装 nodejs-repl</li>\n</ol>\n<h2>二、调试</h2>\n<ol>\n<li>使用 emacs 打开待调试文件；使用 <code>M-x</code> 运行命令 <code>nodejs-repl</code>，便会在编辑窗口相同 frame 里打开 nodejs 的 repl：</li>\n</ol>\n<p><img src=\"./open-nodejs-repl.png\" alt=\"open-nodejs-repl\"></p>\n<ol start=\"2\">\n<li>选中文中的第三方库，使用 <code>nodejs-repl-send-region</code> 命令将其引入 repl 中。（注意，不能使用 <code>nodejs-repl-send-last-sexp</code>！）</li>\n</ol>\n<p><img src=\"./import-lib.png\" alt=\"import-lib\"></p>\n<ol start=\"3\">\n<li>对于需要调试的代码行，运行 <code>nodejs-repl-send-last-sexp</code> ，便会将代码加入 repl 中，并进行运算：</li>\n</ol>\n<p><img src=\"./eval.png\" alt=\"eval\"></p>\n<h2>三、TODO</h2>\n<ol>\n<li>快捷键配置在 js2-mode 中只能部分起作用，js-mode 中都可以。需要研究一下 emacs 快捷键配置和优先级。</li>\n</ol>\n"},{"title":"爱上柯里化 (Favoring Curry)","date":"2017-06-26T23:49:41.000Z","_content":"\n译者注：本文翻译自 [Scott Sauyet](https://github.com/CrossEye) 的 《[Favoring Curry](http://fr.umio.us/favoring-curry/)》，转载请与[原作者](https://github.com/CrossEye)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n我[最近一篇](http://fr.umio.us/why-ramda/) 关于 [Ramda](https://github.com/ramda/ramda) 函数式组合的文章阐述了一个重要的话题。为了使用 Ramda 函数做这种组合，需要这些函数是柯里化的。\n\nCurry，咖喱？某种辛辣的食物？是什么呢？又在哪里？\n\n实际上，`curry` 是为纪念 Haskell Curry 而命名的，他是第一个研究这种技术的人。（是的，人们还用他的姓氏--Haskell--作为一门函数式编程语言；不仅如此，Curry 的中间名字以 'B' 开头，代表 [Brainf*ck](http://en.wikipedia.org/wiki/Brainfuck)\n\n柯里化将多参数函数转化一个新函数：当接受部分参数时，返回等待接受剩余参数的新函数。\n\n原始函数看起来像是这样：\n\n```js\n// uncurried version\nvar formatName1 = function(first, middle, last) {\n    return first + ' ' + middle + ' ' + last;\n};\nformatName1('John', 'Paul', 'Jones');\n//=> 'John Paul Jones' // (Ah, but the musician or the admiral?)\nformatName1('John', 'Paul');\n//=> 'John Paul undefined');\n```\n\n但柯里化后的函数更有用：\n\n```js\n// curried version\nvar formatNames2 = R.curry(function(first, middle, last) {\n    return first + ' ' + middle + ' ' + last;\n});\nformatNames2('John', 'Paul', 'Jones');\n//=> 'John Paul Jones' // (definitely the musician!)\nvar jp = formatNames2('John', 'Paul'); //=> returns a function\njp('Jones'); //=> 'John Paul Jones' (maybe this one's the admiral)\njp('Stevens'); //=> 'John Paul Stevens' (the Supreme Court Justice)\njp('Pontiff'); //=> 'John Paul Pontiff' (ok, so I cheated.)\njp('Ziller'); //=> 'John Paul Ziller' (magician, a wee bit fictional)\njp('Georgeandringo'); //=> 'John Paul Georgeandringo' (rockers)\n```\n\n或这样：\n\n```js\n['Jones', 'Stevens', 'Ziller'].map(jp);\n//=> ['John Paul Jones', 'John Paul Stevens', 'John Paul Ziller']\n```\n\n你也可以分多次传入参数，像这样：\n\n```js\nvar james = formatNames2('James'); //=> returns a function\njames('Byron', 'Dean'); //=> 'James Byron Dean' (rebel)\nvar je = james('Earl'); also returns a function\nje('Carter'); //=> 'James Earl Carter' (president)\nje('Jones'); //=> 'James Earl Jones' (actor, Vader)\n```\n\n（有些人会坚持认为我们正在做的应该叫作 \"部分应用(partial application)\"，\"柯里化\" 的返回函数应该每次只接受一个参数，每次函数处理完单个参数后返回一个新的接受单参数的函数，直到所有必需的参数都已传入。他们可以坚持他们的观点，无所谓）\n\n## 好无聊啊...! 它能为我做什么呢？\n\n这里有一个稍有意义的示例。如果想计算一个数字集合的总和，可以这样：\n\n```js\n// Plain JS:\nvar add = function(a, b) {return a + b;};\nvar numbers = [1, 2, 3, 4, 5];\nvar sum = numbers.reduce(add, 0); //=> 15\n```\n\n而若想编写一个通用的计算数字列表总和的函数，可以这样：\n\n```js\nvar total = function(list) {\n    return list.reduce(add, 0);\n};\nvar sum = total(numbers); //=> 15\n```\n\n在 Ramda 中，`total` 和 `sum` 和上面的定义非常相似。可以这样定义 `sum`：\n\n```js\nvar sum = R.reduce(add, 0, numbers); //=> 15\n```\n\n但由于 `reduce` 是柯里化函数，当跳过最后一个参数时，就类似于 `total` 的定义了：\n\n```js\n// In Ramda:\nvar total = R.reduce(add, 0);  // returns a function\n```\n\n上面将会获得一个可以调用的函数：\n\n```js\nvar sum = total(numbers); //=> 15\n```\n\n再次注意，函数的定义和将函数作用于数据是多么的相似：\n\n```js\nvar total = R.reduce(add, 0); //=> function:: [Number] -> Number\nvar sum =   R.reduce(add, 0, numbers); //=> 15\n```\n\n## 我不关心这些，我又不是数学怪黎叔\n\n那么你做 web 开发吗？huh？会对服务器发起 AJAX 请求吗？使用的是 [Promises](http://promises-aplus.github.io/promises-spec/) 吗？必须要操作返回的数据，对其进行过滤，取子集等？或者你做 server 端开发？会异步查询一个 no-SQL 数据库，并操作这些结果？\n\n我最好的建议是，去看看 Hugh FD Jackson 的文章：[为什么柯里化有帮助](http://hughfdjackson.com/javascript/why-curry-helps/)。它是我读过的这方面最好的文章。如果你想要看视频，花上半个小时看一下 Dr. Boolean 的视频：[Hey Underscore, 你错了](http://www.youtube.com/watch?v=m3svKOdZijA)。（不要被标题吓到，他没有花太多时间批评那个库）\n\n一定要看看这些材料！它们比我解释的更好；你已经察觉到我有多么的啰嗦、夸夸其谈、冗长甚至愚笨。如果你已经看了上面的材料，可以跳过本文剩余小节了。它们解释的已经够清楚了。\n\n我已经警告过你了哦。\n\n---\n\n假设我们希望得到一些这样的数据：\n\n```js\nvar data = {\n    result: \"SUCCESS\",\n    interfaceVersion: \"1.0.3\",\n    requested: \"10/17/2013 15:31:20\",\n    lastUpdated: \"10/16/2013 10:52:39\",\n    tasks: [\n        {id: 104, complete: false,            priority: \"high\",\n                  dueDate: \"2013-11-29\",      username: \"Scott\",\n                  title: \"Do something\",      created: \"9/22/2013\"},\n        {id: 105, complete: false,            priority: \"medium\",\n                  dueDate: \"2013-11-22\",      username: \"Lena\",\n                  title: \"Do something else\", created: \"9/22/2013\"},\n        {id: 107, complete: true,             priority: \"high\",\n                  dueDate: \"2013-11-22\",      username: \"Mike\",\n                  title: \"Fix the foo\",       created: \"9/22/2013\"},\n        {id: 108, complete: false,            priority: \"low\",\n                  dueDate: \"2013-11-15\",      username: \"Punam\",\n                  title: \"Adjust the bar\",    created: \"9/25/2013\"},\n        {id: 110, complete: false,            priority: \"medium\",\n                  dueDate: \"2013-11-15\",      username: \"Scott\",\n                  title: \"Rename everything\", created: \"10/2/2013\"},\n        {id: 112, complete: true,             priority: \"high\",\n                  dueDate: \"2013-11-27\",      username: \"Lena\",\n                  title: \"Alter all quuxes\",  created: \"10/5/2013\"}\n        // , ...\n    ]\n};\n```\n\n我们需要一个函数 `getIncompleteTaskSummaries`，接受成员名字（`memebername`）为参数，然后从服务器（或其他地方）获取数据，挑选出该成员未完成的任务，返回它们的 id、优先级、标题和到期日期，并按到期日期排序。实际上，它返回一个用来解析出这个有序列表的 Promise。\n\n如果向 `getIncompleteTaskSummaries` 传入 \"Scott\"，它可能会返回：\n\n```js\n[\n    {id: 110, title: \"Rename everything\", \n        dueDate: \"2013-11-15\", priority: \"medium\"},\n    {id: 104, title: \"Do something\", \n        dueDate: \"2013-11-29\", priority: \"high\"}\n]\n```\n\n好的，这就开始吧。下面这段代码是否看着很熟悉？\n\n```js\ngetIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(function(data) {\n            return data.tasks;\n        })\n        .then(function(tasks) {\n            var results = [];\n            for (var i = 0, len = tasks.length; i < len; i++) {\n                if (tasks[i].username == membername) {\n                    results.push(tasks[i]);\n                }\n            }\n            return results;\n        })\n        .then(function(tasks) {\n            var results = [];\n            for (var i = 0, len = tasks.length; i < len; i++) {\n                if (!tasks[i].complete) {\n                    results.push(tasks[i]);\n                }\n            }\n            return results;\n        })\n        .then(function(tasks) {\n            var results = [], task;\n            for (var i = 0, len = tasks.length; i < len; i++) {\n                task = tasks[i];\n                results.push({\n                    id: task.id,\n                    dueDate: task.dueDate,\n                    title: task.title,\n                    priority: task.priority\n                })\n            }\n            return results;\n        })\n        .then(function(tasks) {\n            tasks.sort(function(first, second) {\n                var a = first.dueDate, b = second.dueDate;\n                return a < b ? -1 : a > b ? 1 : 0;\n            });\n            return tasks;\n        });\n};\n```\n\n下面的代码是否更好些呢？\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.get('tasks'))\n        .then(R.filter(R.propEq('username', membername)))\n        .then(R.reject(R.propEq('complete', true)))\n        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(R.sortBy(R.get('dueDate')));\n};\n```\n\n如果是的话，那么柯里化会更适合你。所有上面代码块中提及的 Ramda 函数都是柯里化的。（事实上，绝大多数 Ramda 的多参数函数都是柯里化的，除了极个别的几个之外）在很多情形下，柯里化是使代码能更容易组合成这么简洁优雅的模块的原因之一。\n\n让我们看看发生了什么。\n\n`get` （也称为 `prop`）定义如下：\n\n```js\n ramda.get = curry(function(name, obj) {\n     return obj[name];\n });\n```\n\n但是，当调用上面的代码时，我们只提供第一个参数：`name`。正如之前讨论的，这意味着我们会返回一个新函数，等待第一个 `then` 传入 `obj` 参数给它，这就意味着下面的代码：\n\n```js\n.then(R.get('task'))\n```\n\n可以看做是下面代码的缩写：\n\n```js\n.then(function(data) {\n    return data.tasks;\n})\n```\n\n接下来是 `propEq`，定义如下：\n\n```js\nramda.propEq = curry(function(name, val, obj) {\n    return obj[name] === val;\n});\n```\n\n所以当使用参数 `username` 和 `membername` 调用它时，柯里化返给我们一个新函数，等价于：\n\n```js\nfunction(obj) {\n    return obj['username'] === membername;\n}\n```\n\n其中 `membername` 的值绑定到了传递给我们的值上面。\n\n然后将该函数传给 `filter`。\n\nRamda 的 `filter` 的工作原理很像原生的 `Array.prototype.filter` ，但类型签名为：\n\n```js\nramda.filter = curry(function(predicate, list) { /* ... */ });\n```\n\n所以，我们又进行柯里化了，只传入 \"predicate\" 函数（谓词），而没有一同传入从上一步输出的任务列表。（我已经告诉过你，所有的东西都是柯里化的，对吧？）\n\n`propEq('complete', true) -> reject` 与 `propEq('username', membername) -> filter` 做了相似的事情。`reject` 和 `filter` 功能类似，除了它们的输出结果是相反的。它只保留使 predicate 函数返回 false 的元素。\n\n好了，你还在看吗？我的食指开始发酸了。（真的要学习盲打了！）不需要我来解释最后两行了吧？真的吗？你确定？好吧！好吧！那我再解释一下。\n\n接下来我们看看：\n\n```js\nR.pick(['id', 'dueDate', 'title', 'priority'])\n```\n\n`pick` 接受属性名称列表和一个对象，返回从原对象提取指定属性集的新对象。你看，我们又使用了柯里化。由于只传递了属性名称列表，我们得到了一个函数：一旦我们提供一个对象，就会返回一个相同类型的新对象。该函数被传给 `R.map`。与 `filter` 类似，它与原生 `Array.prototype.map` 功能基本相同，但签名如下：\n\n```js\nramda.map = curry(function(fn, list) { /* ... */ });\n```\n\n不得不告诉你，这个函数也是柯里化的，因为我们只提供给它 `pick` 返回的函数（也是柯里化的！），而没有提供列表。`then` 将使用任务列表调用它。\n\n好的，还记得小时候坐在教室，等待上课结束的情形吗？手里时钟的分针像是卡住了，另一只手正伸向桌洞里的糖果；老师却还在一遍一遍地重复相同的事情。还记得吗？然后那一刻终于到了，可能是结束前的最后两分钟，结束的时刻已经在眼前了：谢天谢地！下面是最后一个例子：\n\n```js\n.then(R.sortBy(R.get('dueDate')));\n```\n\n之前已经提到过 `get`。这也是柯里化的，它会返回一个函数：输入对象，输出该对象的 `dueDate` 属性值。我们将其传给 `sortBy`，它接受这样的函数和一个列表，并根据函数返回的值对列表中的元素进行排序。但等等，我们没有列表，对吧？当然没有。我们又在做柯里化。但当调用 `then` 时，它会接收到列表，将列表中的每个对象传给 `get`，并根据结果进行排序。\n\n## 那么，柯里化有多重要呢？\n\n这个例子展示了 Ramda 的一些实用函数和 Ramda 的柯里化特性。或许柯里化并没有那么重要。我们不加柯里化重写一遍：\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(function(data) {\n            return R.get('tasks', data)\n        })\n        .then(function(tasks) {\n            return R.filter(function(task) {\n                return R.propEq('username', membername, task)\n            }, tasks)\n         })\n        .then(function(tasks) {\n            return R.reject(function(task) {\n                return R.propEq('complete', true, task);\n            }, tasks)\n        })\n        .then(function(tasks) {\n            return R.map(function(task) {\n                return R.pick(['id', 'dueDate', 'title', 'priority'], task);\n            }, tasks);\n        })\n        .then(function(abbreviatedTasks) {\n            return R.sortBy(function(abbrTask) {\n                return R.get('dueDate', abbrTask);\n            }, abbreviatedTasks);\n        });\n};\n```\n\n上面是等价的程序。它仍然比原来的代码好一些。Ramda 实用的函数... 确实比较实用，即使没有柯里化。但我不认为它的可读性有下面的好：\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.get('tasks'))\n        .then(R.filter(R.propEq('username', membername)))\n        .then(R.reject(R.propEq('complete', true)))\n        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(R.sortBy(R.get('dueDate')));\n};\n```\n\n这就是我们柯里化的原因。\n\n---\n\n课程结束了。\n\n我警告过你的。\n\n下一次，当我让你去看别人的东西而不是我的的时候，你会注意了吧。现在不读我的文章可能已经来不及了，但是他们的作品真的很棒，强烈推荐大家看一下：\n\n* [为什么柯里化有帮助](http://hughfdjackson.com/javascript/why-curry-helps/) ，Hugh FD Jackson\n* [嗨 Underscore，你做错了](http://www.youtube.com/watch?v=m3svKOdZijA) ，Dr. Boolean, aka Brian Lonsdorf\n\n这里还有一篇我今天刚看到的新的文章。不知它是否会经的其时间的考验，但现在看来值得一读：\n\n* [将回调放在首位，代码会更优雅](http://bahmutov.calepin.co/put-callback-first-for-elegance.html) ，Gleb Bahmutov\n\n## 一点不太好的小秘密\n\n柯里化尽管非常强大，但单独使用并不足以让你的代码变得 \"那么\" 优雅。\n\n应该有三个重要的组成部分：\n\n* [上次](http://fr.umio.us/why-ramda/) 我讨论了 **函数式组合**。它可以轻松地将你所有好的想法组合在一起，而不必使用大量丑陋的胶水代码将它们聚合在一起。\n\n* **柯里化** 同样很有用，因为它很好的支持了组合，而且消除了大量的样板代码，正如上面所示。\n\n* 很多能操作有用数据结构（如对象类型的数组）的 **实用函数** 。\n\n[Ramda](https://github.com/ramda/ramda) 的目标之一便是：在一个简单的包里面提供所有这些功能。\n\n## 致谢\n\n[buzzdecafe](http://buzzdecafe.github.io/) 帮助编辑了本文和上一篇文章，并且这次还起了一个完美标题。谢谢，Mike！\n","source":"_posts/Favoring-Curry.md","raw":"---\ntitle: 爱上柯里化 (Favoring Curry)\ndate: 2017-06-27 07:49:41\ncategories: 'Ramda'\n---\n\n译者注：本文翻译自 [Scott Sauyet](https://github.com/CrossEye) 的 《[Favoring Curry](http://fr.umio.us/favoring-curry/)》，转载请与[原作者](https://github.com/CrossEye)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n我[最近一篇](http://fr.umio.us/why-ramda/) 关于 [Ramda](https://github.com/ramda/ramda) 函数式组合的文章阐述了一个重要的话题。为了使用 Ramda 函数做这种组合，需要这些函数是柯里化的。\n\nCurry，咖喱？某种辛辣的食物？是什么呢？又在哪里？\n\n实际上，`curry` 是为纪念 Haskell Curry 而命名的，他是第一个研究这种技术的人。（是的，人们还用他的姓氏--Haskell--作为一门函数式编程语言；不仅如此，Curry 的中间名字以 'B' 开头，代表 [Brainf*ck](http://en.wikipedia.org/wiki/Brainfuck)\n\n柯里化将多参数函数转化一个新函数：当接受部分参数时，返回等待接受剩余参数的新函数。\n\n原始函数看起来像是这样：\n\n```js\n// uncurried version\nvar formatName1 = function(first, middle, last) {\n    return first + ' ' + middle + ' ' + last;\n};\nformatName1('John', 'Paul', 'Jones');\n//=> 'John Paul Jones' // (Ah, but the musician or the admiral?)\nformatName1('John', 'Paul');\n//=> 'John Paul undefined');\n```\n\n但柯里化后的函数更有用：\n\n```js\n// curried version\nvar formatNames2 = R.curry(function(first, middle, last) {\n    return first + ' ' + middle + ' ' + last;\n});\nformatNames2('John', 'Paul', 'Jones');\n//=> 'John Paul Jones' // (definitely the musician!)\nvar jp = formatNames2('John', 'Paul'); //=> returns a function\njp('Jones'); //=> 'John Paul Jones' (maybe this one's the admiral)\njp('Stevens'); //=> 'John Paul Stevens' (the Supreme Court Justice)\njp('Pontiff'); //=> 'John Paul Pontiff' (ok, so I cheated.)\njp('Ziller'); //=> 'John Paul Ziller' (magician, a wee bit fictional)\njp('Georgeandringo'); //=> 'John Paul Georgeandringo' (rockers)\n```\n\n或这样：\n\n```js\n['Jones', 'Stevens', 'Ziller'].map(jp);\n//=> ['John Paul Jones', 'John Paul Stevens', 'John Paul Ziller']\n```\n\n你也可以分多次传入参数，像这样：\n\n```js\nvar james = formatNames2('James'); //=> returns a function\njames('Byron', 'Dean'); //=> 'James Byron Dean' (rebel)\nvar je = james('Earl'); also returns a function\nje('Carter'); //=> 'James Earl Carter' (president)\nje('Jones'); //=> 'James Earl Jones' (actor, Vader)\n```\n\n（有些人会坚持认为我们正在做的应该叫作 \"部分应用(partial application)\"，\"柯里化\" 的返回函数应该每次只接受一个参数，每次函数处理完单个参数后返回一个新的接受单参数的函数，直到所有必需的参数都已传入。他们可以坚持他们的观点，无所谓）\n\n## 好无聊啊...! 它能为我做什么呢？\n\n这里有一个稍有意义的示例。如果想计算一个数字集合的总和，可以这样：\n\n```js\n// Plain JS:\nvar add = function(a, b) {return a + b;};\nvar numbers = [1, 2, 3, 4, 5];\nvar sum = numbers.reduce(add, 0); //=> 15\n```\n\n而若想编写一个通用的计算数字列表总和的函数，可以这样：\n\n```js\nvar total = function(list) {\n    return list.reduce(add, 0);\n};\nvar sum = total(numbers); //=> 15\n```\n\n在 Ramda 中，`total` 和 `sum` 和上面的定义非常相似。可以这样定义 `sum`：\n\n```js\nvar sum = R.reduce(add, 0, numbers); //=> 15\n```\n\n但由于 `reduce` 是柯里化函数，当跳过最后一个参数时，就类似于 `total` 的定义了：\n\n```js\n// In Ramda:\nvar total = R.reduce(add, 0);  // returns a function\n```\n\n上面将会获得一个可以调用的函数：\n\n```js\nvar sum = total(numbers); //=> 15\n```\n\n再次注意，函数的定义和将函数作用于数据是多么的相似：\n\n```js\nvar total = R.reduce(add, 0); //=> function:: [Number] -> Number\nvar sum =   R.reduce(add, 0, numbers); //=> 15\n```\n\n## 我不关心这些，我又不是数学怪黎叔\n\n那么你做 web 开发吗？huh？会对服务器发起 AJAX 请求吗？使用的是 [Promises](http://promises-aplus.github.io/promises-spec/) 吗？必须要操作返回的数据，对其进行过滤，取子集等？或者你做 server 端开发？会异步查询一个 no-SQL 数据库，并操作这些结果？\n\n我最好的建议是，去看看 Hugh FD Jackson 的文章：[为什么柯里化有帮助](http://hughfdjackson.com/javascript/why-curry-helps/)。它是我读过的这方面最好的文章。如果你想要看视频，花上半个小时看一下 Dr. Boolean 的视频：[Hey Underscore, 你错了](http://www.youtube.com/watch?v=m3svKOdZijA)。（不要被标题吓到，他没有花太多时间批评那个库）\n\n一定要看看这些材料！它们比我解释的更好；你已经察觉到我有多么的啰嗦、夸夸其谈、冗长甚至愚笨。如果你已经看了上面的材料，可以跳过本文剩余小节了。它们解释的已经够清楚了。\n\n我已经警告过你了哦。\n\n---\n\n假设我们希望得到一些这样的数据：\n\n```js\nvar data = {\n    result: \"SUCCESS\",\n    interfaceVersion: \"1.0.3\",\n    requested: \"10/17/2013 15:31:20\",\n    lastUpdated: \"10/16/2013 10:52:39\",\n    tasks: [\n        {id: 104, complete: false,            priority: \"high\",\n                  dueDate: \"2013-11-29\",      username: \"Scott\",\n                  title: \"Do something\",      created: \"9/22/2013\"},\n        {id: 105, complete: false,            priority: \"medium\",\n                  dueDate: \"2013-11-22\",      username: \"Lena\",\n                  title: \"Do something else\", created: \"9/22/2013\"},\n        {id: 107, complete: true,             priority: \"high\",\n                  dueDate: \"2013-11-22\",      username: \"Mike\",\n                  title: \"Fix the foo\",       created: \"9/22/2013\"},\n        {id: 108, complete: false,            priority: \"low\",\n                  dueDate: \"2013-11-15\",      username: \"Punam\",\n                  title: \"Adjust the bar\",    created: \"9/25/2013\"},\n        {id: 110, complete: false,            priority: \"medium\",\n                  dueDate: \"2013-11-15\",      username: \"Scott\",\n                  title: \"Rename everything\", created: \"10/2/2013\"},\n        {id: 112, complete: true,             priority: \"high\",\n                  dueDate: \"2013-11-27\",      username: \"Lena\",\n                  title: \"Alter all quuxes\",  created: \"10/5/2013\"}\n        // , ...\n    ]\n};\n```\n\n我们需要一个函数 `getIncompleteTaskSummaries`，接受成员名字（`memebername`）为参数，然后从服务器（或其他地方）获取数据，挑选出该成员未完成的任务，返回它们的 id、优先级、标题和到期日期，并按到期日期排序。实际上，它返回一个用来解析出这个有序列表的 Promise。\n\n如果向 `getIncompleteTaskSummaries` 传入 \"Scott\"，它可能会返回：\n\n```js\n[\n    {id: 110, title: \"Rename everything\", \n        dueDate: \"2013-11-15\", priority: \"medium\"},\n    {id: 104, title: \"Do something\", \n        dueDate: \"2013-11-29\", priority: \"high\"}\n]\n```\n\n好的，这就开始吧。下面这段代码是否看着很熟悉？\n\n```js\ngetIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(function(data) {\n            return data.tasks;\n        })\n        .then(function(tasks) {\n            var results = [];\n            for (var i = 0, len = tasks.length; i < len; i++) {\n                if (tasks[i].username == membername) {\n                    results.push(tasks[i]);\n                }\n            }\n            return results;\n        })\n        .then(function(tasks) {\n            var results = [];\n            for (var i = 0, len = tasks.length; i < len; i++) {\n                if (!tasks[i].complete) {\n                    results.push(tasks[i]);\n                }\n            }\n            return results;\n        })\n        .then(function(tasks) {\n            var results = [], task;\n            for (var i = 0, len = tasks.length; i < len; i++) {\n                task = tasks[i];\n                results.push({\n                    id: task.id,\n                    dueDate: task.dueDate,\n                    title: task.title,\n                    priority: task.priority\n                })\n            }\n            return results;\n        })\n        .then(function(tasks) {\n            tasks.sort(function(first, second) {\n                var a = first.dueDate, b = second.dueDate;\n                return a < b ? -1 : a > b ? 1 : 0;\n            });\n            return tasks;\n        });\n};\n```\n\n下面的代码是否更好些呢？\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.get('tasks'))\n        .then(R.filter(R.propEq('username', membername)))\n        .then(R.reject(R.propEq('complete', true)))\n        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(R.sortBy(R.get('dueDate')));\n};\n```\n\n如果是的话，那么柯里化会更适合你。所有上面代码块中提及的 Ramda 函数都是柯里化的。（事实上，绝大多数 Ramda 的多参数函数都是柯里化的，除了极个别的几个之外）在很多情形下，柯里化是使代码能更容易组合成这么简洁优雅的模块的原因之一。\n\n让我们看看发生了什么。\n\n`get` （也称为 `prop`）定义如下：\n\n```js\n ramda.get = curry(function(name, obj) {\n     return obj[name];\n });\n```\n\n但是，当调用上面的代码时，我们只提供第一个参数：`name`。正如之前讨论的，这意味着我们会返回一个新函数，等待第一个 `then` 传入 `obj` 参数给它，这就意味着下面的代码：\n\n```js\n.then(R.get('task'))\n```\n\n可以看做是下面代码的缩写：\n\n```js\n.then(function(data) {\n    return data.tasks;\n})\n```\n\n接下来是 `propEq`，定义如下：\n\n```js\nramda.propEq = curry(function(name, val, obj) {\n    return obj[name] === val;\n});\n```\n\n所以当使用参数 `username` 和 `membername` 调用它时，柯里化返给我们一个新函数，等价于：\n\n```js\nfunction(obj) {\n    return obj['username'] === membername;\n}\n```\n\n其中 `membername` 的值绑定到了传递给我们的值上面。\n\n然后将该函数传给 `filter`。\n\nRamda 的 `filter` 的工作原理很像原生的 `Array.prototype.filter` ，但类型签名为：\n\n```js\nramda.filter = curry(function(predicate, list) { /* ... */ });\n```\n\n所以，我们又进行柯里化了，只传入 \"predicate\" 函数（谓词），而没有一同传入从上一步输出的任务列表。（我已经告诉过你，所有的东西都是柯里化的，对吧？）\n\n`propEq('complete', true) -> reject` 与 `propEq('username', membername) -> filter` 做了相似的事情。`reject` 和 `filter` 功能类似，除了它们的输出结果是相反的。它只保留使 predicate 函数返回 false 的元素。\n\n好了，你还在看吗？我的食指开始发酸了。（真的要学习盲打了！）不需要我来解释最后两行了吧？真的吗？你确定？好吧！好吧！那我再解释一下。\n\n接下来我们看看：\n\n```js\nR.pick(['id', 'dueDate', 'title', 'priority'])\n```\n\n`pick` 接受属性名称列表和一个对象，返回从原对象提取指定属性集的新对象。你看，我们又使用了柯里化。由于只传递了属性名称列表，我们得到了一个函数：一旦我们提供一个对象，就会返回一个相同类型的新对象。该函数被传给 `R.map`。与 `filter` 类似，它与原生 `Array.prototype.map` 功能基本相同，但签名如下：\n\n```js\nramda.map = curry(function(fn, list) { /* ... */ });\n```\n\n不得不告诉你，这个函数也是柯里化的，因为我们只提供给它 `pick` 返回的函数（也是柯里化的！），而没有提供列表。`then` 将使用任务列表调用它。\n\n好的，还记得小时候坐在教室，等待上课结束的情形吗？手里时钟的分针像是卡住了，另一只手正伸向桌洞里的糖果；老师却还在一遍一遍地重复相同的事情。还记得吗？然后那一刻终于到了，可能是结束前的最后两分钟，结束的时刻已经在眼前了：谢天谢地！下面是最后一个例子：\n\n```js\n.then(R.sortBy(R.get('dueDate')));\n```\n\n之前已经提到过 `get`。这也是柯里化的，它会返回一个函数：输入对象，输出该对象的 `dueDate` 属性值。我们将其传给 `sortBy`，它接受这样的函数和一个列表，并根据函数返回的值对列表中的元素进行排序。但等等，我们没有列表，对吧？当然没有。我们又在做柯里化。但当调用 `then` 时，它会接收到列表，将列表中的每个对象传给 `get`，并根据结果进行排序。\n\n## 那么，柯里化有多重要呢？\n\n这个例子展示了 Ramda 的一些实用函数和 Ramda 的柯里化特性。或许柯里化并没有那么重要。我们不加柯里化重写一遍：\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(function(data) {\n            return R.get('tasks', data)\n        })\n        .then(function(tasks) {\n            return R.filter(function(task) {\n                return R.propEq('username', membername, task)\n            }, tasks)\n         })\n        .then(function(tasks) {\n            return R.reject(function(task) {\n                return R.propEq('complete', true, task);\n            }, tasks)\n        })\n        .then(function(tasks) {\n            return R.map(function(task) {\n                return R.pick(['id', 'dueDate', 'title', 'priority'], task);\n            }, tasks);\n        })\n        .then(function(abbreviatedTasks) {\n            return R.sortBy(function(abbrTask) {\n                return R.get('dueDate', abbrTask);\n            }, abbreviatedTasks);\n        });\n};\n```\n\n上面是等价的程序。它仍然比原来的代码好一些。Ramda 实用的函数... 确实比较实用，即使没有柯里化。但我不认为它的可读性有下面的好：\n\n```js\nvar getIncompleteTaskSummaries = function(membername) {\n    return fetchData()\n        .then(R.get('tasks'))\n        .then(R.filter(R.propEq('username', membername)))\n        .then(R.reject(R.propEq('complete', true)))\n        .then(R.map(R.pick(['id', 'dueDate', 'title', 'priority'])))\n        .then(R.sortBy(R.get('dueDate')));\n};\n```\n\n这就是我们柯里化的原因。\n\n---\n\n课程结束了。\n\n我警告过你的。\n\n下一次，当我让你去看别人的东西而不是我的的时候，你会注意了吧。现在不读我的文章可能已经来不及了，但是他们的作品真的很棒，强烈推荐大家看一下：\n\n* [为什么柯里化有帮助](http://hughfdjackson.com/javascript/why-curry-helps/) ，Hugh FD Jackson\n* [嗨 Underscore，你做错了](http://www.youtube.com/watch?v=m3svKOdZijA) ，Dr. Boolean, aka Brian Lonsdorf\n\n这里还有一篇我今天刚看到的新的文章。不知它是否会经的其时间的考验，但现在看来值得一读：\n\n* [将回调放在首位，代码会更优雅](http://bahmutov.calepin.co/put-callback-first-for-elegance.html) ，Gleb Bahmutov\n\n## 一点不太好的小秘密\n\n柯里化尽管非常强大，但单独使用并不足以让你的代码变得 \"那么\" 优雅。\n\n应该有三个重要的组成部分：\n\n* [上次](http://fr.umio.us/why-ramda/) 我讨论了 **函数式组合**。它可以轻松地将你所有好的想法组合在一起，而不必使用大量丑陋的胶水代码将它们聚合在一起。\n\n* **柯里化** 同样很有用，因为它很好的支持了组合，而且消除了大量的样板代码，正如上面所示。\n\n* 很多能操作有用数据结构（如对象类型的数组）的 **实用函数** 。\n\n[Ramda](https://github.com/ramda/ramda) 的目标之一便是：在一个简单的包里面提供所有这些功能。\n\n## 致谢\n\n[buzzdecafe](http://buzzdecafe.github.io/) 帮助编辑了本文和上一篇文章，并且这次还起了一个完美标题。谢谢，Mike！\n","slug":"Favoring-Curry","published":1,"updated":"2020-06-06T14:44:04.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfit50002f6mjgxa9lkbt","content":"<p>译者注：本文翻译自 <a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">Scott Sauyet</a> 的 《<a href=\"http://fr.umio.us/favoring-curry/\" target=\"_blank\" rel=\"noopener\">Favoring Curry</a>》，转载请与<a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>我<a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">最近一篇</a> 关于 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> 函数式组合的文章阐述了一个重要的话题。为了使用 Ramda 函数做这种组合，需要这些函数是柯里化的。</p>\n<p>Curry，咖喱？某种辛辣的食物？是什么呢？又在哪里？</p>\n<p>实际上，<code>curry</code> 是为纪念 Haskell Curry 而命名的，他是第一个研究这种技术的人。（是的，人们还用他的姓氏--Haskell--作为一门函数式编程语言；不仅如此，Curry 的中间名字以 'B' 开头，代表 <a href=\"http://en.wikipedia.org/wiki/Brainfuck\" target=\"_blank\" rel=\"noopener\">Brainf*ck</a></p>\n<p>柯里化将多参数函数转化一个新函数：当接受部分参数时，返回等待接受剩余参数的新函数。</p>\n<p>原始函数看起来像是这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uncurried version</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> formatName1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first, middle, last</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first + <span class=\"string\">' '</span> + middle + <span class=\"string\">' '</span> + last;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">formatName1(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>, <span class=\"string\">'Jones'</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; 'John Paul Jones' // (Ah, but the musician or the admiral?)</span></span><br><span class=\"line\">formatName1(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; 'John Paul undefined');</span></span><br></pre></td></tr></table></figure></p>\n<p>但柯里化后的函数更有用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// curried version</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> formatNames2 = R.curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first, middle, last</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first + <span class=\"string\">' '</span> + middle + <span class=\"string\">' '</span> + last;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">formatNames2(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>, <span class=\"string\">'Jones'</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; 'John Paul Jones' // (definitely the musician!)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jp = formatNames2(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>); <span class=\"comment\">//=&gt; returns a function</span></span><br><span class=\"line\">jp(<span class=\"string\">'Jones'</span>); <span class=\"comment\">//=&gt; 'John Paul Jones' (maybe this one's the admiral)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Stevens'</span>); <span class=\"comment\">//=&gt; 'John Paul Stevens' (the Supreme Court Justice)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Pontiff'</span>); <span class=\"comment\">//=&gt; 'John Paul Pontiff' (ok, so I cheated.)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Ziller'</span>); <span class=\"comment\">//=&gt; 'John Paul Ziller' (magician, a wee bit fictional)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Georgeandringo'</span>); <span class=\"comment\">//=&gt; 'John Paul Georgeandringo' (rockers)</span></span><br></pre></td></tr></table></figure></p>\n<p>或这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'Jones'</span>, <span class=\"string\">'Stevens'</span>, <span class=\"string\">'Ziller'</span>].map(jp);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['John Paul Jones', 'John Paul Stevens', 'John Paul Ziller']</span></span><br></pre></td></tr></table></figure></p>\n<p>你也可以分多次传入参数，像这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> james = formatNames2(<span class=\"string\">'James'</span>); <span class=\"comment\">//=&gt; returns a function</span></span><br><span class=\"line\">james(<span class=\"string\">'Byron'</span>, <span class=\"string\">'Dean'</span>); <span class=\"comment\">//=&gt; 'James Byron Dean' (rebel)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> je = james(<span class=\"string\">'Earl'</span>); also returns a <span class=\"function\"><span class=\"keyword\">function</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">je</span>(<span class=\"params\"><span class=\"string\">'Carter'</span></span>); //=&gt; '<span class=\"title\">James</span> <span class=\"title\">Earl</span> <span class=\"title\">Carter</span>' (<span class=\"params\">president</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">je</span>(<span class=\"params\"><span class=\"string\">'Jones'</span></span>); //=&gt; '<span class=\"title\">James</span> <span class=\"title\">Earl</span> <span class=\"title\">Jones</span>' (<span class=\"params\">actor, Vader</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>（有些人会坚持认为我们正在做的应该叫作 &quot;部分应用(partial application)&quot;，&quot;柯里化&quot; 的返回函数应该每次只接受一个参数，每次函数处理完单个参数后返回一个新的接受单参数的函数，直到所有必需的参数都已传入。他们可以坚持他们的观点，无所谓）</p>\n<h2>好无聊啊...! 它能为我做什么呢？</h2>\n<p>这里有一个稍有意义的示例。如果想计算一个数字集合的总和，可以这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Plain JS:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = numbers.reduce(add, <span class=\"number\">0</span>); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>而若想编写一个通用的计算数字列表总和的函数，可以这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> total = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.reduce(add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = total(numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>在 Ramda 中，<code>total</code> 和 <code>sum</code> 和上面的定义非常相似。可以这样定义 <code>sum</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = R.reduce(add, <span class=\"number\">0</span>, numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>但由于 <code>reduce</code> 是柯里化函数，当跳过最后一个参数时，就类似于 <code>total</code> 的定义了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In Ramda:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> total = R.reduce(add, <span class=\"number\">0</span>);  <span class=\"comment\">// returns a function</span></span><br></pre></td></tr></table></figure></p>\n<p>上面将会获得一个可以调用的函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = total(numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>再次注意，函数的定义和将函数作用于数据是多么的相似：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> total = R.reduce(add, <span class=\"number\">0</span>); <span class=\"comment\">//=&gt; function:: [Number] -&gt; Number</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum =   R.reduce(add, <span class=\"number\">0</span>, numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<h2>我不关心这些，我又不是数学怪黎叔</h2>\n<p>那么你做 web 开发吗？huh？会对服务器发起 AJAX 请求吗？使用的是 <a href=\"http://promises-aplus.github.io/promises-spec/\" target=\"_blank\" rel=\"noopener\">Promises</a> 吗？必须要操作返回的数据，对其进行过滤，取子集等？或者你做 server 端开发？会异步查询一个 no-SQL 数据库，并操作这些结果？</p>\n<p>我最好的建议是，去看看 Hugh FD Jackson 的文章：<a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">为什么柯里化有帮助</a>。它是我读过的这方面最好的文章。如果你想要看视频，花上半个小时看一下 Dr. Boolean 的视频：<a href=\"http://www.youtube.com/watch?v=m3svKOdZijA\" target=\"_blank\" rel=\"noopener\">Hey Underscore, 你错了</a>。（不要被标题吓到，他没有花太多时间批评那个库）</p>\n<p>一定要看看这些材料！它们比我解释的更好；你已经察觉到我有多么的啰嗦、夸夸其谈、冗长甚至愚笨。如果你已经看了上面的材料，可以跳过本文剩余小节了。它们解释的已经够清楚了。</p>\n<p>我已经警告过你了哦。</p>\n<hr>\n<p>假设我们希望得到一些这样的数据：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">    result: <span class=\"string\">\"SUCCESS\"</span>,</span><br><span class=\"line\">    interfaceVersion: <span class=\"string\">\"1.0.3\"</span>,</span><br><span class=\"line\">    requested: <span class=\"string\">\"10/17/2013 15:31:20\"</span>,</span><br><span class=\"line\">    lastUpdated: <span class=\"string\">\"10/16/2013 10:52:39\"</span>,</span><br><span class=\"line\">    tasks: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">104</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-29\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Scott\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Do something\"</span>,      <span class=\"attr\">created</span>: <span class=\"string\">\"9/22/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">105</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"medium\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-22\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Lena\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Do something else\"</span>, <span class=\"attr\">created</span>: <span class=\"string\">\"9/22/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">107</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">true</span>,             <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-22\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Mike\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Fix the foo\"</span>,       <span class=\"attr\">created</span>: <span class=\"string\">\"9/22/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">108</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"low\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-15\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Punam\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Adjust the bar\"</span>,    <span class=\"attr\">created</span>: <span class=\"string\">\"9/25/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">110</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"medium\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-15\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Scott\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Rename everything\"</span>, <span class=\"attr\">created</span>: <span class=\"string\">\"10/2/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">112</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">true</span>,             <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-27\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Lena\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Alter all quuxes\"</span>,  <span class=\"attr\">created</span>: <span class=\"string\">\"10/5/2013\"</span>&#125;</span><br><span class=\"line\">        <span class=\"comment\">// , ...</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们需要一个函数 <code>getIncompleteTaskSummaries</code>，接受成员名字（<code>memebername</code>）为参数，然后从服务器（或其他地方）获取数据，挑选出该成员未完成的任务，返回它们的 id、优先级、标题和到期日期，并按到期日期排序。实际上，它返回一个用来解析出这个有序列表的 Promise。</p>\n<p>如果向 <code>getIncompleteTaskSummaries</code> 传入 &quot;Scott&quot;，它可能会返回：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>: <span class=\"number\">110</span>, <span class=\"attr\">title</span>: <span class=\"string\">\"Rename everything\"</span>, </span><br><span class=\"line\">        dueDate: <span class=\"string\">\"2013-11-15\"</span>, <span class=\"attr\">priority</span>: <span class=\"string\">\"medium\"</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>: <span class=\"number\">104</span>, <span class=\"attr\">title</span>: <span class=\"string\">\"Do something\"</span>, </span><br><span class=\"line\">        dueDate: <span class=\"string\">\"2013-11-29\"</span>, <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>好的，这就开始吧。下面这段代码是否看着很熟悉？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data.tasks;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = tasks.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tasks[i].username == membername) &#123;</span><br><span class=\"line\">                    results.push(tasks[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = tasks.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!tasks[i].complete) &#123;</span><br><span class=\"line\">                    results.push(tasks[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> results = [], task;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = tasks.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">                task = tasks[i];</span><br><span class=\"line\">                results.push(&#123;</span><br><span class=\"line\">                    id: task.id,</span><br><span class=\"line\">                    dueDate: task.dueDate,</span><br><span class=\"line\">                    title: task.title,</span><br><span class=\"line\">                    priority: task.priority</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            tasks.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first, second</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> a = first.dueDate, b = second.dueDate;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> a &lt; b ? <span class=\"number\">-1</span> : a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tasks;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>下面的代码是否更好些呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(R.get(<span class=\"string\">'tasks'</span>))</span><br><span class=\"line\">        .then(R.filter(R.propEq(<span class=\"string\">'username'</span>, membername)))</span><br><span class=\"line\">        .then(R.reject(R.propEq(<span class=\"string\">'complete'</span>, <span class=\"literal\">true</span>)))</span><br><span class=\"line\">        .then(R.map(R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>])))</span><br><span class=\"line\">        .then(R.sortBy(R.get(<span class=\"string\">'dueDate'</span>)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果是的话，那么柯里化会更适合你。所有上面代码块中提及的 Ramda 函数都是柯里化的。（事实上，绝大多数 Ramda 的多参数函数都是柯里化的，除了极个别的几个之外）在很多情形下，柯里化是使代码能更容易组合成这么简洁优雅的模块的原因之一。</p>\n<p>让我们看看发生了什么。</p>\n<p><code>get</code> （也称为 <code>prop</code>）定义如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.get = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[name];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>但是，当调用上面的代码时，我们只提供第一个参数：<code>name</code>。正如之前讨论的，这意味着我们会返回一个新函数，等待第一个 <code>then</code> 传入 <code>obj</code> 参数给它，这就意味着下面的代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(R.get(<span class=\"string\">'task'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>可以看做是下面代码的缩写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.tasks;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>接下来是 <code>propEq</code>，定义如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.propEq = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, val, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[name] === val;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>所以当使用参数 <code>username</code> 和 <code>membername</code> 调用它时，柯里化返给我们一个新函数，等价于：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[<span class=\"string\">'username'</span>] === membername;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>membername</code> 的值绑定到了传递给我们的值上面。</p>\n<p>然后将该函数传给 <code>filter</code>。</p>\n<p>Ramda 的 <code>filter</code> 的工作原理很像原生的 <code>Array.prototype.filter</code> ，但类型签名为：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.filter = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">predicate, list</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>所以，我们又进行柯里化了，只传入 &quot;predicate&quot; 函数（谓词），而没有一同传入从上一步输出的任务列表。（我已经告诉过你，所有的东西都是柯里化的，对吧？）</p>\n<p><code>propEq('complete', true) -&gt; reject</code> 与 <code>propEq('username', membername) -&gt; filter</code> 做了相似的事情。<code>reject</code> 和 <code>filter</code> 功能类似，除了它们的输出结果是相反的。它只保留使 predicate 函数返回 false 的元素。</p>\n<p>好了，你还在看吗？我的食指开始发酸了。（真的要学习盲打了！）不需要我来解释最后两行了吧？真的吗？你确定？好吧！好吧！那我再解释一下。</p>\n<p>接下来我们看看：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>])</span><br></pre></td></tr></table></figure></p>\n<p><code>pick</code> 接受属性名称列表和一个对象，返回从原对象提取指定属性集的新对象。你看，我们又使用了柯里化。由于只传递了属性名称列表，我们得到了一个函数：一旦我们提供一个对象，就会返回一个相同类型的新对象。该函数被传给 <code>R.map</code>。与 <code>filter</code> 类似，它与原生 <code>Array.prototype.map</code> 功能基本相同，但签名如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, list</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>不得不告诉你，这个函数也是柯里化的，因为我们只提供给它 <code>pick</code> 返回的函数（也是柯里化的！），而没有提供列表。<code>then</code> 将使用任务列表调用它。</p>\n<p>好的，还记得小时候坐在教室，等待上课结束的情形吗？手里时钟的分针像是卡住了，另一只手正伸向桌洞里的糖果；老师却还在一遍一遍地重复相同的事情。还记得吗？然后那一刻终于到了，可能是结束前的最后两分钟，结束的时刻已经在眼前了：谢天谢地！下面是最后一个例子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(R.sortBy(R.get(<span class=\"string\">'dueDate'</span>)));</span><br></pre></td></tr></table></figure></p>\n<p>之前已经提到过 <code>get</code>。这也是柯里化的，它会返回一个函数：输入对象，输出该对象的 <code>dueDate</code> 属性值。我们将其传给 <code>sortBy</code>，它接受这样的函数和一个列表，并根据函数返回的值对列表中的元素进行排序。但等等，我们没有列表，对吧？当然没有。我们又在做柯里化。但当调用 <code>then</code> 时，它会接收到列表，将列表中的每个对象传给 <code>get</code>，并根据结果进行排序。</p>\n<h2>那么，柯里化有多重要呢？</h2>\n<p>这个例子展示了 Ramda 的一些实用函数和 Ramda 的柯里化特性。或许柯里化并没有那么重要。我们不加柯里化重写一遍：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.get(<span class=\"string\">'tasks'</span>, data)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.propEq(<span class=\"string\">'username'</span>, membername, task)</span><br><span class=\"line\">            &#125;, tasks)</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.reject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.propEq(<span class=\"string\">'complete'</span>, <span class=\"literal\">true</span>, task);</span><br><span class=\"line\">            &#125;, tasks)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>], task);</span><br><span class=\"line\">            &#125;, tasks);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">abbreviatedTasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.sortBy(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">abbrTask</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.get(<span class=\"string\">'dueDate'</span>, abbrTask);</span><br><span class=\"line\">            &#125;, abbreviatedTasks);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面是等价的程序。它仍然比原来的代码好一些。Ramda 实用的函数... 确实比较实用，即使没有柯里化。但我不认为它的可读性有下面的好：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(R.get(<span class=\"string\">'tasks'</span>))</span><br><span class=\"line\">        .then(R.filter(R.propEq(<span class=\"string\">'username'</span>, membername)))</span><br><span class=\"line\">        .then(R.reject(R.propEq(<span class=\"string\">'complete'</span>, <span class=\"literal\">true</span>)))</span><br><span class=\"line\">        .then(R.map(R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>])))</span><br><span class=\"line\">        .then(R.sortBy(R.get(<span class=\"string\">'dueDate'</span>)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这就是我们柯里化的原因。</p>\n<hr>\n<p>课程结束了。</p>\n<p>我警告过你的。</p>\n<p>下一次，当我让你去看别人的东西而不是我的的时候，你会注意了吧。现在不读我的文章可能已经来不及了，但是他们的作品真的很棒，强烈推荐大家看一下：</p>\n<ul>\n<li><a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">为什么柯里化有帮助</a> ，Hugh FD Jackson</li>\n<li><a href=\"http://www.youtube.com/watch?v=m3svKOdZijA\" target=\"_blank\" rel=\"noopener\">嗨 Underscore，你做错了</a> ，Dr. Boolean, aka Brian Lonsdorf</li>\n</ul>\n<p>这里还有一篇我今天刚看到的新的文章。不知它是否会经的其时间的考验，但现在看来值得一读：</p>\n<ul>\n<li><a href=\"http://bahmutov.calepin.co/put-callback-first-for-elegance.html\" target=\"_blank\" rel=\"noopener\">将回调放在首位，代码会更优雅</a> ，Gleb Bahmutov</li>\n</ul>\n<h2>一点不太好的小秘密</h2>\n<p>柯里化尽管非常强大，但单独使用并不足以让你的代码变得 &quot;那么&quot; 优雅。</p>\n<p>应该有三个重要的组成部分：</p>\n<ul>\n<li>\n<p><a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">上次</a> 我讨论了 <strong>函数式组合</strong>。它可以轻松地将你所有好的想法组合在一起，而不必使用大量丑陋的胶水代码将它们聚合在一起。</p>\n</li>\n<li>\n<p><strong>柯里化</strong> 同样很有用，因为它很好的支持了组合，而且消除了大量的样板代码，正如上面所示。</p>\n</li>\n<li>\n<p>很多能操作有用数据结构（如对象类型的数组）的 <strong>实用函数</strong> 。</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> 的目标之一便是：在一个简单的包里面提供所有这些功能。</p>\n<h2>致谢</h2>\n<p><a href=\"http://buzzdecafe.github.io/\" target=\"_blank\" rel=\"noopener\">buzzdecafe</a> 帮助编辑了本文和上一篇文章，并且这次还起了一个完美标题。谢谢，Mike！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 <a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">Scott Sauyet</a> 的 《<a href=\"http://fr.umio.us/favoring-curry/\" target=\"_blank\" rel=\"noopener\">Favoring Curry</a>》，转载请与<a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>我<a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">最近一篇</a> 关于 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> 函数式组合的文章阐述了一个重要的话题。为了使用 Ramda 函数做这种组合，需要这些函数是柯里化的。</p>\n<p>Curry，咖喱？某种辛辣的食物？是什么呢？又在哪里？</p>\n<p>实际上，<code>curry</code> 是为纪念 Haskell Curry 而命名的，他是第一个研究这种技术的人。（是的，人们还用他的姓氏--Haskell--作为一门函数式编程语言；不仅如此，Curry 的中间名字以 'B' 开头，代表 <a href=\"http://en.wikipedia.org/wiki/Brainfuck\" target=\"_blank\" rel=\"noopener\">Brainf*ck</a></p>\n<p>柯里化将多参数函数转化一个新函数：当接受部分参数时，返回等待接受剩余参数的新函数。</p>\n<p>原始函数看起来像是这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// uncurried version</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> formatName1 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first, middle, last</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first + <span class=\"string\">' '</span> + middle + <span class=\"string\">' '</span> + last;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">formatName1(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>, <span class=\"string\">'Jones'</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; 'John Paul Jones' // (Ah, but the musician or the admiral?)</span></span><br><span class=\"line\">formatName1(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; 'John Paul undefined');</span></span><br></pre></td></tr></table></figure></p>\n<p>但柯里化后的函数更有用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// curried version</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> formatNames2 = R.curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first, middle, last</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> first + <span class=\"string\">' '</span> + middle + <span class=\"string\">' '</span> + last;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">formatNames2(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>, <span class=\"string\">'Jones'</span>);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; 'John Paul Jones' // (definitely the musician!)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> jp = formatNames2(<span class=\"string\">'John'</span>, <span class=\"string\">'Paul'</span>); <span class=\"comment\">//=&gt; returns a function</span></span><br><span class=\"line\">jp(<span class=\"string\">'Jones'</span>); <span class=\"comment\">//=&gt; 'John Paul Jones' (maybe this one's the admiral)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Stevens'</span>); <span class=\"comment\">//=&gt; 'John Paul Stevens' (the Supreme Court Justice)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Pontiff'</span>); <span class=\"comment\">//=&gt; 'John Paul Pontiff' (ok, so I cheated.)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Ziller'</span>); <span class=\"comment\">//=&gt; 'John Paul Ziller' (magician, a wee bit fictional)</span></span><br><span class=\"line\">jp(<span class=\"string\">'Georgeandringo'</span>); <span class=\"comment\">//=&gt; 'John Paul Georgeandringo' (rockers)</span></span><br></pre></td></tr></table></figure></p>\n<p>或这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"string\">'Jones'</span>, <span class=\"string\">'Stevens'</span>, <span class=\"string\">'Ziller'</span>].map(jp);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; ['John Paul Jones', 'John Paul Stevens', 'John Paul Ziller']</span></span><br></pre></td></tr></table></figure></p>\n<p>你也可以分多次传入参数，像这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> james = formatNames2(<span class=\"string\">'James'</span>); <span class=\"comment\">//=&gt; returns a function</span></span><br><span class=\"line\">james(<span class=\"string\">'Byron'</span>, <span class=\"string\">'Dean'</span>); <span class=\"comment\">//=&gt; 'James Byron Dean' (rebel)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> je = james(<span class=\"string\">'Earl'</span>); also returns a <span class=\"function\"><span class=\"keyword\">function</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">je</span>(<span class=\"params\"><span class=\"string\">'Carter'</span></span>); //=&gt; '<span class=\"title\">James</span> <span class=\"title\">Earl</span> <span class=\"title\">Carter</span>' (<span class=\"params\">president</span>)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">je</span>(<span class=\"params\"><span class=\"string\">'Jones'</span></span>); //=&gt; '<span class=\"title\">James</span> <span class=\"title\">Earl</span> <span class=\"title\">Jones</span>' (<span class=\"params\">actor, Vader</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>（有些人会坚持认为我们正在做的应该叫作 &quot;部分应用(partial application)&quot;，&quot;柯里化&quot; 的返回函数应该每次只接受一个参数，每次函数处理完单个参数后返回一个新的接受单参数的函数，直到所有必需的参数都已传入。他们可以坚持他们的观点，无所谓）</p>\n<h2>好无聊啊...! 它能为我做什么呢？</h2>\n<p>这里有一个稍有意义的示例。如果想计算一个数字集合的总和，可以这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Plain JS:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = numbers.reduce(add, <span class=\"number\">0</span>); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>而若想编写一个通用的计算数字列表总和的函数，可以这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> total = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list.reduce(add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> sum = total(numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>在 Ramda 中，<code>total</code> 和 <code>sum</code> 和上面的定义非常相似。可以这样定义 <code>sum</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = R.reduce(add, <span class=\"number\">0</span>, numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>但由于 <code>reduce</code> 是柯里化函数，当跳过最后一个参数时，就类似于 <code>total</code> 的定义了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// In Ramda:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> total = R.reduce(add, <span class=\"number\">0</span>);  <span class=\"comment\">// returns a function</span></span><br></pre></td></tr></table></figure></p>\n<p>上面将会获得一个可以调用的函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = total(numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<p>再次注意，函数的定义和将函数作用于数据是多么的相似：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> total = R.reduce(add, <span class=\"number\">0</span>); <span class=\"comment\">//=&gt; function:: [Number] -&gt; Number</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> sum =   R.reduce(add, <span class=\"number\">0</span>, numbers); <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<h2>我不关心这些，我又不是数学怪黎叔</h2>\n<p>那么你做 web 开发吗？huh？会对服务器发起 AJAX 请求吗？使用的是 <a href=\"http://promises-aplus.github.io/promises-spec/\" target=\"_blank\" rel=\"noopener\">Promises</a> 吗？必须要操作返回的数据，对其进行过滤，取子集等？或者你做 server 端开发？会异步查询一个 no-SQL 数据库，并操作这些结果？</p>\n<p>我最好的建议是，去看看 Hugh FD Jackson 的文章：<a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">为什么柯里化有帮助</a>。它是我读过的这方面最好的文章。如果你想要看视频，花上半个小时看一下 Dr. Boolean 的视频：<a href=\"http://www.youtube.com/watch?v=m3svKOdZijA\" target=\"_blank\" rel=\"noopener\">Hey Underscore, 你错了</a>。（不要被标题吓到，他没有花太多时间批评那个库）</p>\n<p>一定要看看这些材料！它们比我解释的更好；你已经察觉到我有多么的啰嗦、夸夸其谈、冗长甚至愚笨。如果你已经看了上面的材料，可以跳过本文剩余小节了。它们解释的已经够清楚了。</p>\n<p>我已经警告过你了哦。</p>\n<hr>\n<p>假设我们希望得到一些这样的数据：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> data = &#123;</span><br><span class=\"line\">    result: <span class=\"string\">\"SUCCESS\"</span>,</span><br><span class=\"line\">    interfaceVersion: <span class=\"string\">\"1.0.3\"</span>,</span><br><span class=\"line\">    requested: <span class=\"string\">\"10/17/2013 15:31:20\"</span>,</span><br><span class=\"line\">    lastUpdated: <span class=\"string\">\"10/16/2013 10:52:39\"</span>,</span><br><span class=\"line\">    tasks: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">104</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-29\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Scott\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Do something\"</span>,      <span class=\"attr\">created</span>: <span class=\"string\">\"9/22/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">105</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"medium\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-22\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Lena\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Do something else\"</span>, <span class=\"attr\">created</span>: <span class=\"string\">\"9/22/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">107</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">true</span>,             <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-22\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Mike\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Fix the foo\"</span>,       <span class=\"attr\">created</span>: <span class=\"string\">\"9/22/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">108</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"low\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-15\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Punam\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Adjust the bar\"</span>,    <span class=\"attr\">created</span>: <span class=\"string\">\"9/25/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">110</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">false</span>,            <span class=\"attr\">priority</span>: <span class=\"string\">\"medium\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-15\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Scott\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Rename everything\"</span>, <span class=\"attr\">created</span>: <span class=\"string\">\"10/2/2013\"</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">id</span>: <span class=\"number\">112</span>, <span class=\"attr\">complete</span>: <span class=\"literal\">true</span>,             <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>,</span><br><span class=\"line\">                  dueDate: <span class=\"string\">\"2013-11-27\"</span>,      <span class=\"attr\">username</span>: <span class=\"string\">\"Lena\"</span>,</span><br><span class=\"line\">                  title: <span class=\"string\">\"Alter all quuxes\"</span>,  <span class=\"attr\">created</span>: <span class=\"string\">\"10/5/2013\"</span>&#125;</span><br><span class=\"line\">        <span class=\"comment\">// , ...</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们需要一个函数 <code>getIncompleteTaskSummaries</code>，接受成员名字（<code>memebername</code>）为参数，然后从服务器（或其他地方）获取数据，挑选出该成员未完成的任务，返回它们的 id、优先级、标题和到期日期，并按到期日期排序。实际上，它返回一个用来解析出这个有序列表的 Promise。</p>\n<p>如果向 <code>getIncompleteTaskSummaries</code> 传入 &quot;Scott&quot;，它可能会返回：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>: <span class=\"number\">110</span>, <span class=\"attr\">title</span>: <span class=\"string\">\"Rename everything\"</span>, </span><br><span class=\"line\">        dueDate: <span class=\"string\">\"2013-11-15\"</span>, <span class=\"attr\">priority</span>: <span class=\"string\">\"medium\"</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">id</span>: <span class=\"number\">104</span>, <span class=\"attr\">title</span>: <span class=\"string\">\"Do something\"</span>, </span><br><span class=\"line\">        dueDate: <span class=\"string\">\"2013-11-29\"</span>, <span class=\"attr\">priority</span>: <span class=\"string\">\"high\"</span>&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>好的，这就开始吧。下面这段代码是否看着很熟悉？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> data.tasks;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = tasks.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (tasks[i].username == membername) &#123;</span><br><span class=\"line\">                    results.push(tasks[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> results = [];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = tasks.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (!tasks[i].complete) &#123;</span><br><span class=\"line\">                    results.push(tasks[i]);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> results = [], task;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>, len = tasks.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">                task = tasks[i];</span><br><span class=\"line\">                results.push(&#123;</span><br><span class=\"line\">                    id: task.id,</span><br><span class=\"line\">                    dueDate: task.dueDate,</span><br><span class=\"line\">                    title: task.title,</span><br><span class=\"line\">                    priority: task.priority</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            tasks.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">first, second</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">var</span> a = first.dueDate, b = second.dueDate;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> a &lt; b ? <span class=\"number\">-1</span> : a &gt; b ? <span class=\"number\">1</span> : <span class=\"number\">0</span>;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> tasks;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>下面的代码是否更好些呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(R.get(<span class=\"string\">'tasks'</span>))</span><br><span class=\"line\">        .then(R.filter(R.propEq(<span class=\"string\">'username'</span>, membername)))</span><br><span class=\"line\">        .then(R.reject(R.propEq(<span class=\"string\">'complete'</span>, <span class=\"literal\">true</span>)))</span><br><span class=\"line\">        .then(R.map(R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>])))</span><br><span class=\"line\">        .then(R.sortBy(R.get(<span class=\"string\">'dueDate'</span>)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>如果是的话，那么柯里化会更适合你。所有上面代码块中提及的 Ramda 函数都是柯里化的。（事实上，绝大多数 Ramda 的多参数函数都是柯里化的，除了极个别的几个之外）在很多情形下，柯里化是使代码能更容易组合成这么简洁优雅的模块的原因之一。</p>\n<p>让我们看看发生了什么。</p>\n<p><code>get</code> （也称为 <code>prop</code>）定义如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.get = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[name];</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>但是，当调用上面的代码时，我们只提供第一个参数：<code>name</code>。正如之前讨论的，这意味着我们会返回一个新函数，等待第一个 <code>then</code> 传入 <code>obj</code> 参数给它，这就意味着下面的代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(R.get(<span class=\"string\">'task'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>可以看做是下面代码的缩写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data.tasks;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>接下来是 <code>propEq</code>，定义如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.propEq = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">name, val, obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[name] === val;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>所以当使用参数 <code>username</code> 和 <code>membername</code> 调用它时，柯里化返给我们一个新函数，等价于：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">obj</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj[<span class=\"string\">'username'</span>] === membername;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>membername</code> 的值绑定到了传递给我们的值上面。</p>\n<p>然后将该函数传给 <code>filter</code>。</p>\n<p>Ramda 的 <code>filter</code> 的工作原理很像原生的 <code>Array.prototype.filter</code> ，但类型签名为：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.filter = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">predicate, list</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>所以，我们又进行柯里化了，只传入 &quot;predicate&quot; 函数（谓词），而没有一同传入从上一步输出的任务列表。（我已经告诉过你，所有的东西都是柯里化的，对吧？）</p>\n<p><code>propEq('complete', true) -&gt; reject</code> 与 <code>propEq('username', membername) -&gt; filter</code> 做了相似的事情。<code>reject</code> 和 <code>filter</code> 功能类似，除了它们的输出结果是相反的。它只保留使 predicate 函数返回 false 的元素。</p>\n<p>好了，你还在看吗？我的食指开始发酸了。（真的要学习盲打了！）不需要我来解释最后两行了吧？真的吗？你确定？好吧！好吧！那我再解释一下。</p>\n<p>接下来我们看看：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>])</span><br></pre></td></tr></table></figure></p>\n<p><code>pick</code> 接受属性名称列表和一个对象，返回从原对象提取指定属性集的新对象。你看，我们又使用了柯里化。由于只传递了属性名称列表，我们得到了一个函数：一旦我们提供一个对象，就会返回一个相同类型的新对象。该函数被传给 <code>R.map</code>。与 <code>filter</code> 类似，它与原生 <code>Array.prototype.map</code> 功能基本相同，但签名如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ramda.map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, list</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;);</span><br></pre></td></tr></table></figure></p>\n<p>不得不告诉你，这个函数也是柯里化的，因为我们只提供给它 <code>pick</code> 返回的函数（也是柯里化的！），而没有提供列表。<code>then</code> 将使用任务列表调用它。</p>\n<p>好的，还记得小时候坐在教室，等待上课结束的情形吗？手里时钟的分针像是卡住了，另一只手正伸向桌洞里的糖果；老师却还在一遍一遍地重复相同的事情。还记得吗？然后那一刻终于到了，可能是结束前的最后两分钟，结束的时刻已经在眼前了：谢天谢地！下面是最后一个例子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.then(R.sortBy(R.get(<span class=\"string\">'dueDate'</span>)));</span><br></pre></td></tr></table></figure></p>\n<p>之前已经提到过 <code>get</code>。这也是柯里化的，它会返回一个函数：输入对象，输出该对象的 <code>dueDate</code> 属性值。我们将其传给 <code>sortBy</code>，它接受这样的函数和一个列表，并根据函数返回的值对列表中的元素进行排序。但等等，我们没有列表，对吧？当然没有。我们又在做柯里化。但当调用 <code>then</code> 时，它会接收到列表，将列表中的每个对象传给 <code>get</code>，并根据结果进行排序。</p>\n<h2>那么，柯里化有多重要呢？</h2>\n<p>这个例子展示了 Ramda 的一些实用函数和 Ramda 的柯里化特性。或许柯里化并没有那么重要。我们不加柯里化重写一遍：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.get(<span class=\"string\">'tasks'</span>, data)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.propEq(<span class=\"string\">'username'</span>, membername, task)</span><br><span class=\"line\">            &#125;, tasks)</span><br><span class=\"line\">         &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.reject(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.propEq(<span class=\"string\">'complete'</span>, <span class=\"literal\">true</span>, task);</span><br><span class=\"line\">            &#125;, tasks)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>], task);</span><br><span class=\"line\">            &#125;, tasks);</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">abbreviatedTasks</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> R.sortBy(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">abbrTask</span>) </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> R.get(<span class=\"string\">'dueDate'</span>, abbrTask);</span><br><span class=\"line\">            &#125;, abbreviatedTasks);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>上面是等价的程序。它仍然比原来的代码好一些。Ramda 实用的函数... 确实比较实用，即使没有柯里化。但我不认为它的可读性有下面的好：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIncompleteTaskSummaries = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">membername</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetchData()</span><br><span class=\"line\">        .then(R.get(<span class=\"string\">'tasks'</span>))</span><br><span class=\"line\">        .then(R.filter(R.propEq(<span class=\"string\">'username'</span>, membername)))</span><br><span class=\"line\">        .then(R.reject(R.propEq(<span class=\"string\">'complete'</span>, <span class=\"literal\">true</span>)))</span><br><span class=\"line\">        .then(R.map(R.pick([<span class=\"string\">'id'</span>, <span class=\"string\">'dueDate'</span>, <span class=\"string\">'title'</span>, <span class=\"string\">'priority'</span>])))</span><br><span class=\"line\">        .then(R.sortBy(R.get(<span class=\"string\">'dueDate'</span>)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这就是我们柯里化的原因。</p>\n<hr>\n<p>课程结束了。</p>\n<p>我警告过你的。</p>\n<p>下一次，当我让你去看别人的东西而不是我的的时候，你会注意了吧。现在不读我的文章可能已经来不及了，但是他们的作品真的很棒，强烈推荐大家看一下：</p>\n<ul>\n<li><a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">为什么柯里化有帮助</a> ，Hugh FD Jackson</li>\n<li><a href=\"http://www.youtube.com/watch?v=m3svKOdZijA\" target=\"_blank\" rel=\"noopener\">嗨 Underscore，你做错了</a> ，Dr. Boolean, aka Brian Lonsdorf</li>\n</ul>\n<p>这里还有一篇我今天刚看到的新的文章。不知它是否会经的其时间的考验，但现在看来值得一读：</p>\n<ul>\n<li><a href=\"http://bahmutov.calepin.co/put-callback-first-for-elegance.html\" target=\"_blank\" rel=\"noopener\">将回调放在首位，代码会更优雅</a> ，Gleb Bahmutov</li>\n</ul>\n<h2>一点不太好的小秘密</h2>\n<p>柯里化尽管非常强大，但单独使用并不足以让你的代码变得 &quot;那么&quot; 优雅。</p>\n<p>应该有三个重要的组成部分：</p>\n<ul>\n<li>\n<p><a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">上次</a> 我讨论了 <strong>函数式组合</strong>。它可以轻松地将你所有好的想法组合在一起，而不必使用大量丑陋的胶水代码将它们聚合在一起。</p>\n</li>\n<li>\n<p><strong>柯里化</strong> 同样很有用，因为它很好的支持了组合，而且消除了大量的样板代码，正如上面所示。</p>\n</li>\n<li>\n<p>很多能操作有用数据结构（如对象类型的数组）的 <strong>实用函数</strong> 。</p>\n</li>\n</ul>\n<p><a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> 的目标之一便是：在一个简单的包里面提供所有这些功能。</p>\n<h2>致谢</h2>\n<p><a href=\"http://buzzdecafe.github.io/\" target=\"_blank\" rel=\"noopener\">buzzdecafe</a> 帮助编辑了本文和上一篇文章，并且这次还起了一个完美标题。谢谢，Mike！</p>\n"},{"title":"Functional Programming: Abstract and Composition","date":"2017-09-29T02:10:16.000Z","_content":"","source":"_posts/Functional-Programming-Abstract-and-Composition.md","raw":"---\ntitle: 'Functional Programming: Abstract and Composition'\ndate: 2017-09-29 10:10:16\ncategories: 'Functional Programming'\n---\n","slug":"Functional-Programming-Abstract-and-Composition","published":1,"updated":"2020-06-06T14:44:04.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfit80004f6mj2cgiuxqw","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Fantasy-Land-Specification","date":"2018-09-08T08:45:36.000Z","_content":"(又名 \"代数 JavaScript 规范\")\n\n![logo](./logo.png)\n\n该项目规定了通用代数数据结构的互操作性：\n\n* [Setoid](#setoid)\n* [Ord](#ord)\n* [Semigroupoid](#semigroupoid)\n* [Category](#category)\n* [Semigroup](#semigroup)\n* [Monoid](#monoid)\n* [Group](#group)\n* [Filterable](#filterable)\n* [Functor](#functor)\n* [Contravariant](#contravariant)\n* [Apply](#apply)\n* [Applicative](#applicative)\n* [Alt](#alt)\n* [Plus](#plus)\n* [Alternative](#alternative)\n* [Foldable](#foldable)\n* [Traversable](#traversable)\n* [Chain](#chain)\n* [ChainRec](#chainrec)\n* [Monad](#monad)\n* [Extend](#extend)\n* [Comonad](#comonad)\n* [Bifunctor](#bifunctor)\n* [Profunctor](#profunctor)\n\n![dependencies](./dependencies.png)\n\n## 概览\n\n代数是遵循一定法则的、具有封闭性的，一系列值及一系列操作的集合。\n\n每个 Fantasy Land 代数是一个单独的规范。一个代数可能依赖于其他必需实现的代数。\n\n## 术语\n\n1. \"值\"：任何 JavaScript 值，包括下面定义的结构的任何值。\n\n2. \"等价\"：对给定值的等价性的恰当定义。这个定义应该保证两个值可以在其对应的抽象的程序中，能够安全地进行交换。例如：\n\n    - 当两个列表对应的索引上的值都相等时，它们是等价的。\n    - 当两个普通的 JavaScript 对象所有键值对都相等时，它们（作为字典）是等价的。\n    - 当两个 promises 生成相等的值时，它们是等价的。\n    - 当两个函数给定相同的输入，产生相同的输出时，它们是等价的。\n\n## 类型签名符号\n\n本文档使用的类型签名符号如下所述：[^1]\n\n* `::` __\"是 xx 的成员\"。_\n    - `e :: t` 读作：\"表达式 `e` 是类型 `t` 的成员\"。\n    - `true :: Boolean` - \"`true` 是类型 `Boolean` 的成员\"。\n    - `42 :: Integer, Number` - \"`42` 是类型 `Integer` 和 `Number` 的成员\"。\n* _新类型可以通过类型构造函数创建。_\n    - 类型构造函数可以接受零或多个类型参数。\n    - `Array` 是一个接受单个参数的类型构造函数。\n    - `Array String` 代表包含字符串的数组的类型。后面每个都是 `Array String` 类型的：`[]`，`['foo', 'bar', 'baz']`。\n    - `Array (Array String)` 代表包含字符串的数组的数组的类型。后面每个都是 `Array (Array String)` 类型的：`[]`，`[[], []]`， `[[], ['foo'], ['bar', 'baz']]`。\n* _小写字母代表类型变量。_\n    - 类型变量可以接受任何类型，除非受到类型约束的限制（参见下面的胖箭头）。\n    - `->` (箭头) _函数类型的构造函数_\n    - `->` 是一个 _中缀_ 构造函数，它接受两个类型参数，左侧参数为输入的类型，右侧参数为输出的类型。\n    - `->` 的输入类型可以通过一组类型创建出来，该函数接受零个或多个参数。其语法是：`(<input-types>) -> <output-type>`，其中 `<input-types>` 包含零个或多个 \"逗号-空格\" （`, `）分开的类型表示，对于一元函数，圆括号也可以省略。\n    - `String -> Array String` 是一种接受一个 `String` 并返回一个 `Array String` 的函数的类型。\n    - `String -> Array String -> Array String` 是一种函数类型，它接受一个 `String` 并返回一个函数，返回的函数接受一个 `Array String` 并返回一个 `Array String`。\n    - `(String, Array String) -> Array String` 是一种函数类型，它接受一个 `String` 和 `Aray String` 作为参数，并返回一个 `Array String` 。\n    - `() -> Number` 是一种不带输入参数，返回 `Number` 的函数类型。\n* `~>` (波浪形箭头) _方法类型的构造函数。_\n    - 当一个函数是一个对象（Object）的属性时，它被称为方法。所有方法都有一个隐含的参数类型 - 它是属性所在对象的类型。\n    - `a ~> a -> a` 是一种对象中方法的类型，它接受 `a` 类型的参数，并返回一个 `a` 类型的值。\n* `=>` (胖箭头) 表示对类型变量的约束。\n    - 在 `a ~> a -> a`（参见上面的波浪形箭头）中，`a` 可以为任意类型。半群 `a => a ~> a -> a` 会添加一个约束，使得类型 `a` 现在必须满足该半群的类型类。满足类型类意味着，须合法地实现该类型类指定所有函数/方法。\n\n例如：\n\n```\ntraverse :: Applicative f, Traversable t => t a ~> (TypeRep f, a -> f b) -> f (t b)\n'------'    '--------------------------'    '-'    '-------------------'    '-----'\n '           '                               '      '                        '\n '           ' - type constraints            '      ' - argument types       ' - return type\n '                                           '\n '- method name                              ' - method target type\n```\n\n[^1]: 更多相关信息，请参阅 Sanctuary 文档中的 [Types](https://sanctuary.js.org/#types) 部分。\n\n## 前缀方法名\n\n为了使数据类型与 Fantasy Land 兼容，其值必须具有某些属性。这些属性都以 `fantasy-land/` 为前缀。例如：\n\n```js\n//  MyType#fantasy-land/map :: MyType a ~> (a -> b) -> MyType b\nMyType.prototype['fantasy-land/map'] = ...\n```\n\n在本文中，不使用前缀的名称，只是为了减少干扰。\n\n为了方便起见，你可以使用 `fantasy-land` 包：\n\n```js\nvar fl = require('fantasy-land')\n\n// ...\n\nMyType.prototype[fl.map] = ...\n\n// ...\n\nvar foo = bar[fl.map](x => x + 1)\n```\n\n## 类型表示 (JavaScript 中的构造函数？)\n\n某些行为是从类型成员的角度定义的。而另外一些行为不需要类型成员。因此，某些代数需要一个类型来提供值层面上的表示（具有某些属性）。例如，Identity 类型可以提供 `Id` 作为其类型表示：`Id :: TypeRep Identity`。\n\n如果一个类型提供了类型表示，那么这个类型的每个成员都必须有一个指向该类型表示的 `contructor` 属性。\n\n## 代数\n\n### Setoid\n\n1. `a.equals(a) === true` (自反性)\n2. `a.equals(b) === b.equals(a)` (对称性)\n3. 如果 `a.equals(b)` 并且 `b.equals(a)`，则 `a.equals(c)` (传递性)\n\n#### `equals` 方法\n\n```hs\nequals :: Setoid a => a ~> a -> Boolean\n```\n\n具有 Setoid 的值必须提供 `equals` 方法。`equals` 方法接受一个参数：\n\n    a.equals(b)\n\n1. `b` 必须是相同 Setoid 的值\n    1. 如果 `b` 不是相同的 Setoid，则 `equals` 的行为未指定（建议返回 `false`）。\n    2. `equals` 必须返回一个布尔值（`true` 或 `false`）。\n\n### Ord\n\n实现 Ord 规范的值还必须实现 [Setoid](#setoid) 规范。\n\n1. `a.lte(b)` 或 `b.lte(a)` (完全性)\n2. 如果 `a.lte(b)` 且 `b.lte(a)`，则 `a.equals(b)` (反对称性)\n3. 如果 `a.lte(b)` 且 `b.lte(c)`，则 `a.lte(c)` (传递性)\n\n#### `lte` 方法\n\n```hs\nlte :: Ord a => a ~> a -> Boolean\n```\n\n具有 Ord 的值必须提供 `lte` 方法。`lte` 方法接受一个参数：\n\n    `a.lte(b)`\n\n1. `b` 必须是相同 Ord 的值。\n    1. 如果 `b` 不是相同的 Ord，则 `lte` 的行为未指定 (建议返回 `false`)。\n2. `lte` 必须返回布尔值（`true` 或 `false`）。\n\n### Semigroupoid\n\n1. `a.compose(b).compose(c) === a.compose(b.compose(c))` (结合性)\n\n#### `compose` 方法\n\n```hs\ncompose :: Semigroupoid c => c i j ~> c j k -> c i k\n```\n\n具有 Semigoupoid 的值必须提供 `compose` 组合方法。`compose` 方法接受一个参数：\n\n    a.compose(b)\n\n1. `b` 必须返回相同 Semigroupoid 规范。\n    1. 如果 `b` 不是相同的 Semigroupoid，compose 的行为未指定。\n2. `compose` 必须返回相同 Semigroupoid 的值。\n\n### Category\n实现范畴规范的值还必须实现[半群](#semigroupoid)规范。\n\n1. `a.compose(C.id())` 等价于 `a` (右同一性)\n2. `C.id().compose(a)` 等价于 `a` (左同一性)\n\n#### `id` 方法\n\n```hs\nid :: Category c => () -> c a a\n```\n\n具有范畴的值必须在其[类型表示](#type-representatives)中提供一个 `id` 函数。\n\n    C.id()\n\n给定值 `c`，可以通过 `contructor` 属性来访问其类型表示：\n\n    c.constructgor.id()\n\n1. `id` 必须返回相同范畴的值。\n\n### Semigroup\n\n1. `a.concat(b).concat(c)` 等价于 `a.concat(b.concat(c))` （结合性）\n\n#### `concat` 方法\n\n```hs\nconcat :: Semigroup a => a ~> a -> a\n```\n\n具有 Semigroup 的值必须提供 `concat` 方法。`concat` 方法接受一个参数：\n\n    s.concat(b)\n\n1. `b` 必须是相同 Semigroup 的值\n    1. 如果 `b` 不是相同的 Semigroup，则 `concat` 的行为未指定。\n2. `concat` 必须返回相同 Semigroup 的值。\n\n### Monoid\n\n实现 Monoid 规范的值还必须实现 [Semigroup](#semigroup) 规范\n\n1. `m.concat(M.empty())` 等价于 `m` (右结合性)\n2. `M.empty().concat(m)` 等价于 `m` (左结合性)\n\n#### `empty` 方法\n\n```hs\nempty :: Monoid m => () -> m\n```\n\n具有 Monoid 的值必须在其类型表示上提供 `empty` 方法：\n\n    M.empty()\n\n给定值` `m，可以通过 `constructor` 属性来访问其类型表示：\n\n    m.constructor.empty()\n\n1. `empty` 必须返回相同 Monoid 的值。\n\n### Group\n\n实现 Group 规范的值还必须实现 [Monoid](#monoid) 规范。\n\n1. `g.concat(g.invert())` 等价于 `g.constructor.empty()` (右反转性??)\n2. `g.invert().concat(g)` 等价于 `g.constructor.empty()` (左翻转性??)\n\n#### `invert` 方法\n\n```hs\ninvert :: Group g => g ~> () -> g\n```\n\n具有 Semigroup 的值必须提供 `invert` 方法。`invert` 方法接受零个参数：\n\n    g.invert()\n\n1. `invert` 必须返回相同 Group 的值。\n\n### Filterable\n\n1. `v.filter(x => p(x) && q(x))` 等价于 `v.filter(p).filter(q)` (分配性)\n2. `v.filter(x => true)` 等价于 `v` (同一性)\n3. `v.filter(x -> false)` 等价于 `w.filter(x => false)`，如果 `v` 和 `w` 具有相同的 Filterable 值 (湮灭??)\n\n#### `filter` 方法\n\n```hs\nfilter :: Filterable f => f a ~> (a -> Boolean) -> f a\n```\n\n具有 Filterable 的值必须提供 `filter` 方法。`filter` 方法接受一个参数：\n\n    v.filter(p)\n\n1. `p` 必须是一个函数。\n    1. 如果 `p` 不是函数，则 `filter` 的行为未指定。\n    2. `p` 必须返回 `ture` 或 `false`。如果返回任何其它值，`filter` 的行为未指定。\n\n2. `filter` 必须返回相同 Filterable 的值。\n\n### Functor\n\n1. `u.map(a => a)` 等价于 `u` (同一性)\n2. `u.map(x => f(g(x)))` 等价于 `u.map(g).map(f)` (组合性)\n\n#### `map` 方法\n\n```hs\nmap :: Functor f => f a ~> (a -> b) -> f b\n```\n\n具有 Functor 的值必须提供 `map` 方法。`map` 方法接受一个参数：\n\n    u.map(f)\n\n1. `f` 必须是一个函数，\n    1. 如果 `f` 不是函数，则 `map` 的行为未指定。\n    2. `f` 可以返回任何值。\n    3. `f` 返回值的任何部分都不应该被检查(??)。\n\n2. `map` 必须返回相同 Functor 的值。\n\n\n### Contravariant\n\n1. `u.contramap(a => a)` 等价于 `u` (同一性)\n2. `u.contramap(x => f(g(x)))` 等价于 `u.contramap(f).contramap(g)` (组合性)\n\n#### `contramap` 方法\n\n```hs\ncontramap :: Contravariant f => f a ~> (b -> a) -> f b\n```\n\n具有 Contravariant 的值必须提供 `contramap` 方法。`contramap` 方法接受一个参数：\n\n    u.contramap(f)\n\n1. `f` 必须是一个函数，\n    1. 如果 `f` 不是函数，则 `contramap` 的行为未指定。\n    2. `f` 可以返回任何值。\n    3. `f` 返回值的任何部分都不应该被检查(??)。\n2. `contramap` 必须返回相同 Contravariant 的值。\n\n### Apply\n\n实现 Apply 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `v.ap(u.ap(a.map(f => g => x => f(g(x)))))` 等价于 `v.ap(u).ap(a)` (组合型)，推导过程??\n\n#### `ap` 方法\n\n```hs\nap :: Apply f => f a ~> f (a -> b) -> f b\n```\n\n具有 Apply 的值必须提供 `ap` 方法。`ap` 方法接受一个参数：\n\n    a.ap(b)\n\n1. `b` 必须是一个函数的 Apply\n    1. 如果 `b` 不代表函数，则 `ap` 的行为未指定。\n    2. `b` 必须与 a 具有相同的 Apply。\n2. `a` 可以是任意值的 Apply。(??)\n3. `ap` 必须能将 Apply `b` 内的函数应用于 Apply `a` 的值上\n    1. 函数返回值的任何部分都不应该被检查。\n4. 由 `ap` 返回的 `Apply` 必须与 `a` 和 `b` 的相同。\n\n### Applicative\n\n实现 Applicative 规范的值还必须实现 [Apply](#apply) 规范。\n\n1. `v.ap(A.of(x => x))` 等价于 `v` (同一性)\n2. `A.of(x).ap(A.of(f))` 等价于 `A.of(f(x))` (同态性, homomorphism)\n3. `A.of(y).ap(u)` 等价于 `u.ap(A.of(f => f(y)))` (交换性)\n\n#### `of` 方法\n\n```hs\nof :: Applicative f => a -> f a\n```\n\n具有 Applicative 的值必须在其类型表示中提供 `of` 函数。`of` 函数接受一个参数：\n\n    F.of(a)\n\n给定值 `f`，可以通过 `contructor` 属性访问其类型表示：\n\n    f.contructor.of(a)\n\n1. `of` 必须提供相同的 Applicative\n    1. a 的任何部分都不应该被检查\n\n### Alt\n\n实现 Alt 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `a.alt(b).alt(c)` 等价于 `a.alt(b.alt(c))` (结合性)\n2. `a.alt(b).map(f)` 等价于 `a.map(f).alt(b.map(f))` (分配性) (看起来像乘法，有什么实际用途呢？)\n\n#### `alt` 方法\n\n```hs\nalt :: Alt f => f a ~> f a -> f a\n```\n\n具有 Alt 的值必须提供 `alt` 方法。`alt` 方法接受一个参数：\n\n    a.alt(b)\n\n1. `b` 必须是相同 Alt 的值\n    1. 如果 `b` 不是相同的 Alt，则 `alt` 的行为未指定。\n    2. `a` 和 `b` 可以包含相同类型的任何值。\n    3. `a` 和 `b` 包含值的任何部分都不应该被检查。\n2. `alt` 必须返回相同 Alt 的值。\n\n### Plus\n\n实现 Plus 规范的值还必须实现 [Alt](#alt) 规范。\n\n1. `x.alt(A.zero())` 等价于 `x` (右同一性)\n2. `A.zero().alt(x)` 等价于 `x` (左同一性)\n3. `A.zero().map(f)` 等价于 `A.zero()` (湮灭??)\n\n#### `zero` 方法\n\n```hs\nzero :: Plus f => () -> f a\n```\n\n具有 Plus 的值必须在其类型表示中提供 `zero` 函数：\n\n    A.zero()\n\n给定值 `x`，可以通过 `contructor` 属性访问其类型表示：\n\n    x.contructor.zero()\n\n`zero` 必须返回相同 Plus 的值。\n\n### Alternative\n\n实现 Alternative 规范的值还必须实现 [Applicative](#applicative) 和 [Plus](#plus) 规范。\n\n1. `x.ap(f.alt(g))` 等价于 `x.ap(f).alt(x.ap(g))` (分配性)\n2. `x.ap(A.zero())` 等价于 `A.zero()` (湮灭)\n\n### Foldable\n\n`u.reduce` 等价于 `u.reduce((acc, x) => acc.concat([x]), []).reduce`\n\n#### `reduce` 方法\n\n```hs\nreduce :: Foldable f => f a ~> ((b, a) -> b, b) -> b\n```\n\n具有 Foldable 的值必须在其类型表示中提供 `reduce` 函数。`reduce` 函数接受两个参数：\n\n    u.reduce(f, x)\n\n1. `f` 必须是一个二元函数\n    1. 如果 `f` 不是函数，则 `reduce` 的行为未指定。\n    2. `f` 的第一个参数类型必须与 `x` 的相同。\n    3. `f` 的返回值类型必须与 `x` 的相同。\n    4. `f` 返回值的任何部分都不应该被检查。\n2. `x` 是归约的初始累积值\n    1. `x` 的任何部分都不应该被检查\n\n### Traversable\n\n实现 Traversable 规范的值还必须实现 [Functor](#functor) 和 [Foldable](#foldable) 规范。\n\n1. 对于任意 `t`，`t(u.traverse(F, x => x))` 等价于 `u.traverse(G, t)` ，因为 `t(a).map(f)` 等价于 `t(a.map(f))` (自然性)\n2. 对于任意 Applicative `F`，`u.traverse(F, F.of)` 等价于 `F.of(u)` (同一性)\n3. `u.traverse(Compose, x => new Compose(x))` 等价于 `new Compose(u.traverse(F, x => x).map(x => x.traverse(G, x => x)))`，对下面定义的 `Compose` 和 任意 Applicatives `F` 和 `G` 都适用 (组合性)\n\n```js\nvar Compose = function(c) {\n  this.c = c;\n};\n\nCompose.of = function(x) {\n  return new Compose(F.of(G.of(x)));\n};\n\nCompose.prototype.ap = function(f) {\n  return new Compose(this.c.ap(f.c.map(u => y => y.ap(u))))\n};\n\nCompose.prototype.map = function(f) {\n  return new Compose(this.c.map(y => y.map(f)));\n};\n```\n\n#### `traverse` 方法\n\n```hs\ntraverse :: Applicative f, Traversable t => t a ~> (TypeRep f, a -> f b) -> f (t b)\n```\n\n具有 Traversable 的值必须提供 `traverse` 函数。`traverse` 函数接受两个参数：\n\n    u.traverse(A, f)\n\n1. `A` 必须是一个 Applicative 的类型表示。\n2. `f` 必须是一个返回值的函数\n    1. 如果 `f` 不是函数，则 `traverse` 的行为未指定。\n    2. `f` 必须返回类型表示为 `A` 的值。\n3. `traverse` 必须返回类型表示为 `A` 的值。\n\n### Chain\n\n实现 Chain 规范的值还必须实现 [Apply](#apply) 规范。\n\n1. `m.chain(f).chain(g)` 等价于 `m.chain(x => f(x).chain(g))` (结合性)\n\n#### `chain` 方法\n\n```hs\nchain :: Chain m => m a ~> (a -> m b) -> m b\n```\n\n具有 Chain 的值必须提供 `chain` 函数。`chain` 函数接受一个参数：\n\n    m.chain(f)\n\n1. `f` 必须是一个返回值的函数\n    1. 如果 `f` 不是函数，则 `chain` 的行为未指定。\n    2. `f` 必须返回相同 Chain 的值。\n2. `chain` 必须返回相同 Chain 的值。\n\n### ChainRec\n\n实现 ChainRec 规范的值还必须实现 [Chain](#chain) 规范。\n\n1. `M.chainRec((next, done, v) => p(v) ? d(v).map(done) : n(v).map(next), i)` 等价于 `function step(v) { return p(v) ? d(v) : n(v).chain(step); }(i)` (等价性)\n2. `M.chainRec(f, i)` 栈的用量必须是 `f` 自身栈用量的常数倍。\n\n#### `chainRec` 方法\n\n```hs\nchainRec :: ChainRec m => ((a -> c), b -> c, a) -> m b\n```\n\n具有 ChainRec 的值必须在其类型表示中提供 `chainRec` 函数。`chainRec` 函数接受两个参数：\n\n    M.chainRec(f, i)\n\n给定值 `m`，可以通过 `contructor` 属性访问其类型表示：\n\n    m.constructor.chainRec(f, i)\n\n1. `f` 必须是一个返回值的函数\n    1. 如果 `f` 不是函数，则 `chainRec` 的行为未指定。\n    2. `f` 接受三个参数 `next`，`done`，`value`\n        1. `next` 是一个函数，其接受一个与 i 类型相同的参数，可以返回任意值\n        2. `done` 也是一个函数，其接受一个参数，并返回一个与 `next` 返回值类型相同的值\n        3. `value` 是一个与 i 类型相同的值。\n    3. `f` 必须返回一个相同 ChainRec 的值，其中包含的是从 `done` 或 `next` 返回的值。\n2. `chainRec` 必须返回一个相同 ChainRec 的值，其中包含的值的类型与 `done` 的参数类型相同。\n\n### Monad\n\n实现 Monad 规范的值还必须实现 [Applicative](#applicative) 和 [Chain](#chain) 规范。\n\n1. `M.of(a).chain(f)` 等价于 `f(a)` (左同一性)\n2. `m.chain(M.of)` 等价于 `m` (右同一性)\n\n### Extend\n\n实现 Extend 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `w.extend(g).extend(f)` 等价于 `w.extend(\\_w => f(\\_w.extend(g)))`\n\n`extend` 方法\n\n```hs\nextend :: Extend w => w a ~> (w a -> b) -> w b\n```\n\n具有 Extend 的值必须提供 `extend` 函数。`extend` 函数接受一个参数：\n\n    w.extend(f)\n\n1. `f` 必须是一个返回值的函数，\n    1. 如果 `f` 不是函数，则 extend 的行为未指定。\n    2. `f` 必须返回一个 `v` 类型的值，其中 `v` 是 `w` 中包含的某个变量 `v` (??)\n    3. `f` 返回值的任何部分都不应该被检查。\n2. `extend` 必须返回相同 Extend 的值。\n\n### Comonad\n\n实现 Comonad 规范的值还必须实现 [Extend](#extend) 规范。\n\n1. `w.extend(_w => _w.extract())` 等价于 `w` (左同一性)\n2. `w.extend(f).extract()` 等价于 `f(w)` (右同一性)\n\n#### `extract` 方法\n\n具有 Comonad 的值必须提供 `extract` 函数。`extract` 函数接受零个参数：\n\n    w.extract()\n\n1. `extract` 必须返回一个 `v` 类型的值，其中 `v` 是 `w` 中包含的某个变量 `v` (??)\n    1. `v` 必须与在 `extend` 中的 `f` 返回的类型相同。\n\n### Bifunctor\n\n实现 Bifunctor 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `p.bimap(a => a, b => b)` 等价于 `p` (同一性)\n2. `p.bimap(a => f(g(a)), b => h(i(b)))` 等价于 `p.bimap(g, i).bimap(f, h)` (组合性)\n\n### `bimap` 方法\n\n```hs\nbimap :: Bifunctor f => f a c ~> (a -> b, c -> d) -> f b d\n```\n\n具有 Bifunctor 的值必须提供 `bimap` 函数。`bimap` 函数接受两个参数：\n\n    c.bimap(f, g)\n\n1. `f` 必须是一个返回值的函数，\n    1. 如果 `f` 不是函数，则 `bimap` 的行为未指定。\n    2. `f` 可以返回任意值\n    3. `f` 返回值的任何部分都不应该被检查。\n2. `g` 必须是一个返回值的函数，\n    1. 如果 `g` 不是函数，则 `bimap` 的行为未指定。\n    2. `g` 可以返回任意值\n    3.`g` 返回值的任何部分都不应该被检查。\n3. `bimap` 必须返回相同 Bifunctor 的值。\n\n### Profunctor\n\n实现 Profunctor 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `p.promap(a => a, b => b)` 等价于 `p` (同一性)\n2. `p.promap(a => f(g(a)), b => h(i(b)))` 等价于 `p.promap(f, i).promap(g, h)` (组合性)\n\n#### `promap` 方法\n\n```hs\npromap :: Profunctor p => p b c ~> (a -> b, c -> d) -> p a d\n```\n\n1. `f` 必须是一个返回值的函数，\n    1. 如果 `f` 不是函数，则 `promap` 的行为未指定。\n    2. `f` 可以返回任意值\n    3. `f` 返回值的任何部分都不应该被检查。\n2. `g` 必须是一个返回值的函数，\n    1. 如果 `g` 不是函数，则 `promap` 的行为未指定。\n    2. `g` 可以返回任意值\n    3. `g` 返回值的任何部分都不应该被检查。\n3. `promap` 必须返回相同 Profunctor 的值。\n\n## 推导\n\n当创建满足多个代数的数据类型是，作者可以选择实现某些方法，然后推导出剩余的方法。推导：\n\n  - [`equals`][] 可以由 [`lte`][] 推导出：\n    \n    ```js\n    function(other) { retrun this.lte(other) && other.lte(this) }    \n    ```\n\n  - [`map`][] 可以由 [`ap`][] 和 [`of`][] 推导出：\n\n    ```js\n    function(f) { return this.ap(this.of(f))}\n    ```\n\n  - [`map`][] 可以由 [`chain`][] 和 [`of`][] 推导出：\n\n    ```js\n    function(f) { return this.chain(a => this.of(f(a))); }\n    ```\n\n  - [`map`][] 可以由 [`bimap`][] 推导出 (??)：\n  \n    ```js\n    function(f) { return this.bimap(a => a, f); }\n    ```\n\n  - [`map`][] 可以由 [`promap`][] 推导出：\n\n    ```js\n    function(f) { return this.promap(a => a, f); }\n    ```\n\n  - [`ap`][] 可以由 [`chain`][] 推导出：\n    ```js\n    function(m) { return m.chain(f => this.map(f)); }\n    ```\n\n  - [`reduce`][] 可以由下列推导出：\n\n    ```js\n    function(f, acc) {\n      function Const(value) {\n        this.value = value;\n      }\n      Const.of = function(\\_) {\n        return new Const(acc);\n      }\n      Const.prototype.map = function(\\_) {\n        return this;\n      }\n      Const.prototype.ap = function(b) {\n        return new Const(f(b.value, this.value));\n      }\n      return this.traverse(x => new Const(x), Const.of).value;\n    }\n    ```\n\n  - [`map`][] 的推导如下：\n\n    ```js\n    function(f) {\n      function Id(value) {\n        this.value = value;\n      }\n      Id.of = function(x) {\n        return new Id(x);\n      }\n      Id.prototype.map = function(f) {\n        return new Id(f(b.value));\n      }\n      Id.prototype.ap = function(b) {\n        return new Id(this.value(b.value));\n      }\n      return this.traverse(x => Id.of(f(x)), Id.of).value;\n    }    \n    ```\n\n\n  - [`filter`][] 可以由 [`of`][]，[`chain`][] 和 [`zero`][] 推导出：\n    ```js\n    function(pred) {\n      var F = this.constructor;\n      return this.chain(x => pred(x) ? F.of(x) : F.zero());\n    }\n    ```\n  - [`filter`][] 还可以由 [`concat`][]，[`of`][]，[`zero`][] 和 [`reduce`][]：\n\n    ```js\n    function(pred) {\n      var F = this.constructor;\n      return this.reduce((f, x) => pred(x) ? f.concat(F.of(x)) : f, F.zero());\n    }\n    ```\n## 注意\n\n1. 如果实现的方法和规则不止一种，应该选择一种实现，并为其他用途提供包装。\n2. 我们不鼓励重载特定的方法。那样会很容易造成崩溃和错误的行为。\n3. 建议对未指定的行为抛出异常。\n4. 在 [sanctuary-identity](https://github.com/sanctuary-js/sanctuary-identity) 中提供了一个实现了许多方法的 Id 容器。\n\n[`ap`]: #code-ap-code-fang-fa\n[`bimap`]: #code-bimap-code-fang-fa\n[`chain`]: #code-chain-code-fang-fa\n[`concat`]: #code-concat-code-fang-fa\n[`empty`]: #code-empty-code-fang-fa\n[`equals`]: #code-equals-code-fang-fa\n[`extend`]: #code-extend-code-fang-fa\n[`extract`]: #code-extract-code-fang-fa\n[`filter`]: #code-filter-code-fang-fa\n[`lte`]: #code-lte-code-fang-fa\n[`map`]: #code-map-code-fang-fa\n[`of`]: #code-of-code-fang-fa\n[`promap`]: #code-promap-code-fang-fa\n[`reduce`]: #code-reduce-code-fang-fa\n[`sequence`]: #code-sequence-code-fang-fa\n[`zero`]: #code-zero-code-fang-fa\n\n## 备选方案\n此外，还存在一个 Static Land 规范，其思想与 Fantasy Land 完全相同，但是是基于静态方法而非实例方法。\n","source":"_posts/Fantasy-Land-Specification.md","raw":"---\ntitle: Fantasy-Land-Specification\ndate: 2018-09-08 16:45:36\ntags:\n---\n(又名 \"代数 JavaScript 规范\")\n\n![logo](./logo.png)\n\n该项目规定了通用代数数据结构的互操作性：\n\n* [Setoid](#setoid)\n* [Ord](#ord)\n* [Semigroupoid](#semigroupoid)\n* [Category](#category)\n* [Semigroup](#semigroup)\n* [Monoid](#monoid)\n* [Group](#group)\n* [Filterable](#filterable)\n* [Functor](#functor)\n* [Contravariant](#contravariant)\n* [Apply](#apply)\n* [Applicative](#applicative)\n* [Alt](#alt)\n* [Plus](#plus)\n* [Alternative](#alternative)\n* [Foldable](#foldable)\n* [Traversable](#traversable)\n* [Chain](#chain)\n* [ChainRec](#chainrec)\n* [Monad](#monad)\n* [Extend](#extend)\n* [Comonad](#comonad)\n* [Bifunctor](#bifunctor)\n* [Profunctor](#profunctor)\n\n![dependencies](./dependencies.png)\n\n## 概览\n\n代数是遵循一定法则的、具有封闭性的，一系列值及一系列操作的集合。\n\n每个 Fantasy Land 代数是一个单独的规范。一个代数可能依赖于其他必需实现的代数。\n\n## 术语\n\n1. \"值\"：任何 JavaScript 值，包括下面定义的结构的任何值。\n\n2. \"等价\"：对给定值的等价性的恰当定义。这个定义应该保证两个值可以在其对应的抽象的程序中，能够安全地进行交换。例如：\n\n    - 当两个列表对应的索引上的值都相等时，它们是等价的。\n    - 当两个普通的 JavaScript 对象所有键值对都相等时，它们（作为字典）是等价的。\n    - 当两个 promises 生成相等的值时，它们是等价的。\n    - 当两个函数给定相同的输入，产生相同的输出时，它们是等价的。\n\n## 类型签名符号\n\n本文档使用的类型签名符号如下所述：[^1]\n\n* `::` __\"是 xx 的成员\"。_\n    - `e :: t` 读作：\"表达式 `e` 是类型 `t` 的成员\"。\n    - `true :: Boolean` - \"`true` 是类型 `Boolean` 的成员\"。\n    - `42 :: Integer, Number` - \"`42` 是类型 `Integer` 和 `Number` 的成员\"。\n* _新类型可以通过类型构造函数创建。_\n    - 类型构造函数可以接受零或多个类型参数。\n    - `Array` 是一个接受单个参数的类型构造函数。\n    - `Array String` 代表包含字符串的数组的类型。后面每个都是 `Array String` 类型的：`[]`，`['foo', 'bar', 'baz']`。\n    - `Array (Array String)` 代表包含字符串的数组的数组的类型。后面每个都是 `Array (Array String)` 类型的：`[]`，`[[], []]`， `[[], ['foo'], ['bar', 'baz']]`。\n* _小写字母代表类型变量。_\n    - 类型变量可以接受任何类型，除非受到类型约束的限制（参见下面的胖箭头）。\n    - `->` (箭头) _函数类型的构造函数_\n    - `->` 是一个 _中缀_ 构造函数，它接受两个类型参数，左侧参数为输入的类型，右侧参数为输出的类型。\n    - `->` 的输入类型可以通过一组类型创建出来，该函数接受零个或多个参数。其语法是：`(<input-types>) -> <output-type>`，其中 `<input-types>` 包含零个或多个 \"逗号-空格\" （`, `）分开的类型表示，对于一元函数，圆括号也可以省略。\n    - `String -> Array String` 是一种接受一个 `String` 并返回一个 `Array String` 的函数的类型。\n    - `String -> Array String -> Array String` 是一种函数类型，它接受一个 `String` 并返回一个函数，返回的函数接受一个 `Array String` 并返回一个 `Array String`。\n    - `(String, Array String) -> Array String` 是一种函数类型，它接受一个 `String` 和 `Aray String` 作为参数，并返回一个 `Array String` 。\n    - `() -> Number` 是一种不带输入参数，返回 `Number` 的函数类型。\n* `~>` (波浪形箭头) _方法类型的构造函数。_\n    - 当一个函数是一个对象（Object）的属性时，它被称为方法。所有方法都有一个隐含的参数类型 - 它是属性所在对象的类型。\n    - `a ~> a -> a` 是一种对象中方法的类型，它接受 `a` 类型的参数，并返回一个 `a` 类型的值。\n* `=>` (胖箭头) 表示对类型变量的约束。\n    - 在 `a ~> a -> a`（参见上面的波浪形箭头）中，`a` 可以为任意类型。半群 `a => a ~> a -> a` 会添加一个约束，使得类型 `a` 现在必须满足该半群的类型类。满足类型类意味着，须合法地实现该类型类指定所有函数/方法。\n\n例如：\n\n```\ntraverse :: Applicative f, Traversable t => t a ~> (TypeRep f, a -> f b) -> f (t b)\n'------'    '--------------------------'    '-'    '-------------------'    '-----'\n '           '                               '      '                        '\n '           ' - type constraints            '      ' - argument types       ' - return type\n '                                           '\n '- method name                              ' - method target type\n```\n\n[^1]: 更多相关信息，请参阅 Sanctuary 文档中的 [Types](https://sanctuary.js.org/#types) 部分。\n\n## 前缀方法名\n\n为了使数据类型与 Fantasy Land 兼容，其值必须具有某些属性。这些属性都以 `fantasy-land/` 为前缀。例如：\n\n```js\n//  MyType#fantasy-land/map :: MyType a ~> (a -> b) -> MyType b\nMyType.prototype['fantasy-land/map'] = ...\n```\n\n在本文中，不使用前缀的名称，只是为了减少干扰。\n\n为了方便起见，你可以使用 `fantasy-land` 包：\n\n```js\nvar fl = require('fantasy-land')\n\n// ...\n\nMyType.prototype[fl.map] = ...\n\n// ...\n\nvar foo = bar[fl.map](x => x + 1)\n```\n\n## 类型表示 (JavaScript 中的构造函数？)\n\n某些行为是从类型成员的角度定义的。而另外一些行为不需要类型成员。因此，某些代数需要一个类型来提供值层面上的表示（具有某些属性）。例如，Identity 类型可以提供 `Id` 作为其类型表示：`Id :: TypeRep Identity`。\n\n如果一个类型提供了类型表示，那么这个类型的每个成员都必须有一个指向该类型表示的 `contructor` 属性。\n\n## 代数\n\n### Setoid\n\n1. `a.equals(a) === true` (自反性)\n2. `a.equals(b) === b.equals(a)` (对称性)\n3. 如果 `a.equals(b)` 并且 `b.equals(a)`，则 `a.equals(c)` (传递性)\n\n#### `equals` 方法\n\n```hs\nequals :: Setoid a => a ~> a -> Boolean\n```\n\n具有 Setoid 的值必须提供 `equals` 方法。`equals` 方法接受一个参数：\n\n    a.equals(b)\n\n1. `b` 必须是相同 Setoid 的值\n    1. 如果 `b` 不是相同的 Setoid，则 `equals` 的行为未指定（建议返回 `false`）。\n    2. `equals` 必须返回一个布尔值（`true` 或 `false`）。\n\n### Ord\n\n实现 Ord 规范的值还必须实现 [Setoid](#setoid) 规范。\n\n1. `a.lte(b)` 或 `b.lte(a)` (完全性)\n2. 如果 `a.lte(b)` 且 `b.lte(a)`，则 `a.equals(b)` (反对称性)\n3. 如果 `a.lte(b)` 且 `b.lte(c)`，则 `a.lte(c)` (传递性)\n\n#### `lte` 方法\n\n```hs\nlte :: Ord a => a ~> a -> Boolean\n```\n\n具有 Ord 的值必须提供 `lte` 方法。`lte` 方法接受一个参数：\n\n    `a.lte(b)`\n\n1. `b` 必须是相同 Ord 的值。\n    1. 如果 `b` 不是相同的 Ord，则 `lte` 的行为未指定 (建议返回 `false`)。\n2. `lte` 必须返回布尔值（`true` 或 `false`）。\n\n### Semigroupoid\n\n1. `a.compose(b).compose(c) === a.compose(b.compose(c))` (结合性)\n\n#### `compose` 方法\n\n```hs\ncompose :: Semigroupoid c => c i j ~> c j k -> c i k\n```\n\n具有 Semigoupoid 的值必须提供 `compose` 组合方法。`compose` 方法接受一个参数：\n\n    a.compose(b)\n\n1. `b` 必须返回相同 Semigroupoid 规范。\n    1. 如果 `b` 不是相同的 Semigroupoid，compose 的行为未指定。\n2. `compose` 必须返回相同 Semigroupoid 的值。\n\n### Category\n实现范畴规范的值还必须实现[半群](#semigroupoid)规范。\n\n1. `a.compose(C.id())` 等价于 `a` (右同一性)\n2. `C.id().compose(a)` 等价于 `a` (左同一性)\n\n#### `id` 方法\n\n```hs\nid :: Category c => () -> c a a\n```\n\n具有范畴的值必须在其[类型表示](#type-representatives)中提供一个 `id` 函数。\n\n    C.id()\n\n给定值 `c`，可以通过 `contructor` 属性来访问其类型表示：\n\n    c.constructgor.id()\n\n1. `id` 必须返回相同范畴的值。\n\n### Semigroup\n\n1. `a.concat(b).concat(c)` 等价于 `a.concat(b.concat(c))` （结合性）\n\n#### `concat` 方法\n\n```hs\nconcat :: Semigroup a => a ~> a -> a\n```\n\n具有 Semigroup 的值必须提供 `concat` 方法。`concat` 方法接受一个参数：\n\n    s.concat(b)\n\n1. `b` 必须是相同 Semigroup 的值\n    1. 如果 `b` 不是相同的 Semigroup，则 `concat` 的行为未指定。\n2. `concat` 必须返回相同 Semigroup 的值。\n\n### Monoid\n\n实现 Monoid 规范的值还必须实现 [Semigroup](#semigroup) 规范\n\n1. `m.concat(M.empty())` 等价于 `m` (右结合性)\n2. `M.empty().concat(m)` 等价于 `m` (左结合性)\n\n#### `empty` 方法\n\n```hs\nempty :: Monoid m => () -> m\n```\n\n具有 Monoid 的值必须在其类型表示上提供 `empty` 方法：\n\n    M.empty()\n\n给定值` `m，可以通过 `constructor` 属性来访问其类型表示：\n\n    m.constructor.empty()\n\n1. `empty` 必须返回相同 Monoid 的值。\n\n### Group\n\n实现 Group 规范的值还必须实现 [Monoid](#monoid) 规范。\n\n1. `g.concat(g.invert())` 等价于 `g.constructor.empty()` (右反转性??)\n2. `g.invert().concat(g)` 等价于 `g.constructor.empty()` (左翻转性??)\n\n#### `invert` 方法\n\n```hs\ninvert :: Group g => g ~> () -> g\n```\n\n具有 Semigroup 的值必须提供 `invert` 方法。`invert` 方法接受零个参数：\n\n    g.invert()\n\n1. `invert` 必须返回相同 Group 的值。\n\n### Filterable\n\n1. `v.filter(x => p(x) && q(x))` 等价于 `v.filter(p).filter(q)` (分配性)\n2. `v.filter(x => true)` 等价于 `v` (同一性)\n3. `v.filter(x -> false)` 等价于 `w.filter(x => false)`，如果 `v` 和 `w` 具有相同的 Filterable 值 (湮灭??)\n\n#### `filter` 方法\n\n```hs\nfilter :: Filterable f => f a ~> (a -> Boolean) -> f a\n```\n\n具有 Filterable 的值必须提供 `filter` 方法。`filter` 方法接受一个参数：\n\n    v.filter(p)\n\n1. `p` 必须是一个函数。\n    1. 如果 `p` 不是函数，则 `filter` 的行为未指定。\n    2. `p` 必须返回 `ture` 或 `false`。如果返回任何其它值，`filter` 的行为未指定。\n\n2. `filter` 必须返回相同 Filterable 的值。\n\n### Functor\n\n1. `u.map(a => a)` 等价于 `u` (同一性)\n2. `u.map(x => f(g(x)))` 等价于 `u.map(g).map(f)` (组合性)\n\n#### `map` 方法\n\n```hs\nmap :: Functor f => f a ~> (a -> b) -> f b\n```\n\n具有 Functor 的值必须提供 `map` 方法。`map` 方法接受一个参数：\n\n    u.map(f)\n\n1. `f` 必须是一个函数，\n    1. 如果 `f` 不是函数，则 `map` 的行为未指定。\n    2. `f` 可以返回任何值。\n    3. `f` 返回值的任何部分都不应该被检查(??)。\n\n2. `map` 必须返回相同 Functor 的值。\n\n\n### Contravariant\n\n1. `u.contramap(a => a)` 等价于 `u` (同一性)\n2. `u.contramap(x => f(g(x)))` 等价于 `u.contramap(f).contramap(g)` (组合性)\n\n#### `contramap` 方法\n\n```hs\ncontramap :: Contravariant f => f a ~> (b -> a) -> f b\n```\n\n具有 Contravariant 的值必须提供 `contramap` 方法。`contramap` 方法接受一个参数：\n\n    u.contramap(f)\n\n1. `f` 必须是一个函数，\n    1. 如果 `f` 不是函数，则 `contramap` 的行为未指定。\n    2. `f` 可以返回任何值。\n    3. `f` 返回值的任何部分都不应该被检查(??)。\n2. `contramap` 必须返回相同 Contravariant 的值。\n\n### Apply\n\n实现 Apply 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `v.ap(u.ap(a.map(f => g => x => f(g(x)))))` 等价于 `v.ap(u).ap(a)` (组合型)，推导过程??\n\n#### `ap` 方法\n\n```hs\nap :: Apply f => f a ~> f (a -> b) -> f b\n```\n\n具有 Apply 的值必须提供 `ap` 方法。`ap` 方法接受一个参数：\n\n    a.ap(b)\n\n1. `b` 必须是一个函数的 Apply\n    1. 如果 `b` 不代表函数，则 `ap` 的行为未指定。\n    2. `b` 必须与 a 具有相同的 Apply。\n2. `a` 可以是任意值的 Apply。(??)\n3. `ap` 必须能将 Apply `b` 内的函数应用于 Apply `a` 的值上\n    1. 函数返回值的任何部分都不应该被检查。\n4. 由 `ap` 返回的 `Apply` 必须与 `a` 和 `b` 的相同。\n\n### Applicative\n\n实现 Applicative 规范的值还必须实现 [Apply](#apply) 规范。\n\n1. `v.ap(A.of(x => x))` 等价于 `v` (同一性)\n2. `A.of(x).ap(A.of(f))` 等价于 `A.of(f(x))` (同态性, homomorphism)\n3. `A.of(y).ap(u)` 等价于 `u.ap(A.of(f => f(y)))` (交换性)\n\n#### `of` 方法\n\n```hs\nof :: Applicative f => a -> f a\n```\n\n具有 Applicative 的值必须在其类型表示中提供 `of` 函数。`of` 函数接受一个参数：\n\n    F.of(a)\n\n给定值 `f`，可以通过 `contructor` 属性访问其类型表示：\n\n    f.contructor.of(a)\n\n1. `of` 必须提供相同的 Applicative\n    1. a 的任何部分都不应该被检查\n\n### Alt\n\n实现 Alt 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `a.alt(b).alt(c)` 等价于 `a.alt(b.alt(c))` (结合性)\n2. `a.alt(b).map(f)` 等价于 `a.map(f).alt(b.map(f))` (分配性) (看起来像乘法，有什么实际用途呢？)\n\n#### `alt` 方法\n\n```hs\nalt :: Alt f => f a ~> f a -> f a\n```\n\n具有 Alt 的值必须提供 `alt` 方法。`alt` 方法接受一个参数：\n\n    a.alt(b)\n\n1. `b` 必须是相同 Alt 的值\n    1. 如果 `b` 不是相同的 Alt，则 `alt` 的行为未指定。\n    2. `a` 和 `b` 可以包含相同类型的任何值。\n    3. `a` 和 `b` 包含值的任何部分都不应该被检查。\n2. `alt` 必须返回相同 Alt 的值。\n\n### Plus\n\n实现 Plus 规范的值还必须实现 [Alt](#alt) 规范。\n\n1. `x.alt(A.zero())` 等价于 `x` (右同一性)\n2. `A.zero().alt(x)` 等价于 `x` (左同一性)\n3. `A.zero().map(f)` 等价于 `A.zero()` (湮灭??)\n\n#### `zero` 方法\n\n```hs\nzero :: Plus f => () -> f a\n```\n\n具有 Plus 的值必须在其类型表示中提供 `zero` 函数：\n\n    A.zero()\n\n给定值 `x`，可以通过 `contructor` 属性访问其类型表示：\n\n    x.contructor.zero()\n\n`zero` 必须返回相同 Plus 的值。\n\n### Alternative\n\n实现 Alternative 规范的值还必须实现 [Applicative](#applicative) 和 [Plus](#plus) 规范。\n\n1. `x.ap(f.alt(g))` 等价于 `x.ap(f).alt(x.ap(g))` (分配性)\n2. `x.ap(A.zero())` 等价于 `A.zero()` (湮灭)\n\n### Foldable\n\n`u.reduce` 等价于 `u.reduce((acc, x) => acc.concat([x]), []).reduce`\n\n#### `reduce` 方法\n\n```hs\nreduce :: Foldable f => f a ~> ((b, a) -> b, b) -> b\n```\n\n具有 Foldable 的值必须在其类型表示中提供 `reduce` 函数。`reduce` 函数接受两个参数：\n\n    u.reduce(f, x)\n\n1. `f` 必须是一个二元函数\n    1. 如果 `f` 不是函数，则 `reduce` 的行为未指定。\n    2. `f` 的第一个参数类型必须与 `x` 的相同。\n    3. `f` 的返回值类型必须与 `x` 的相同。\n    4. `f` 返回值的任何部分都不应该被检查。\n2. `x` 是归约的初始累积值\n    1. `x` 的任何部分都不应该被检查\n\n### Traversable\n\n实现 Traversable 规范的值还必须实现 [Functor](#functor) 和 [Foldable](#foldable) 规范。\n\n1. 对于任意 `t`，`t(u.traverse(F, x => x))` 等价于 `u.traverse(G, t)` ，因为 `t(a).map(f)` 等价于 `t(a.map(f))` (自然性)\n2. 对于任意 Applicative `F`，`u.traverse(F, F.of)` 等价于 `F.of(u)` (同一性)\n3. `u.traverse(Compose, x => new Compose(x))` 等价于 `new Compose(u.traverse(F, x => x).map(x => x.traverse(G, x => x)))`，对下面定义的 `Compose` 和 任意 Applicatives `F` 和 `G` 都适用 (组合性)\n\n```js\nvar Compose = function(c) {\n  this.c = c;\n};\n\nCompose.of = function(x) {\n  return new Compose(F.of(G.of(x)));\n};\n\nCompose.prototype.ap = function(f) {\n  return new Compose(this.c.ap(f.c.map(u => y => y.ap(u))))\n};\n\nCompose.prototype.map = function(f) {\n  return new Compose(this.c.map(y => y.map(f)));\n};\n```\n\n#### `traverse` 方法\n\n```hs\ntraverse :: Applicative f, Traversable t => t a ~> (TypeRep f, a -> f b) -> f (t b)\n```\n\n具有 Traversable 的值必须提供 `traverse` 函数。`traverse` 函数接受两个参数：\n\n    u.traverse(A, f)\n\n1. `A` 必须是一个 Applicative 的类型表示。\n2. `f` 必须是一个返回值的函数\n    1. 如果 `f` 不是函数，则 `traverse` 的行为未指定。\n    2. `f` 必须返回类型表示为 `A` 的值。\n3. `traverse` 必须返回类型表示为 `A` 的值。\n\n### Chain\n\n实现 Chain 规范的值还必须实现 [Apply](#apply) 规范。\n\n1. `m.chain(f).chain(g)` 等价于 `m.chain(x => f(x).chain(g))` (结合性)\n\n#### `chain` 方法\n\n```hs\nchain :: Chain m => m a ~> (a -> m b) -> m b\n```\n\n具有 Chain 的值必须提供 `chain` 函数。`chain` 函数接受一个参数：\n\n    m.chain(f)\n\n1. `f` 必须是一个返回值的函数\n    1. 如果 `f` 不是函数，则 `chain` 的行为未指定。\n    2. `f` 必须返回相同 Chain 的值。\n2. `chain` 必须返回相同 Chain 的值。\n\n### ChainRec\n\n实现 ChainRec 规范的值还必须实现 [Chain](#chain) 规范。\n\n1. `M.chainRec((next, done, v) => p(v) ? d(v).map(done) : n(v).map(next), i)` 等价于 `function step(v) { return p(v) ? d(v) : n(v).chain(step); }(i)` (等价性)\n2. `M.chainRec(f, i)` 栈的用量必须是 `f` 自身栈用量的常数倍。\n\n#### `chainRec` 方法\n\n```hs\nchainRec :: ChainRec m => ((a -> c), b -> c, a) -> m b\n```\n\n具有 ChainRec 的值必须在其类型表示中提供 `chainRec` 函数。`chainRec` 函数接受两个参数：\n\n    M.chainRec(f, i)\n\n给定值 `m`，可以通过 `contructor` 属性访问其类型表示：\n\n    m.constructor.chainRec(f, i)\n\n1. `f` 必须是一个返回值的函数\n    1. 如果 `f` 不是函数，则 `chainRec` 的行为未指定。\n    2. `f` 接受三个参数 `next`，`done`，`value`\n        1. `next` 是一个函数，其接受一个与 i 类型相同的参数，可以返回任意值\n        2. `done` 也是一个函数，其接受一个参数，并返回一个与 `next` 返回值类型相同的值\n        3. `value` 是一个与 i 类型相同的值。\n    3. `f` 必须返回一个相同 ChainRec 的值，其中包含的是从 `done` 或 `next` 返回的值。\n2. `chainRec` 必须返回一个相同 ChainRec 的值，其中包含的值的类型与 `done` 的参数类型相同。\n\n### Monad\n\n实现 Monad 规范的值还必须实现 [Applicative](#applicative) 和 [Chain](#chain) 规范。\n\n1. `M.of(a).chain(f)` 等价于 `f(a)` (左同一性)\n2. `m.chain(M.of)` 等价于 `m` (右同一性)\n\n### Extend\n\n实现 Extend 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `w.extend(g).extend(f)` 等价于 `w.extend(\\_w => f(\\_w.extend(g)))`\n\n`extend` 方法\n\n```hs\nextend :: Extend w => w a ~> (w a -> b) -> w b\n```\n\n具有 Extend 的值必须提供 `extend` 函数。`extend` 函数接受一个参数：\n\n    w.extend(f)\n\n1. `f` 必须是一个返回值的函数，\n    1. 如果 `f` 不是函数，则 extend 的行为未指定。\n    2. `f` 必须返回一个 `v` 类型的值，其中 `v` 是 `w` 中包含的某个变量 `v` (??)\n    3. `f` 返回值的任何部分都不应该被检查。\n2. `extend` 必须返回相同 Extend 的值。\n\n### Comonad\n\n实现 Comonad 规范的值还必须实现 [Extend](#extend) 规范。\n\n1. `w.extend(_w => _w.extract())` 等价于 `w` (左同一性)\n2. `w.extend(f).extract()` 等价于 `f(w)` (右同一性)\n\n#### `extract` 方法\n\n具有 Comonad 的值必须提供 `extract` 函数。`extract` 函数接受零个参数：\n\n    w.extract()\n\n1. `extract` 必须返回一个 `v` 类型的值，其中 `v` 是 `w` 中包含的某个变量 `v` (??)\n    1. `v` 必须与在 `extend` 中的 `f` 返回的类型相同。\n\n### Bifunctor\n\n实现 Bifunctor 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `p.bimap(a => a, b => b)` 等价于 `p` (同一性)\n2. `p.bimap(a => f(g(a)), b => h(i(b)))` 等价于 `p.bimap(g, i).bimap(f, h)` (组合性)\n\n### `bimap` 方法\n\n```hs\nbimap :: Bifunctor f => f a c ~> (a -> b, c -> d) -> f b d\n```\n\n具有 Bifunctor 的值必须提供 `bimap` 函数。`bimap` 函数接受两个参数：\n\n    c.bimap(f, g)\n\n1. `f` 必须是一个返回值的函数，\n    1. 如果 `f` 不是函数，则 `bimap` 的行为未指定。\n    2. `f` 可以返回任意值\n    3. `f` 返回值的任何部分都不应该被检查。\n2. `g` 必须是一个返回值的函数，\n    1. 如果 `g` 不是函数，则 `bimap` 的行为未指定。\n    2. `g` 可以返回任意值\n    3.`g` 返回值的任何部分都不应该被检查。\n3. `bimap` 必须返回相同 Bifunctor 的值。\n\n### Profunctor\n\n实现 Profunctor 规范的值还必须实现 [Functor](#functor) 规范。\n\n1. `p.promap(a => a, b => b)` 等价于 `p` (同一性)\n2. `p.promap(a => f(g(a)), b => h(i(b)))` 等价于 `p.promap(f, i).promap(g, h)` (组合性)\n\n#### `promap` 方法\n\n```hs\npromap :: Profunctor p => p b c ~> (a -> b, c -> d) -> p a d\n```\n\n1. `f` 必须是一个返回值的函数，\n    1. 如果 `f` 不是函数，则 `promap` 的行为未指定。\n    2. `f` 可以返回任意值\n    3. `f` 返回值的任何部分都不应该被检查。\n2. `g` 必须是一个返回值的函数，\n    1. 如果 `g` 不是函数，则 `promap` 的行为未指定。\n    2. `g` 可以返回任意值\n    3. `g` 返回值的任何部分都不应该被检查。\n3. `promap` 必须返回相同 Profunctor 的值。\n\n## 推导\n\n当创建满足多个代数的数据类型是，作者可以选择实现某些方法，然后推导出剩余的方法。推导：\n\n  - [`equals`][] 可以由 [`lte`][] 推导出：\n    \n    ```js\n    function(other) { retrun this.lte(other) && other.lte(this) }    \n    ```\n\n  - [`map`][] 可以由 [`ap`][] 和 [`of`][] 推导出：\n\n    ```js\n    function(f) { return this.ap(this.of(f))}\n    ```\n\n  - [`map`][] 可以由 [`chain`][] 和 [`of`][] 推导出：\n\n    ```js\n    function(f) { return this.chain(a => this.of(f(a))); }\n    ```\n\n  - [`map`][] 可以由 [`bimap`][] 推导出 (??)：\n  \n    ```js\n    function(f) { return this.bimap(a => a, f); }\n    ```\n\n  - [`map`][] 可以由 [`promap`][] 推导出：\n\n    ```js\n    function(f) { return this.promap(a => a, f); }\n    ```\n\n  - [`ap`][] 可以由 [`chain`][] 推导出：\n    ```js\n    function(m) { return m.chain(f => this.map(f)); }\n    ```\n\n  - [`reduce`][] 可以由下列推导出：\n\n    ```js\n    function(f, acc) {\n      function Const(value) {\n        this.value = value;\n      }\n      Const.of = function(\\_) {\n        return new Const(acc);\n      }\n      Const.prototype.map = function(\\_) {\n        return this;\n      }\n      Const.prototype.ap = function(b) {\n        return new Const(f(b.value, this.value));\n      }\n      return this.traverse(x => new Const(x), Const.of).value;\n    }\n    ```\n\n  - [`map`][] 的推导如下：\n\n    ```js\n    function(f) {\n      function Id(value) {\n        this.value = value;\n      }\n      Id.of = function(x) {\n        return new Id(x);\n      }\n      Id.prototype.map = function(f) {\n        return new Id(f(b.value));\n      }\n      Id.prototype.ap = function(b) {\n        return new Id(this.value(b.value));\n      }\n      return this.traverse(x => Id.of(f(x)), Id.of).value;\n    }    \n    ```\n\n\n  - [`filter`][] 可以由 [`of`][]，[`chain`][] 和 [`zero`][] 推导出：\n    ```js\n    function(pred) {\n      var F = this.constructor;\n      return this.chain(x => pred(x) ? F.of(x) : F.zero());\n    }\n    ```\n  - [`filter`][] 还可以由 [`concat`][]，[`of`][]，[`zero`][] 和 [`reduce`][]：\n\n    ```js\n    function(pred) {\n      var F = this.constructor;\n      return this.reduce((f, x) => pred(x) ? f.concat(F.of(x)) : f, F.zero());\n    }\n    ```\n## 注意\n\n1. 如果实现的方法和规则不止一种，应该选择一种实现，并为其他用途提供包装。\n2. 我们不鼓励重载特定的方法。那样会很容易造成崩溃和错误的行为。\n3. 建议对未指定的行为抛出异常。\n4. 在 [sanctuary-identity](https://github.com/sanctuary-js/sanctuary-identity) 中提供了一个实现了许多方法的 Id 容器。\n\n[`ap`]: #code-ap-code-fang-fa\n[`bimap`]: #code-bimap-code-fang-fa\n[`chain`]: #code-chain-code-fang-fa\n[`concat`]: #code-concat-code-fang-fa\n[`empty`]: #code-empty-code-fang-fa\n[`equals`]: #code-equals-code-fang-fa\n[`extend`]: #code-extend-code-fang-fa\n[`extract`]: #code-extract-code-fang-fa\n[`filter`]: #code-filter-code-fang-fa\n[`lte`]: #code-lte-code-fang-fa\n[`map`]: #code-map-code-fang-fa\n[`of`]: #code-of-code-fang-fa\n[`promap`]: #code-promap-code-fang-fa\n[`reduce`]: #code-reduce-code-fang-fa\n[`sequence`]: #code-sequence-code-fang-fa\n[`zero`]: #code-zero-code-fang-fa\n\n## 备选方案\n此外，还存在一个 Static Land 规范，其思想与 Fantasy Land 完全相同，但是是基于静态方法而非实例方法。\n","slug":"Fantasy-Land-Specification","published":1,"updated":"2020-06-06T14:44:04.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfita0005f6mjisyvbiko","content":"<p>(又名 &quot;代数 JavaScript 规范&quot;)</p>\n<p><img src=\"./logo.png\" alt=\"logo\"></p>\n<p>该项目规定了通用代数数据结构的互操作性：</p>\n<ul>\n<li><a href=\"#setoid\">Setoid</a></li>\n<li><a href=\"#ord\">Ord</a></li>\n<li><a href=\"#semigroupoid\">Semigroupoid</a></li>\n<li><a href=\"#category\">Category</a></li>\n<li><a href=\"#semigroup\">Semigroup</a></li>\n<li><a href=\"#monoid\">Monoid</a></li>\n<li><a href=\"#group\">Group</a></li>\n<li><a href=\"#filterable\">Filterable</a></li>\n<li><a href=\"#functor\">Functor</a></li>\n<li><a href=\"#contravariant\">Contravariant</a></li>\n<li><a href=\"#apply\">Apply</a></li>\n<li><a href=\"#applicative\">Applicative</a></li>\n<li><a href=\"#alt\">Alt</a></li>\n<li><a href=\"#plus\">Plus</a></li>\n<li><a href=\"#alternative\">Alternative</a></li>\n<li><a href=\"#foldable\">Foldable</a></li>\n<li><a href=\"#traversable\">Traversable</a></li>\n<li><a href=\"#chain\">Chain</a></li>\n<li><a href=\"#chainrec\">ChainRec</a></li>\n<li><a href=\"#monad\">Monad</a></li>\n<li><a href=\"#extend\">Extend</a></li>\n<li><a href=\"#comonad\">Comonad</a></li>\n<li><a href=\"#bifunctor\">Bifunctor</a></li>\n<li><a href=\"#profunctor\">Profunctor</a></li>\n</ul>\n<p><img src=\"./dependencies.png\" alt=\"dependencies\"></p>\n<h2>概览</h2>\n<p>代数是遵循一定法则的、具有封闭性的，一系列值及一系列操作的集合。</p>\n<p>每个 Fantasy Land 代数是一个单独的规范。一个代数可能依赖于其他必需实现的代数。</p>\n<h2>术语</h2>\n<ol>\n<li>\n<p>&quot;值&quot;：任何 JavaScript 值，包括下面定义的结构的任何值。</p>\n</li>\n<li>\n<p>&quot;等价&quot;：对给定值的等价性的恰当定义。这个定义应该保证两个值可以在其对应的抽象的程序中，能够安全地进行交换。例如：</p>\n<ul>\n<li>当两个列表对应的索引上的值都相等时，它们是等价的。</li>\n<li>当两个普通的 JavaScript 对象所有键值对都相等时，它们（作为字典）是等价的。</li>\n<li>当两个 promises 生成相等的值时，它们是等价的。</li>\n<li>当两个函数给定相同的输入，产生相同的输出时，它们是等价的。</li>\n</ul>\n</li>\n</ol>\n<h2>类型签名符号</h2>\n<p>本文档使用的类型签名符号如下所述：[^1]</p>\n<ul>\n<li><code>::</code> _<em>&quot;是 xx 的成员&quot;。</em>\n<ul>\n<li><code>e :: t</code> 读作：&quot;表达式 <code>e</code> 是类型 <code>t</code> 的成员&quot;。</li>\n<li><code>true :: Boolean</code> - &quot;<code>true</code> 是类型 <code>Boolean</code> 的成员&quot;。</li>\n<li><code>42 :: Integer, Number</code> - &quot;<code>42</code> 是类型 <code>Integer</code> 和 <code>Number</code> 的成员&quot;。</li>\n</ul>\n</li>\n<li><em>新类型可以通过类型构造函数创建。</em>\n<ul>\n<li>类型构造函数可以接受零或多个类型参数。</li>\n<li><code>Array</code> 是一个接受单个参数的类型构造函数。</li>\n<li><code>Array String</code> 代表包含字符串的数组的类型。后面每个都是 <code>Array String</code> 类型的：<code>[]</code>，<code>['foo', 'bar', 'baz']</code>。</li>\n<li><code>Array (Array String)</code> 代表包含字符串的数组的数组的类型。后面每个都是 <code>Array (Array String)</code> 类型的：<code>[]</code>，<code>[[], []]</code>， <code>[[], ['foo'], ['bar', 'baz']]</code>。</li>\n</ul>\n</li>\n<li><em>小写字母代表类型变量。</em>\n<ul>\n<li>类型变量可以接受任何类型，除非受到类型约束的限制（参见下面的胖箭头）。</li>\n<li><code>-&gt;</code> (箭头) <em>函数类型的构造函数</em></li>\n<li><code>-&gt;</code> 是一个 <em>中缀</em> 构造函数，它接受两个类型参数，左侧参数为输入的类型，右侧参数为输出的类型。</li>\n<li><code>-&gt;</code> 的输入类型可以通过一组类型创建出来，该函数接受零个或多个参数。其语法是：<code>(&lt;input-types&gt;) -&gt; &lt;output-type&gt;</code>，其中 <code>&lt;input-types&gt;</code> 包含零个或多个 &quot;逗号-空格&quot; （<code>,</code>）分开的类型表示，对于一元函数，圆括号也可以省略。</li>\n<li><code>String -&gt; Array String</code> 是一种接受一个 <code>String</code> 并返回一个 <code>Array String</code> 的函数的类型。</li>\n<li><code>String -&gt; Array String -&gt; Array String</code> 是一种函数类型，它接受一个 <code>String</code> 并返回一个函数，返回的函数接受一个 <code>Array String</code> 并返回一个 <code>Array String</code>。</li>\n<li><code>(String, Array String) -&gt; Array String</code> 是一种函数类型，它接受一个 <code>String</code> 和 <code>Aray String</code> 作为参数，并返回一个 <code>Array String</code> 。</li>\n<li><code>() -&gt; Number</code> 是一种不带输入参数，返回 <code>Number</code> 的函数类型。</li>\n</ul>\n</li>\n<li><code>~&gt;</code> (波浪形箭头) <em>方法类型的构造函数。</em>\n<ul>\n<li>当一个函数是一个对象（Object）的属性时，它被称为方法。所有方法都有一个隐含的参数类型 - 它是属性所在对象的类型。</li>\n<li><code>a ~&gt; a -&gt; a</code> 是一种对象中方法的类型，它接受 <code>a</code> 类型的参数，并返回一个 <code>a</code> 类型的值。</li>\n</ul>\n</li>\n<li><code>=&gt;</code> (胖箭头) 表示对类型变量的约束。\n<ul>\n<li>在 <code>a ~&gt; a -&gt; a</code>（参见上面的波浪形箭头）中，<code>a</code> 可以为任意类型。半群 <code>a =&gt; a ~&gt; a -&gt; a</code> 会添加一个约束，使得类型 <code>a</code> 现在必须满足该半群的类型类。满足类型类意味着，须合法地实现该类型类指定所有函数/方法。</li>\n</ul>\n</li>\n</ul>\n<p>例如：</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traverse :: Applicative f, Traversable t =&gt; t a ~&gt; (TypeRep f, a -&gt; f b) -&gt; f (t b)</span><br><span class=\"line\">&apos;------&apos;    &apos;--------------------------&apos;    &apos;-&apos;    &apos;-------------------&apos;    &apos;-----&apos;</span><br><span class=\"line\"> &apos;           &apos;                               &apos;      &apos;                        &apos;</span><br><span class=\"line\"> &apos;           &apos; - type constraints            &apos;      &apos; - argument types       &apos; - return type</span><br><span class=\"line\"> &apos;                                           &apos;</span><br><span class=\"line\"> &apos;- method name                              &apos; - method target type</span><br></pre></td></tr></table></figure></p>\n<p>[^1]: 更多相关信息，请参阅 Sanctuary 文档中的 <a href=\"https://sanctuary.js.org/#types\" target=\"_blank\" rel=\"noopener\">Types</a> 部分。</p>\n<h2>前缀方法名</h2>\n<p>为了使数据类型与 Fantasy Land 兼容，其值必须具有某些属性。这些属性都以 <code>fantasy-land/</code> 为前缀。例如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  MyType#fantasy-land/map :: MyType a ~&gt; (a -&gt; b) -&gt; MyType b</span></span><br><span class=\"line\">MyType.prototype[<span class=\"string\">'fantasy-land/map'</span>] = ...</span><br></pre></td></tr></table></figure></p>\n<p>在本文中，不使用前缀的名称，只是为了减少干扰。</p>\n<p>为了方便起见，你可以使用 <code>fantasy-land</code> 包：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fl = <span class=\"built_in\">require</span>(<span class=\"string\">'fantasy-land'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">MyType.prototype[fl.map] = ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = bar[fl.map](<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<h2>类型表示 (JavaScript 中的构造函数？)</h2>\n<p>某些行为是从类型成员的角度定义的。而另外一些行为不需要类型成员。因此，某些代数需要一个类型来提供值层面上的表示（具有某些属性）。例如，Identity 类型可以提供 <code>Id</code> 作为其类型表示：<code>Id :: TypeRep Identity</code>。</p>\n<p>如果一个类型提供了类型表示，那么这个类型的每个成员都必须有一个指向该类型表示的 <code>contructor</code> 属性。</p>\n<h2>代数</h2>\n<h3>Setoid</h3>\n<ol>\n<li><code>a.equals(a) === true</code> (自反性)</li>\n<li><code>a.equals(b) === b.equals(a)</code> (对称性)</li>\n<li>如果 <code>a.equals(b)</code> 并且 <code>b.equals(a)</code>，则 <code>a.equals(c)</code> (传递性)</li>\n</ol>\n<h4><code>equals</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">equals</span> :: <span class=\"type\">Setoid</span> a =&gt; a ~&gt; a -&gt; <span class=\"type\">Boolean</span></span><br></pre></td></tr></table></figure></p>\n<p>具有 Setoid 的值必须提供 <code>equals</code> 方法。<code>equals</code> 方法接受一个参数：</p>\n<pre><code>a.equals(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Setoid 的值\n<ol>\n<li>如果 <code>b</code> 不是相同的 Setoid，则 <code>equals</code> 的行为未指定（建议返回 <code>false</code>）。</li>\n<li><code>equals</code> 必须返回一个布尔值（<code>true</code> 或 <code>false</code>）。</li>\n</ol>\n</li>\n</ol>\n<h3>Ord</h3>\n<p>实现 Ord 规范的值还必须实现 <a href=\"#setoid\">Setoid</a> 规范。</p>\n<ol>\n<li><code>a.lte(b)</code> 或 <code>b.lte(a)</code> (完全性)</li>\n<li>如果 <code>a.lte(b)</code> 且 <code>b.lte(a)</code>，则 <code>a.equals(b)</code> (反对称性)</li>\n<li>如果 <code>a.lte(b)</code> 且 <code>b.lte(c)</code>，则 <code>a.lte(c)</code> (传递性)</li>\n</ol>\n<h4><code>lte</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">lte</span> :: <span class=\"type\">Ord</span> a =&gt; a ~&gt; a -&gt; <span class=\"type\">Boolean</span></span><br></pre></td></tr></table></figure></p>\n<p>具有 Ord 的值必须提供 <code>lte</code> 方法。<code>lte</code> 方法接受一个参数：</p>\n<pre><code>`a.lte(b)`\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Ord 的值。\n<ol>\n<li>如果 <code>b</code> 不是相同的 Ord，则 <code>lte</code> 的行为未指定 (建议返回 <code>false</code>)。</li>\n</ol>\n</li>\n<li><code>lte</code> 必须返回布尔值（<code>true</code> 或 <code>false</code>）。</li>\n</ol>\n<h3>Semigroupoid</h3>\n<ol>\n<li><code>a.compose(b).compose(c) === a.compose(b.compose(c))</code> (结合性)</li>\n</ol>\n<h4><code>compose</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">compose</span> :: <span class=\"type\">Semigroupoid</span> c =&gt; c i j ~&gt; c j k -&gt; c i k</span><br></pre></td></tr></table></figure></p>\n<p>具有 Semigoupoid 的值必须提供 <code>compose</code> 组合方法。<code>compose</code> 方法接受一个参数：</p>\n<pre><code>a.compose(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须返回相同 Semigroupoid 规范。\n<ol>\n<li>如果 <code>b</code> 不是相同的 Semigroupoid，compose 的行为未指定。</li>\n</ol>\n</li>\n<li><code>compose</code> 必须返回相同 Semigroupoid 的值。</li>\n</ol>\n<h3>Category</h3>\n<p>实现范畴规范的值还必须实现<a href=\"#semigroupoid\">半群</a>规范。</p>\n<ol>\n<li><code>a.compose(C.id())</code> 等价于 <code>a</code> (右同一性)</li>\n<li><code>C.id().compose(a)</code> 等价于 <code>a</code> (左同一性)</li>\n</ol>\n<h4><code>id</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">id</span> :: <span class=\"type\">Category</span> c =&gt; () -&gt; c a a</span><br></pre></td></tr></table></figure></p>\n<p>具有范畴的值必须在其<a href=\"#type-representatives\">类型表示</a>中提供一个 <code>id</code> 函数。</p>\n<pre><code>C.id()\n</code></pre>\n<p>给定值 <code>c</code>，可以通过 <code>contructor</code> 属性来访问其类型表示：</p>\n<pre><code>c.constructgor.id()\n</code></pre>\n<ol>\n<li><code>id</code> 必须返回相同范畴的值。</li>\n</ol>\n<h3>Semigroup</h3>\n<ol>\n<li><code>a.concat(b).concat(c)</code> 等价于 <code>a.concat(b.concat(c))</code> （结合性）</li>\n</ol>\n<h4><code>concat</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">concat</span> :: <span class=\"type\">Semigroup</span> a =&gt; a ~&gt; a -&gt; a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Semigroup 的值必须提供 <code>concat</code> 方法。<code>concat</code> 方法接受一个参数：</p>\n<pre><code>s.concat(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Semigroup 的值\n<ol>\n<li>如果 <code>b</code> 不是相同的 Semigroup，则 <code>concat</code> 的行为未指定。</li>\n</ol>\n</li>\n<li><code>concat</code> 必须返回相同 Semigroup 的值。</li>\n</ol>\n<h3>Monoid</h3>\n<p>实现 Monoid 规范的值还必须实现 <a href=\"#semigroup\">Semigroup</a> 规范</p>\n<ol>\n<li><code>m.concat(M.empty())</code> 等价于 <code>m</code> (右结合性)</li>\n<li><code>M.empty().concat(m)</code> 等价于 <code>m</code> (左结合性)</li>\n</ol>\n<h4><code>empty</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">empty</span> :: <span class=\"type\">Monoid</span> m =&gt; () -&gt; m</span><br></pre></td></tr></table></figure></p>\n<p>具有 Monoid 的值必须在其类型表示上提供 <code>empty</code> 方法：</p>\n<pre><code>M.empty()\n</code></pre>\n<p>给定值<code></code>m，可以通过 <code>constructor</code> 属性来访问其类型表示：</p>\n<pre><code>m.constructor.empty()\n</code></pre>\n<ol>\n<li><code>empty</code> 必须返回相同 Monoid 的值。</li>\n</ol>\n<h3>Group</h3>\n<p>实现 Group 规范的值还必须实现 <a href=\"#monoid\">Monoid</a> 规范。</p>\n<ol>\n<li><code>g.concat(g.invert())</code> 等价于 <code>g.constructor.empty()</code> (右反转性??)</li>\n<li><code>g.invert().concat(g)</code> 等价于 <code>g.constructor.empty()</code> (左翻转性??)</li>\n</ol>\n<h4><code>invert</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">invert</span> :: <span class=\"type\">Group</span> g =&gt; g ~&gt; () -&gt; g</span><br></pre></td></tr></table></figure></p>\n<p>具有 Semigroup 的值必须提供 <code>invert</code> 方法。<code>invert</code> 方法接受零个参数：</p>\n<pre><code>g.invert()\n</code></pre>\n<ol>\n<li><code>invert</code> 必须返回相同 Group 的值。</li>\n</ol>\n<h3>Filterable</h3>\n<ol>\n<li><code>v.filter(x =&gt; p(x) &amp;&amp; q(x))</code> 等价于 <code>v.filter(p).filter(q)</code> (分配性)</li>\n<li><code>v.filter(x =&gt; true)</code> 等价于 <code>v</code> (同一性)</li>\n<li><code>v.filter(x -&gt; false)</code> 等价于 <code>w.filter(x =&gt; false)</code>，如果 <code>v</code> 和 <code>w</code> 具有相同的 Filterable 值 (湮灭??)</li>\n</ol>\n<h4><code>filter</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">filter</span> :: <span class=\"type\">Filterable</span> f =&gt; f a ~&gt; (a -&gt; <span class=\"type\">Boolean</span>) -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Filterable 的值必须提供 <code>filter</code> 方法。<code>filter</code> 方法接受一个参数：</p>\n<pre><code>v.filter(p)\n</code></pre>\n<ol>\n<li>\n<p><code>p</code> 必须是一个函数。</p>\n<ol>\n<li>如果 <code>p</code> 不是函数，则 <code>filter</code> 的行为未指定。</li>\n<li><code>p</code> 必须返回 <code>ture</code> 或 <code>false</code>。如果返回任何其它值，<code>filter</code> 的行为未指定。</li>\n</ol>\n</li>\n<li>\n<p><code>filter</code> 必须返回相同 Filterable 的值。</p>\n</li>\n</ol>\n<h3>Functor</h3>\n<ol>\n<li><code>u.map(a =&gt; a)</code> 等价于 <code>u</code> (同一性)</li>\n<li><code>u.map(x =&gt; f(g(x)))</code> 等价于 <code>u.map(g).map(f)</code> (组合性)</li>\n</ol>\n<h4><code>map</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">map</span> :: <span class=\"type\">Functor</span> f =&gt; f a ~&gt; (a -&gt; b) -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Functor 的值必须提供 <code>map</code> 方法。<code>map</code> 方法接受一个参数：</p>\n<pre><code>u.map(f)\n</code></pre>\n<ol>\n<li>\n<p><code>f</code> 必须是一个函数，</p>\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>map</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任何值。</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查(??)。</li>\n</ol>\n</li>\n<li>\n<p><code>map</code> 必须返回相同 Functor 的值。</p>\n</li>\n</ol>\n<h3>Contravariant</h3>\n<ol>\n<li><code>u.contramap(a =&gt; a)</code> 等价于 <code>u</code> (同一性)</li>\n<li><code>u.contramap(x =&gt; f(g(x)))</code> 等价于 <code>u.contramap(f).contramap(g)</code> (组合性)</li>\n</ol>\n<h4><code>contramap</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">contramap</span> :: <span class=\"type\">Contravariant</span> f =&gt; f a ~&gt; (b -&gt; a) -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Contravariant 的值必须提供 <code>contramap</code> 方法。<code>contramap</code> 方法接受一个参数：</p>\n<pre><code>u.contramap(f)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>contramap</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任何值。</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查(??)。</li>\n</ol>\n</li>\n<li><code>contramap</code> 必须返回相同 Contravariant 的值。</li>\n</ol>\n<h3>Apply</h3>\n<p>实现 Apply 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>v.ap(u.ap(a.map(f =&gt; g =&gt; x =&gt; f(g(x)))))</code> 等价于 <code>v.ap(u).ap(a)</code> (组合型)，推导过程??</li>\n</ol>\n<h4><code>ap</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">ap</span> :: <span class=\"type\">Apply</span> f =&gt; f a ~&gt; f (a -&gt; b) -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Apply 的值必须提供 <code>ap</code> 方法。<code>ap</code> 方法接受一个参数：</p>\n<pre><code>a.ap(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是一个函数的 Apply\n<ol>\n<li>如果 <code>b</code> 不代表函数，则 <code>ap</code> 的行为未指定。</li>\n<li><code>b</code> 必须与 a 具有相同的 Apply。</li>\n</ol>\n</li>\n<li><code>a</code> 可以是任意值的 Apply。(??)</li>\n<li><code>ap</code> 必须能将 Apply <code>b</code> 内的函数应用于 Apply <code>a</code> 的值上\n<ol>\n<li>函数返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li>由 <code>ap</code> 返回的 <code>Apply</code> 必须与 <code>a</code> 和 <code>b</code> 的相同。</li>\n</ol>\n<h3>Applicative</h3>\n<p>实现 Applicative 规范的值还必须实现 <a href=\"#apply\">Apply</a> 规范。</p>\n<ol>\n<li><code>v.ap(A.of(x =&gt; x))</code> 等价于 <code>v</code> (同一性)</li>\n<li><code>A.of(x).ap(A.of(f))</code> 等价于 <code>A.of(f(x))</code> (同态性, homomorphism)</li>\n<li><code>A.of(y).ap(u)</code> 等价于 <code>u.ap(A.of(f =&gt; f(y)))</code> (交换性)</li>\n</ol>\n<h4><code>of</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">of</span> :: <span class=\"type\">Applicative</span> f =&gt; a -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Applicative 的值必须在其类型表示中提供 <code>of</code> 函数。<code>of</code> 函数接受一个参数：</p>\n<pre><code>F.of(a)\n</code></pre>\n<p>给定值 <code>f</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>\n<pre><code>f.contructor.of(a)\n</code></pre>\n<ol>\n<li><code>of</code> 必须提供相同的 Applicative\n<ol>\n<li>a 的任何部分都不应该被检查</li>\n</ol>\n</li>\n</ol>\n<h3>Alt</h3>\n<p>实现 Alt 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>a.alt(b).alt(c)</code> 等价于 <code>a.alt(b.alt(c))</code> (结合性)</li>\n<li><code>a.alt(b).map(f)</code> 等价于 <code>a.map(f).alt(b.map(f))</code> (分配性) (看起来像乘法，有什么实际用途呢？)</li>\n</ol>\n<h4><code>alt</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">alt</span> :: <span class=\"type\">Alt</span> f =&gt; f a ~&gt; f a -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Alt 的值必须提供 <code>alt</code> 方法。<code>alt</code> 方法接受一个参数：</p>\n<pre><code>a.alt(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Alt 的值\n<ol>\n<li>如果 <code>b</code> 不是相同的 Alt，则 <code>alt</code> 的行为未指定。</li>\n<li><code>a</code> 和 <code>b</code> 可以包含相同类型的任何值。</li>\n<li><code>a</code> 和 <code>b</code> 包含值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>alt</code> 必须返回相同 Alt 的值。</li>\n</ol>\n<h3>Plus</h3>\n<p>实现 Plus 规范的值还必须实现 <a href=\"#alt\">Alt</a> 规范。</p>\n<ol>\n<li><code>x.alt(A.zero())</code> 等价于 <code>x</code> (右同一性)</li>\n<li><code>A.zero().alt(x)</code> 等价于 <code>x</code> (左同一性)</li>\n<li><code>A.zero().map(f)</code> 等价于 <code>A.zero()</code> (湮灭??)</li>\n</ol>\n<h4><code>zero</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">zero</span> :: <span class=\"type\">Plus</span> f =&gt; () -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Plus 的值必须在其类型表示中提供 <code>zero</code> 函数：</p>\n<pre><code>A.zero()\n</code></pre>\n<p>给定值 <code>x</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>\n<pre><code>x.contructor.zero()\n</code></pre>\n<p><code>zero</code> 必须返回相同 Plus 的值。</p>\n<h3>Alternative</h3>\n<p>实现 Alternative 规范的值还必须实现 <a href=\"#applicative\">Applicative</a> 和 <a href=\"#plus\">Plus</a> 规范。</p>\n<ol>\n<li><code>x.ap(f.alt(g))</code> 等价于 <code>x.ap(f).alt(x.ap(g))</code> (分配性)</li>\n<li><code>x.ap(A.zero())</code> 等价于 <code>A.zero()</code> (湮灭)</li>\n</ol>\n<h3>Foldable</h3>\n<p><code>u.reduce</code> 等价于 <code>u.reduce((acc, x) =&gt; acc.concat([x]), []).reduce</code></p>\n<h4><code>reduce</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">reduce</span> :: <span class=\"type\">Foldable</span> f =&gt; f a ~&gt; ((b, a) -&gt; b, b) -&gt; b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Foldable 的值必须在其类型表示中提供 <code>reduce</code> 函数。<code>reduce</code> 函数接受两个参数：</p>\n<pre><code>u.reduce(f, x)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个二元函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>reduce</code> 的行为未指定。</li>\n<li><code>f</code> 的第一个参数类型必须与 <code>x</code> 的相同。</li>\n<li><code>f</code> 的返回值类型必须与 <code>x</code> 的相同。</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>x</code> 是归约的初始累积值\n<ol>\n<li><code>x</code> 的任何部分都不应该被检查</li>\n</ol>\n</li>\n</ol>\n<h3>Traversable</h3>\n<p>实现 Traversable 规范的值还必须实现 <a href=\"#functor\">Functor</a> 和 <a href=\"#foldable\">Foldable</a> 规范。</p>\n<ol>\n<li>对于任意 <code>t</code>，<code>t(u.traverse(F, x =&gt; x))</code> 等价于 <code>u.traverse(G, t)</code> ，因为 <code>t(a).map(f)</code> 等价于 <code>t(a.map(f))</code> (自然性)</li>\n<li>对于任意 Applicative <code>F</code>，<code>u.traverse(F, F.of)</code> 等价于 <code>F.of(u)</code> (同一性)</li>\n<li><code>u.traverse(Compose, x =&gt; new Compose(x))</code> 等价于 <code>new Compose(u.traverse(F, x =&gt; x).map(x =&gt; x.traverse(G, x =&gt; x)))</code>，对下面定义的 <code>Compose</code> 和 任意 Applicatives <code>F</code> 和 <code>G</code> 都适用 (组合性)</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Compose.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(F.of(G.of(x)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Compose.prototype.ap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(<span class=\"keyword\">this</span>.c.ap(f.c.map(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> y.ap(u))))</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Compose.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(<span class=\"keyword\">this</span>.c.map(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> y.map(f)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4><code>traverse</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">traverse</span> :: <span class=\"type\">Applicative</span> f, <span class=\"type\">Traversable</span> t =&gt; t a ~&gt; (<span class=\"type\">TypeRep</span> f, a -&gt; f b) -&gt; f (t b)</span><br></pre></td></tr></table></figure></p>\n<p>具有 Traversable 的值必须提供 <code>traverse</code> 函数。<code>traverse</code> 函数接受两个参数：</p>\n<pre><code>u.traverse(A, f)\n</code></pre>\n<ol>\n<li><code>A</code> 必须是一个 Applicative 的类型表示。</li>\n<li><code>f</code> 必须是一个返回值的函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>traverse</code> 的行为未指定。</li>\n<li><code>f</code> 必须返回类型表示为 <code>A</code> 的值。</li>\n</ol>\n</li>\n<li><code>traverse</code> 必须返回类型表示为 <code>A</code> 的值。</li>\n</ol>\n<h3>Chain</h3>\n<p>实现 Chain 规范的值还必须实现 <a href=\"#apply\">Apply</a> 规范。</p>\n<ol>\n<li><code>m.chain(f).chain(g)</code> 等价于 <code>m.chain(x =&gt; f(x).chain(g))</code> (结合性)</li>\n</ol>\n<h4><code>chain</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">chain</span> :: <span class=\"type\">Chain</span> m =&gt; m a ~&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Chain 的值必须提供 <code>chain</code> 函数。<code>chain</code> 函数接受一个参数：</p>\n<pre><code>m.chain(f)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>chain</code> 的行为未指定。</li>\n<li><code>f</code> 必须返回相同 Chain 的值。</li>\n</ol>\n</li>\n<li><code>chain</code> 必须返回相同 Chain 的值。</li>\n</ol>\n<h3>ChainRec</h3>\n<p>实现 ChainRec 规范的值还必须实现 <a href=\"#chain\">Chain</a> 规范。</p>\n<ol>\n<li><code>M.chainRec((next, done, v) =&gt; p(v) ? d(v).map(done) : n(v).map(next), i)</code> 等价于 <code>function step(v) { return p(v) ? d(v) : n(v).chain(step); }(i)</code> (等价性)</li>\n<li><code>M.chainRec(f, i)</code> 栈的用量必须是 <code>f</code> 自身栈用量的常数倍。</li>\n</ol>\n<h4><code>chainRec</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">chainRec</span> :: <span class=\"type\">ChainRec</span> m =&gt; ((a -&gt; c), b -&gt; c, a) -&gt; m b</span><br></pre></td></tr></table></figure></p>\n<p>具有 ChainRec 的值必须在其类型表示中提供 <code>chainRec</code> 函数。<code>chainRec</code> 函数接受两个参数：</p>\n<pre><code>M.chainRec(f, i)\n</code></pre>\n<p>给定值 <code>m</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>\n<pre><code>m.constructor.chainRec(f, i)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>chainRec</code> 的行为未指定。</li>\n<li><code>f</code> 接受三个参数 <code>next</code>，<code>done</code>，<code>value</code>\n<ol>\n<li><code>next</code> 是一个函数，其接受一个与 i 类型相同的参数，可以返回任意值</li>\n<li><code>done</code> 也是一个函数，其接受一个参数，并返回一个与 <code>next</code> 返回值类型相同的值</li>\n<li><code>value</code> 是一个与 i 类型相同的值。</li>\n</ol>\n</li>\n<li><code>f</code> 必须返回一个相同 ChainRec 的值，其中包含的是从 <code>done</code> 或 <code>next</code> 返回的值。</li>\n</ol>\n</li>\n<li><code>chainRec</code> 必须返回一个相同 ChainRec 的值，其中包含的值的类型与 <code>done</code> 的参数类型相同。</li>\n</ol>\n<h3>Monad</h3>\n<p>实现 Monad 规范的值还必须实现 <a href=\"#applicative\">Applicative</a> 和 <a href=\"#chain\">Chain</a> 规范。</p>\n<ol>\n<li><code>M.of(a).chain(f)</code> 等价于 <code>f(a)</code> (左同一性)</li>\n<li><code>m.chain(M.of)</code> 等价于 <code>m</code> (右同一性)</li>\n</ol>\n<h3>Extend</h3>\n<p>实现 Extend 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>w.extend(g).extend(f)</code> 等价于 <code>w.extend(\\_w =&gt; f(\\_w.extend(g)))</code></li>\n</ol>\n<p><code>extend</code> 方法</p>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">extend</span> :: <span class=\"type\">Extend</span> w =&gt; w a ~&gt; (w a -&gt; b) -&gt; w b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Extend 的值必须提供 <code>extend</code> 函数。<code>extend</code> 函数接受一个参数：</p>\n<pre><code>w.extend(f)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 extend 的行为未指定。</li>\n<li><code>f</code> 必须返回一个 <code>v</code> 类型的值，其中 <code>v</code> 是 <code>w</code> 中包含的某个变量 <code>v</code> (??)</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>extend</code> 必须返回相同 Extend 的值。</li>\n</ol>\n<h3>Comonad</h3>\n<p>实现 Comonad 规范的值还必须实现 <a href=\"#extend\">Extend</a> 规范。</p>\n<ol>\n<li><code>w.extend(_w =&gt; _w.extract())</code> 等价于 <code>w</code> (左同一性)</li>\n<li><code>w.extend(f).extract()</code> 等价于 <code>f(w)</code> (右同一性)</li>\n</ol>\n<h4><code>extract</code> 方法</h4>\n<p>具有 Comonad 的值必须提供 <code>extract</code> 函数。<code>extract</code> 函数接受零个参数：</p>\n<pre><code>w.extract()\n</code></pre>\n<ol>\n<li><code>extract</code> 必须返回一个 <code>v</code> 类型的值，其中 <code>v</code> 是 <code>w</code> 中包含的某个变量 <code>v</code> (??)\n<ol>\n<li><code>v</code> 必须与在 <code>extend</code> 中的 <code>f</code> 返回的类型相同。</li>\n</ol>\n</li>\n</ol>\n<h3>Bifunctor</h3>\n<p>实现 Bifunctor 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>p.bimap(a =&gt; a, b =&gt; b)</code> 等价于 <code>p</code> (同一性)</li>\n<li><code>p.bimap(a =&gt; f(g(a)), b =&gt; h(i(b)))</code> 等价于 <code>p.bimap(g, i).bimap(f, h)</code> (组合性)</li>\n</ol>\n<h3><code>bimap</code> 方法</h3>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">bimap</span> :: <span class=\"type\">Bifunctor</span> f =&gt; f a c ~&gt; (a -&gt; b, c -&gt; d) -&gt; f b d</span><br></pre></td></tr></table></figure></p>\n<p>具有 Bifunctor 的值必须提供 <code>bimap</code> 函数。<code>bimap</code> 函数接受两个参数：</p>\n<pre><code>c.bimap(f, g)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>bimap</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任意值</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>g</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>g</code> 不是函数，则 <code>bimap</code> 的行为未指定。</li>\n<li><code>g</code> 可以返回任意值\n3.<code>g</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>bimap</code> 必须返回相同 Bifunctor 的值。</li>\n</ol>\n<h3>Profunctor</h3>\n<p>实现 Profunctor 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>p.promap(a =&gt; a, b =&gt; b)</code> 等价于 <code>p</code> (同一性)</li>\n<li><code>p.promap(a =&gt; f(g(a)), b =&gt; h(i(b)))</code> 等价于 <code>p.promap(f, i).promap(g, h)</code> (组合性)</li>\n</ol>\n<h4><code>promap</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">promap</span> :: <span class=\"type\">Profunctor</span> p =&gt; p b c ~&gt; (a -&gt; b, c -&gt; d) -&gt; p a d</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>promap</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任意值</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>g</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>g</code> 不是函数，则 <code>promap</code> 的行为未指定。</li>\n<li><code>g</code> 可以返回任意值</li>\n<li><code>g</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>promap</code> 必须返回相同 Profunctor 的值。</li>\n</ol>\n<h2>推导</h2>\n<p>当创建满足多个代数的数据类型是，作者可以选择实现某些方法，然后推导出剩余的方法。推导：</p>\n<ul>\n<li>\n<p><a href=\"#code-equals-code-fang-fa\"><code>equals</code></a> 可以由 <a href=\"#code-lte-code-fang-fa\"><code>lte</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">other</span>) </span>&#123; retrun <span class=\"keyword\">this</span>.lte(other) &amp;&amp; other.lte(<span class=\"keyword\">this</span>) &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-ap-code-fang-fa\"><code>ap</code></a> 和 <a href=\"#code-of-code-fang-fa\"><code>of</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.ap(<span class=\"keyword\">this</span>.of(f))&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-chain-code-fang-fa\"><code>chain</code></a> 和 <a href=\"#code-of-code-fang-fa\"><code>of</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.chain(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"keyword\">this</span>.of(f(a))); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-bimap-code-fang-fa\"><code>bimap</code></a> 推导出 (??)：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.bimap(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a, f); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-promap-code-fang-fa\"><code>promap</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.promap(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a, f); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-ap-code-fang-fa\"><code>ap</code></a> 可以由 <a href=\"#code-chain-code-fang-fa\"><code>chain</code></a> 推导出：\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123; <span class=\"keyword\">return</span> m.chain(<span class=\"function\"><span class=\"params\">f</span> =&gt;</span> <span class=\"keyword\">this</span>.map(f)); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-reduce-code-fang-fa\"><code>reduce</code></a> 可以由下列推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, acc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Const</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Const.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">\\_</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Const(acc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Const.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">\\_</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Const.prototype.ap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Const(f(b.value, <span class=\"keyword\">this</span>.value));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.traverse(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">new</span> Const(x), Const.of).value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 的推导如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Id</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Id.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Id(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Id.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Id(f(b.value));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Id.prototype.ap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Id(<span class=\"keyword\">this</span>.value(b.value));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.traverse(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> Id.of(f(x)), Id.of).value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-filter-code-fang-fa\"><code>filter</code></a> 可以由 <a href=\"#code-of-code-fang-fa\"><code>of</code></a>，<a href=\"#code-chain-code-fang-fa\"><code>chain</code></a> 和 <a href=\"#code-zero-code-fang-fa\"><code>zero</code></a> 推导出：\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pred</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"keyword\">this</span>.constructor;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.chain(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> pred(x) ? F.of(x) : F.zero());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-filter-code-fang-fa\"><code>filter</code></a> 还可以由 <a href=\"#code-concat-code-fang-fa\"><code>concat</code></a>，<a href=\"#code-of-code-fang-fa\"><code>of</code></a>，<a href=\"#code-zero-code-fang-fa\"><code>zero</code></a> 和 <a href=\"#code-reduce-code-fang-fa\"><code>reduce</code></a>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pred</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"keyword\">this</span>.constructor;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.reduce(<span class=\"function\">(<span class=\"params\">f, x</span>) =&gt;</span> pred(x) ? f.concat(F.of(x)) : f, F.zero());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2>注意</h2>\n<ol>\n<li>如果实现的方法和规则不止一种，应该选择一种实现，并为其他用途提供包装。</li>\n<li>我们不鼓励重载特定的方法。那样会很容易造成崩溃和错误的行为。</li>\n<li>建议对未指定的行为抛出异常。</li>\n<li>在 <a href=\"https://github.com/sanctuary-js/sanctuary-identity\" target=\"_blank\" rel=\"noopener\">sanctuary-identity</a> 中提供了一个实现了许多方法的 Id 容器。</li>\n</ol>\n<h2>备选方案</h2>\n<p>此外，还存在一个 Static Land 规范，其思想与 Fantasy Land 完全相同，但是是基于静态方法而非实例方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>(又名 &quot;代数 JavaScript 规范&quot;)</p>\n<p><img src=\"./logo.png\" alt=\"logo\"></p>\n<p>该项目规定了通用代数数据结构的互操作性：</p>\n<ul>\n<li><a href=\"#setoid\">Setoid</a></li>\n<li><a href=\"#ord\">Ord</a></li>\n<li><a href=\"#semigroupoid\">Semigroupoid</a></li>\n<li><a href=\"#category\">Category</a></li>\n<li><a href=\"#semigroup\">Semigroup</a></li>\n<li><a href=\"#monoid\">Monoid</a></li>\n<li><a href=\"#group\">Group</a></li>\n<li><a href=\"#filterable\">Filterable</a></li>\n<li><a href=\"#functor\">Functor</a></li>\n<li><a href=\"#contravariant\">Contravariant</a></li>\n<li><a href=\"#apply\">Apply</a></li>\n<li><a href=\"#applicative\">Applicative</a></li>\n<li><a href=\"#alt\">Alt</a></li>\n<li><a href=\"#plus\">Plus</a></li>\n<li><a href=\"#alternative\">Alternative</a></li>\n<li><a href=\"#foldable\">Foldable</a></li>\n<li><a href=\"#traversable\">Traversable</a></li>\n<li><a href=\"#chain\">Chain</a></li>\n<li><a href=\"#chainrec\">ChainRec</a></li>\n<li><a href=\"#monad\">Monad</a></li>\n<li><a href=\"#extend\">Extend</a></li>\n<li><a href=\"#comonad\">Comonad</a></li>\n<li><a href=\"#bifunctor\">Bifunctor</a></li>\n<li><a href=\"#profunctor\">Profunctor</a></li>\n</ul>\n<p><img src=\"./dependencies.png\" alt=\"dependencies\"></p>\n<h2>概览</h2>\n<p>代数是遵循一定法则的、具有封闭性的，一系列值及一系列操作的集合。</p>\n<p>每个 Fantasy Land 代数是一个单独的规范。一个代数可能依赖于其他必需实现的代数。</p>\n<h2>术语</h2>\n<ol>\n<li>\n<p>&quot;值&quot;：任何 JavaScript 值，包括下面定义的结构的任何值。</p>\n</li>\n<li>\n<p>&quot;等价&quot;：对给定值的等价性的恰当定义。这个定义应该保证两个值可以在其对应的抽象的程序中，能够安全地进行交换。例如：</p>\n<ul>\n<li>当两个列表对应的索引上的值都相等时，它们是等价的。</li>\n<li>当两个普通的 JavaScript 对象所有键值对都相等时，它们（作为字典）是等价的。</li>\n<li>当两个 promises 生成相等的值时，它们是等价的。</li>\n<li>当两个函数给定相同的输入，产生相同的输出时，它们是等价的。</li>\n</ul>\n</li>\n</ol>\n<h2>类型签名符号</h2>\n<p>本文档使用的类型签名符号如下所述：[^1]</p>\n<ul>\n<li><code>::</code> _<em>&quot;是 xx 的成员&quot;。</em>\n<ul>\n<li><code>e :: t</code> 读作：&quot;表达式 <code>e</code> 是类型 <code>t</code> 的成员&quot;。</li>\n<li><code>true :: Boolean</code> - &quot;<code>true</code> 是类型 <code>Boolean</code> 的成员&quot;。</li>\n<li><code>42 :: Integer, Number</code> - &quot;<code>42</code> 是类型 <code>Integer</code> 和 <code>Number</code> 的成员&quot;。</li>\n</ul>\n</li>\n<li><em>新类型可以通过类型构造函数创建。</em>\n<ul>\n<li>类型构造函数可以接受零或多个类型参数。</li>\n<li><code>Array</code> 是一个接受单个参数的类型构造函数。</li>\n<li><code>Array String</code> 代表包含字符串的数组的类型。后面每个都是 <code>Array String</code> 类型的：<code>[]</code>，<code>['foo', 'bar', 'baz']</code>。</li>\n<li><code>Array (Array String)</code> 代表包含字符串的数组的数组的类型。后面每个都是 <code>Array (Array String)</code> 类型的：<code>[]</code>，<code>[[], []]</code>， <code>[[], ['foo'], ['bar', 'baz']]</code>。</li>\n</ul>\n</li>\n<li><em>小写字母代表类型变量。</em>\n<ul>\n<li>类型变量可以接受任何类型，除非受到类型约束的限制（参见下面的胖箭头）。</li>\n<li><code>-&gt;</code> (箭头) <em>函数类型的构造函数</em></li>\n<li><code>-&gt;</code> 是一个 <em>中缀</em> 构造函数，它接受两个类型参数，左侧参数为输入的类型，右侧参数为输出的类型。</li>\n<li><code>-&gt;</code> 的输入类型可以通过一组类型创建出来，该函数接受零个或多个参数。其语法是：<code>(&lt;input-types&gt;) -&gt; &lt;output-type&gt;</code>，其中 <code>&lt;input-types&gt;</code> 包含零个或多个 &quot;逗号-空格&quot; （<code>,</code>）分开的类型表示，对于一元函数，圆括号也可以省略。</li>\n<li><code>String -&gt; Array String</code> 是一种接受一个 <code>String</code> 并返回一个 <code>Array String</code> 的函数的类型。</li>\n<li><code>String -&gt; Array String -&gt; Array String</code> 是一种函数类型，它接受一个 <code>String</code> 并返回一个函数，返回的函数接受一个 <code>Array String</code> 并返回一个 <code>Array String</code>。</li>\n<li><code>(String, Array String) -&gt; Array String</code> 是一种函数类型，它接受一个 <code>String</code> 和 <code>Aray String</code> 作为参数，并返回一个 <code>Array String</code> 。</li>\n<li><code>() -&gt; Number</code> 是一种不带输入参数，返回 <code>Number</code> 的函数类型。</li>\n</ul>\n</li>\n<li><code>~&gt;</code> (波浪形箭头) <em>方法类型的构造函数。</em>\n<ul>\n<li>当一个函数是一个对象（Object）的属性时，它被称为方法。所有方法都有一个隐含的参数类型 - 它是属性所在对象的类型。</li>\n<li><code>a ~&gt; a -&gt; a</code> 是一种对象中方法的类型，它接受 <code>a</code> 类型的参数，并返回一个 <code>a</code> 类型的值。</li>\n</ul>\n</li>\n<li><code>=&gt;</code> (胖箭头) 表示对类型变量的约束。\n<ul>\n<li>在 <code>a ~&gt; a -&gt; a</code>（参见上面的波浪形箭头）中，<code>a</code> 可以为任意类型。半群 <code>a =&gt; a ~&gt; a -&gt; a</code> 会添加一个约束，使得类型 <code>a</code> 现在必须满足该半群的类型类。满足类型类意味着，须合法地实现该类型类指定所有函数/方法。</li>\n</ul>\n</li>\n</ul>\n<p>例如：</p>\n<p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">traverse :: Applicative f, Traversable t =&gt; t a ~&gt; (TypeRep f, a -&gt; f b) -&gt; f (t b)</span><br><span class=\"line\">&apos;------&apos;    &apos;--------------------------&apos;    &apos;-&apos;    &apos;-------------------&apos;    &apos;-----&apos;</span><br><span class=\"line\"> &apos;           &apos;                               &apos;      &apos;                        &apos;</span><br><span class=\"line\"> &apos;           &apos; - type constraints            &apos;      &apos; - argument types       &apos; - return type</span><br><span class=\"line\"> &apos;                                           &apos;</span><br><span class=\"line\"> &apos;- method name                              &apos; - method target type</span><br></pre></td></tr></table></figure></p>\n<p>[^1]: 更多相关信息，请参阅 Sanctuary 文档中的 <a href=\"https://sanctuary.js.org/#types\" target=\"_blank\" rel=\"noopener\">Types</a> 部分。</p>\n<h2>前缀方法名</h2>\n<p>为了使数据类型与 Fantasy Land 兼容，其值必须具有某些属性。这些属性都以 <code>fantasy-land/</code> 为前缀。例如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  MyType#fantasy-land/map :: MyType a ~&gt; (a -&gt; b) -&gt; MyType b</span></span><br><span class=\"line\">MyType.prototype[<span class=\"string\">'fantasy-land/map'</span>] = ...</span><br></pre></td></tr></table></figure></p>\n<p>在本文中，不使用前缀的名称，只是为了减少干扰。</p>\n<p>为了方便起见，你可以使用 <code>fantasy-land</code> 包：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fl = <span class=\"built_in\">require</span>(<span class=\"string\">'fantasy-land'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\">MyType.prototype[fl.map] = ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> foo = bar[fl.map](<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<h2>类型表示 (JavaScript 中的构造函数？)</h2>\n<p>某些行为是从类型成员的角度定义的。而另外一些行为不需要类型成员。因此，某些代数需要一个类型来提供值层面上的表示（具有某些属性）。例如，Identity 类型可以提供 <code>Id</code> 作为其类型表示：<code>Id :: TypeRep Identity</code>。</p>\n<p>如果一个类型提供了类型表示，那么这个类型的每个成员都必须有一个指向该类型表示的 <code>contructor</code> 属性。</p>\n<h2>代数</h2>\n<h3>Setoid</h3>\n<ol>\n<li><code>a.equals(a) === true</code> (自反性)</li>\n<li><code>a.equals(b) === b.equals(a)</code> (对称性)</li>\n<li>如果 <code>a.equals(b)</code> 并且 <code>b.equals(a)</code>，则 <code>a.equals(c)</code> (传递性)</li>\n</ol>\n<h4><code>equals</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">equals</span> :: <span class=\"type\">Setoid</span> a =&gt; a ~&gt; a -&gt; <span class=\"type\">Boolean</span></span><br></pre></td></tr></table></figure></p>\n<p>具有 Setoid 的值必须提供 <code>equals</code> 方法。<code>equals</code> 方法接受一个参数：</p>\n<pre><code>a.equals(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Setoid 的值\n<ol>\n<li>如果 <code>b</code> 不是相同的 Setoid，则 <code>equals</code> 的行为未指定（建议返回 <code>false</code>）。</li>\n<li><code>equals</code> 必须返回一个布尔值（<code>true</code> 或 <code>false</code>）。</li>\n</ol>\n</li>\n</ol>\n<h3>Ord</h3>\n<p>实现 Ord 规范的值还必须实现 <a href=\"#setoid\">Setoid</a> 规范。</p>\n<ol>\n<li><code>a.lte(b)</code> 或 <code>b.lte(a)</code> (完全性)</li>\n<li>如果 <code>a.lte(b)</code> 且 <code>b.lte(a)</code>，则 <code>a.equals(b)</code> (反对称性)</li>\n<li>如果 <code>a.lte(b)</code> 且 <code>b.lte(c)</code>，则 <code>a.lte(c)</code> (传递性)</li>\n</ol>\n<h4><code>lte</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">lte</span> :: <span class=\"type\">Ord</span> a =&gt; a ~&gt; a -&gt; <span class=\"type\">Boolean</span></span><br></pre></td></tr></table></figure></p>\n<p>具有 Ord 的值必须提供 <code>lte</code> 方法。<code>lte</code> 方法接受一个参数：</p>\n<pre><code>`a.lte(b)`\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Ord 的值。\n<ol>\n<li>如果 <code>b</code> 不是相同的 Ord，则 <code>lte</code> 的行为未指定 (建议返回 <code>false</code>)。</li>\n</ol>\n</li>\n<li><code>lte</code> 必须返回布尔值（<code>true</code> 或 <code>false</code>）。</li>\n</ol>\n<h3>Semigroupoid</h3>\n<ol>\n<li><code>a.compose(b).compose(c) === a.compose(b.compose(c))</code> (结合性)</li>\n</ol>\n<h4><code>compose</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">compose</span> :: <span class=\"type\">Semigroupoid</span> c =&gt; c i j ~&gt; c j k -&gt; c i k</span><br></pre></td></tr></table></figure></p>\n<p>具有 Semigoupoid 的值必须提供 <code>compose</code> 组合方法。<code>compose</code> 方法接受一个参数：</p>\n<pre><code>a.compose(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须返回相同 Semigroupoid 规范。\n<ol>\n<li>如果 <code>b</code> 不是相同的 Semigroupoid，compose 的行为未指定。</li>\n</ol>\n</li>\n<li><code>compose</code> 必须返回相同 Semigroupoid 的值。</li>\n</ol>\n<h3>Category</h3>\n<p>实现范畴规范的值还必须实现<a href=\"#semigroupoid\">半群</a>规范。</p>\n<ol>\n<li><code>a.compose(C.id())</code> 等价于 <code>a</code> (右同一性)</li>\n<li><code>C.id().compose(a)</code> 等价于 <code>a</code> (左同一性)</li>\n</ol>\n<h4><code>id</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">id</span> :: <span class=\"type\">Category</span> c =&gt; () -&gt; c a a</span><br></pre></td></tr></table></figure></p>\n<p>具有范畴的值必须在其<a href=\"#type-representatives\">类型表示</a>中提供一个 <code>id</code> 函数。</p>\n<pre><code>C.id()\n</code></pre>\n<p>给定值 <code>c</code>，可以通过 <code>contructor</code> 属性来访问其类型表示：</p>\n<pre><code>c.constructgor.id()\n</code></pre>\n<ol>\n<li><code>id</code> 必须返回相同范畴的值。</li>\n</ol>\n<h3>Semigroup</h3>\n<ol>\n<li><code>a.concat(b).concat(c)</code> 等价于 <code>a.concat(b.concat(c))</code> （结合性）</li>\n</ol>\n<h4><code>concat</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">concat</span> :: <span class=\"type\">Semigroup</span> a =&gt; a ~&gt; a -&gt; a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Semigroup 的值必须提供 <code>concat</code> 方法。<code>concat</code> 方法接受一个参数：</p>\n<pre><code>s.concat(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Semigroup 的值\n<ol>\n<li>如果 <code>b</code> 不是相同的 Semigroup，则 <code>concat</code> 的行为未指定。</li>\n</ol>\n</li>\n<li><code>concat</code> 必须返回相同 Semigroup 的值。</li>\n</ol>\n<h3>Monoid</h3>\n<p>实现 Monoid 规范的值还必须实现 <a href=\"#semigroup\">Semigroup</a> 规范</p>\n<ol>\n<li><code>m.concat(M.empty())</code> 等价于 <code>m</code> (右结合性)</li>\n<li><code>M.empty().concat(m)</code> 等价于 <code>m</code> (左结合性)</li>\n</ol>\n<h4><code>empty</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">empty</span> :: <span class=\"type\">Monoid</span> m =&gt; () -&gt; m</span><br></pre></td></tr></table></figure></p>\n<p>具有 Monoid 的值必须在其类型表示上提供 <code>empty</code> 方法：</p>\n<pre><code>M.empty()\n</code></pre>\n<p>给定值<code></code>m，可以通过 <code>constructor</code> 属性来访问其类型表示：</p>\n<pre><code>m.constructor.empty()\n</code></pre>\n<ol>\n<li><code>empty</code> 必须返回相同 Monoid 的值。</li>\n</ol>\n<h3>Group</h3>\n<p>实现 Group 规范的值还必须实现 <a href=\"#monoid\">Monoid</a> 规范。</p>\n<ol>\n<li><code>g.concat(g.invert())</code> 等价于 <code>g.constructor.empty()</code> (右反转性??)</li>\n<li><code>g.invert().concat(g)</code> 等价于 <code>g.constructor.empty()</code> (左翻转性??)</li>\n</ol>\n<h4><code>invert</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">invert</span> :: <span class=\"type\">Group</span> g =&gt; g ~&gt; () -&gt; g</span><br></pre></td></tr></table></figure></p>\n<p>具有 Semigroup 的值必须提供 <code>invert</code> 方法。<code>invert</code> 方法接受零个参数：</p>\n<pre><code>g.invert()\n</code></pre>\n<ol>\n<li><code>invert</code> 必须返回相同 Group 的值。</li>\n</ol>\n<h3>Filterable</h3>\n<ol>\n<li><code>v.filter(x =&gt; p(x) &amp;&amp; q(x))</code> 等价于 <code>v.filter(p).filter(q)</code> (分配性)</li>\n<li><code>v.filter(x =&gt; true)</code> 等价于 <code>v</code> (同一性)</li>\n<li><code>v.filter(x -&gt; false)</code> 等价于 <code>w.filter(x =&gt; false)</code>，如果 <code>v</code> 和 <code>w</code> 具有相同的 Filterable 值 (湮灭??)</li>\n</ol>\n<h4><code>filter</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">filter</span> :: <span class=\"type\">Filterable</span> f =&gt; f a ~&gt; (a -&gt; <span class=\"type\">Boolean</span>) -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Filterable 的值必须提供 <code>filter</code> 方法。<code>filter</code> 方法接受一个参数：</p>\n<pre><code>v.filter(p)\n</code></pre>\n<ol>\n<li>\n<p><code>p</code> 必须是一个函数。</p>\n<ol>\n<li>如果 <code>p</code> 不是函数，则 <code>filter</code> 的行为未指定。</li>\n<li><code>p</code> 必须返回 <code>ture</code> 或 <code>false</code>。如果返回任何其它值，<code>filter</code> 的行为未指定。</li>\n</ol>\n</li>\n<li>\n<p><code>filter</code> 必须返回相同 Filterable 的值。</p>\n</li>\n</ol>\n<h3>Functor</h3>\n<ol>\n<li><code>u.map(a =&gt; a)</code> 等价于 <code>u</code> (同一性)</li>\n<li><code>u.map(x =&gt; f(g(x)))</code> 等价于 <code>u.map(g).map(f)</code> (组合性)</li>\n</ol>\n<h4><code>map</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">map</span> :: <span class=\"type\">Functor</span> f =&gt; f a ~&gt; (a -&gt; b) -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Functor 的值必须提供 <code>map</code> 方法。<code>map</code> 方法接受一个参数：</p>\n<pre><code>u.map(f)\n</code></pre>\n<ol>\n<li>\n<p><code>f</code> 必须是一个函数，</p>\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>map</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任何值。</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查(??)。</li>\n</ol>\n</li>\n<li>\n<p><code>map</code> 必须返回相同 Functor 的值。</p>\n</li>\n</ol>\n<h3>Contravariant</h3>\n<ol>\n<li><code>u.contramap(a =&gt; a)</code> 等价于 <code>u</code> (同一性)</li>\n<li><code>u.contramap(x =&gt; f(g(x)))</code> 等价于 <code>u.contramap(f).contramap(g)</code> (组合性)</li>\n</ol>\n<h4><code>contramap</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">contramap</span> :: <span class=\"type\">Contravariant</span> f =&gt; f a ~&gt; (b -&gt; a) -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Contravariant 的值必须提供 <code>contramap</code> 方法。<code>contramap</code> 方法接受一个参数：</p>\n<pre><code>u.contramap(f)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>contramap</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任何值。</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查(??)。</li>\n</ol>\n</li>\n<li><code>contramap</code> 必须返回相同 Contravariant 的值。</li>\n</ol>\n<h3>Apply</h3>\n<p>实现 Apply 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>v.ap(u.ap(a.map(f =&gt; g =&gt; x =&gt; f(g(x)))))</code> 等价于 <code>v.ap(u).ap(a)</code> (组合型)，推导过程??</li>\n</ol>\n<h4><code>ap</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">ap</span> :: <span class=\"type\">Apply</span> f =&gt; f a ~&gt; f (a -&gt; b) -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Apply 的值必须提供 <code>ap</code> 方法。<code>ap</code> 方法接受一个参数：</p>\n<pre><code>a.ap(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是一个函数的 Apply\n<ol>\n<li>如果 <code>b</code> 不代表函数，则 <code>ap</code> 的行为未指定。</li>\n<li><code>b</code> 必须与 a 具有相同的 Apply。</li>\n</ol>\n</li>\n<li><code>a</code> 可以是任意值的 Apply。(??)</li>\n<li><code>ap</code> 必须能将 Apply <code>b</code> 内的函数应用于 Apply <code>a</code> 的值上\n<ol>\n<li>函数返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li>由 <code>ap</code> 返回的 <code>Apply</code> 必须与 <code>a</code> 和 <code>b</code> 的相同。</li>\n</ol>\n<h3>Applicative</h3>\n<p>实现 Applicative 规范的值还必须实现 <a href=\"#apply\">Apply</a> 规范。</p>\n<ol>\n<li><code>v.ap(A.of(x =&gt; x))</code> 等价于 <code>v</code> (同一性)</li>\n<li><code>A.of(x).ap(A.of(f))</code> 等价于 <code>A.of(f(x))</code> (同态性, homomorphism)</li>\n<li><code>A.of(y).ap(u)</code> 等价于 <code>u.ap(A.of(f =&gt; f(y)))</code> (交换性)</li>\n</ol>\n<h4><code>of</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">of</span> :: <span class=\"type\">Applicative</span> f =&gt; a -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Applicative 的值必须在其类型表示中提供 <code>of</code> 函数。<code>of</code> 函数接受一个参数：</p>\n<pre><code>F.of(a)\n</code></pre>\n<p>给定值 <code>f</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>\n<pre><code>f.contructor.of(a)\n</code></pre>\n<ol>\n<li><code>of</code> 必须提供相同的 Applicative\n<ol>\n<li>a 的任何部分都不应该被检查</li>\n</ol>\n</li>\n</ol>\n<h3>Alt</h3>\n<p>实现 Alt 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>a.alt(b).alt(c)</code> 等价于 <code>a.alt(b.alt(c))</code> (结合性)</li>\n<li><code>a.alt(b).map(f)</code> 等价于 <code>a.map(f).alt(b.map(f))</code> (分配性) (看起来像乘法，有什么实际用途呢？)</li>\n</ol>\n<h4><code>alt</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">alt</span> :: <span class=\"type\">Alt</span> f =&gt; f a ~&gt; f a -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Alt 的值必须提供 <code>alt</code> 方法。<code>alt</code> 方法接受一个参数：</p>\n<pre><code>a.alt(b)\n</code></pre>\n<ol>\n<li><code>b</code> 必须是相同 Alt 的值\n<ol>\n<li>如果 <code>b</code> 不是相同的 Alt，则 <code>alt</code> 的行为未指定。</li>\n<li><code>a</code> 和 <code>b</code> 可以包含相同类型的任何值。</li>\n<li><code>a</code> 和 <code>b</code> 包含值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>alt</code> 必须返回相同 Alt 的值。</li>\n</ol>\n<h3>Plus</h3>\n<p>实现 Plus 规范的值还必须实现 <a href=\"#alt\">Alt</a> 规范。</p>\n<ol>\n<li><code>x.alt(A.zero())</code> 等价于 <code>x</code> (右同一性)</li>\n<li><code>A.zero().alt(x)</code> 等价于 <code>x</code> (左同一性)</li>\n<li><code>A.zero().map(f)</code> 等价于 <code>A.zero()</code> (湮灭??)</li>\n</ol>\n<h4><code>zero</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">zero</span> :: <span class=\"type\">Plus</span> f =&gt; () -&gt; f a</span><br></pre></td></tr></table></figure></p>\n<p>具有 Plus 的值必须在其类型表示中提供 <code>zero</code> 函数：</p>\n<pre><code>A.zero()\n</code></pre>\n<p>给定值 <code>x</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>\n<pre><code>x.contructor.zero()\n</code></pre>\n<p><code>zero</code> 必须返回相同 Plus 的值。</p>\n<h3>Alternative</h3>\n<p>实现 Alternative 规范的值还必须实现 <a href=\"#applicative\">Applicative</a> 和 <a href=\"#plus\">Plus</a> 规范。</p>\n<ol>\n<li><code>x.ap(f.alt(g))</code> 等价于 <code>x.ap(f).alt(x.ap(g))</code> (分配性)</li>\n<li><code>x.ap(A.zero())</code> 等价于 <code>A.zero()</code> (湮灭)</li>\n</ol>\n<h3>Foldable</h3>\n<p><code>u.reduce</code> 等价于 <code>u.reduce((acc, x) =&gt; acc.concat([x]), []).reduce</code></p>\n<h4><code>reduce</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">reduce</span> :: <span class=\"type\">Foldable</span> f =&gt; f a ~&gt; ((b, a) -&gt; b, b) -&gt; b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Foldable 的值必须在其类型表示中提供 <code>reduce</code> 函数。<code>reduce</code> 函数接受两个参数：</p>\n<pre><code>u.reduce(f, x)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个二元函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>reduce</code> 的行为未指定。</li>\n<li><code>f</code> 的第一个参数类型必须与 <code>x</code> 的相同。</li>\n<li><code>f</code> 的返回值类型必须与 <code>x</code> 的相同。</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>x</code> 是归约的初始累积值\n<ol>\n<li><code>x</code> 的任何部分都不应该被检查</li>\n</ol>\n</li>\n</ol>\n<h3>Traversable</h3>\n<p>实现 Traversable 规范的值还必须实现 <a href=\"#functor\">Functor</a> 和 <a href=\"#foldable\">Foldable</a> 规范。</p>\n<ol>\n<li>对于任意 <code>t</code>，<code>t(u.traverse(F, x =&gt; x))</code> 等价于 <code>u.traverse(G, t)</code> ，因为 <code>t(a).map(f)</code> 等价于 <code>t(a.map(f))</code> (自然性)</li>\n<li>对于任意 Applicative <code>F</code>，<code>u.traverse(F, F.of)</code> 等价于 <code>F.of(u)</code> (同一性)</li>\n<li><code>u.traverse(Compose, x =&gt; new Compose(x))</code> 等价于 <code>new Compose(u.traverse(F, x =&gt; x).map(x =&gt; x.traverse(G, x =&gt; x)))</code>，对下面定义的 <code>Compose</code> 和 任意 Applicatives <code>F</code> 和 <code>G</code> 都适用 (组合性)</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> Compose = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.c = c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Compose.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(F.of(G.of(x)));</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Compose.prototype.ap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(<span class=\"keyword\">this</span>.c.ap(f.c.map(<span class=\"function\"><span class=\"params\">u</span> =&gt;</span> <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> y.ap(u))))</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">Compose.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Compose(<span class=\"keyword\">this</span>.c.map(<span class=\"function\"><span class=\"params\">y</span> =&gt;</span> y.map(f)));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h4><code>traverse</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">traverse</span> :: <span class=\"type\">Applicative</span> f, <span class=\"type\">Traversable</span> t =&gt; t a ~&gt; (<span class=\"type\">TypeRep</span> f, a -&gt; f b) -&gt; f (t b)</span><br></pre></td></tr></table></figure></p>\n<p>具有 Traversable 的值必须提供 <code>traverse</code> 函数。<code>traverse</code> 函数接受两个参数：</p>\n<pre><code>u.traverse(A, f)\n</code></pre>\n<ol>\n<li><code>A</code> 必须是一个 Applicative 的类型表示。</li>\n<li><code>f</code> 必须是一个返回值的函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>traverse</code> 的行为未指定。</li>\n<li><code>f</code> 必须返回类型表示为 <code>A</code> 的值。</li>\n</ol>\n</li>\n<li><code>traverse</code> 必须返回类型表示为 <code>A</code> 的值。</li>\n</ol>\n<h3>Chain</h3>\n<p>实现 Chain 规范的值还必须实现 <a href=\"#apply\">Apply</a> 规范。</p>\n<ol>\n<li><code>m.chain(f).chain(g)</code> 等价于 <code>m.chain(x =&gt; f(x).chain(g))</code> (结合性)</li>\n</ol>\n<h4><code>chain</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">chain</span> :: <span class=\"type\">Chain</span> m =&gt; m a ~&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Chain 的值必须提供 <code>chain</code> 函数。<code>chain</code> 函数接受一个参数：</p>\n<pre><code>m.chain(f)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>chain</code> 的行为未指定。</li>\n<li><code>f</code> 必须返回相同 Chain 的值。</li>\n</ol>\n</li>\n<li><code>chain</code> 必须返回相同 Chain 的值。</li>\n</ol>\n<h3>ChainRec</h3>\n<p>实现 ChainRec 规范的值还必须实现 <a href=\"#chain\">Chain</a> 规范。</p>\n<ol>\n<li><code>M.chainRec((next, done, v) =&gt; p(v) ? d(v).map(done) : n(v).map(next), i)</code> 等价于 <code>function step(v) { return p(v) ? d(v) : n(v).chain(step); }(i)</code> (等价性)</li>\n<li><code>M.chainRec(f, i)</code> 栈的用量必须是 <code>f</code> 自身栈用量的常数倍。</li>\n</ol>\n<h4><code>chainRec</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">chainRec</span> :: <span class=\"type\">ChainRec</span> m =&gt; ((a -&gt; c), b -&gt; c, a) -&gt; m b</span><br></pre></td></tr></table></figure></p>\n<p>具有 ChainRec 的值必须在其类型表示中提供 <code>chainRec</code> 函数。<code>chainRec</code> 函数接受两个参数：</p>\n<pre><code>M.chainRec(f, i)\n</code></pre>\n<p>给定值 <code>m</code>，可以通过 <code>contructor</code> 属性访问其类型表示：</p>\n<pre><code>m.constructor.chainRec(f, i)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>chainRec</code> 的行为未指定。</li>\n<li><code>f</code> 接受三个参数 <code>next</code>，<code>done</code>，<code>value</code>\n<ol>\n<li><code>next</code> 是一个函数，其接受一个与 i 类型相同的参数，可以返回任意值</li>\n<li><code>done</code> 也是一个函数，其接受一个参数，并返回一个与 <code>next</code> 返回值类型相同的值</li>\n<li><code>value</code> 是一个与 i 类型相同的值。</li>\n</ol>\n</li>\n<li><code>f</code> 必须返回一个相同 ChainRec 的值，其中包含的是从 <code>done</code> 或 <code>next</code> 返回的值。</li>\n</ol>\n</li>\n<li><code>chainRec</code> 必须返回一个相同 ChainRec 的值，其中包含的值的类型与 <code>done</code> 的参数类型相同。</li>\n</ol>\n<h3>Monad</h3>\n<p>实现 Monad 规范的值还必须实现 <a href=\"#applicative\">Applicative</a> 和 <a href=\"#chain\">Chain</a> 规范。</p>\n<ol>\n<li><code>M.of(a).chain(f)</code> 等价于 <code>f(a)</code> (左同一性)</li>\n<li><code>m.chain(M.of)</code> 等价于 <code>m</code> (右同一性)</li>\n</ol>\n<h3>Extend</h3>\n<p>实现 Extend 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>w.extend(g).extend(f)</code> 等价于 <code>w.extend(\\_w =&gt; f(\\_w.extend(g)))</code></li>\n</ol>\n<p><code>extend</code> 方法</p>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">extend</span> :: <span class=\"type\">Extend</span> w =&gt; w a ~&gt; (w a -&gt; b) -&gt; w b</span><br></pre></td></tr></table></figure></p>\n<p>具有 Extend 的值必须提供 <code>extend</code> 函数。<code>extend</code> 函数接受一个参数：</p>\n<pre><code>w.extend(f)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 extend 的行为未指定。</li>\n<li><code>f</code> 必须返回一个 <code>v</code> 类型的值，其中 <code>v</code> 是 <code>w</code> 中包含的某个变量 <code>v</code> (??)</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>extend</code> 必须返回相同 Extend 的值。</li>\n</ol>\n<h3>Comonad</h3>\n<p>实现 Comonad 规范的值还必须实现 <a href=\"#extend\">Extend</a> 规范。</p>\n<ol>\n<li><code>w.extend(_w =&gt; _w.extract())</code> 等价于 <code>w</code> (左同一性)</li>\n<li><code>w.extend(f).extract()</code> 等价于 <code>f(w)</code> (右同一性)</li>\n</ol>\n<h4><code>extract</code> 方法</h4>\n<p>具有 Comonad 的值必须提供 <code>extract</code> 函数。<code>extract</code> 函数接受零个参数：</p>\n<pre><code>w.extract()\n</code></pre>\n<ol>\n<li><code>extract</code> 必须返回一个 <code>v</code> 类型的值，其中 <code>v</code> 是 <code>w</code> 中包含的某个变量 <code>v</code> (??)\n<ol>\n<li><code>v</code> 必须与在 <code>extend</code> 中的 <code>f</code> 返回的类型相同。</li>\n</ol>\n</li>\n</ol>\n<h3>Bifunctor</h3>\n<p>实现 Bifunctor 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>p.bimap(a =&gt; a, b =&gt; b)</code> 等价于 <code>p</code> (同一性)</li>\n<li><code>p.bimap(a =&gt; f(g(a)), b =&gt; h(i(b)))</code> 等价于 <code>p.bimap(g, i).bimap(f, h)</code> (组合性)</li>\n</ol>\n<h3><code>bimap</code> 方法</h3>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">bimap</span> :: <span class=\"type\">Bifunctor</span> f =&gt; f a c ~&gt; (a -&gt; b, c -&gt; d) -&gt; f b d</span><br></pre></td></tr></table></figure></p>\n<p>具有 Bifunctor 的值必须提供 <code>bimap</code> 函数。<code>bimap</code> 函数接受两个参数：</p>\n<pre><code>c.bimap(f, g)\n</code></pre>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>bimap</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任意值</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>g</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>g</code> 不是函数，则 <code>bimap</code> 的行为未指定。</li>\n<li><code>g</code> 可以返回任意值\n3.<code>g</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>bimap</code> 必须返回相同 Bifunctor 的值。</li>\n</ol>\n<h3>Profunctor</h3>\n<p>实现 Profunctor 规范的值还必须实现 <a href=\"#functor\">Functor</a> 规范。</p>\n<ol>\n<li><code>p.promap(a =&gt; a, b =&gt; b)</code> 等价于 <code>p</code> (同一性)</li>\n<li><code>p.promap(a =&gt; f(g(a)), b =&gt; h(i(b)))</code> 等价于 <code>p.promap(f, i).promap(g, h)</code> (组合性)</li>\n</ol>\n<h4><code>promap</code> 方法</h4>\n<p><figure class=\"highlight hs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">promap</span> :: <span class=\"type\">Profunctor</span> p =&gt; p b c ~&gt; (a -&gt; b, c -&gt; d) -&gt; p a d</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><code>f</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>f</code> 不是函数，则 <code>promap</code> 的行为未指定。</li>\n<li><code>f</code> 可以返回任意值</li>\n<li><code>f</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>g</code> 必须是一个返回值的函数，\n<ol>\n<li>如果 <code>g</code> 不是函数，则 <code>promap</code> 的行为未指定。</li>\n<li><code>g</code> 可以返回任意值</li>\n<li><code>g</code> 返回值的任何部分都不应该被检查。</li>\n</ol>\n</li>\n<li><code>promap</code> 必须返回相同 Profunctor 的值。</li>\n</ol>\n<h2>推导</h2>\n<p>当创建满足多个代数的数据类型是，作者可以选择实现某些方法，然后推导出剩余的方法。推导：</p>\n<ul>\n<li>\n<p><a href=\"#code-equals-code-fang-fa\"><code>equals</code></a> 可以由 <a href=\"#code-lte-code-fang-fa\"><code>lte</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">other</span>) </span>&#123; retrun <span class=\"keyword\">this</span>.lte(other) &amp;&amp; other.lte(<span class=\"keyword\">this</span>) &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-ap-code-fang-fa\"><code>ap</code></a> 和 <a href=\"#code-of-code-fang-fa\"><code>of</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.ap(<span class=\"keyword\">this</span>.of(f))&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-chain-code-fang-fa\"><code>chain</code></a> 和 <a href=\"#code-of-code-fang-fa\"><code>of</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.chain(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> <span class=\"keyword\">this</span>.of(f(a))); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-bimap-code-fang-fa\"><code>bimap</code></a> 推导出 (??)：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.bimap(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a, f); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 可以由 <a href=\"#code-promap-code-fang-fa\"><code>promap</code></a> 推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.promap(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a, f); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-ap-code-fang-fa\"><code>ap</code></a> 可以由 <a href=\"#code-chain-code-fang-fa\"><code>chain</code></a> 推导出：\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>) </span>&#123; <span class=\"keyword\">return</span> m.chain(<span class=\"function\"><span class=\"params\">f</span> =&gt;</span> <span class=\"keyword\">this</span>.map(f)); &#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-reduce-code-fang-fa\"><code>reduce</code></a> 可以由下列推导出：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f, acc</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Const</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Const.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">\\_</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Const(acc);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Const.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">\\_</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Const.prototype.ap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Const(f(b.value, <span class=\"keyword\">this</span>.value));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.traverse(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"keyword\">new</span> Const(x), Const.of).value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-map-code-fang-fa\"><code>map</code></a> 的推导如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Id</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Id.of = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Id(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Id.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">f</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Id(f(b.value));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Id.prototype.ap = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Id(<span class=\"keyword\">this</span>.value(b.value));</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.traverse(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> Id.of(f(x)), Id.of).value;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-filter-code-fang-fa\"><code>filter</code></a> 可以由 <a href=\"#code-of-code-fang-fa\"><code>of</code></a>，<a href=\"#code-chain-code-fang-fa\"><code>chain</code></a> 和 <a href=\"#code-zero-code-fang-fa\"><code>zero</code></a> 推导出：\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pred</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"keyword\">this</span>.constructor;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.chain(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> pred(x) ? F.of(x) : F.zero());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p><a href=\"#code-filter-code-fang-fa\"><code>filter</code></a> 还可以由 <a href=\"#code-concat-code-fang-fa\"><code>concat</code></a>，<a href=\"#code-of-code-fang-fa\"><code>of</code></a>，<a href=\"#code-zero-code-fang-fa\"><code>zero</code></a> 和 <a href=\"#code-reduce-code-fang-fa\"><code>reduce</code></a>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">pred</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"keyword\">this</span>.constructor;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.reduce(<span class=\"function\">(<span class=\"params\">f, x</span>) =&gt;</span> pred(x) ? f.concat(F.of(x)) : f, F.zero());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<h2>注意</h2>\n<ol>\n<li>如果实现的方法和规则不止一种，应该选择一种实现，并为其他用途提供包装。</li>\n<li>我们不鼓励重载特定的方法。那样会很容易造成崩溃和错误的行为。</li>\n<li>建议对未指定的行为抛出异常。</li>\n<li>在 <a href=\"https://github.com/sanctuary-js/sanctuary-identity\" target=\"_blank\" rel=\"noopener\">sanctuary-identity</a> 中提供了一个实现了许多方法的 Id 容器。</li>\n</ol>\n<h2>备选方案</h2>\n<p>此外，还存在一个 Static Land 规范，其思想与 Fantasy Land 完全相同，但是是基于静态方法而非实例方法。</p>\n"},{"title":"Haskell: Type and TypeClass","date":"2017-10-15T03:52:43.000Z","_content":"\nWhat are typeclasses?\n\nTypeclasses define a set of functions that can have different implementations depending on the type of data they are given. \n","source":"_posts/Haskell-Type-and-TypeClass.md","raw":"---\ntitle: 'Haskell: Type and TypeClass'\ndate: 2017-10-15 11:52:43\ncategories: 'Haskell'\n---\n\nWhat are typeclasses?\n\nTypeclasses define a set of functions that can have different implementations depending on the type of data they are given. \n","slug":"Haskell-Type-and-TypeClass","published":1,"updated":"2020-06-06T14:44:04.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitb0006f6mjzf3ip3ha","content":"<p>What are typeclasses?</p>\n<p>Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>What are typeclasses?</p>\n<p>Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.</p>\n"},{"title":"Functor/Applicative/Monoid/Monad","date":"2016-11-19T05:31:25.000Z","_content":"## Applicative类 的定义\n\n```haskell\nclass (Functor f) => Applicative f where\n  pure :: a -> f a\n  (<*>) :: f (a -> b) -> f a -> f b\n```\n\nApplicative 中定义了 `pure` 和 `<*>`\n\n## Applicative Functor 的几个实例\n\n### Maybe\n```haskell\ninstance Applicative Maybe where\n  pure = Just\n  Nothing <*> _ = Nothing\n  (Just f) <*> something = fmap f something\n```\n\n### Applicative 相较于 Functor 的改进之处：\n\nwith the Applicative type class, we can chain the use of the <\\*> function, thus enabling us to seamlessly operate on several applicative values instead of just one. For instance, check this out:\n\n```haskell\npure(+) <*> Just 3 <*> Just 5 -- Just 8\n```\n\nlift 相当于 `pure`\n\n### Applicative 中还定义了 `<$>`\n\n<$> 相当于中缀版的 fmap，但应用于 Applicative 的链式调用特别方便\n\n```haskell\n(<$>) :: (Functor f) => (a -> b) -> f a -> f b\nf <$> x = fmap f x\n-- pure f <*> x <*> y <*> ... === fmap f x <*> y... === f <$> x <*> y...\n```\n\n### List 也是 Applicative Functor\n\n```haskell\ninstance Applicative [] where\n  pure x = [x]\n  fs <*> xs = [f x | f <- fs, x <- xs]\n```\n\n理解了 haskell 中 List 的 `<*>` 也就理解了 Ramda 中的 `liftN`\n将 fs 中的每个 f map 到 xs 中的每个 x。\n\n例如\n```haskell\nfs = [f1, f2, f3]\nxs = [x1, x2]\nfs <*> xs === [f1 x1, f1 f2, f2 x1, f2 x2, f3 x1, f3 x2]\n```\n\n### 函数 `(->) r` 也是 Applicative Functor 很有意思\n\n```haskell\nFunction :: ((->) r)\nFunction a = ((->) r) a \n           = r -> a\n```\n\n\n```haskell\ninstance Applicative ((->) r) where\n  pure x = (\\_ -> x)\n  f <*> g = \\x -> f x (g x)\n```\n\n```haskell\n(pure 3) \"blah\" -- 3\n(+) <$> (+3) <*> (*100) $ 5 -- 508\n```\n\n`<$>` + `<*>` 大致对标 Ramda 中的 converge\n\n## Laws\n\n### 1. [Functor Laws](https://en.wikibooks.org/wiki/Haskell/The_Functor_class)\n\n```haskell\nfmap id = id\nfmap (g . f) = fmap g . fmap f\n```\n\n### 2. [Applicative Functor Laws](https://en.wikibooks.org/wiki/Haskell/Applicative_functors)\n```haskell\npure id <*> v = v                             -- Identity\npure f <*> pure x = pure (f x)                -- Homomorphism\nu <*> pure y = pure ($ y) <*> u               -- Interchange\npure (.) <*> u <*> v <*> w = u <*> (v <*> w)  -- Composition\n```\na bonus law\n```\nfmap f x = pure f <*> x\n```\n\n### 3. [Monad Laws](https://wiki.haskell.org/Monad_laws)\n```haskell\nreturn a >>= k  =  k a\nm >>= return  =  m\nm >>= (x -> k x >>= h)  =  (m >>= k) >>= h\n```\n","source":"_posts/Functor-Applicative-Monoid-Monad.md","raw":"---\ntitle: Functor/Applicative/Monoid/Monad\ndate: 2016-11-19 13:31:25\ncategories: 'Haskell'\n---\n## Applicative类 的定义\n\n```haskell\nclass (Functor f) => Applicative f where\n  pure :: a -> f a\n  (<*>) :: f (a -> b) -> f a -> f b\n```\n\nApplicative 中定义了 `pure` 和 `<*>`\n\n## Applicative Functor 的几个实例\n\n### Maybe\n```haskell\ninstance Applicative Maybe where\n  pure = Just\n  Nothing <*> _ = Nothing\n  (Just f) <*> something = fmap f something\n```\n\n### Applicative 相较于 Functor 的改进之处：\n\nwith the Applicative type class, we can chain the use of the <\\*> function, thus enabling us to seamlessly operate on several applicative values instead of just one. For instance, check this out:\n\n```haskell\npure(+) <*> Just 3 <*> Just 5 -- Just 8\n```\n\nlift 相当于 `pure`\n\n### Applicative 中还定义了 `<$>`\n\n<$> 相当于中缀版的 fmap，但应用于 Applicative 的链式调用特别方便\n\n```haskell\n(<$>) :: (Functor f) => (a -> b) -> f a -> f b\nf <$> x = fmap f x\n-- pure f <*> x <*> y <*> ... === fmap f x <*> y... === f <$> x <*> y...\n```\n\n### List 也是 Applicative Functor\n\n```haskell\ninstance Applicative [] where\n  pure x = [x]\n  fs <*> xs = [f x | f <- fs, x <- xs]\n```\n\n理解了 haskell 中 List 的 `<*>` 也就理解了 Ramda 中的 `liftN`\n将 fs 中的每个 f map 到 xs 中的每个 x。\n\n例如\n```haskell\nfs = [f1, f2, f3]\nxs = [x1, x2]\nfs <*> xs === [f1 x1, f1 f2, f2 x1, f2 x2, f3 x1, f3 x2]\n```\n\n### 函数 `(->) r` 也是 Applicative Functor 很有意思\n\n```haskell\nFunction :: ((->) r)\nFunction a = ((->) r) a \n           = r -> a\n```\n\n\n```haskell\ninstance Applicative ((->) r) where\n  pure x = (\\_ -> x)\n  f <*> g = \\x -> f x (g x)\n```\n\n```haskell\n(pure 3) \"blah\" -- 3\n(+) <$> (+3) <*> (*100) $ 5 -- 508\n```\n\n`<$>` + `<*>` 大致对标 Ramda 中的 converge\n\n## Laws\n\n### 1. [Functor Laws](https://en.wikibooks.org/wiki/Haskell/The_Functor_class)\n\n```haskell\nfmap id = id\nfmap (g . f) = fmap g . fmap f\n```\n\n### 2. [Applicative Functor Laws](https://en.wikibooks.org/wiki/Haskell/Applicative_functors)\n```haskell\npure id <*> v = v                             -- Identity\npure f <*> pure x = pure (f x)                -- Homomorphism\nu <*> pure y = pure ($ y) <*> u               -- Interchange\npure (.) <*> u <*> v <*> w = u <*> (v <*> w)  -- Composition\n```\na bonus law\n```\nfmap f x = pure f <*> x\n```\n\n### 3. [Monad Laws](https://wiki.haskell.org/Monad_laws)\n```haskell\nreturn a >>= k  =  k a\nm >>= return  =  m\nm >>= (x -> k x >>= h)  =  (m >>= k) >>= h\n```\n","slug":"Functor-Applicative-Monoid-Monad","published":1,"updated":"2020-06-06T14:44:04.085Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitc0008f6mj69i7v4sg","content":"<h2>Applicative类 的定义</h2>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> (<span class=\"type\">Functor</span> <span class=\"title\">f</span>) =&gt; <span class=\"type\">Applicative</span> f <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure :: a -&gt; f a</span><br><span class=\"line\">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>Applicative 中定义了 <code>pure</code> 和 <code>&lt;*&gt;</code></p>\n<h2>Applicative Functor 的几个实例</h2>\n<h3>Maybe</h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> <span class=\"type\">Maybe</span> <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure = <span class=\"type\">Just</span></span><br><span class=\"line\">  <span class=\"type\">Nothing</span> &lt;*&gt; _ = <span class=\"type\">Nothing</span></span><br><span class=\"line\">  (<span class=\"type\">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure></p>\n<h3>Applicative 相较于 Functor 的改进之处：</h3>\n<p>with the Applicative type class, we can chain the use of the &lt;*&gt; function, thus enabling us to seamlessly operate on several applicative values instead of just one. For instance, check this out:</p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">pure</span>(+) &lt;*&gt; <span class=\"type\">Just</span> <span class=\"number\">3</span> &lt;*&gt; <span class=\"type\">Just</span> <span class=\"number\">5</span> <span class=\"comment\">-- Just 8</span></span><br></pre></td></tr></table></figure></p>\n<p>lift 相当于 <code>pure</code></p>\n<h3>Applicative 中还定义了 <code>&lt;$&gt;</code></h3>\n<p>&lt;$&gt; 相当于中缀版的 fmap，但应用于 Applicative 的链式调用特别方便</p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&lt;$&gt;) :: (<span class=\"type\">Functor</span> f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class=\"line\"><span class=\"title\">f</span> &lt;$&gt; x = fmap f x</span><br><span class=\"line\"><span class=\"comment\">-- pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ... === fmap f x &lt;*&gt; y... === f &lt;$&gt; x &lt;*&gt; y...</span></span><br></pre></td></tr></table></figure></p>\n<h3>List 也是 Applicative Functor</h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> [] <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure x = [x]</span><br><span class=\"line\">  fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure></p>\n<p>理解了 haskell 中 List 的 <code>&lt;*&gt;</code> 也就理解了 Ramda 中的 <code>liftN</code>\n将 fs 中的每个 f map 到 xs 中的每个 x。</p>\n<p>例如\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fs</span> = [f1, f2, f3]</span><br><span class=\"line\"><span class=\"title\">xs</span> = [x1, x2]</span><br><span class=\"line\"><span class=\"title\">fs</span> &lt;*&gt; xs === [f1 x1, f1 f2, f2 x1, f2 x2, f3 x1, f3 x2]</span><br></pre></td></tr></table></figure></p>\n<h3>函数 <code>(-&gt;) r</code> 也是 Applicative Functor 很有意思</h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Function</span> :: ((-&gt;) r)</span><br><span class=\"line\"><span class=\"type\">Function</span> a = ((-&gt;) r) a </span><br><span class=\"line\">           = r -&gt; a</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure x = (\\_ -&gt; x)</span><br><span class=\"line\">  f &lt;*&gt; g = \\x -&gt; f x (g x)</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(pure <span class=\"number\">3</span>) <span class=\"string\">\"blah\"</span> <span class=\"comment\">-- 3</span></span><br><span class=\"line\">(+) &lt;$&gt; (+<span class=\"number\">3</span>) &lt;*&gt; (*<span class=\"number\">100</span>) $ <span class=\"number\">5</span> <span class=\"comment\">-- 508</span></span><br></pre></td></tr></table></figure></p>\n<p><code>&lt;$&gt;</code> + <code>&lt;*&gt;</code> 大致对标 Ramda 中的 converge</p>\n<h2>Laws</h2>\n<h3>1. <a href=\"https://en.wikibooks.org/wiki/Haskell/The_Functor_class\" target=\"_blank\" rel=\"noopener\">Functor Laws</a></h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fmap</span> id = id</span><br><span class=\"line\"><span class=\"title\">fmap</span> (g . f) = fmap g . fmap f</span><br></pre></td></tr></table></figure></p>\n<h3>2. <a href=\"https://en.wikibooks.org/wiki/Haskell/Applicative_functors\" target=\"_blank\" rel=\"noopener\">Applicative Functor Laws</a></h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">pure</span> id &lt;*&gt; v = v                             <span class=\"comment\">-- Identity</span></span><br><span class=\"line\"><span class=\"title\">pure</span> f &lt;*&gt; pure x = pure (f x)                <span class=\"comment\">-- Homomorphism</span></span><br><span class=\"line\"><span class=\"title\">u</span> &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u               <span class=\"comment\">-- Interchange</span></span><br><span class=\"line\"><span class=\"title\">pure</span> (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)  <span class=\"comment\">-- Composition</span></span><br></pre></td></tr></table></figure></p>\n<p>a bonus law\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmap f x = pure f &lt;*&gt; x</span><br></pre></td></tr></table></figure></p>\n<h3>3. <a href=\"https://wiki.haskell.org/Monad_laws\" target=\"_blank\" rel=\"noopener\">Monad Laws</a></h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">return</span> a &gt;&gt;= k  =  k a</span><br><span class=\"line\"><span class=\"title\">m</span> &gt;&gt;= return  =  m</span><br><span class=\"line\"><span class=\"title\">m</span> &gt;&gt;= (x -&gt; k x &gt;&gt;= h)  =  (m &gt;&gt;= k) &gt;&gt;= h</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>Applicative类 的定义</h2>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> (<span class=\"type\">Functor</span> <span class=\"title\">f</span>) =&gt; <span class=\"type\">Applicative</span> f <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure :: a -&gt; f a</span><br><span class=\"line\">  (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure></p>\n<p>Applicative 中定义了 <code>pure</code> 和 <code>&lt;*&gt;</code></p>\n<h2>Applicative Functor 的几个实例</h2>\n<h3>Maybe</h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> <span class=\"type\">Maybe</span> <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure = <span class=\"type\">Just</span></span><br><span class=\"line\">  <span class=\"type\">Nothing</span> &lt;*&gt; _ = <span class=\"type\">Nothing</span></span><br><span class=\"line\">  (<span class=\"type\">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure></p>\n<h3>Applicative 相较于 Functor 的改进之处：</h3>\n<p>with the Applicative type class, we can chain the use of the &lt;*&gt; function, thus enabling us to seamlessly operate on several applicative values instead of just one. For instance, check this out:</p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">pure</span>(+) &lt;*&gt; <span class=\"type\">Just</span> <span class=\"number\">3</span> &lt;*&gt; <span class=\"type\">Just</span> <span class=\"number\">5</span> <span class=\"comment\">-- Just 8</span></span><br></pre></td></tr></table></figure></p>\n<p>lift 相当于 <code>pure</code></p>\n<h3>Applicative 中还定义了 <code>&lt;$&gt;</code></h3>\n<p>&lt;$&gt; 相当于中缀版的 fmap，但应用于 Applicative 的链式调用特别方便</p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(&lt;$&gt;) :: (<span class=\"type\">Functor</span> f) =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class=\"line\"><span class=\"title\">f</span> &lt;$&gt; x = fmap f x</span><br><span class=\"line\"><span class=\"comment\">-- pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ... === fmap f x &lt;*&gt; y... === f &lt;$&gt; x &lt;*&gt; y...</span></span><br></pre></td></tr></table></figure></p>\n<h3>List 也是 Applicative Functor</h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> [] <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure x = [x]</span><br><span class=\"line\">  fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure></p>\n<p>理解了 haskell 中 List 的 <code>&lt;*&gt;</code> 也就理解了 Ramda 中的 <code>liftN</code>\n将 fs 中的每个 f map 到 xs 中的每个 x。</p>\n<p>例如\n<figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fs</span> = [f1, f2, f3]</span><br><span class=\"line\"><span class=\"title\">xs</span> = [x1, x2]</span><br><span class=\"line\"><span class=\"title\">fs</span> &lt;*&gt; xs === [f1 x1, f1 f2, f2 x1, f2 x2, f3 x1, f3 x2]</span><br></pre></td></tr></table></figure></p>\n<h3>函数 <code>(-&gt;) r</code> 也是 Applicative Functor 很有意思</h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Function</span> :: ((-&gt;) r)</span><br><span class=\"line\"><span class=\"type\">Function</span> a = ((-&gt;) r) a </span><br><span class=\"line\">           = r -&gt; a</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">  pure x = (\\_ -&gt; x)</span><br><span class=\"line\">  f &lt;*&gt; g = \\x -&gt; f x (g x)</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(pure <span class=\"number\">3</span>) <span class=\"string\">\"blah\"</span> <span class=\"comment\">-- 3</span></span><br><span class=\"line\">(+) &lt;$&gt; (+<span class=\"number\">3</span>) &lt;*&gt; (*<span class=\"number\">100</span>) $ <span class=\"number\">5</span> <span class=\"comment\">-- 508</span></span><br></pre></td></tr></table></figure></p>\n<p><code>&lt;$&gt;</code> + <code>&lt;*&gt;</code> 大致对标 Ramda 中的 converge</p>\n<h2>Laws</h2>\n<h3>1. <a href=\"https://en.wikibooks.org/wiki/Haskell/The_Functor_class\" target=\"_blank\" rel=\"noopener\">Functor Laws</a></h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">fmap</span> id = id</span><br><span class=\"line\"><span class=\"title\">fmap</span> (g . f) = fmap g . fmap f</span><br></pre></td></tr></table></figure></p>\n<h3>2. <a href=\"https://en.wikibooks.org/wiki/Haskell/Applicative_functors\" target=\"_blank\" rel=\"noopener\">Applicative Functor Laws</a></h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">pure</span> id &lt;*&gt; v = v                             <span class=\"comment\">-- Identity</span></span><br><span class=\"line\"><span class=\"title\">pure</span> f &lt;*&gt; pure x = pure (f x)                <span class=\"comment\">-- Homomorphism</span></span><br><span class=\"line\"><span class=\"title\">u</span> &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u               <span class=\"comment\">-- Interchange</span></span><br><span class=\"line\"><span class=\"title\">pure</span> (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)  <span class=\"comment\">-- Composition</span></span><br></pre></td></tr></table></figure></p>\n<p>a bonus law\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fmap f x = pure f &lt;*&gt; x</span><br></pre></td></tr></table></figure></p>\n<h3>3. <a href=\"https://wiki.haskell.org/Monad_laws\" target=\"_blank\" rel=\"noopener\">Monad Laws</a></h3>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title\">return</span> a &gt;&gt;= k  =  k a</span><br><span class=\"line\"><span class=\"title\">m</span> &gt;&gt;= return  =  m</span><br><span class=\"line\"><span class=\"title\">m</span> &gt;&gt;= (x -&gt; k x &gt;&gt;= h)  =  (m &gt;&gt;= k) &gt;&gt;= h</span><br></pre></td></tr></table></figure></p>\n"},{"title":"函数式编程中的“函数们”","date":"2017-12-04T00:30:46.000Z","_content":"\n函数式编程中的函数有三种不同的解读方式，分别为纯函数、高阶函数和一等函数。本文分别对这三者的概念、应用和联系进行详解。\n\n# 纯函数\n\n定义：\n\n> 1. 相同的输入必定产生相同的输出；\n> 2. 在计算的过程中，不会产生副作用。\n\n满足上述两个条件，我们就说该函数是纯函数。\n\n纯函数也即数学意义上的函数，表达的是数据之间的转换（映射）关系，而非计算步骤的详述。数学函数的定义：\n\n> 函数通常由定义域 *X* 、值域 *Y* 以及定义域到值域的映射 *f* （*f: X -> Y*）组成。\n\n![function](./function.png)\n\n纯函数让我们对写出的函数具有完全的控制能力。纯函数的结果 **必须** 只依赖于输入参数，不受外部环境的影响；同时纯函数在计算结果的过程中，也不会影响（污染）外部环境，即不会产生副作用。\n\n## 函数组合\n\n纯函数定义中的两个条件保证了它（的计算过程）与外界是完全隔离，这也是函数组合的基础。\n\n只有函数组合中的所有函数都是纯函数，我们组合起来的新函数才会是纯函数。我们可以对使用纯函数组合出来的新函数从数学上证明（推导）其正确性，而无需借助大量的单元测试。\n\n只要在函数组合时引入一个非纯函数，整个组合出来的函数将沦为非纯函数。如果将函数组合比作管道的拼接，只要组成管道的任何一小节有泄露或者外部注入，我们便失去了对整条管道的完全控制。\n\n![pipeline-leaking](./pipeline-leaking.png)\n\n要想实现函数组合，还需要满足连续性，描述如下：\n\n因为纯函数可以看作定义域到值域映射，待组合的函数中的上一个函数的值域须等于下一个函数的定义域，也即上一个函数的输出（类型）等于下一个的输入（类型）。\n\n假设有两个函数：*f: X -> Y* 和 *g: Y -> Z*，只有 `codomain(f) = domain(g)` 时，*f* 和 *g* 才可以组合。\n\n![function_composition](./functions_composition.png)\n\n## 引用透明及缓存\n\n在不改变整个程序行为的情况下，如果能将其中的一段代码替换为其执行的结果，我们就说这段代码是引用透明的。\n\n因此，执行一段引用透明的代码（函数），对于相同的参数，总是给出相同的结果。我们也称这样的函数（代码）为纯函数。\n\n引用透明的一个典型应用即函数缓存。我们可以将已经执行过的函数输入值缓存起来，下次调用时，若输入值相同，直接跳过计算过程，用缓存结果代替计算结果返回即可。\n\n函数缓存的实现依赖于闭包，而闭包的实现又依赖于高阶函数，高阶函数的实现又依赖于一等函数。我们按照这条依赖链，从里往外依次对它们进行讲解。\n\n# 一等函数（First Class Functions）\n\n程序语言会对基本元素的使用方式进行限制，带有最少限制的元素被称为一等公民，其拥有的 “权利” 如下：\n\n> - 可以使用变量命名；\n> - 可以提供给函数作为参数；\n> - 可以由函数作为结果返回；\n> - 可以包含在数据结构中；\n\n乍一看，我们应该首先会想到程序中的基本数据结构（如 number、array、object 等）是一等公民。如果函数也被视为一等公民，我们便可以像使用普通数据一样对其使用变量命名，作为参数或返回值使用，或者将其包含在数据结构中。在这里函数和数据的边界开始变得不再那么分明了。函数被视为一等公民后，其能力和适用范围被大大扩展了。\n\n下面使用 JavaScript 对上面第一条和第四条 “权利” 进行讲解。第二、三条与高阶函数密切相关，将放到下一节的高阶函数中讲解。\n\n## 使用变量命名\n\n```js\nconst square = x => x * x\n```\n\n上面代码定义了一个求平方值的函数，并将其赋给了 square 变量。\n\n## 可以包含在数据结构中\n\n[Ramda](http://ramda.cn/) 中有一个API：[evolve](http://ramda.cn/docs/#evolve)，其接受的首个参数便是一个属性值为函数的对象。[evolve](http://ramda.cn/docs/#evolve) 函数会递归地对 \"待处理对象\" 的属性进行变换，变换的方式由 transformation 内置函数属性值的对象定义。示例如下（示例中的 `R.xxx` 都是 [Ramda](http://ramda.cn/docs/) 中的API，相关API的功能可以参考[Ramda](http://ramda.cn/docs/)文档）：\n\n```js\nvar tomato  = {name: 'Tomato', data: {elapsed: 100, remaining: 1400}, id:123};\nvar transformations = {\n  name: R.toUpper,\n  data: {elapsed: R.add(1), remaining: R.add(-1)}\n};\n\nR.evolve(transformations)(tomato);\n//=> {name: 'TOMATO', data: {elapsed: 101, remaining: 1399}, id:123}\n```\n\n# 高阶函数\n\n定义：\n\n> 使用函数作为输入参数，或者返回结果为函数的函数，被称为高阶函数。\n\n作为参数或返回值的函数，是一等函数的应用之一。高阶函数以一等函数作为基础，只有支持一等函数的语言才能进行高阶函数编程。\n\n以熟悉的 [filter](http://ramda.cn/docs/#filter) 函数为例，我们可以用 [filter](http://ramda.cn/docs/#filter) 对列表中的元素进行过滤，筛选出符合条件的元素。[filter](http://ramda.cn/docs/#filter) 的类型签名和示例代码如下：\n\n```js\nfilter :: (a → Boolean) → [a] → [a]\n```\n\n```js\nconst isEven = n => n % 2 === 0;\n\nconst filterEven = R.filter(isEven);\n\nfilterEven([1, 2, 3, 4]); //=> [2, 4]\n```\n\n[filter](http://ramda.cn/docs/#filter) 接受一个判断函数（判断输入值是否为偶数）`isEven`，返回一个过滤出偶数的函数 `filterEven`。\n\n# 闭包\n\n定义：\n\n> 闭包是由函数及该函数捕获的其上下文中的自由变量组成的记录\n\n举例讲：\n\n```js\nfunction add(x) {\n  const xIn = x;\n  return function addInner(y) {\n    return xIn + y;\n  }\n}\nconst inc = add(1);\ninc(8); //=> 9;\n\nconst plus2 = add(2);\nplus2(8); //=> 10;\n```\n\n上述代码中返回的函数 `addInner` 及由其捕获的在其上下文中定义的自由变量 `xIn`，便组成了一个闭包。\n\n![closure](./closure.png)\n\n上述代码中最外层的 `add` 函数是一个高阶函数，其返回值为一等函数 `addInner`。\n\n其实 `add` 函数的参数 `x` 也是 `addInner` 上下文的一部分，所以 'xIn' 也就没有存在的必要了，`add` 代码优化如下：\n\n```js\nfunction add(x) {\n  return function addInner(y) {\n    return x + y;\n  }\n}\n```\n\n借助于箭头函数，我们可以进一步优化 `add` 的实现：\n\n```js\nconst add = x => y => x + y\n```\n\n是不是非常简洁？由此我们可以一窥函数式编程强大的表达能力。\n\n闭包主要用来做数据缓存，而数据缓存应用非常广泛：包括函数工厂模式、模拟拥有私有变量的对象、函数缓存、还有大名鼎鼎的柯里化。\n\n其实上述代码中 `add` 函数便是柯里化形式的函数。\n\n上述代码中的 `const inc = add(1);` 和 `const plus2 = add(2);` 是一种函数工厂模式，通过向 `add` 函数传入不同的参数，便会产生功能不同的函数。函数工厂可以提高函数的抽象和复用能力。\n\n例如我们有一个如下形式的 Ajax 请求函数：\n\n```js\nconst ajax = method => type => query => { ... };\n\nconst get = ajax('GET');\nconst post = ajax('POST');\n\nconst getJson = get('json');\nconst getHtml = ajax('GET')('text/html') = get('text/html');\n```\n\n我们抽象出了最一般的 `ajax` 请求函数，在具体应用时，我们用能通过函数工厂生产出作用不同的函数。\n\n通过上面几个小节，我们讲解了纯函数（数学意义上的函数）、一等函数、高阶函数，还有闭包。\n\n下面通过一个集上述所有概念于一身的 **函数缓存** ，来结束函数式编程中的 “函数们” 的论述。\n\n# 函数缓存 memoize\n\n函数实现：\n\n```js\nconst memoize = pureFunc => {\n  const cache = {};\n  return function() {\n    const argStr = JSON.stringify(arguments);\n    cache[argStr] = cache[argStr] || pureFunc.apply(pureFunc, arguments);\n    return cache[argStr];\n  };\n};\n```\n\n`memoize` 的功能是对传入函数 `pureFunc` 进行缓存，返回缓存版本的 `pureFunc`。当我们使用参数调用缓存的函数时，缓存的函数会到 `cache` 中查找该参数是否被缓存过，如果有缓存，则不需要再次计算，直接返回已缓存值，否则对本次输入的参数进行计算，缓存计算的结果以备后用，然后将结果返回。\n\n`memoize` 只有对纯函数的缓存才有意义。因为纯函数是引用透明的，其输出只依赖于输入，并且计算过程不会影响外部环境。\n\n举一个极端的例子，假如我们有一个随机数字生成函数 `random()`, 如果对其进行了缓存：\n\n```js\nconst memoizedRandom = memoize(random);\n```\n\n`memoizedRandom` 除了第一次生成一个随机值外，随后的调用都返回第一次缓存的值，这样就失去了 `random` 的意义。再假如，我们对终端字符输入函数 `getchar()` 进行了缓存，每次调用都会是第一次获取的字母。\n\n`memoize` 内部实现了一个闭包的创建。返回的缓存函数和自由变量 `cache` 共同构成了一个闭包。自由变量 `cached` 用于对已经计算过的数据（参数）的缓存。而闭包本身是由高阶函数和一等函数实现的。\n\n![functions-in-memoize](./functions-in-memoize.png)\n\n# 总结\n\n本文对函数式编程中的 “函数们” 做了详细解释：纯函数、一等函数、高阶函数，并展示了它们的应用。其中纯函数是函数组合的基础；一等函数是高阶函数的实现基础，一等函数和高阶函数又是闭包的实现基础。\n\n最后通过函数缓存函数 `memoize` 将纯函数、一等函数、高阶函数和闭包联系了起来，用函数式编程中的 “函数们” （函数式三镖客）的一次 “联合行动” 结束本文。\n\n# 参考文档\n\n[What is a Function?](http://www.mathsisfun.com/sets/function.html).\n\n[Functional Programming](https://en.wikipedia.org/wiki/Functional_programming).\n\n[Referential Transparency](https://en.wikipedia.org/wiki/Referential_transparency).\n","source":"_posts/Functions-in-Functional-Programming.md","raw":"---\ntitle: 函数式编程中的“函数们”\ndate: 2017-12-04 08:30:46\ntags:\n---\n\n函数式编程中的函数有三种不同的解读方式，分别为纯函数、高阶函数和一等函数。本文分别对这三者的概念、应用和联系进行详解。\n\n# 纯函数\n\n定义：\n\n> 1. 相同的输入必定产生相同的输出；\n> 2. 在计算的过程中，不会产生副作用。\n\n满足上述两个条件，我们就说该函数是纯函数。\n\n纯函数也即数学意义上的函数，表达的是数据之间的转换（映射）关系，而非计算步骤的详述。数学函数的定义：\n\n> 函数通常由定义域 *X* 、值域 *Y* 以及定义域到值域的映射 *f* （*f: X -> Y*）组成。\n\n![function](./function.png)\n\n纯函数让我们对写出的函数具有完全的控制能力。纯函数的结果 **必须** 只依赖于输入参数，不受外部环境的影响；同时纯函数在计算结果的过程中，也不会影响（污染）外部环境，即不会产生副作用。\n\n## 函数组合\n\n纯函数定义中的两个条件保证了它（的计算过程）与外界是完全隔离，这也是函数组合的基础。\n\n只有函数组合中的所有函数都是纯函数，我们组合起来的新函数才会是纯函数。我们可以对使用纯函数组合出来的新函数从数学上证明（推导）其正确性，而无需借助大量的单元测试。\n\n只要在函数组合时引入一个非纯函数，整个组合出来的函数将沦为非纯函数。如果将函数组合比作管道的拼接，只要组成管道的任何一小节有泄露或者外部注入，我们便失去了对整条管道的完全控制。\n\n![pipeline-leaking](./pipeline-leaking.png)\n\n要想实现函数组合，还需要满足连续性，描述如下：\n\n因为纯函数可以看作定义域到值域映射，待组合的函数中的上一个函数的值域须等于下一个函数的定义域，也即上一个函数的输出（类型）等于下一个的输入（类型）。\n\n假设有两个函数：*f: X -> Y* 和 *g: Y -> Z*，只有 `codomain(f) = domain(g)` 时，*f* 和 *g* 才可以组合。\n\n![function_composition](./functions_composition.png)\n\n## 引用透明及缓存\n\n在不改变整个程序行为的情况下，如果能将其中的一段代码替换为其执行的结果，我们就说这段代码是引用透明的。\n\n因此，执行一段引用透明的代码（函数），对于相同的参数，总是给出相同的结果。我们也称这样的函数（代码）为纯函数。\n\n引用透明的一个典型应用即函数缓存。我们可以将已经执行过的函数输入值缓存起来，下次调用时，若输入值相同，直接跳过计算过程，用缓存结果代替计算结果返回即可。\n\n函数缓存的实现依赖于闭包，而闭包的实现又依赖于高阶函数，高阶函数的实现又依赖于一等函数。我们按照这条依赖链，从里往外依次对它们进行讲解。\n\n# 一等函数（First Class Functions）\n\n程序语言会对基本元素的使用方式进行限制，带有最少限制的元素被称为一等公民，其拥有的 “权利” 如下：\n\n> - 可以使用变量命名；\n> - 可以提供给函数作为参数；\n> - 可以由函数作为结果返回；\n> - 可以包含在数据结构中；\n\n乍一看，我们应该首先会想到程序中的基本数据结构（如 number、array、object 等）是一等公民。如果函数也被视为一等公民，我们便可以像使用普通数据一样对其使用变量命名，作为参数或返回值使用，或者将其包含在数据结构中。在这里函数和数据的边界开始变得不再那么分明了。函数被视为一等公民后，其能力和适用范围被大大扩展了。\n\n下面使用 JavaScript 对上面第一条和第四条 “权利” 进行讲解。第二、三条与高阶函数密切相关，将放到下一节的高阶函数中讲解。\n\n## 使用变量命名\n\n```js\nconst square = x => x * x\n```\n\n上面代码定义了一个求平方值的函数，并将其赋给了 square 变量。\n\n## 可以包含在数据结构中\n\n[Ramda](http://ramda.cn/) 中有一个API：[evolve](http://ramda.cn/docs/#evolve)，其接受的首个参数便是一个属性值为函数的对象。[evolve](http://ramda.cn/docs/#evolve) 函数会递归地对 \"待处理对象\" 的属性进行变换，变换的方式由 transformation 内置函数属性值的对象定义。示例如下（示例中的 `R.xxx` 都是 [Ramda](http://ramda.cn/docs/) 中的API，相关API的功能可以参考[Ramda](http://ramda.cn/docs/)文档）：\n\n```js\nvar tomato  = {name: 'Tomato', data: {elapsed: 100, remaining: 1400}, id:123};\nvar transformations = {\n  name: R.toUpper,\n  data: {elapsed: R.add(1), remaining: R.add(-1)}\n};\n\nR.evolve(transformations)(tomato);\n//=> {name: 'TOMATO', data: {elapsed: 101, remaining: 1399}, id:123}\n```\n\n# 高阶函数\n\n定义：\n\n> 使用函数作为输入参数，或者返回结果为函数的函数，被称为高阶函数。\n\n作为参数或返回值的函数，是一等函数的应用之一。高阶函数以一等函数作为基础，只有支持一等函数的语言才能进行高阶函数编程。\n\n以熟悉的 [filter](http://ramda.cn/docs/#filter) 函数为例，我们可以用 [filter](http://ramda.cn/docs/#filter) 对列表中的元素进行过滤，筛选出符合条件的元素。[filter](http://ramda.cn/docs/#filter) 的类型签名和示例代码如下：\n\n```js\nfilter :: (a → Boolean) → [a] → [a]\n```\n\n```js\nconst isEven = n => n % 2 === 0;\n\nconst filterEven = R.filter(isEven);\n\nfilterEven([1, 2, 3, 4]); //=> [2, 4]\n```\n\n[filter](http://ramda.cn/docs/#filter) 接受一个判断函数（判断输入值是否为偶数）`isEven`，返回一个过滤出偶数的函数 `filterEven`。\n\n# 闭包\n\n定义：\n\n> 闭包是由函数及该函数捕获的其上下文中的自由变量组成的记录\n\n举例讲：\n\n```js\nfunction add(x) {\n  const xIn = x;\n  return function addInner(y) {\n    return xIn + y;\n  }\n}\nconst inc = add(1);\ninc(8); //=> 9;\n\nconst plus2 = add(2);\nplus2(8); //=> 10;\n```\n\n上述代码中返回的函数 `addInner` 及由其捕获的在其上下文中定义的自由变量 `xIn`，便组成了一个闭包。\n\n![closure](./closure.png)\n\n上述代码中最外层的 `add` 函数是一个高阶函数，其返回值为一等函数 `addInner`。\n\n其实 `add` 函数的参数 `x` 也是 `addInner` 上下文的一部分，所以 'xIn' 也就没有存在的必要了，`add` 代码优化如下：\n\n```js\nfunction add(x) {\n  return function addInner(y) {\n    return x + y;\n  }\n}\n```\n\n借助于箭头函数，我们可以进一步优化 `add` 的实现：\n\n```js\nconst add = x => y => x + y\n```\n\n是不是非常简洁？由此我们可以一窥函数式编程强大的表达能力。\n\n闭包主要用来做数据缓存，而数据缓存应用非常广泛：包括函数工厂模式、模拟拥有私有变量的对象、函数缓存、还有大名鼎鼎的柯里化。\n\n其实上述代码中 `add` 函数便是柯里化形式的函数。\n\n上述代码中的 `const inc = add(1);` 和 `const plus2 = add(2);` 是一种函数工厂模式，通过向 `add` 函数传入不同的参数，便会产生功能不同的函数。函数工厂可以提高函数的抽象和复用能力。\n\n例如我们有一个如下形式的 Ajax 请求函数：\n\n```js\nconst ajax = method => type => query => { ... };\n\nconst get = ajax('GET');\nconst post = ajax('POST');\n\nconst getJson = get('json');\nconst getHtml = ajax('GET')('text/html') = get('text/html');\n```\n\n我们抽象出了最一般的 `ajax` 请求函数，在具体应用时，我们用能通过函数工厂生产出作用不同的函数。\n\n通过上面几个小节，我们讲解了纯函数（数学意义上的函数）、一等函数、高阶函数，还有闭包。\n\n下面通过一个集上述所有概念于一身的 **函数缓存** ，来结束函数式编程中的 “函数们” 的论述。\n\n# 函数缓存 memoize\n\n函数实现：\n\n```js\nconst memoize = pureFunc => {\n  const cache = {};\n  return function() {\n    const argStr = JSON.stringify(arguments);\n    cache[argStr] = cache[argStr] || pureFunc.apply(pureFunc, arguments);\n    return cache[argStr];\n  };\n};\n```\n\n`memoize` 的功能是对传入函数 `pureFunc` 进行缓存，返回缓存版本的 `pureFunc`。当我们使用参数调用缓存的函数时，缓存的函数会到 `cache` 中查找该参数是否被缓存过，如果有缓存，则不需要再次计算，直接返回已缓存值，否则对本次输入的参数进行计算，缓存计算的结果以备后用，然后将结果返回。\n\n`memoize` 只有对纯函数的缓存才有意义。因为纯函数是引用透明的，其输出只依赖于输入，并且计算过程不会影响外部环境。\n\n举一个极端的例子，假如我们有一个随机数字生成函数 `random()`, 如果对其进行了缓存：\n\n```js\nconst memoizedRandom = memoize(random);\n```\n\n`memoizedRandom` 除了第一次生成一个随机值外，随后的调用都返回第一次缓存的值，这样就失去了 `random` 的意义。再假如，我们对终端字符输入函数 `getchar()` 进行了缓存，每次调用都会是第一次获取的字母。\n\n`memoize` 内部实现了一个闭包的创建。返回的缓存函数和自由变量 `cache` 共同构成了一个闭包。自由变量 `cached` 用于对已经计算过的数据（参数）的缓存。而闭包本身是由高阶函数和一等函数实现的。\n\n![functions-in-memoize](./functions-in-memoize.png)\n\n# 总结\n\n本文对函数式编程中的 “函数们” 做了详细解释：纯函数、一等函数、高阶函数，并展示了它们的应用。其中纯函数是函数组合的基础；一等函数是高阶函数的实现基础，一等函数和高阶函数又是闭包的实现基础。\n\n最后通过函数缓存函数 `memoize` 将纯函数、一等函数、高阶函数和闭包联系了起来，用函数式编程中的 “函数们” （函数式三镖客）的一次 “联合行动” 结束本文。\n\n# 参考文档\n\n[What is a Function?](http://www.mathsisfun.com/sets/function.html).\n\n[Functional Programming](https://en.wikipedia.org/wiki/Functional_programming).\n\n[Referential Transparency](https://en.wikipedia.org/wiki/Referential_transparency).\n","slug":"Functions-in-Functional-Programming","published":1,"updated":"2020-06-06T14:44:04.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfite0009f6mjfn9vb8f1","content":"<p>函数式编程中的函数有三种不同的解读方式，分别为纯函数、高阶函数和一等函数。本文分别对这三者的概念、应用和联系进行详解。</p>\n<h1>纯函数</h1>\n<p>定义：</p>\n<blockquote>\n<ol>\n<li>相同的输入必定产生相同的输出；</li>\n<li>在计算的过程中，不会产生副作用。</li>\n</ol>\n</blockquote>\n<p>满足上述两个条件，我们就说该函数是纯函数。</p>\n<p>纯函数也即数学意义上的函数，表达的是数据之间的转换（映射）关系，而非计算步骤的详述。数学函数的定义：</p>\n<blockquote>\n<p>函数通常由定义域 <em>X</em> 、值域 <em>Y</em> 以及定义域到值域的映射 <em>f</em> （<em>f: X -&gt; Y</em>）组成。</p>\n</blockquote>\n<p><img src=\"./function.png\" alt=\"function\"></p>\n<p>纯函数让我们对写出的函数具有完全的控制能力。纯函数的结果 <strong>必须</strong> 只依赖于输入参数，不受外部环境的影响；同时纯函数在计算结果的过程中，也不会影响（污染）外部环境，即不会产生副作用。</p>\n<h2>函数组合</h2>\n<p>纯函数定义中的两个条件保证了它（的计算过程）与外界是完全隔离，这也是函数组合的基础。</p>\n<p>只有函数组合中的所有函数都是纯函数，我们组合起来的新函数才会是纯函数。我们可以对使用纯函数组合出来的新函数从数学上证明（推导）其正确性，而无需借助大量的单元测试。</p>\n<p>只要在函数组合时引入一个非纯函数，整个组合出来的函数将沦为非纯函数。如果将函数组合比作管道的拼接，只要组成管道的任何一小节有泄露或者外部注入，我们便失去了对整条管道的完全控制。</p>\n<p><img src=\"./pipeline-leaking.png\" alt=\"pipeline-leaking\"></p>\n<p>要想实现函数组合，还需要满足连续性，描述如下：</p>\n<p>因为纯函数可以看作定义域到值域映射，待组合的函数中的上一个函数的值域须等于下一个函数的定义域，也即上一个函数的输出（类型）等于下一个的输入（类型）。</p>\n<p>假设有两个函数：<em>f: X -&gt; Y</em> 和 <em>g: Y -&gt; Z</em>，只有 <code>codomain(f) = domain(g)</code> 时，<em>f</em> 和 <em>g</em> 才可以组合。</p>\n<p><img src=\"./functions_composition.png\" alt=\"function_composition\"></p>\n<h2>引用透明及缓存</h2>\n<p>在不改变整个程序行为的情况下，如果能将其中的一段代码替换为其执行的结果，我们就说这段代码是引用透明的。</p>\n<p>因此，执行一段引用透明的代码（函数），对于相同的参数，总是给出相同的结果。我们也称这样的函数（代码）为纯函数。</p>\n<p>引用透明的一个典型应用即函数缓存。我们可以将已经执行过的函数输入值缓存起来，下次调用时，若输入值相同，直接跳过计算过程，用缓存结果代替计算结果返回即可。</p>\n<p>函数缓存的实现依赖于闭包，而闭包的实现又依赖于高阶函数，高阶函数的实现又依赖于一等函数。我们按照这条依赖链，从里往外依次对它们进行讲解。</p>\n<h1>一等函数（First Class Functions）</h1>\n<p>程序语言会对基本元素的使用方式进行限制，带有最少限制的元素被称为一等公民，其拥有的 “权利” 如下：</p>\n<blockquote>\n<ul>\n<li>可以使用变量命名；</li>\n<li>可以提供给函数作为参数；</li>\n<li>可以由函数作为结果返回；</li>\n<li>可以包含在数据结构中；</li>\n</ul>\n</blockquote>\n<p>乍一看，我们应该首先会想到程序中的基本数据结构（如 number、array、object 等）是一等公民。如果函数也被视为一等公民，我们便可以像使用普通数据一样对其使用变量命名，作为参数或返回值使用，或者将其包含在数据结构中。在这里函数和数据的边界开始变得不再那么分明了。函数被视为一等公民后，其能力和适用范围被大大扩展了。</p>\n<p>下面使用 JavaScript 对上面第一条和第四条 “权利” 进行讲解。第二、三条与高阶函数密切相关，将放到下一节的高阶函数中讲解。</p>\n<h2>使用变量命名</h2>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x</span><br></pre></td></tr></table></figure></p>\n<p>上面代码定义了一个求平方值的函数，并将其赋给了 square 变量。</p>\n<h2>可以包含在数据结构中</h2>\n<p><a href=\"http://ramda.cn/\" target=\"_blank\" rel=\"noopener\">Ramda</a> 中有一个API：<a href=\"http://ramda.cn/docs/#evolve\" target=\"_blank\" rel=\"noopener\">evolve</a>，其接受的首个参数便是一个属性值为函数的对象。<a href=\"http://ramda.cn/docs/#evolve\" target=\"_blank\" rel=\"noopener\">evolve</a> 函数会递归地对 &quot;待处理对象&quot; 的属性进行变换，变换的方式由 transformation 内置函数属性值的对象定义。示例如下（示例中的 <code>R.xxx</code> 都是 <a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">Ramda</a> 中的API，相关API的功能可以参考<a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">Ramda</a>文档）：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tomato  = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Tomato'</span>, <span class=\"attr\">data</span>: &#123;<span class=\"attr\">elapsed</span>: <span class=\"number\">100</span>, <span class=\"attr\">remaining</span>: <span class=\"number\">1400</span>&#125;, <span class=\"attr\">id</span>:<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> transformations = &#123;</span><br><span class=\"line\">  name: R.toUpper,</span><br><span class=\"line\">  data: &#123;<span class=\"attr\">elapsed</span>: R.add(<span class=\"number\">1</span>), <span class=\"attr\">remaining</span>: R.add(<span class=\"number\">-1</span>)&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">R.evolve(transformations)(tomato);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; &#123;name: 'TOMATO', data: &#123;elapsed: 101, remaining: 1399&#125;, id:123&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h1>高阶函数</h1>\n<p>定义：</p>\n<blockquote>\n<p>使用函数作为输入参数，或者返回结果为函数的函数，被称为高阶函数。</p>\n</blockquote>\n<p>作为参数或返回值的函数，是一等函数的应用之一。高阶函数以一等函数作为基础，只有支持一等函数的语言才能进行高阶函数编程。</p>\n<p>以熟悉的 <a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 函数为例，我们可以用 <a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 对列表中的元素进行过滤，筛选出符合条件的元素。<a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 的类型签名和示例代码如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter :: (a → <span class=\"built_in\">Boolean</span>) → [a] → [a]</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> filterEven = R.filter(isEven);</span><br><span class=\"line\"></span><br><span class=\"line\">filterEven([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]); <span class=\"comment\">//=&gt; [2, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 接受一个判断函数（判断输入值是否为偶数）<code>isEven</code>，返回一个过滤出偶数的函数 <code>filterEven</code>。</p>\n<h1>闭包</h1>\n<p>定义：</p>\n<blockquote>\n<p>闭包是由函数及该函数捕获的其上下文中的自由变量组成的记录</p>\n</blockquote>\n<p>举例讲：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> xIn = x;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addInner</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xIn + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> inc = add(<span class=\"number\">1</span>);</span><br><span class=\"line\">inc(<span class=\"number\">8</span>); <span class=\"comment\">//=&gt; 9;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus2 = add(<span class=\"number\">2</span>);</span><br><span class=\"line\">plus2(<span class=\"number\">8</span>); <span class=\"comment\">//=&gt; 10;</span></span><br></pre></td></tr></table></figure></p>\n<p>上述代码中返回的函数 <code>addInner</code> 及由其捕获的在其上下文中定义的自由变量 <code>xIn</code>，便组成了一个闭包。</p>\n<p><img src=\"./closure.png\" alt=\"closure\"></p>\n<p>上述代码中最外层的 <code>add</code> 函数是一个高阶函数，其返回值为一等函数 <code>addInner</code>。</p>\n<p>其实 <code>add</code> 函数的参数 <code>x</code> 也是 <code>addInner</code> 上下文的一部分，所以 'xIn' 也就没有存在的必要了，<code>add</code> 代码优化如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addInner</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>借助于箭头函数，我们可以进一步优化 <code>add</code> 的实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> x + y</span><br></pre></td></tr></table></figure></p>\n<p>是不是非常简洁？由此我们可以一窥函数式编程强大的表达能力。</p>\n<p>闭包主要用来做数据缓存，而数据缓存应用非常广泛：包括函数工厂模式、模拟拥有私有变量的对象、函数缓存、还有大名鼎鼎的柯里化。</p>\n<p>其实上述代码中 <code>add</code> 函数便是柯里化形式的函数。</p>\n<p>上述代码中的 <code>const inc = add(1);</code> 和 <code>const plus2 = add(2);</code> 是一种函数工厂模式，通过向 <code>add</code> 函数传入不同的参数，便会产生功能不同的函数。函数工厂可以提高函数的抽象和复用能力。</p>\n<p>例如我们有一个如下形式的 Ajax 请求函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ajax = <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> <span class=\"function\"><span class=\"params\">type</span> =&gt;</span> <span class=\"function\"><span class=\"params\">query</span> =&gt;</span> &#123; ... &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">get</span> = ajax('GET');</span><br><span class=\"line\">const post = ajax('POST');</span><br><span class=\"line\"></span><br><span class=\"line\">const getJson = <span class=\"keyword\">get</span>('json');</span><br><span class=\"line\">const getHtml = ajax('GET')('text/html') = <span class=\"keyword\">get</span>('text/html');</span><br></pre></td></tr></table></figure></p>\n<p>我们抽象出了最一般的 <code>ajax</code> 请求函数，在具体应用时，我们用能通过函数工厂生产出作用不同的函数。</p>\n<p>通过上面几个小节，我们讲解了纯函数（数学意义上的函数）、一等函数、高阶函数，还有闭包。</p>\n<p>下面通过一个集上述所有概念于一身的 <strong>函数缓存</strong> ，来结束函数式编程中的 “函数们” 的论述。</p>\n<h1>函数缓存 memoize</h1>\n<p>函数实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoize = <span class=\"function\"><span class=\"params\">pureFunc</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> argStr = <span class=\"built_in\">JSON</span>.stringify(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    cache[argStr] = cache[argStr] || pureFunc.apply(pureFunc, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache[argStr];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>memoize</code> 的功能是对传入函数 <code>pureFunc</code> 进行缓存，返回缓存版本的 <code>pureFunc</code>。当我们使用参数调用缓存的函数时，缓存的函数会到 <code>cache</code> 中查找该参数是否被缓存过，如果有缓存，则不需要再次计算，直接返回已缓存值，否则对本次输入的参数进行计算，缓存计算的结果以备后用，然后将结果返回。</p>\n<p><code>memoize</code> 只有对纯函数的缓存才有意义。因为纯函数是引用透明的，其输出只依赖于输入，并且计算过程不会影响外部环境。</p>\n<p>举一个极端的例子，假如我们有一个随机数字生成函数 <code>random()</code>, 如果对其进行了缓存：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedRandom = memoize(random);</span><br></pre></td></tr></table></figure></p>\n<p><code>memoizedRandom</code> 除了第一次生成一个随机值外，随后的调用都返回第一次缓存的值，这样就失去了 <code>random</code> 的意义。再假如，我们对终端字符输入函数 <code>getchar()</code> 进行了缓存，每次调用都会是第一次获取的字母。</p>\n<p><code>memoize</code> 内部实现了一个闭包的创建。返回的缓存函数和自由变量 <code>cache</code> 共同构成了一个闭包。自由变量 <code>cached</code> 用于对已经计算过的数据（参数）的缓存。而闭包本身是由高阶函数和一等函数实现的。</p>\n<p><img src=\"./functions-in-memoize.png\" alt=\"functions-in-memoize\"></p>\n<h1>总结</h1>\n<p>本文对函数式编程中的 “函数们” 做了详细解释：纯函数、一等函数、高阶函数，并展示了它们的应用。其中纯函数是函数组合的基础；一等函数是高阶函数的实现基础，一等函数和高阶函数又是闭包的实现基础。</p>\n<p>最后通过函数缓存函数 <code>memoize</code> 将纯函数、一等函数、高阶函数和闭包联系了起来，用函数式编程中的 “函数们” （函数式三镖客）的一次 “联合行动” 结束本文。</p>\n<h1>参考文档</h1>\n<p><a href=\"http://www.mathsisfun.com/sets/function.html\" target=\"_blank\" rel=\"noopener\">What is a Function?</a>.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Functional_programming\" target=\"_blank\" rel=\"noopener\">Functional Programming</a>.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Referential_transparency\" target=\"_blank\" rel=\"noopener\">Referential Transparency</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>函数式编程中的函数有三种不同的解读方式，分别为纯函数、高阶函数和一等函数。本文分别对这三者的概念、应用和联系进行详解。</p>\n<h1>纯函数</h1>\n<p>定义：</p>\n<blockquote>\n<ol>\n<li>相同的输入必定产生相同的输出；</li>\n<li>在计算的过程中，不会产生副作用。</li>\n</ol>\n</blockquote>\n<p>满足上述两个条件，我们就说该函数是纯函数。</p>\n<p>纯函数也即数学意义上的函数，表达的是数据之间的转换（映射）关系，而非计算步骤的详述。数学函数的定义：</p>\n<blockquote>\n<p>函数通常由定义域 <em>X</em> 、值域 <em>Y</em> 以及定义域到值域的映射 <em>f</em> （<em>f: X -&gt; Y</em>）组成。</p>\n</blockquote>\n<p><img src=\"./function.png\" alt=\"function\"></p>\n<p>纯函数让我们对写出的函数具有完全的控制能力。纯函数的结果 <strong>必须</strong> 只依赖于输入参数，不受外部环境的影响；同时纯函数在计算结果的过程中，也不会影响（污染）外部环境，即不会产生副作用。</p>\n<h2>函数组合</h2>\n<p>纯函数定义中的两个条件保证了它（的计算过程）与外界是完全隔离，这也是函数组合的基础。</p>\n<p>只有函数组合中的所有函数都是纯函数，我们组合起来的新函数才会是纯函数。我们可以对使用纯函数组合出来的新函数从数学上证明（推导）其正确性，而无需借助大量的单元测试。</p>\n<p>只要在函数组合时引入一个非纯函数，整个组合出来的函数将沦为非纯函数。如果将函数组合比作管道的拼接，只要组成管道的任何一小节有泄露或者外部注入，我们便失去了对整条管道的完全控制。</p>\n<p><img src=\"./pipeline-leaking.png\" alt=\"pipeline-leaking\"></p>\n<p>要想实现函数组合，还需要满足连续性，描述如下：</p>\n<p>因为纯函数可以看作定义域到值域映射，待组合的函数中的上一个函数的值域须等于下一个函数的定义域，也即上一个函数的输出（类型）等于下一个的输入（类型）。</p>\n<p>假设有两个函数：<em>f: X -&gt; Y</em> 和 <em>g: Y -&gt; Z</em>，只有 <code>codomain(f) = domain(g)</code> 时，<em>f</em> 和 <em>g</em> 才可以组合。</p>\n<p><img src=\"./functions_composition.png\" alt=\"function_composition\"></p>\n<h2>引用透明及缓存</h2>\n<p>在不改变整个程序行为的情况下，如果能将其中的一段代码替换为其执行的结果，我们就说这段代码是引用透明的。</p>\n<p>因此，执行一段引用透明的代码（函数），对于相同的参数，总是给出相同的结果。我们也称这样的函数（代码）为纯函数。</p>\n<p>引用透明的一个典型应用即函数缓存。我们可以将已经执行过的函数输入值缓存起来，下次调用时，若输入值相同，直接跳过计算过程，用缓存结果代替计算结果返回即可。</p>\n<p>函数缓存的实现依赖于闭包，而闭包的实现又依赖于高阶函数，高阶函数的实现又依赖于一等函数。我们按照这条依赖链，从里往外依次对它们进行讲解。</p>\n<h1>一等函数（First Class Functions）</h1>\n<p>程序语言会对基本元素的使用方式进行限制，带有最少限制的元素被称为一等公民，其拥有的 “权利” 如下：</p>\n<blockquote>\n<ul>\n<li>可以使用变量命名；</li>\n<li>可以提供给函数作为参数；</li>\n<li>可以由函数作为结果返回；</li>\n<li>可以包含在数据结构中；</li>\n</ul>\n</blockquote>\n<p>乍一看，我们应该首先会想到程序中的基本数据结构（如 number、array、object 等）是一等公民。如果函数也被视为一等公民，我们便可以像使用普通数据一样对其使用变量命名，作为参数或返回值使用，或者将其包含在数据结构中。在这里函数和数据的边界开始变得不再那么分明了。函数被视为一等公民后，其能力和适用范围被大大扩展了。</p>\n<p>下面使用 JavaScript 对上面第一条和第四条 “权利” 进行讲解。第二、三条与高阶函数密切相关，将放到下一节的高阶函数中讲解。</p>\n<h2>使用变量命名</h2>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x</span><br></pre></td></tr></table></figure></p>\n<p>上面代码定义了一个求平方值的函数，并将其赋给了 square 变量。</p>\n<h2>可以包含在数据结构中</h2>\n<p><a href=\"http://ramda.cn/\" target=\"_blank\" rel=\"noopener\">Ramda</a> 中有一个API：<a href=\"http://ramda.cn/docs/#evolve\" target=\"_blank\" rel=\"noopener\">evolve</a>，其接受的首个参数便是一个属性值为函数的对象。<a href=\"http://ramda.cn/docs/#evolve\" target=\"_blank\" rel=\"noopener\">evolve</a> 函数会递归地对 &quot;待处理对象&quot; 的属性进行变换，变换的方式由 transformation 内置函数属性值的对象定义。示例如下（示例中的 <code>R.xxx</code> 都是 <a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">Ramda</a> 中的API，相关API的功能可以参考<a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">Ramda</a>文档）：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> tomato  = &#123;<span class=\"attr\">name</span>: <span class=\"string\">'Tomato'</span>, <span class=\"attr\">data</span>: &#123;<span class=\"attr\">elapsed</span>: <span class=\"number\">100</span>, <span class=\"attr\">remaining</span>: <span class=\"number\">1400</span>&#125;, <span class=\"attr\">id</span>:<span class=\"number\">123</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> transformations = &#123;</span><br><span class=\"line\">  name: R.toUpper,</span><br><span class=\"line\">  data: &#123;<span class=\"attr\">elapsed</span>: R.add(<span class=\"number\">1</span>), <span class=\"attr\">remaining</span>: R.add(<span class=\"number\">-1</span>)&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">R.evolve(transformations)(tomato);</span><br><span class=\"line\"><span class=\"comment\">//=&gt; &#123;name: 'TOMATO', data: &#123;elapsed: 101, remaining: 1399&#125;, id:123&#125;</span></span><br></pre></td></tr></table></figure></p>\n<h1>高阶函数</h1>\n<p>定义：</p>\n<blockquote>\n<p>使用函数作为输入参数，或者返回结果为函数的函数，被称为高阶函数。</p>\n</blockquote>\n<p>作为参数或返回值的函数，是一等函数的应用之一。高阶函数以一等函数作为基础，只有支持一等函数的语言才能进行高阶函数编程。</p>\n<p>以熟悉的 <a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 函数为例，我们可以用 <a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 对列表中的元素进行过滤，筛选出符合条件的元素。<a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 的类型签名和示例代码如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter :: (a → <span class=\"built_in\">Boolean</span>) → [a] → [a]</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> n % <span class=\"number\">2</span> === <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> filterEven = R.filter(isEven);</span><br><span class=\"line\"></span><br><span class=\"line\">filterEven([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]); <span class=\"comment\">//=&gt; [2, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a> 接受一个判断函数（判断输入值是否为偶数）<code>isEven</code>，返回一个过滤出偶数的函数 <code>filterEven</code>。</p>\n<h1>闭包</h1>\n<p>定义：</p>\n<blockquote>\n<p>闭包是由函数及该函数捕获的其上下文中的自由变量组成的记录</p>\n</blockquote>\n<p>举例讲：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> xIn = x;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addInner</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xIn + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> inc = add(<span class=\"number\">1</span>);</span><br><span class=\"line\">inc(<span class=\"number\">8</span>); <span class=\"comment\">//=&gt; 9;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus2 = add(<span class=\"number\">2</span>);</span><br><span class=\"line\">plus2(<span class=\"number\">8</span>); <span class=\"comment\">//=&gt; 10;</span></span><br></pre></td></tr></table></figure></p>\n<p>上述代码中返回的函数 <code>addInner</code> 及由其捕获的在其上下文中定义的自由变量 <code>xIn</code>，便组成了一个闭包。</p>\n<p><img src=\"./closure.png\" alt=\"closure\"></p>\n<p>上述代码中最外层的 <code>add</code> 函数是一个高阶函数，其返回值为一等函数 <code>addInner</code>。</p>\n<p>其实 <code>add</code> 函数的参数 <code>x</code> 也是 <code>addInner</code> 上下文的一部分，所以 'xIn' 也就没有存在的必要了，<code>add</code> 代码优化如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">addInner</span>(<span class=\"params\">y</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>借助于箭头函数，我们可以进一步优化 <code>add</code> 的实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> x + y</span><br></pre></td></tr></table></figure></p>\n<p>是不是非常简洁？由此我们可以一窥函数式编程强大的表达能力。</p>\n<p>闭包主要用来做数据缓存，而数据缓存应用非常广泛：包括函数工厂模式、模拟拥有私有变量的对象、函数缓存、还有大名鼎鼎的柯里化。</p>\n<p>其实上述代码中 <code>add</code> 函数便是柯里化形式的函数。</p>\n<p>上述代码中的 <code>const inc = add(1);</code> 和 <code>const plus2 = add(2);</code> 是一种函数工厂模式，通过向 <code>add</code> 函数传入不同的参数，便会产生功能不同的函数。函数工厂可以提高函数的抽象和复用能力。</p>\n<p>例如我们有一个如下形式的 Ajax 请求函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> ajax = <span class=\"function\"><span class=\"params\">method</span> =&gt;</span> <span class=\"function\"><span class=\"params\">type</span> =&gt;</span> <span class=\"function\"><span class=\"params\">query</span> =&gt;</span> &#123; ... &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">get</span> = ajax('GET');</span><br><span class=\"line\">const post = ajax('POST');</span><br><span class=\"line\"></span><br><span class=\"line\">const getJson = <span class=\"keyword\">get</span>('json');</span><br><span class=\"line\">const getHtml = ajax('GET')('text/html') = <span class=\"keyword\">get</span>('text/html');</span><br></pre></td></tr></table></figure></p>\n<p>我们抽象出了最一般的 <code>ajax</code> 请求函数，在具体应用时，我们用能通过函数工厂生产出作用不同的函数。</p>\n<p>通过上面几个小节，我们讲解了纯函数（数学意义上的函数）、一等函数、高阶函数，还有闭包。</p>\n<p>下面通过一个集上述所有概念于一身的 <strong>函数缓存</strong> ，来结束函数式编程中的 “函数们” 的论述。</p>\n<h1>函数缓存 memoize</h1>\n<p>函数实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoize = <span class=\"function\"><span class=\"params\">pureFunc</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> cache = &#123;&#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> argStr = <span class=\"built_in\">JSON</span>.stringify(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    cache[argStr] = cache[argStr] || pureFunc.apply(pureFunc, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache[argStr];</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>memoize</code> 的功能是对传入函数 <code>pureFunc</code> 进行缓存，返回缓存版本的 <code>pureFunc</code>。当我们使用参数调用缓存的函数时，缓存的函数会到 <code>cache</code> 中查找该参数是否被缓存过，如果有缓存，则不需要再次计算，直接返回已缓存值，否则对本次输入的参数进行计算，缓存计算的结果以备后用，然后将结果返回。</p>\n<p><code>memoize</code> 只有对纯函数的缓存才有意义。因为纯函数是引用透明的，其输出只依赖于输入，并且计算过程不会影响外部环境。</p>\n<p>举一个极端的例子，假如我们有一个随机数字生成函数 <code>random()</code>, 如果对其进行了缓存：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> memoizedRandom = memoize(random);</span><br></pre></td></tr></table></figure></p>\n<p><code>memoizedRandom</code> 除了第一次生成一个随机值外，随后的调用都返回第一次缓存的值，这样就失去了 <code>random</code> 的意义。再假如，我们对终端字符输入函数 <code>getchar()</code> 进行了缓存，每次调用都会是第一次获取的字母。</p>\n<p><code>memoize</code> 内部实现了一个闭包的创建。返回的缓存函数和自由变量 <code>cache</code> 共同构成了一个闭包。自由变量 <code>cached</code> 用于对已经计算过的数据（参数）的缓存。而闭包本身是由高阶函数和一等函数实现的。</p>\n<p><img src=\"./functions-in-memoize.png\" alt=\"functions-in-memoize\"></p>\n<h1>总结</h1>\n<p>本文对函数式编程中的 “函数们” 做了详细解释：纯函数、一等函数、高阶函数，并展示了它们的应用。其中纯函数是函数组合的基础；一等函数是高阶函数的实现基础，一等函数和高阶函数又是闭包的实现基础。</p>\n<p>最后通过函数缓存函数 <code>memoize</code> 将纯函数、一等函数、高阶函数和闭包联系了起来，用函数式编程中的 “函数们” （函数式三镖客）的一次 “联合行动” 结束本文。</p>\n<h1>参考文档</h1>\n<p><a href=\"http://www.mathsisfun.com/sets/function.html\" target=\"_blank\" rel=\"noopener\">What is a Function?</a>.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Functional_programming\" target=\"_blank\" rel=\"noopener\">Functional Programming</a>.</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Referential_transparency\" target=\"_blank\" rel=\"noopener\">Referential Transparency</a>.</p>\n"},{"title":"Hexo Workflow","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\n### Generate & Deploy together\n\n``` bash\n$ hexo d -g\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n","source":"_posts/Hexo-Workflow.md","raw":"---\ntitle: Hexo Workflow\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\n### Generate & Deploy together\n\n``` bash\n$ hexo d -g\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n","slug":"Hexo-Workflow","published":1,"date":"2020-06-06T14:44:04.086Z","updated":"2020-06-06T14:44:04.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitg000cf6mj8t4fl7mf","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2>Quick Start</h2>\n<h3>Create a new post</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3>Run server</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3>Generate static files</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3>Deploy to remote sites</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h3>Generate &amp; Deploy together</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2>Quick Start</h2>\n<h3>Create a new post</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3>Run server</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3>Generate static files</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3>Deploy to remote sites</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<h3>Generate &amp; Deploy together</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure></p>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"Ramda 简介","date":"2017-06-25T06:49:18.000Z","_content":"\n译者注：本文翻译自 [Michael Hurley](https://github.com/buzzdecafe) 的 《[Introducing Ramda](http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/)》，转载请与[原作者](https://github.com/buzzdecafe)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n在过去一年的时间里，我的同事 Scott Sauyet 和我一直在编写 [Ramda](https://github.com/ramda/ramda) ：\"一个实用的 JavaScript 函数式编程库\"。当我们为 Frontend Masters 注册 \"使用 JavaScript 进行核心函数式编程\" 工作室时，惊讶地发现，他们选择 Ramda 来说明他们的示例。这件事给了我们信心，我们认为现在是宣布 Ramda 到来的时候了。\n\n现在已经存在一些优秀的函数式库，如 [Underscore](https://github.com/jashkenas/underscore) 和 [Lodash](https://github.com/lodash/lodash)。Ramda 包含了所有你想要的列表操作函数，像 `map`、`filter`、`reduce` 和 `find` 等。但 Ramda 跟 Underscore 和 Lodash 有很大的区别。Ramda 的主要特性如下：\n\n* **Ramda 先接受函数参数，最后接受数据参数。** [Brian Lonsdorf 解释了为什么这样的参数顺序很重要](http://www.youtube.com/watch?v=m3svKOdZijA)。简言之，柯里化和 \"函数优先\" 这两者相结合，使开发者在最终传入数据之前，能够以非常少的代码（通常为 \"point-free\" 风格，也即无参数风格）来组合函数。例如，以下面代码为例：\n\n```js\n// Underscore/Lodash style:\nvar validUsersNamedBuzz = function(users) {\n  return _.filter(users, function(user) { \n    return user.name === 'Buzz' && _.isEmpty(user.errors); \n  });\n};\n```\n\n现在可以这么写：\n\n```js\n// Ramda style:\nvar validUsersNamedBuzz = R.filter(R.where({name: 'Buzz', errors: R.isEmpty}));\n```\n\n* **Ramda 的函数是自动柯里化的** 。当你需要对 Underscore 或 Lodash 中的函数进行手动柯里化（或部分柯里化）时，Ramda 在内部已经替你完成这项工作了。实际上，Ramda 中所有的多元（多参数）函数都默认是柯里化的。例如：\n\n```js\n// `prop` takes two arguments. If I just give it one, I get a function back\nvar moo = R.prop('moo');\n// when I call that function with one argument, I get the result.\nvar value = moo({moo: 'cow'}); // => 'cow'    \n```\n\n这种自动柯里化使得 \"通过组合函数来创建新函数\" 变得非常容易。因为 API 都是函数优先、数据最后（先传函数，最后传数据参数），你可以不断地组合函数，直到创建出需要的新函数，然后将数据传入其中。（Hugh Jackson 发表了一遍描述这种风格优点的 [非常优秀的文章](http://hughfdjackson.com/javascript/why-curry-helps/)。\n\n```js\n// take an object with an `amount` property\n// add one to it\n// find its remainder when divided by 7\nvar amtAdd1Mod7 = R.compose(R.moduloBy(7), R.add(1), R.prop('amount'));\n\n// we can use that as is:\namtAdd1Mod7({amount: 17}); // => 4\namtAdd1Mod7({amount: 987}); // => 1\namtAdd1Mod7({amount: 68}); // => 6\n// etc. \n\n// But we can also use our composed function on a list of objects, e.g. to `map`:\nvar amountObjects = [\n  {amount: 903}, {amount: 2875654}, {amount: 6}\n]\nR.map(amtAdd1Mod7, amountObjects); // => [1, 6, 0]\n\n// of course, `map` is also curried, so you can generate a new function \n// using `amtAdd1Mod7` that will wait for a list of \"amountObjects\" to \n// get passed in:\nvar amountsToValue = map(amtAdd1Mod7);\namountsToValue(amountObjects); // => [1, 6, 0]\n```\n\n[Ramda 提供了 npm 包](https://www.npmjs.org/package/ramda)，可以下载下来尝试一下。如果你对 Ramda 库有什么想法或改进建议，[请联系我们](https://github.com/CrossEye/ramda/issues)。\n","source":"_posts/Introducing-Ramda.md","raw":"---\ntitle: Ramda 简介\ndate: 2017-06-25 14:49:18\ncategories: 'Ramda'\n---\n\n译者注：本文翻译自 [Michael Hurley](https://github.com/buzzdecafe) 的 《[Introducing Ramda](http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/)》，转载请与[原作者](https://github.com/buzzdecafe)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n在过去一年的时间里，我的同事 Scott Sauyet 和我一直在编写 [Ramda](https://github.com/ramda/ramda) ：\"一个实用的 JavaScript 函数式编程库\"。当我们为 Frontend Masters 注册 \"使用 JavaScript 进行核心函数式编程\" 工作室时，惊讶地发现，他们选择 Ramda 来说明他们的示例。这件事给了我们信心，我们认为现在是宣布 Ramda 到来的时候了。\n\n现在已经存在一些优秀的函数式库，如 [Underscore](https://github.com/jashkenas/underscore) 和 [Lodash](https://github.com/lodash/lodash)。Ramda 包含了所有你想要的列表操作函数，像 `map`、`filter`、`reduce` 和 `find` 等。但 Ramda 跟 Underscore 和 Lodash 有很大的区别。Ramda 的主要特性如下：\n\n* **Ramda 先接受函数参数，最后接受数据参数。** [Brian Lonsdorf 解释了为什么这样的参数顺序很重要](http://www.youtube.com/watch?v=m3svKOdZijA)。简言之，柯里化和 \"函数优先\" 这两者相结合，使开发者在最终传入数据之前，能够以非常少的代码（通常为 \"point-free\" 风格，也即无参数风格）来组合函数。例如，以下面代码为例：\n\n```js\n// Underscore/Lodash style:\nvar validUsersNamedBuzz = function(users) {\n  return _.filter(users, function(user) { \n    return user.name === 'Buzz' && _.isEmpty(user.errors); \n  });\n};\n```\n\n现在可以这么写：\n\n```js\n// Ramda style:\nvar validUsersNamedBuzz = R.filter(R.where({name: 'Buzz', errors: R.isEmpty}));\n```\n\n* **Ramda 的函数是自动柯里化的** 。当你需要对 Underscore 或 Lodash 中的函数进行手动柯里化（或部分柯里化）时，Ramda 在内部已经替你完成这项工作了。实际上，Ramda 中所有的多元（多参数）函数都默认是柯里化的。例如：\n\n```js\n// `prop` takes two arguments. If I just give it one, I get a function back\nvar moo = R.prop('moo');\n// when I call that function with one argument, I get the result.\nvar value = moo({moo: 'cow'}); // => 'cow'    \n```\n\n这种自动柯里化使得 \"通过组合函数来创建新函数\" 变得非常容易。因为 API 都是函数优先、数据最后（先传函数，最后传数据参数），你可以不断地组合函数，直到创建出需要的新函数，然后将数据传入其中。（Hugh Jackson 发表了一遍描述这种风格优点的 [非常优秀的文章](http://hughfdjackson.com/javascript/why-curry-helps/)。\n\n```js\n// take an object with an `amount` property\n// add one to it\n// find its remainder when divided by 7\nvar amtAdd1Mod7 = R.compose(R.moduloBy(7), R.add(1), R.prop('amount'));\n\n// we can use that as is:\namtAdd1Mod7({amount: 17}); // => 4\namtAdd1Mod7({amount: 987}); // => 1\namtAdd1Mod7({amount: 68}); // => 6\n// etc. \n\n// But we can also use our composed function on a list of objects, e.g. to `map`:\nvar amountObjects = [\n  {amount: 903}, {amount: 2875654}, {amount: 6}\n]\nR.map(amtAdd1Mod7, amountObjects); // => [1, 6, 0]\n\n// of course, `map` is also curried, so you can generate a new function \n// using `amtAdd1Mod7` that will wait for a list of \"amountObjects\" to \n// get passed in:\nvar amountsToValue = map(amtAdd1Mod7);\namountsToValue(amountObjects); // => [1, 6, 0]\n```\n\n[Ramda 提供了 npm 包](https://www.npmjs.org/package/ramda)，可以下载下来尝试一下。如果你对 Ramda 库有什么想法或改进建议，[请联系我们](https://github.com/CrossEye/ramda/issues)。\n","slug":"Introducing-Ramda","published":1,"updated":"2020-06-06T14:44:04.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiti000df6mjzj6b89gi","content":"<p>译者注：本文翻译自 <a href=\"https://github.com/buzzdecafe\" target=\"_blank\" rel=\"noopener\">Michael Hurley</a> 的 《<a href=\"http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/\" target=\"_blank\" rel=\"noopener\">Introducing Ramda</a>》，转载请与<a href=\"https://github.com/buzzdecafe\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>在过去一年的时间里，我的同事 Scott Sauyet 和我一直在编写 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> ：&quot;一个实用的 JavaScript 函数式编程库&quot;。当我们为 Frontend Masters 注册 &quot;使用 JavaScript 进行核心函数式编程&quot; 工作室时，惊讶地发现，他们选择 Ramda 来说明他们的示例。这件事给了我们信心，我们认为现在是宣布 Ramda 到来的时候了。</p>\n<p>现在已经存在一些优秀的函数式库，如 <a href=\"https://github.com/jashkenas/underscore\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"noopener\">Lodash</a>。Ramda 包含了所有你想要的列表操作函数，像 <code>map</code>、<code>filter</code>、<code>reduce</code> 和 <code>find</code> 等。但 Ramda 跟 Underscore 和 Lodash 有很大的区别。Ramda 的主要特性如下：</p>\n<ul>\n<li><strong>Ramda 先接受函数参数，最后接受数据参数。</strong> <a href=\"http://www.youtube.com/watch?v=m3svKOdZijA\" target=\"_blank\" rel=\"noopener\">Brian Lonsdorf 解释了为什么这样的参数顺序很重要</a>。简言之，柯里化和 &quot;函数优先&quot; 这两者相结合，使开发者在最终传入数据之前，能够以非常少的代码（通常为 &quot;point-free&quot; 风格，也即无参数风格）来组合函数。例如，以下面代码为例：</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Underscore/Lodash style:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> validUsersNamedBuzz = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">users</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.filter(users, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.name === <span class=\"string\">'Buzz'</span> &amp;&amp; _.isEmpty(user.errors); </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>现在可以这么写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Ramda style:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> validUsersNamedBuzz = R.filter(R.where(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Buzz'</span>, <span class=\"attr\">errors</span>: R.isEmpty&#125;));</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>Ramda 的函数是自动柯里化的</strong> 。当你需要对 Underscore 或 Lodash 中的函数进行手动柯里化（或部分柯里化）时，Ramda 在内部已经替你完成这项工作了。实际上，Ramda 中所有的多元（多参数）函数都默认是柯里化的。例如：</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `prop` takes two arguments. If I just give it one, I get a function back</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> moo = R.prop(<span class=\"string\">'moo'</span>);</span><br><span class=\"line\"><span class=\"comment\">// when I call that function with one argument, I get the result.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = moo(&#123;<span class=\"attr\">moo</span>: <span class=\"string\">'cow'</span>&#125;); <span class=\"comment\">// =&gt; 'cow'</span></span><br></pre></td></tr></table></figure></p>\n<p>这种自动柯里化使得 &quot;通过组合函数来创建新函数&quot; 变得非常容易。因为 API 都是函数优先、数据最后（先传函数，最后传数据参数），你可以不断地组合函数，直到创建出需要的新函数，然后将数据传入其中。（Hugh Jackson 发表了一遍描述这种风格优点的 <a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">非常优秀的文章</a>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// take an object with an `amount` property</span></span><br><span class=\"line\"><span class=\"comment\">// add one to it</span></span><br><span class=\"line\"><span class=\"comment\">// find its remainder when divided by 7</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> amtAdd1Mod7 = R.compose(R.moduloBy(<span class=\"number\">7</span>), R.add(<span class=\"number\">1</span>), R.prop(<span class=\"string\">'amount'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// we can use that as is:</span></span><br><span class=\"line\">amtAdd1Mod7(&#123;<span class=\"attr\">amount</span>: <span class=\"number\">17</span>&#125;); <span class=\"comment\">// =&gt; 4</span></span><br><span class=\"line\">amtAdd1Mod7(&#123;<span class=\"attr\">amount</span>: <span class=\"number\">987</span>&#125;); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">amtAdd1Mod7(&#123;<span class=\"attr\">amount</span>: <span class=\"number\">68</span>&#125;); <span class=\"comment\">// =&gt; 6</span></span><br><span class=\"line\"><span class=\"comment\">// etc. </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But we can also use our composed function on a list of objects, e.g. to `map`:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> amountObjects = [</span><br><span class=\"line\">  &#123;<span class=\"attr\">amount</span>: <span class=\"number\">903</span>&#125;, &#123;<span class=\"attr\">amount</span>: <span class=\"number\">2875654</span>&#125;, &#123;<span class=\"attr\">amount</span>: <span class=\"number\">6</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">R.map(amtAdd1Mod7, amountObjects); <span class=\"comment\">// =&gt; [1, 6, 0]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// of course, `map` is also curried, so you can generate a new function </span></span><br><span class=\"line\"><span class=\"comment\">// using `amtAdd1Mod7` that will wait for a list of \"amountObjects\" to </span></span><br><span class=\"line\"><span class=\"comment\">// get passed in:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> amountsToValue = map(amtAdd1Mod7);</span><br><span class=\"line\">amountsToValue(amountObjects); <span class=\"comment\">// =&gt; [1, 6, 0]</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://www.npmjs.org/package/ramda\" target=\"_blank\" rel=\"noopener\">Ramda 提供了 npm 包</a>，可以下载下来尝试一下。如果你对 Ramda 库有什么想法或改进建议，<a href=\"https://github.com/CrossEye/ramda/issues\" target=\"_blank\" rel=\"noopener\">请联系我们</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 <a href=\"https://github.com/buzzdecafe\" target=\"_blank\" rel=\"noopener\">Michael Hurley</a> 的 《<a href=\"http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/\" target=\"_blank\" rel=\"noopener\">Introducing Ramda</a>》，转载请与<a href=\"https://github.com/buzzdecafe\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>在过去一年的时间里，我的同事 Scott Sauyet 和我一直在编写 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> ：&quot;一个实用的 JavaScript 函数式编程库&quot;。当我们为 Frontend Masters 注册 &quot;使用 JavaScript 进行核心函数式编程&quot; 工作室时，惊讶地发现，他们选择 Ramda 来说明他们的示例。这件事给了我们信心，我们认为现在是宣布 Ramda 到来的时候了。</p>\n<p>现在已经存在一些优秀的函数式库，如 <a href=\"https://github.com/jashkenas/underscore\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"noopener\">Lodash</a>。Ramda 包含了所有你想要的列表操作函数，像 <code>map</code>、<code>filter</code>、<code>reduce</code> 和 <code>find</code> 等。但 Ramda 跟 Underscore 和 Lodash 有很大的区别。Ramda 的主要特性如下：</p>\n<ul>\n<li><strong>Ramda 先接受函数参数，最后接受数据参数。</strong> <a href=\"http://www.youtube.com/watch?v=m3svKOdZijA\" target=\"_blank\" rel=\"noopener\">Brian Lonsdorf 解释了为什么这样的参数顺序很重要</a>。简言之，柯里化和 &quot;函数优先&quot; 这两者相结合，使开发者在最终传入数据之前，能够以非常少的代码（通常为 &quot;point-free&quot; 风格，也即无参数风格）来组合函数。例如，以下面代码为例：</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Underscore/Lodash style:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> validUsersNamedBuzz = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">users</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _.filter(users, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">user</span>) </span>&#123; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> user.name === <span class=\"string\">'Buzz'</span> &amp;&amp; _.isEmpty(user.errors); </span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>现在可以这么写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Ramda style:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> validUsersNamedBuzz = R.filter(R.where(&#123;<span class=\"attr\">name</span>: <span class=\"string\">'Buzz'</span>, <span class=\"attr\">errors</span>: R.isEmpty&#125;));</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong>Ramda 的函数是自动柯里化的</strong> 。当你需要对 Underscore 或 Lodash 中的函数进行手动柯里化（或部分柯里化）时，Ramda 在内部已经替你完成这项工作了。实际上，Ramda 中所有的多元（多参数）函数都默认是柯里化的。例如：</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `prop` takes two arguments. If I just give it one, I get a function back</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> moo = R.prop(<span class=\"string\">'moo'</span>);</span><br><span class=\"line\"><span class=\"comment\">// when I call that function with one argument, I get the result.</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> value = moo(&#123;<span class=\"attr\">moo</span>: <span class=\"string\">'cow'</span>&#125;); <span class=\"comment\">// =&gt; 'cow'</span></span><br></pre></td></tr></table></figure></p>\n<p>这种自动柯里化使得 &quot;通过组合函数来创建新函数&quot; 变得非常容易。因为 API 都是函数优先、数据最后（先传函数，最后传数据参数），你可以不断地组合函数，直到创建出需要的新函数，然后将数据传入其中。（Hugh Jackson 发表了一遍描述这种风格优点的 <a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">非常优秀的文章</a>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// take an object with an `amount` property</span></span><br><span class=\"line\"><span class=\"comment\">// add one to it</span></span><br><span class=\"line\"><span class=\"comment\">// find its remainder when divided by 7</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> amtAdd1Mod7 = R.compose(R.moduloBy(<span class=\"number\">7</span>), R.add(<span class=\"number\">1</span>), R.prop(<span class=\"string\">'amount'</span>));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// we can use that as is:</span></span><br><span class=\"line\">amtAdd1Mod7(&#123;<span class=\"attr\">amount</span>: <span class=\"number\">17</span>&#125;); <span class=\"comment\">// =&gt; 4</span></span><br><span class=\"line\">amtAdd1Mod7(&#123;<span class=\"attr\">amount</span>: <span class=\"number\">987</span>&#125;); <span class=\"comment\">// =&gt; 1</span></span><br><span class=\"line\">amtAdd1Mod7(&#123;<span class=\"attr\">amount</span>: <span class=\"number\">68</span>&#125;); <span class=\"comment\">// =&gt; 6</span></span><br><span class=\"line\"><span class=\"comment\">// etc. </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// But we can also use our composed function on a list of objects, e.g. to `map`:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> amountObjects = [</span><br><span class=\"line\">  &#123;<span class=\"attr\">amount</span>: <span class=\"number\">903</span>&#125;, &#123;<span class=\"attr\">amount</span>: <span class=\"number\">2875654</span>&#125;, &#123;<span class=\"attr\">amount</span>: <span class=\"number\">6</span>&#125;</span><br><span class=\"line\">]</span><br><span class=\"line\">R.map(amtAdd1Mod7, amountObjects); <span class=\"comment\">// =&gt; [1, 6, 0]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// of course, `map` is also curried, so you can generate a new function </span></span><br><span class=\"line\"><span class=\"comment\">// using `amtAdd1Mod7` that will wait for a list of \"amountObjects\" to </span></span><br><span class=\"line\"><span class=\"comment\">// get passed in:</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> amountsToValue = map(amtAdd1Mod7);</span><br><span class=\"line\">amountsToValue(amountObjects); <span class=\"comment\">// =&gt; [1, 6, 0]</span></span><br></pre></td></tr></table></figure></p>\n<p><a href=\"https://www.npmjs.org/package/ramda\" target=\"_blank\" rel=\"noopener\">Ramda 提供了 npm 包</a>，可以下载下来尝试一下。如果你对 Ramda 库有什么想法或改进建议，<a href=\"https://github.com/CrossEye/ramda/issues\" target=\"_blank\" rel=\"noopener\">请联系我们</a>。</p>\n"},{"title":"Hexo-Init","date":"2018-09-09T00:54:45.000Z","_content":"\n## Hexo 踩坑指南\n\n### 安装主题\n\n我选用 [next](https://github.com/theme-next/hexo-theme-next) 主题，简洁、素雅\n\n安装指南：\n\n```bash\n$ cd hexo\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n### favicon 配置\n\n需要在 `themes/next/_config.yml` 中对 favicon 进行配置，我的配置如下\n\n```bash\n# ---------------------------------------------------------------\n# Site Information Settings\n# ---------------------------------------------------------------\n\n# To get or check favicons visit: https://realfavicongenerator.net\n# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.\n\n# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.\n# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.\n\n# For example, you put your favicons into `hexo-site/source/images` directory.\n# Then need to rename & redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.\nfavicon:\n  small: /favicon.ico\n  medium: /favicon.ico\n  apple_touch_icon: /images/apple-touch-icon-next.ico\n  safari_pinned_tab: /logo.svg\n  #android_manifest: /images/manifest.json\n  #ms_browserconfig: /images/browserconfig.xml\n```\n\n### 关于锚点失效问题\n\n这是 [hexo-renderer-markdown-it](https://github.com/hexojs/hexo-renderer-markdown-it) 的一个 bug，但作者不想修复，认为是其他库的坑，所以我们要参考这个 [issue](https://github.com/hexojs/hexo-renderer-markdown-it/issues/40) ，手动到 node_modules 中修改该库，具体如下：\n\n```js\n'use strict';\n\nmodule.exports = function (data, options) {\n  var MdIt = require('markdown-it');\n  var cfg = this.config.markdown;\n  var opt = (cfg) ? cfg : 'default';\n  var parser = (opt === 'default' || opt === 'commonmark' || opt === 'zero') ?\n    new MdIt(opt) :\n    new MdIt(opt.render);\n\n  parser.use(require('markdown-it-named-headings')) // 只需要添加这行代码\n\n  if (opt.plugins) {\n    parser = opt.plugins.reduce(function (parser, pugs) {\n      return parser.use(require(pugs));\n    }, parser);\n  }\n\n  if (opt.anchors) {\n    parser = parser.use(require('./anchors'), opt.anchors);\n  }\n\n  return parser.render(data.text);\n};\n```\n\n### 自动化修复以上问题的脚本\n\n写了一个自动化脚本，git pull 下我的博客备份后，自动安装、修复上述问题。\n\n运行工程目录下的 `./hexo-init.sh`，内容如下：\n\n```bash\n#!/bin/bash\n\nnpm i hexo-cli -g\n\nyarn\n\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n\n# 修复锚点不生效问题\ncp ./init_source/hexo-renderer-markdown-it/lib/renderer.js ./node_modules/hexo-renderer-markdown-it/lib/renderer.js\n\n# 自动配置 favicon\ncp ./init_source/next/_config.yml ./themes/next/_config.yml\n```\n\n### Git pull 下来的 Hexo 工程，hexo deploy 后将整个项目都 push 上去了\n\n每次 git pull 备份的工程后，需要清理一下 hexo 工程，具体方法如下：\n\n```bash\n$ cd adispring.github.io\nrm -rf .git .deploy_git hexo clean\n```\n\n","source":"_posts/Hexo-Init.md","raw":"---\ntitle: Hexo-Init\ndate: 2018-09-09 08:54:45\ntags:\n---\n\n## Hexo 踩坑指南\n\n### 安装主题\n\n我选用 [next](https://github.com/theme-next/hexo-theme-next) 主题，简洁、素雅\n\n安装指南：\n\n```bash\n$ cd hexo\n$ git clone https://github.com/theme-next/hexo-theme-next themes/next\n```\n\n### favicon 配置\n\n需要在 `themes/next/_config.yml` 中对 favicon 进行配置，我的配置如下\n\n```bash\n# ---------------------------------------------------------------\n# Site Information Settings\n# ---------------------------------------------------------------\n\n# To get or check favicons visit: https://realfavicongenerator.net\n# Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.\n\n# Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.\n# And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.\n\n# For example, you put your favicons into `hexo-site/source/images` directory.\n# Then need to rename & redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.\nfavicon:\n  small: /favicon.ico\n  medium: /favicon.ico\n  apple_touch_icon: /images/apple-touch-icon-next.ico\n  safari_pinned_tab: /logo.svg\n  #android_manifest: /images/manifest.json\n  #ms_browserconfig: /images/browserconfig.xml\n```\n\n### 关于锚点失效问题\n\n这是 [hexo-renderer-markdown-it](https://github.com/hexojs/hexo-renderer-markdown-it) 的一个 bug，但作者不想修复，认为是其他库的坑，所以我们要参考这个 [issue](https://github.com/hexojs/hexo-renderer-markdown-it/issues/40) ，手动到 node_modules 中修改该库，具体如下：\n\n```js\n'use strict';\n\nmodule.exports = function (data, options) {\n  var MdIt = require('markdown-it');\n  var cfg = this.config.markdown;\n  var opt = (cfg) ? cfg : 'default';\n  var parser = (opt === 'default' || opt === 'commonmark' || opt === 'zero') ?\n    new MdIt(opt) :\n    new MdIt(opt.render);\n\n  parser.use(require('markdown-it-named-headings')) // 只需要添加这行代码\n\n  if (opt.plugins) {\n    parser = opt.plugins.reduce(function (parser, pugs) {\n      return parser.use(require(pugs));\n    }, parser);\n  }\n\n  if (opt.anchors) {\n    parser = parser.use(require('./anchors'), opt.anchors);\n  }\n\n  return parser.render(data.text);\n};\n```\n\n### 自动化修复以上问题的脚本\n\n写了一个自动化脚本，git pull 下我的博客备份后，自动安装、修复上述问题。\n\n运行工程目录下的 `./hexo-init.sh`，内容如下：\n\n```bash\n#!/bin/bash\n\nnpm i hexo-cli -g\n\nyarn\n\ngit clone https://github.com/theme-next/hexo-theme-next themes/next\n\n# 修复锚点不生效问题\ncp ./init_source/hexo-renderer-markdown-it/lib/renderer.js ./node_modules/hexo-renderer-markdown-it/lib/renderer.js\n\n# 自动配置 favicon\ncp ./init_source/next/_config.yml ./themes/next/_config.yml\n```\n\n### Git pull 下来的 Hexo 工程，hexo deploy 后将整个项目都 push 上去了\n\n每次 git pull 备份的工程后，需要清理一下 hexo 工程，具体方法如下：\n\n```bash\n$ cd adispring.github.io\nrm -rf .git .deploy_git hexo clean\n```\n\n","slug":"Hexo-Init","published":1,"updated":"2020-06-06T14:44:04.086Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitj000gf6mjud0nnck7","content":"<h2>Hexo 踩坑指南</h2>\n<h3>安装主题</h3>\n<p>我选用 <a href=\"https://github.com/theme-next/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">next</a> 主题，简洁、素雅</p>\n<p>安装指南：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> hexo</span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>\n<h3>favicon 配置</h3>\n<p>需要在 <code>themes/next/_config.yml</code> 中对 favicon 进行配置，我的配置如下</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Site Information Settings</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># To get or check favicons visit: https://realfavicongenerator.net</span></span><br><span class=\"line\"><span class=\"comment\"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span></span><br><span class=\"line\"><span class=\"comment\"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># For example, you put your favicons into `hexo-site/source/images` directory.</span></span><br><span class=\"line\"><span class=\"comment\"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span></span><br><span class=\"line\">favicon:</span><br><span class=\"line\">  small: /favicon.ico</span><br><span class=\"line\">  medium: /favicon.ico</span><br><span class=\"line\">  apple_touch_icon: /images/apple-touch-icon-next.ico</span><br><span class=\"line\">  safari_pinned_tab: /logo.svg</span><br><span class=\"line\">  <span class=\"comment\">#android_manifest: /images/manifest.json</span></span><br><span class=\"line\">  <span class=\"comment\">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure></p>\n<h3>关于锚点失效问题</h3>\n<p>这是 <a href=\"https://github.com/hexojs/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a> 的一个 bug，但作者不想修复，认为是其他库的坑，所以我们要参考这个 <a href=\"https://github.com/hexojs/hexo-renderer-markdown-it/issues/40\" target=\"_blank\" rel=\"noopener\">issue</a> ，手动到 node_modules 中修改该库，具体如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> MdIt = <span class=\"built_in\">require</span>(<span class=\"string\">'markdown-it'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cfg = <span class=\"keyword\">this</span>.config.markdown;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> opt = (cfg) ? cfg : <span class=\"string\">'default'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> parser = (opt === <span class=\"string\">'default'</span> || opt === <span class=\"string\">'commonmark'</span> || opt === <span class=\"string\">'zero'</span>) ?</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MdIt(opt) :</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MdIt(opt.render);</span><br><span class=\"line\"></span><br><span class=\"line\">  parser.use(<span class=\"built_in\">require</span>(<span class=\"string\">'markdown-it-named-headings'</span>)) <span class=\"comment\">// 只需要添加这行代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opt.plugins) &#123;</span><br><span class=\"line\">    parser = opt.plugins.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">parser, pugs</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> parser.use(<span class=\"built_in\">require</span>(pugs));</span><br><span class=\"line\">    &#125;, parser);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opt.anchors) &#123;</span><br><span class=\"line\">    parser = parser.use(<span class=\"built_in\">require</span>(<span class=\"string\">'./anchors'</span>), opt.anchors);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> parser.render(data.text);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3>自动化修复以上问题的脚本</h3>\n<p>写了一个自动化脚本，git pull 下我的博客备份后，自动安装、修复上述问题。</p>\n<p>运行工程目录下的 <code>./hexo-init.sh</code>，内容如下：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm i hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">yarn</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修复锚点不生效问题</span></span><br><span class=\"line\">cp ./init_source/hexo-renderer-markdown-it/lib/renderer.js ./node_modules/hexo-renderer-markdown-it/lib/renderer.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自动配置 favicon</span></span><br><span class=\"line\">cp ./init_source/next/_config.yml ./themes/next/_config.yml</span><br></pre></td></tr></table></figure></p>\n<h3>Git pull 下来的 Hexo 工程，hexo deploy 后将整个项目都 push 上去了</h3>\n<p>每次 git pull 备份的工程后，需要清理一下 hexo 工程，具体方法如下：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> adispring.github.io</span><br><span class=\"line\">rm -rf .git .deploy_git hexo clean</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2>Hexo 踩坑指南</h2>\n<h3>安装主题</h3>\n<p>我选用 <a href=\"https://github.com/theme-next/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">next</a> 主题，简洁、素雅</p>\n<p>安装指南：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> hexo</span><br><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>\n<h3>favicon 配置</h3>\n<p>需要在 <code>themes/next/_config.yml</code> 中对 favicon 进行配置，我的配置如下</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"><span class=\"comment\"># Site Information Settings</span></span><br><span class=\"line\"><span class=\"comment\"># ---------------------------------------------------------------</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># To get or check favicons visit: https://realfavicongenerator.net</span></span><br><span class=\"line\"><span class=\"comment\"># Put your favicons into `hexo-site/source/` (recommend) or `hexo-site/themes/next/source/images/` directory.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Default NexT favicons placed in `hexo-site/themes/next/source/images/` directory.</span></span><br><span class=\"line\"><span class=\"comment\"># And if you want to place your icons in `hexo-site/source/` root directory, you must remove `/images` prefix from pathes.</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># For example, you put your favicons into `hexo-site/source/images` directory.</span></span><br><span class=\"line\"><span class=\"comment\"># Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.</span></span><br><span class=\"line\">favicon:</span><br><span class=\"line\">  small: /favicon.ico</span><br><span class=\"line\">  medium: /favicon.ico</span><br><span class=\"line\">  apple_touch_icon: /images/apple-touch-icon-next.ico</span><br><span class=\"line\">  safari_pinned_tab: /logo.svg</span><br><span class=\"line\">  <span class=\"comment\">#android_manifest: /images/manifest.json</span></span><br><span class=\"line\">  <span class=\"comment\">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure></p>\n<h3>关于锚点失效问题</h3>\n<p>这是 <a href=\"https://github.com/hexojs/hexo-renderer-markdown-it\" target=\"_blank\" rel=\"noopener\">hexo-renderer-markdown-it</a> 的一个 bug，但作者不想修复，认为是其他库的坑，所以我们要参考这个 <a href=\"https://github.com/hexojs/hexo-renderer-markdown-it/issues/40\" target=\"_blank\" rel=\"noopener\">issue</a> ，手动到 node_modules 中修改该库，具体如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">'use strict'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">data, options</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> MdIt = <span class=\"built_in\">require</span>(<span class=\"string\">'markdown-it'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> cfg = <span class=\"keyword\">this</span>.config.markdown;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> opt = (cfg) ? cfg : <span class=\"string\">'default'</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> parser = (opt === <span class=\"string\">'default'</span> || opt === <span class=\"string\">'commonmark'</span> || opt === <span class=\"string\">'zero'</span>) ?</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MdIt(opt) :</span><br><span class=\"line\">    <span class=\"keyword\">new</span> MdIt(opt.render);</span><br><span class=\"line\"></span><br><span class=\"line\">  parser.use(<span class=\"built_in\">require</span>(<span class=\"string\">'markdown-it-named-headings'</span>)) <span class=\"comment\">// 只需要添加这行代码</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opt.plugins) &#123;</span><br><span class=\"line\">    parser = opt.plugins.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">parser, pugs</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> parser.use(<span class=\"built_in\">require</span>(pugs));</span><br><span class=\"line\">    &#125;, parser);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (opt.anchors) &#123;</span><br><span class=\"line\">    parser = parser.use(<span class=\"built_in\">require</span>(<span class=\"string\">'./anchors'</span>), opt.anchors);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> parser.render(data.text);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3>自动化修复以上问题的脚本</h3>\n<p>写了一个自动化脚本，git pull 下我的博客备份后，自动安装、修复上述问题。</p>\n<p>运行工程目录下的 <code>./hexo-init.sh</code>，内容如下：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/bash</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm i hexo-cli -g</span><br><span class=\"line\"></span><br><span class=\"line\">yarn</span><br><span class=\"line\"></span><br><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修复锚点不生效问题</span></span><br><span class=\"line\">cp ./init_source/hexo-renderer-markdown-it/lib/renderer.js ./node_modules/hexo-renderer-markdown-it/lib/renderer.js</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 自动配置 favicon</span></span><br><span class=\"line\">cp ./init_source/next/_config.yml ./themes/next/_config.yml</span><br></pre></td></tr></table></figure></p>\n<h3>Git pull 下来的 Hexo 工程，hexo deploy 后将整个项目都 push 上去了</h3>\n<p>每次 git pull 备份的工程后，需要清理一下 hexo 工程，具体方法如下：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> adispring.github.io</span><br><span class=\"line\">rm -rf .git .deploy_git hexo clean</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Practical Ramda: Recursion","date":"2017-11-10T16:10:07.000Z","_content":"本文首先介绍了递归的定义、实质、满足条件等，然后利用 Ramda API 和 [Spread & Rest](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) 操作符对递归进行实例讲解。\n\n# 递归的理论基础\n\n递归的定义：一种直接或者间接调用自身的过程。\n\n递归的实质：将待求解问题分解成规模缩小的同类子问题，然后递归调用方法来表示问题的解。是一个不断将问题拆分然后组合的过程。\n\n递归的过程：“能进则进，不进则退”。\n\n递归问题需满足的条件：\n\n1. 一个（或多个）基本情景 -- 一个不使用递归而产生结果的终止情景；\n2. 一组可以将所有其他情景归约至基本情景的规则。\n\n递归的条件归结为：一个终止条件和一组归约的规则。\n\n递归能让我们写出非常简洁、直观的代码，但简洁并不等于简单（容易）。递归是一种从总体到局部的思维过程，与传统的命令式的思维方式差异较大。命令式思维要求显示地提供详细的求解步骤，而递归（或者函数式）要求用概括性的语言对问题进行描述，问题的描述本身就是编程的整个过程，这要求我们具有很强的抽象思维和逻辑推理能力。\n\n递归的编程模式：\n\n1. 定义终止条件；\n2. 编写递归的归约规则。\n\n但如果语言中实现了惰性求值，也可以不定义终止条件，比如递归生成无限长的序列。\n\n以上便是递归的理论解释，下面我们通过一些实例对递归进行实际演示。\n\n# 递归的实践\n\n递归能够很好地处理列表和树形数据结构的很多问题。很多时候，我们解决问题的模式就是对不断缩小的列表或树反复做同一件事情。实际上，列表和树本身的构造也可以看做递归的过程。\n\n列表可以看作有列表首元素（头部）和其余元素（尾部）的组合，如下所示：\n\n```js\nvar list = R.prepend(1, R.prepend(2, R.prepend(3, []))); // => [1, 2, 3]\nvar list = [1, ...[2, ...[3, ...[]]]];\n```\n\n本文中我们使用 ramda 和 expect npm库进行演示：\n\n```js\nconst R = require('ramda');\nconst expect = require('expect');\n```\n\n## 快速排序\n\n下面以经典的快速排序为例开始递归算法的演示。快排的定义为：所有小于头部的元素（它们也需要排序）在先，大于头部的元素（它们也需要排序）在后，终止条件为空数组。\n\n首先我们用模式匹配 [R.cond](http://ramda.cn/docs/#cond) 的方式来进行递归排序。\n\n```js\nvar quickSort = R.cond(\n  [R.isEmpty, R.always([])],\n  [\n    R.T,\n    xs => {\n    const head = R.head(xs);\n    const tail = R.tail(xs);\n    return R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail)\n     .concat(head)\n     .concat(R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail));\n  }]\n);\n\nexpect(quickSort([5, 1, 9, 4, 6, 7, 3])).toEqual([1, 3, 4, 5, 6, 7, 9]);\n```\n\n快排的过程如下所示（借用 [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/recursion) 的图)：\n\n![quicksort](./quicksort.png)\n\n如果只有一个 `if-else` 对，我们也可以使用 [R.ifElse](http://ramda.cn/docs/#ifElse) 来代替 [R.cond](http://ramda.cn/docs/#cond)。另外，我们还可以用 [R.when](http://ramda.cn/docs/#when) 和 [R.unless](http://ramda.cn/docs/#unless) 来进一步简化 [R.ifElse](http://ramda.cn/docs/#ifElse)。\n\n使用 Ramda API 的递归规则还是有些冗长，我们可以使用 ES6 中的 [Spread & Rest](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) 操作符和 [R.unless](http://ramda.cn/docs/#unless) 对列表的头部元素和其他尾部元素的提取和组合进行简化，如下所示：\n\n```js\nvar quickSort = R.unless(\n  R.isEmpty,\n  ([head, ...tail]) => [\n    ...R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail),\n    head,\n    ...R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail),\n  ]\n);\n\nexpect(quickSort([5, 1, 9, 4, 6, 7, 3])).toEqual([1, 3, 4, 5, 6, 7, 9]);\n```\n\n## 斐波那契序列\n\n下面展示的是斐波那契序列, 斐波那契序列的数学表达式如下所示：\n\n- f(0) = 0\n- f(1) = 1\n- f(n) = f(n-1) + f(n-2)\n\n以序列元素值为半径的斐波那契螺旋线如下所示：\n\n![fibonacci](./fibonacci.jpg)\n\n代码实现如下：\n\n```js\nvar fib = n => R.unless(\n  R.contains(R.__, [0, 1]),\n  () => fib(n - 1) + fib(n - 2)\n)(n);\n\nexpect(fib(6)).toEqual(8);\n```\n\n## map、filter、reduce\n\n[map](http://ramda.cn/docs/#map)、[filter](http://ramda.cn/docs/#filter)、[reduce](http://ramda.cn/docs/#reduce) 作为函数式编程中处理列表的三个基本函数，在底层实现或者演示时，一般会采用命令式的 for 循环迭代来实现，既然列表本身可以看作递归结构，我们就用递归来尝试实现函数式编程中处理列表的 \"三镖客\"。\n\n首先以 `map` 为例，从命令式 for 循环实现开始，然后是递归实现，并在对递归实现的优化中展示函数式编程（或者说 Ramda 库）灵活、多变而又优雅的编程方式，体会什么才是真正的编程之美。\n\n\nmap 的 [Hindley-Milner](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html) 类型签名如下所示：\n\n```js\nmap :: Functor f => (a → b) → f a → f b\n```\n\n其实 `map` 是 [Functor](https://en.wikipedia.org/wiki/Functor) 的一个函数，Functor 是具体范畴之间的映射（态射），关于范畴、Functor、态射等函数式的概念不在本次的讨论范围之内，感兴趣的同学可以自己查看相关资料。在这里，可以将 Functor 看做是列表（列表是 Functor 的一个实例），`map` 看作不同类型列表之间的映射，将源列表中的元素进行转换，生成一个包含映射后元素的新列表。\n\n`map` 列表形式的类型签名如下：\n\n```js\nmap :: (a → b) → [a] → [b]\n```\n\n`map` 命令式实现：\n\n```js\nvar map = (fn, list) => {\n  var newList = [];\n  for (let i = 0; i < list.length; i++) {\n    newList[i] = fn(list[i]);\n  }\n  return newList;\n};\n\nexpect(map(R.multiply(2), R.range(1, 5))).toEqual([2, 4, 6, 8]);\n```\n\n`map` 递归实现1，三目运算符版：\n\n```js\nvar mapR = (fn, list) =>\n  (R.isEmpty(list) ? list : R.prepend(fn(R.head(list)), mapR(fn, R.tail(list))));\n```\n\n`map` 递归实现2，模式匹配（[R.cond](http://ramda.cn/docs/#cond)）版：\n\n```js\nvar mapR2 = (fn, list) => R.cond([\n  [R.isEmpty, R.identity],\n  [R.T, R.converge(R.prepend, [R.compose(fn, R.head), xs => mapR2(fn, R.tail(xs))])],\n])(list);\n```\n\n`map` 递归实现3，unless（[R.unless](http://ramda.cn/docs/#unless)）版：\n\n```js\nvar mapR3 = (fn, list) => R.unless(\n  R.isEmpty,\n  R.converge(R.prepend, [R.compose(fn, R.head), xs => mapR3(fn, R.tail(xs))])\n)(list);\n```\n\n`map` 递归实现4，[Spread Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)  + unless 版：\n\n```js\nvar mapR5 = (fn, xs) => R.unless(\n  R.isEmpty,\n  ([head, ...tail]) => [fn(head), ...mapR5(fn, tail)]\n)(xs);\n```\n\n总结一下上述命令式、递归实现以及递归的优化实现的特点。\n\n命令式实现需要显式写出内部的每步实现步骤，包括如何获取、变换和组合元素等；还使用了 mutable 的数据，包括全局的结果列表 `newList` 和 迭代索引 `i`。命令式的好处是符合正常的思维方式，但缺点是引入了较多冗余的 \"噪声\"，比如 for 循环、全局变量 `newList` 和 `i` 都是辅助项，这些辅助项稍微增多，代码复杂度会显著上升，真正有用的信息便会淹没在了这些 \"噪声\" 里面。\n\n反观递归式（函数式）的实现（如 `map` 的 `Spead Operator` + `unless` 版实现），我们只需要通过对问题的描述，便得到功能的实现。而描述的过程看似简单，实则内含了对问题本质的抽象和逻辑分析，对人们的思维能力要求更高。\n\n再讲一下 `Spead Operator` 语法糖。很多人不屑于用语法糖，态度往往是：这不就是 xxx 的语法糖吗？没什么大不了的啊。但语法上的便利其实也是很重要的一方面，因为我们想要表达的思想是要由语法来承载的。\n\n这里引用《函数式编程思维》中的一段话：\n\n> 我跟 Martin Fowler 在巴塞罗那的一辆出租车上有过一次记忆深刻的讨论，我们聊的是 Smalltalk 的衰落和 Java 的兴盛。Fowler 在这两种语言上都有很深厚的积累，他说，起初 他觉得从 Smalltalk 到 Java 的变化只是一些语法上的不便，结果却发现被阻碍的还有原先 语言所承载的思维方式。在语法处处掣肘下塑造出来的抽象，很难配合我们的思维过程而 不产生无谓的摩擦。\n\n\n下面对 `filter` 和 `reduce` 的递归实现做一个展示。\n\n`filter` 的递归实现如下：\n\n```js\nvar filterR = (pred, list) =>\n  R.isEmpty(list) ? list : pred(R.head(list)) ? R.prepend(R.head(list), filterR(pred, R.tail(list))) : filterR(pred, R.tail(list));\n\nvar filterR2 = (pred, list) => R.cond([\n  [R.isEmpty, R.identity],\n  [R.compose(pred, R.head), R.converge(R.prepend, [R.head, xs => filterR2(pred, R.tail(xs))])],\n  [R.T, xs => filterR2(pred, R.tail(xs))],\n])(list);\n\nvar filterR3 = (pred, list) => R.unless(\n  R.isEmpty,\n  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs => filterR3(pred, R.tail(xs))])\n)(list);\n\nvar filterR3 = (pred, list) => R.unless(\n  R.isEmpty,\n  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs => filterR3(pred, R.tail(xs))])\n)(list);\n\nvar filterR4 = (pred, list) => R.unless(\n  R.isEmpty,\n  ([head, ...tail]) => [...(pred(head) ? [head] : []), ...filterR4(pred, tail)]\n)(list);\n\nexpect(filterR(a => a % 2, R.range(1, 10))).toEqual([1, 3, 5, 7, 9]);\n```\n\nreduce 的递归实现如下：\n\n```js\nvar reduceR = (fn, acc, list) =>\n  (R.isEmpty(list) ? acc : reduceR(fn, fn(acc, R.head(list)), R.tail(list)));\n\nvar reduceR2 = (fn, acc, list) => R.cond([\n  [R.isEmpty, () => acc],\n  [R.T, xs => reduceR2(fn, fn(acc, R.head(xs)), R.tail(xs))],\n])(list);\n\nvar reduceR3 = (fn, acc, list) => R.ifElse(\n  R.isEmpty,\n  () => acc,\n  xs => reduceR3(fn, fn(acc, R.head(xs)), R.tail(xs))\n)(list);\n\nexpect(reduceR(R.add, 0, R.range(1, 5))).toEqual(10);\n```\n\n# 总结\n\n本文从递归的定义、实质等基本理论开始，然后是递归的一些实例，其中大量运用了 [ramda](http://ramda.cn) 函数式编程库中的 API，既是对递归的演示，也是对 ramda API 的实践展示。展示了递归和函数式在编程时的强悍的表达能力和对极致简约的追求。\n","source":"_posts/Practical-Ramda-Recursion.md","raw":"---\ntitle: 'Practical Ramda: Recursion'\ndate: 2017-11-11 00:10:07\ncategories: 'Practical Ramda'\n---\n本文首先介绍了递归的定义、实质、满足条件等，然后利用 Ramda API 和 [Spread & Rest](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) 操作符对递归进行实例讲解。\n\n# 递归的理论基础\n\n递归的定义：一种直接或者间接调用自身的过程。\n\n递归的实质：将待求解问题分解成规模缩小的同类子问题，然后递归调用方法来表示问题的解。是一个不断将问题拆分然后组合的过程。\n\n递归的过程：“能进则进，不进则退”。\n\n递归问题需满足的条件：\n\n1. 一个（或多个）基本情景 -- 一个不使用递归而产生结果的终止情景；\n2. 一组可以将所有其他情景归约至基本情景的规则。\n\n递归的条件归结为：一个终止条件和一组归约的规则。\n\n递归能让我们写出非常简洁、直观的代码，但简洁并不等于简单（容易）。递归是一种从总体到局部的思维过程，与传统的命令式的思维方式差异较大。命令式思维要求显示地提供详细的求解步骤，而递归（或者函数式）要求用概括性的语言对问题进行描述，问题的描述本身就是编程的整个过程，这要求我们具有很强的抽象思维和逻辑推理能力。\n\n递归的编程模式：\n\n1. 定义终止条件；\n2. 编写递归的归约规则。\n\n但如果语言中实现了惰性求值，也可以不定义终止条件，比如递归生成无限长的序列。\n\n以上便是递归的理论解释，下面我们通过一些实例对递归进行实际演示。\n\n# 递归的实践\n\n递归能够很好地处理列表和树形数据结构的很多问题。很多时候，我们解决问题的模式就是对不断缩小的列表或树反复做同一件事情。实际上，列表和树本身的构造也可以看做递归的过程。\n\n列表可以看作有列表首元素（头部）和其余元素（尾部）的组合，如下所示：\n\n```js\nvar list = R.prepend(1, R.prepend(2, R.prepend(3, []))); // => [1, 2, 3]\nvar list = [1, ...[2, ...[3, ...[]]]];\n```\n\n本文中我们使用 ramda 和 expect npm库进行演示：\n\n```js\nconst R = require('ramda');\nconst expect = require('expect');\n```\n\n## 快速排序\n\n下面以经典的快速排序为例开始递归算法的演示。快排的定义为：所有小于头部的元素（它们也需要排序）在先，大于头部的元素（它们也需要排序）在后，终止条件为空数组。\n\n首先我们用模式匹配 [R.cond](http://ramda.cn/docs/#cond) 的方式来进行递归排序。\n\n```js\nvar quickSort = R.cond(\n  [R.isEmpty, R.always([])],\n  [\n    R.T,\n    xs => {\n    const head = R.head(xs);\n    const tail = R.tail(xs);\n    return R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail)\n     .concat(head)\n     .concat(R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail));\n  }]\n);\n\nexpect(quickSort([5, 1, 9, 4, 6, 7, 3])).toEqual([1, 3, 4, 5, 6, 7, 9]);\n```\n\n快排的过程如下所示（借用 [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/recursion) 的图)：\n\n![quicksort](./quicksort.png)\n\n如果只有一个 `if-else` 对，我们也可以使用 [R.ifElse](http://ramda.cn/docs/#ifElse) 来代替 [R.cond](http://ramda.cn/docs/#cond)。另外，我们还可以用 [R.when](http://ramda.cn/docs/#when) 和 [R.unless](http://ramda.cn/docs/#unless) 来进一步简化 [R.ifElse](http://ramda.cn/docs/#ifElse)。\n\n使用 Ramda API 的递归规则还是有些冗长，我们可以使用 ES6 中的 [Spread & Rest](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator) 操作符和 [R.unless](http://ramda.cn/docs/#unless) 对列表的头部元素和其他尾部元素的提取和组合进行简化，如下所示：\n\n```js\nvar quickSort = R.unless(\n  R.isEmpty,\n  ([head, ...tail]) => [\n    ...R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail),\n    head,\n    ...R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail),\n  ]\n);\n\nexpect(quickSort([5, 1, 9, 4, 6, 7, 3])).toEqual([1, 3, 4, 5, 6, 7, 9]);\n```\n\n## 斐波那契序列\n\n下面展示的是斐波那契序列, 斐波那契序列的数学表达式如下所示：\n\n- f(0) = 0\n- f(1) = 1\n- f(n) = f(n-1) + f(n-2)\n\n以序列元素值为半径的斐波那契螺旋线如下所示：\n\n![fibonacci](./fibonacci.jpg)\n\n代码实现如下：\n\n```js\nvar fib = n => R.unless(\n  R.contains(R.__, [0, 1]),\n  () => fib(n - 1) + fib(n - 2)\n)(n);\n\nexpect(fib(6)).toEqual(8);\n```\n\n## map、filter、reduce\n\n[map](http://ramda.cn/docs/#map)、[filter](http://ramda.cn/docs/#filter)、[reduce](http://ramda.cn/docs/#reduce) 作为函数式编程中处理列表的三个基本函数，在底层实现或者演示时，一般会采用命令式的 for 循环迭代来实现，既然列表本身可以看作递归结构，我们就用递归来尝试实现函数式编程中处理列表的 \"三镖客\"。\n\n首先以 `map` 为例，从命令式 for 循环实现开始，然后是递归实现，并在对递归实现的优化中展示函数式编程（或者说 Ramda 库）灵活、多变而又优雅的编程方式，体会什么才是真正的编程之美。\n\n\nmap 的 [Hindley-Milner](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html) 类型签名如下所示：\n\n```js\nmap :: Functor f => (a → b) → f a → f b\n```\n\n其实 `map` 是 [Functor](https://en.wikipedia.org/wiki/Functor) 的一个函数，Functor 是具体范畴之间的映射（态射），关于范畴、Functor、态射等函数式的概念不在本次的讨论范围之内，感兴趣的同学可以自己查看相关资料。在这里，可以将 Functor 看做是列表（列表是 Functor 的一个实例），`map` 看作不同类型列表之间的映射，将源列表中的元素进行转换，生成一个包含映射后元素的新列表。\n\n`map` 列表形式的类型签名如下：\n\n```js\nmap :: (a → b) → [a] → [b]\n```\n\n`map` 命令式实现：\n\n```js\nvar map = (fn, list) => {\n  var newList = [];\n  for (let i = 0; i < list.length; i++) {\n    newList[i] = fn(list[i]);\n  }\n  return newList;\n};\n\nexpect(map(R.multiply(2), R.range(1, 5))).toEqual([2, 4, 6, 8]);\n```\n\n`map` 递归实现1，三目运算符版：\n\n```js\nvar mapR = (fn, list) =>\n  (R.isEmpty(list) ? list : R.prepend(fn(R.head(list)), mapR(fn, R.tail(list))));\n```\n\n`map` 递归实现2，模式匹配（[R.cond](http://ramda.cn/docs/#cond)）版：\n\n```js\nvar mapR2 = (fn, list) => R.cond([\n  [R.isEmpty, R.identity],\n  [R.T, R.converge(R.prepend, [R.compose(fn, R.head), xs => mapR2(fn, R.tail(xs))])],\n])(list);\n```\n\n`map` 递归实现3，unless（[R.unless](http://ramda.cn/docs/#unless)）版：\n\n```js\nvar mapR3 = (fn, list) => R.unless(\n  R.isEmpty,\n  R.converge(R.prepend, [R.compose(fn, R.head), xs => mapR3(fn, R.tail(xs))])\n)(list);\n```\n\n`map` 递归实现4，[Spread Operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)  + unless 版：\n\n```js\nvar mapR5 = (fn, xs) => R.unless(\n  R.isEmpty,\n  ([head, ...tail]) => [fn(head), ...mapR5(fn, tail)]\n)(xs);\n```\n\n总结一下上述命令式、递归实现以及递归的优化实现的特点。\n\n命令式实现需要显式写出内部的每步实现步骤，包括如何获取、变换和组合元素等；还使用了 mutable 的数据，包括全局的结果列表 `newList` 和 迭代索引 `i`。命令式的好处是符合正常的思维方式，但缺点是引入了较多冗余的 \"噪声\"，比如 for 循环、全局变量 `newList` 和 `i` 都是辅助项，这些辅助项稍微增多，代码复杂度会显著上升，真正有用的信息便会淹没在了这些 \"噪声\" 里面。\n\n反观递归式（函数式）的实现（如 `map` 的 `Spead Operator` + `unless` 版实现），我们只需要通过对问题的描述，便得到功能的实现。而描述的过程看似简单，实则内含了对问题本质的抽象和逻辑分析，对人们的思维能力要求更高。\n\n再讲一下 `Spead Operator` 语法糖。很多人不屑于用语法糖，态度往往是：这不就是 xxx 的语法糖吗？没什么大不了的啊。但语法上的便利其实也是很重要的一方面，因为我们想要表达的思想是要由语法来承载的。\n\n这里引用《函数式编程思维》中的一段话：\n\n> 我跟 Martin Fowler 在巴塞罗那的一辆出租车上有过一次记忆深刻的讨论，我们聊的是 Smalltalk 的衰落和 Java 的兴盛。Fowler 在这两种语言上都有很深厚的积累，他说，起初 他觉得从 Smalltalk 到 Java 的变化只是一些语法上的不便，结果却发现被阻碍的还有原先 语言所承载的思维方式。在语法处处掣肘下塑造出来的抽象，很难配合我们的思维过程而 不产生无谓的摩擦。\n\n\n下面对 `filter` 和 `reduce` 的递归实现做一个展示。\n\n`filter` 的递归实现如下：\n\n```js\nvar filterR = (pred, list) =>\n  R.isEmpty(list) ? list : pred(R.head(list)) ? R.prepend(R.head(list), filterR(pred, R.tail(list))) : filterR(pred, R.tail(list));\n\nvar filterR2 = (pred, list) => R.cond([\n  [R.isEmpty, R.identity],\n  [R.compose(pred, R.head), R.converge(R.prepend, [R.head, xs => filterR2(pred, R.tail(xs))])],\n  [R.T, xs => filterR2(pred, R.tail(xs))],\n])(list);\n\nvar filterR3 = (pred, list) => R.unless(\n  R.isEmpty,\n  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs => filterR3(pred, R.tail(xs))])\n)(list);\n\nvar filterR3 = (pred, list) => R.unless(\n  R.isEmpty,\n  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs => filterR3(pred, R.tail(xs))])\n)(list);\n\nvar filterR4 = (pred, list) => R.unless(\n  R.isEmpty,\n  ([head, ...tail]) => [...(pred(head) ? [head] : []), ...filterR4(pred, tail)]\n)(list);\n\nexpect(filterR(a => a % 2, R.range(1, 10))).toEqual([1, 3, 5, 7, 9]);\n```\n\nreduce 的递归实现如下：\n\n```js\nvar reduceR = (fn, acc, list) =>\n  (R.isEmpty(list) ? acc : reduceR(fn, fn(acc, R.head(list)), R.tail(list)));\n\nvar reduceR2 = (fn, acc, list) => R.cond([\n  [R.isEmpty, () => acc],\n  [R.T, xs => reduceR2(fn, fn(acc, R.head(xs)), R.tail(xs))],\n])(list);\n\nvar reduceR3 = (fn, acc, list) => R.ifElse(\n  R.isEmpty,\n  () => acc,\n  xs => reduceR3(fn, fn(acc, R.head(xs)), R.tail(xs))\n)(list);\n\nexpect(reduceR(R.add, 0, R.range(1, 5))).toEqual(10);\n```\n\n# 总结\n\n本文从递归的定义、实质等基本理论开始，然后是递归的一些实例，其中大量运用了 [ramda](http://ramda.cn) 函数式编程库中的 API，既是对递归的演示，也是对 ramda API 的实践展示。展示了递归和函数式在编程时的强悍的表达能力和对极致简约的追求。\n","slug":"Practical-Ramda-Recursion","published":1,"updated":"2020-06-06T14:44:04.087Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitk000hf6mjsmhvf8lj","content":"<p>本文首先介绍了递归的定义、实质、满足条件等，然后利用 Ramda API 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread &amp; Rest</a> 操作符对递归进行实例讲解。</p>\n<h1>递归的理论基础</h1>\n<p>递归的定义：一种直接或者间接调用自身的过程。</p>\n<p>递归的实质：将待求解问题分解成规模缩小的同类子问题，然后递归调用方法来表示问题的解。是一个不断将问题拆分然后组合的过程。</p>\n<p>递归的过程：“能进则进，不进则退”。</p>\n<p>递归问题需满足的条件：</p>\n<ol>\n<li>一个（或多个）基本情景 -- 一个不使用递归而产生结果的终止情景；</li>\n<li>一组可以将所有其他情景归约至基本情景的规则。</li>\n</ol>\n<p>递归的条件归结为：一个终止条件和一组归约的规则。</p>\n<p>递归能让我们写出非常简洁、直观的代码，但简洁并不等于简单（容易）。递归是一种从总体到局部的思维过程，与传统的命令式的思维方式差异较大。命令式思维要求显示地提供详细的求解步骤，而递归（或者函数式）要求用概括性的语言对问题进行描述，问题的描述本身就是编程的整个过程，这要求我们具有很强的抽象思维和逻辑推理能力。</p>\n<p>递归的编程模式：</p>\n<ol>\n<li>定义终止条件；</li>\n<li>编写递归的归约规则。</li>\n</ol>\n<p>但如果语言中实现了惰性求值，也可以不定义终止条件，比如递归生成无限长的序列。</p>\n<p>以上便是递归的理论解释，下面我们通过一些实例对递归进行实际演示。</p>\n<h1>递归的实践</h1>\n<p>递归能够很好地处理列表和树形数据结构的很多问题。很多时候，我们解决问题的模式就是对不断缩小的列表或树反复做同一件事情。实际上，列表和树本身的构造也可以看做递归的过程。</p>\n<p>列表可以看作有列表首元素（头部）和其余元素（尾部）的组合，如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = R.prepend(<span class=\"number\">1</span>, R.prepend(<span class=\"number\">2</span>, R.prepend(<span class=\"number\">3</span>, []))); <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, ...[<span class=\"number\">2</span>, ...[<span class=\"number\">3</span>, ...[]]]];</span><br></pre></td></tr></table></figure></p>\n<p>本文中我们使用 ramda 和 expect npm库进行演示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> R = <span class=\"built_in\">require</span>(<span class=\"string\">'ramda'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'expect'</span>);</span><br></pre></td></tr></table></figure></p>\n<h2>快速排序</h2>\n<p>下面以经典的快速排序为例开始递归算法的演示。快排的定义为：所有小于头部的元素（它们也需要排序）在先，大于头部的元素（它们也需要排序）在后，终止条件为空数组。</p>\n<p>首先我们用模式匹配 <a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">R.cond</a> 的方式来进行递归排序。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quickSort = R.cond(</span><br><span class=\"line\">  [R.isEmpty, R.always([])],</span><br><span class=\"line\">  [</span><br><span class=\"line\">    R.T,</span><br><span class=\"line\">    xs =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> head = R.head(xs);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tail = R.tail(xs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail)</span><br><span class=\"line\">     .concat(head)</span><br><span class=\"line\">     .concat(R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail));</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(quickSort([<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>])).toEqual([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>快排的过程如下所示（借用 <a href=\"http://learnyouahaskell.com/recursion\" target=\"_blank\" rel=\"noopener\">Learn You a Haskell for Great Good!</a> 的图)：</p>\n<p><img src=\"./quicksort.png\" alt=\"quicksort\"></p>\n<p>如果只有一个 <code>if-else</code> 对，我们也可以使用 <a href=\"http://ramda.cn/docs/#ifElse\" target=\"_blank\" rel=\"noopener\">R.ifElse</a> 来代替 <a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">R.cond</a>。另外，我们还可以用 <a href=\"http://ramda.cn/docs/#when\" target=\"_blank\" rel=\"noopener\">R.when</a> 和 <a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">R.unless</a> 来进一步简化 <a href=\"http://ramda.cn/docs/#ifElse\" target=\"_blank\" rel=\"noopener\">R.ifElse</a>。</p>\n<p>使用 Ramda API 的递归规则还是有些冗长，我们可以使用 ES6 中的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread &amp; Rest</a> 操作符和 <a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">R.unless</a> 对列表的头部元素和其他尾部元素的提取和组合进行简化，如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quickSort = R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  ([head, ...tail]) =&gt; [</span><br><span class=\"line\">    ...R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail),</span><br><span class=\"line\">    head,</span><br><span class=\"line\">    ...R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail),</span><br><span class=\"line\">  ]</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(quickSort([<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>])).toEqual([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]);</span><br></pre></td></tr></table></figure></p>\n<h2>斐波那契序列</h2>\n<p>下面展示的是斐波那契序列, 斐波那契序列的数学表达式如下所示：</p>\n<ul>\n<li>f(0) = 0</li>\n<li>f(1) = 1</li>\n<li>f(n) = f(n-1) + f(n-2)</li>\n</ul>\n<p>以序列元素值为半径的斐波那契螺旋线如下所示：</p>\n<p><img src=\"./fibonacci.jpg\" alt=\"fibonacci\"></p>\n<p>代码实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fib = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> R.unless(</span><br><span class=\"line\">  R.contains(R.__, [<span class=\"number\">0</span>, <span class=\"number\">1</span>]),</span><br><span class=\"line\">  () =&gt; fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>)</span><br><span class=\"line\">)(n);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(fib(<span class=\"number\">6</span>)).toEqual(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure></p>\n<h2>map、filter、reduce</h2>\n<p><a href=\"http://ramda.cn/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>、<a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a>、<a href=\"http://ramda.cn/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a> 作为函数式编程中处理列表的三个基本函数，在底层实现或者演示时，一般会采用命令式的 for 循环迭代来实现，既然列表本身可以看作递归结构，我们就用递归来尝试实现函数式编程中处理列表的 &quot;三镖客&quot;。</p>\n<p>首先以 <code>map</code> 为例，从命令式 for 循环实现开始，然后是递归实现，并在对递归实现的优化中展示函数式编程（或者说 Ramda 库）灵活、多变而又优雅的编程方式，体会什么才是真正的编程之美。</p>\n<p>map 的 <a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html\" target=\"_blank\" rel=\"noopener\">Hindley-Milner</a> 类型签名如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map :: Functor f =&gt; (a → b) → f a → f b</span><br></pre></td></tr></table></figure></p>\n<p>其实 <code>map</code> 是 <a href=\"https://en.wikipedia.org/wiki/Functor\" target=\"_blank\" rel=\"noopener\">Functor</a> 的一个函数，Functor 是具体范畴之间的映射（态射），关于范畴、Functor、态射等函数式的概念不在本次的讨论范围之内，感兴趣的同学可以自己查看相关资料。在这里，可以将 Functor 看做是列表（列表是 Functor 的一个实例），<code>map</code> 看作不同类型列表之间的映射，将源列表中的元素进行转换，生成一个包含映射后元素的新列表。</p>\n<p><code>map</code> 列表形式的类型签名如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map :: (a → b) → [a] → [b]</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 命令式实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newList = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; list.length; i++) &#123;</span><br><span class=\"line\">    newList[i] = fn(list[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newList;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">expect(map(R.multiply(<span class=\"number\">2</span>), R.range(<span class=\"number\">1</span>, <span class=\"number\">5</span>))).toEqual([<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现1，三目运算符版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span></span><br><span class=\"line\">  (R.isEmpty(list) ? list : R.prepend(fn(R.head(list)), mapR(fn, R.tail(list))));</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现2，模式匹配（<a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">R.cond</a>）版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR2 = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span> R.cond([</span><br><span class=\"line\">  [R.isEmpty, R.identity],</span><br><span class=\"line\">  [R.T, R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR2(fn, R.tail(xs))])],</span><br><span class=\"line\">])(list);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现3，unless（<a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">R.unless</a>）版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR3 = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR3(fn, R.tail(xs))])</span><br><span class=\"line\">)(list);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现4，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread Operator</a>  + unless 版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR5 = <span class=\"function\">(<span class=\"params\">fn, xs</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  ([head, ...tail]) =&gt; [fn(head), ...mapR5(fn, tail)]</span><br><span class=\"line\">)(xs);</span><br></pre></td></tr></table></figure></p>\n<p>总结一下上述命令式、递归实现以及递归的优化实现的特点。</p>\n<p>命令式实现需要显式写出内部的每步实现步骤，包括如何获取、变换和组合元素等；还使用了 mutable 的数据，包括全局的结果列表 <code>newList</code> 和 迭代索引 <code>i</code>。命令式的好处是符合正常的思维方式，但缺点是引入了较多冗余的 &quot;噪声&quot;，比如 for 循环、全局变量 <code>newList</code> 和 <code>i</code> 都是辅助项，这些辅助项稍微增多，代码复杂度会显著上升，真正有用的信息便会淹没在了这些 &quot;噪声&quot; 里面。</p>\n<p>反观递归式（函数式）的实现（如 <code>map</code> 的 <code>Spead Operator</code> + <code>unless</code> 版实现），我们只需要通过对问题的描述，便得到功能的实现。而描述的过程看似简单，实则内含了对问题本质的抽象和逻辑分析，对人们的思维能力要求更高。</p>\n<p>再讲一下 <code>Spead Operator</code> 语法糖。很多人不屑于用语法糖，态度往往是：这不就是 xxx 的语法糖吗？没什么大不了的啊。但语法上的便利其实也是很重要的一方面，因为我们想要表达的思想是要由语法来承载的。</p>\n<p>这里引用《函数式编程思维》中的一段话：</p>\n<blockquote>\n<p>我跟 Martin Fowler 在巴塞罗那的一辆出租车上有过一次记忆深刻的讨论，我们聊的是 Smalltalk 的衰落和 Java 的兴盛。Fowler 在这两种语言上都有很深厚的积累，他说，起初 他觉得从 Smalltalk 到 Java 的变化只是一些语法上的不便，结果却发现被阻碍的还有原先 语言所承载的思维方式。在语法处处掣肘下塑造出来的抽象，很难配合我们的思维过程而 不产生无谓的摩擦。</p>\n</blockquote>\n<p>下面对 <code>filter</code> 和 <code>reduce</code> 的递归实现做一个展示。</p>\n<p><code>filter</code> 的递归实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filterR = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span></span><br><span class=\"line\">  R.isEmpty(list) ? list : pred(R.head(list)) ? R.prepend(R.head(list), filterR(pred, R.tail(list))) : filterR(pred, R.tail(list));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR2 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.cond([</span><br><span class=\"line\">  [R.isEmpty, R.identity],</span><br><span class=\"line\">  [R.compose(pred, R.head), R.converge(R.prepend, [R.head, xs =&gt; filterR2(pred, R.tail(xs))])],</span><br><span class=\"line\">  [R.T, xs =&gt; filterR2(pred, R.tail(xs))],</span><br><span class=\"line\">])(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR3 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR3 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR4 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  ([head, ...tail]) =&gt; [...(pred(head) ? [head] : []), ...filterR4(pred, tail)]</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(filterR(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a % <span class=\"number\">2</span>, R.range(<span class=\"number\">1</span>, <span class=\"number\">10</span>))).toEqual([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>reduce 的递归实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reduceR = <span class=\"function\">(<span class=\"params\">fn, acc, list</span>) =&gt;</span></span><br><span class=\"line\">  (R.isEmpty(list) ? acc : reduceR(fn, fn(acc, R.head(list)), R.tail(list)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduceR2 = <span class=\"function\">(<span class=\"params\">fn, acc, list</span>) =&gt;</span> R.cond([</span><br><span class=\"line\">  [R.isEmpty, () =&gt; acc],</span><br><span class=\"line\">  [R.T, xs =&gt; reduceR2(fn, fn(acc, R.head(xs)), R.tail(xs))],</span><br><span class=\"line\">])(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduceR3 = <span class=\"function\">(<span class=\"params\">fn, acc, list</span>) =&gt;</span> R.ifElse(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  () =&gt; acc,</span><br><span class=\"line\">  xs =&gt; reduceR3(fn, fn(acc, R.head(xs)), R.tail(xs))</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(reduceR(R.add, <span class=\"number\">0</span>, R.range(<span class=\"number\">1</span>, <span class=\"number\">5</span>))).toEqual(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></p>\n<h1>总结</h1>\n<p>本文从递归的定义、实质等基本理论开始，然后是递归的一些实例，其中大量运用了 <a href=\"http://ramda.cn\" target=\"_blank\" rel=\"noopener\">ramda</a> 函数式编程库中的 API，既是对递归的演示，也是对 ramda API 的实践展示。展示了递归和函数式在编程时的强悍的表达能力和对极致简约的追求。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文首先介绍了递归的定义、实质、满足条件等，然后利用 Ramda API 和 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread &amp; Rest</a> 操作符对递归进行实例讲解。</p>\n<h1>递归的理论基础</h1>\n<p>递归的定义：一种直接或者间接调用自身的过程。</p>\n<p>递归的实质：将待求解问题分解成规模缩小的同类子问题，然后递归调用方法来表示问题的解。是一个不断将问题拆分然后组合的过程。</p>\n<p>递归的过程：“能进则进，不进则退”。</p>\n<p>递归问题需满足的条件：</p>\n<ol>\n<li>一个（或多个）基本情景 -- 一个不使用递归而产生结果的终止情景；</li>\n<li>一组可以将所有其他情景归约至基本情景的规则。</li>\n</ol>\n<p>递归的条件归结为：一个终止条件和一组归约的规则。</p>\n<p>递归能让我们写出非常简洁、直观的代码，但简洁并不等于简单（容易）。递归是一种从总体到局部的思维过程，与传统的命令式的思维方式差异较大。命令式思维要求显示地提供详细的求解步骤，而递归（或者函数式）要求用概括性的语言对问题进行描述，问题的描述本身就是编程的整个过程，这要求我们具有很强的抽象思维和逻辑推理能力。</p>\n<p>递归的编程模式：</p>\n<ol>\n<li>定义终止条件；</li>\n<li>编写递归的归约规则。</li>\n</ol>\n<p>但如果语言中实现了惰性求值，也可以不定义终止条件，比如递归生成无限长的序列。</p>\n<p>以上便是递归的理论解释，下面我们通过一些实例对递归进行实际演示。</p>\n<h1>递归的实践</h1>\n<p>递归能够很好地处理列表和树形数据结构的很多问题。很多时候，我们解决问题的模式就是对不断缩小的列表或树反复做同一件事情。实际上，列表和树本身的构造也可以看做递归的过程。</p>\n<p>列表可以看作有列表首元素（头部）和其余元素（尾部）的组合，如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = R.prepend(<span class=\"number\">1</span>, R.prepend(<span class=\"number\">2</span>, R.prepend(<span class=\"number\">3</span>, []))); <span class=\"comment\">// =&gt; [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> list = [<span class=\"number\">1</span>, ...[<span class=\"number\">2</span>, ...[<span class=\"number\">3</span>, ...[]]]];</span><br></pre></td></tr></table></figure></p>\n<p>本文中我们使用 ramda 和 expect npm库进行演示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> R = <span class=\"built_in\">require</span>(<span class=\"string\">'ramda'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> expect = <span class=\"built_in\">require</span>(<span class=\"string\">'expect'</span>);</span><br></pre></td></tr></table></figure></p>\n<h2>快速排序</h2>\n<p>下面以经典的快速排序为例开始递归算法的演示。快排的定义为：所有小于头部的元素（它们也需要排序）在先，大于头部的元素（它们也需要排序）在后，终止条件为空数组。</p>\n<p>首先我们用模式匹配 <a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">R.cond</a> 的方式来进行递归排序。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quickSort = R.cond(</span><br><span class=\"line\">  [R.isEmpty, R.always([])],</span><br><span class=\"line\">  [</span><br><span class=\"line\">    R.T,</span><br><span class=\"line\">    xs =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> head = R.head(xs);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> tail = R.tail(xs);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail)</span><br><span class=\"line\">     .concat(head)</span><br><span class=\"line\">     .concat(R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail));</span><br><span class=\"line\">  &#125;]</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(quickSort([<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>])).toEqual([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>快排的过程如下所示（借用 <a href=\"http://learnyouahaskell.com/recursion\" target=\"_blank\" rel=\"noopener\">Learn You a Haskell for Great Good!</a> 的图)：</p>\n<p><img src=\"./quicksort.png\" alt=\"quicksort\"></p>\n<p>如果只有一个 <code>if-else</code> 对，我们也可以使用 <a href=\"http://ramda.cn/docs/#ifElse\" target=\"_blank\" rel=\"noopener\">R.ifElse</a> 来代替 <a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">R.cond</a>。另外，我们还可以用 <a href=\"http://ramda.cn/docs/#when\" target=\"_blank\" rel=\"noopener\">R.when</a> 和 <a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">R.unless</a> 来进一步简化 <a href=\"http://ramda.cn/docs/#ifElse\" target=\"_blank\" rel=\"noopener\">R.ifElse</a>。</p>\n<p>使用 Ramda API 的递归规则还是有些冗长，我们可以使用 ES6 中的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread &amp; Rest</a> 操作符和 <a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">R.unless</a> 对列表的头部元素和其他尾部元素的提取和组合进行简化，如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> quickSort = R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  ([head, ...tail]) =&gt; [</span><br><span class=\"line\">    ...R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail),</span><br><span class=\"line\">    head,</span><br><span class=\"line\">    ...R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail),</span><br><span class=\"line\">  ]</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(quickSort([<span class=\"number\">5</span>, <span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>])).toEqual([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]);</span><br></pre></td></tr></table></figure></p>\n<h2>斐波那契序列</h2>\n<p>下面展示的是斐波那契序列, 斐波那契序列的数学表达式如下所示：</p>\n<ul>\n<li>f(0) = 0</li>\n<li>f(1) = 1</li>\n<li>f(n) = f(n-1) + f(n-2)</li>\n</ul>\n<p>以序列元素值为半径的斐波那契螺旋线如下所示：</p>\n<p><img src=\"./fibonacci.jpg\" alt=\"fibonacci\"></p>\n<p>代码实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> fib = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> R.unless(</span><br><span class=\"line\">  R.contains(R.__, [<span class=\"number\">0</span>, <span class=\"number\">1</span>]),</span><br><span class=\"line\">  () =&gt; fib(n - <span class=\"number\">1</span>) + fib(n - <span class=\"number\">2</span>)</span><br><span class=\"line\">)(n);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(fib(<span class=\"number\">6</span>)).toEqual(<span class=\"number\">8</span>);</span><br></pre></td></tr></table></figure></p>\n<h2>map、filter、reduce</h2>\n<p><a href=\"http://ramda.cn/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a>、<a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a>、<a href=\"http://ramda.cn/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a> 作为函数式编程中处理列表的三个基本函数，在底层实现或者演示时，一般会采用命令式的 for 循环迭代来实现，既然列表本身可以看作递归结构，我们就用递归来尝试实现函数式编程中处理列表的 &quot;三镖客&quot;。</p>\n<p>首先以 <code>map</code> 为例，从命令式 for 循环实现开始，然后是递归实现，并在对递归实现的优化中展示函数式编程（或者说 Ramda 库）灵活、多变而又优雅的编程方式，体会什么才是真正的编程之美。</p>\n<p>map 的 <a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html\" target=\"_blank\" rel=\"noopener\">Hindley-Milner</a> 类型签名如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map :: Functor f =&gt; (a → b) → f a → f b</span><br></pre></td></tr></table></figure></p>\n<p>其实 <code>map</code> 是 <a href=\"https://en.wikipedia.org/wiki/Functor\" target=\"_blank\" rel=\"noopener\">Functor</a> 的一个函数，Functor 是具体范畴之间的映射（态射），关于范畴、Functor、态射等函数式的概念不在本次的讨论范围之内，感兴趣的同学可以自己查看相关资料。在这里，可以将 Functor 看做是列表（列表是 Functor 的一个实例），<code>map</code> 看作不同类型列表之间的映射，将源列表中的元素进行转换，生成一个包含映射后元素的新列表。</p>\n<p><code>map</code> 列表形式的类型签名如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map :: (a → b) → [a] → [b]</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 命令式实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> newList = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; list.length; i++) &#123;</span><br><span class=\"line\">    newList[i] = fn(list[i]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newList;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">expect(map(R.multiply(<span class=\"number\">2</span>), R.range(<span class=\"number\">1</span>, <span class=\"number\">5</span>))).toEqual([<span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>]);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现1，三目运算符版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span></span><br><span class=\"line\">  (R.isEmpty(list) ? list : R.prepend(fn(R.head(list)), mapR(fn, R.tail(list))));</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现2，模式匹配（<a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">R.cond</a>）版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR2 = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span> R.cond([</span><br><span class=\"line\">  [R.isEmpty, R.identity],</span><br><span class=\"line\">  [R.T, R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR2(fn, R.tail(xs))])],</span><br><span class=\"line\">])(list);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现3，unless（<a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">R.unless</a>）版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR3 = <span class=\"function\">(<span class=\"params\">fn, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR3(fn, R.tail(xs))])</span><br><span class=\"line\">)(list);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> 递归实现4，<a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator\" target=\"_blank\" rel=\"noopener\">Spread Operator</a>  + unless 版：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> mapR5 = <span class=\"function\">(<span class=\"params\">fn, xs</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  ([head, ...tail]) =&gt; [fn(head), ...mapR5(fn, tail)]</span><br><span class=\"line\">)(xs);</span><br></pre></td></tr></table></figure></p>\n<p>总结一下上述命令式、递归实现以及递归的优化实现的特点。</p>\n<p>命令式实现需要显式写出内部的每步实现步骤，包括如何获取、变换和组合元素等；还使用了 mutable 的数据，包括全局的结果列表 <code>newList</code> 和 迭代索引 <code>i</code>。命令式的好处是符合正常的思维方式，但缺点是引入了较多冗余的 &quot;噪声&quot;，比如 for 循环、全局变量 <code>newList</code> 和 <code>i</code> 都是辅助项，这些辅助项稍微增多，代码复杂度会显著上升，真正有用的信息便会淹没在了这些 &quot;噪声&quot; 里面。</p>\n<p>反观递归式（函数式）的实现（如 <code>map</code> 的 <code>Spead Operator</code> + <code>unless</code> 版实现），我们只需要通过对问题的描述，便得到功能的实现。而描述的过程看似简单，实则内含了对问题本质的抽象和逻辑分析，对人们的思维能力要求更高。</p>\n<p>再讲一下 <code>Spead Operator</code> 语法糖。很多人不屑于用语法糖，态度往往是：这不就是 xxx 的语法糖吗？没什么大不了的啊。但语法上的便利其实也是很重要的一方面，因为我们想要表达的思想是要由语法来承载的。</p>\n<p>这里引用《函数式编程思维》中的一段话：</p>\n<blockquote>\n<p>我跟 Martin Fowler 在巴塞罗那的一辆出租车上有过一次记忆深刻的讨论，我们聊的是 Smalltalk 的衰落和 Java 的兴盛。Fowler 在这两种语言上都有很深厚的积累，他说，起初 他觉得从 Smalltalk 到 Java 的变化只是一些语法上的不便，结果却发现被阻碍的还有原先 语言所承载的思维方式。在语法处处掣肘下塑造出来的抽象，很难配合我们的思维过程而 不产生无谓的摩擦。</p>\n</blockquote>\n<p>下面对 <code>filter</code> 和 <code>reduce</code> 的递归实现做一个展示。</p>\n<p><code>filter</code> 的递归实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> filterR = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span></span><br><span class=\"line\">  R.isEmpty(list) ? list : pred(R.head(list)) ? R.prepend(R.head(list), filterR(pred, R.tail(list))) : filterR(pred, R.tail(list));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR2 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.cond([</span><br><span class=\"line\">  [R.isEmpty, R.identity],</span><br><span class=\"line\">  [R.compose(pred, R.head), R.converge(R.prepend, [R.head, xs =&gt; filterR2(pred, R.tail(xs))])],</span><br><span class=\"line\">  [R.T, xs =&gt; filterR2(pred, R.tail(xs))],</span><br><span class=\"line\">])(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR3 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR3 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> filterR4 = <span class=\"function\">(<span class=\"params\">pred, list</span>) =&gt;</span> R.unless(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  ([head, ...tail]) =&gt; [...(pred(head) ? [head] : []), ...filterR4(pred, tail)]</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(filterR(<span class=\"function\"><span class=\"params\">a</span> =&gt;</span> a % <span class=\"number\">2</span>, R.range(<span class=\"number\">1</span>, <span class=\"number\">10</span>))).toEqual([<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>]);</span><br></pre></td></tr></table></figure></p>\n<p>reduce 的递归实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> reduceR = <span class=\"function\">(<span class=\"params\">fn, acc, list</span>) =&gt;</span></span><br><span class=\"line\">  (R.isEmpty(list) ? acc : reduceR(fn, fn(acc, R.head(list)), R.tail(list)));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduceR2 = <span class=\"function\">(<span class=\"params\">fn, acc, list</span>) =&gt;</span> R.cond([</span><br><span class=\"line\">  [R.isEmpty, () =&gt; acc],</span><br><span class=\"line\">  [R.T, xs =&gt; reduceR2(fn, fn(acc, R.head(xs)), R.tail(xs))],</span><br><span class=\"line\">])(list);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> reduceR3 = <span class=\"function\">(<span class=\"params\">fn, acc, list</span>) =&gt;</span> R.ifElse(</span><br><span class=\"line\">  R.isEmpty,</span><br><span class=\"line\">  () =&gt; acc,</span><br><span class=\"line\">  xs =&gt; reduceR3(fn, fn(acc, R.head(xs)), R.tail(xs))</span><br><span class=\"line\">)(list);</span><br><span class=\"line\"></span><br><span class=\"line\">expect(reduceR(R.add, <span class=\"number\">0</span>, R.range(<span class=\"number\">1</span>, <span class=\"number\">5</span>))).toEqual(<span class=\"number\">10</span>);</span><br></pre></td></tr></table></figure></p>\n<h1>总结</h1>\n<p>本文从递归的定义、实质等基本理论开始，然后是递归的一些实例，其中大量运用了 <a href=\"http://ramda.cn\" target=\"_blank\" rel=\"noopener\">ramda</a> 函数式编程库中的 API，既是对递归的演示，也是对 ramda API 的实践展示。展示了递归和函数式在编程时的强悍的表达能力和对极致简约的追求。</p>\n"},{"title":"Product Softwares in *nix","date":"2017-07-28T23:57:42.000Z","_content":"\n总结一些在 *nix 操作系统中常用的软件\n\n## [Spacemacs](https://github.com/syl20bnr/spacemacs)\n\n- [org-mode](http://orgmode.org/)\n\n## [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n\n- [autojump](https://github.com/wting/autojump)\n\n## [tmux](https://github.com/tmux/tmux)\n\n## [percol](https://github.com/mooz/percol)\n\n## [Nodejs](https://nodejs.org/en/)\n","source":"_posts/Product-Softwares-in-nix.md","raw":"---\ntitle: Product Softwares in *nix\ndate: 2017-07-29 07:57:42\ntags: \n---\n\n总结一些在 *nix 操作系统中常用的软件\n\n## [Spacemacs](https://github.com/syl20bnr/spacemacs)\n\n- [org-mode](http://orgmode.org/)\n\n## [oh-my-zsh](https://github.com/robbyrussell/oh-my-zsh)\n\n- [autojump](https://github.com/wting/autojump)\n\n## [tmux](https://github.com/tmux/tmux)\n\n## [percol](https://github.com/mooz/percol)\n\n## [Nodejs](https://nodejs.org/en/)\n","slug":"Product-Softwares-in-nix","published":1,"updated":"2020-06-06T14:44:04.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitm000kf6mjzzekykkr","content":"<p>总结一些在 *nix 操作系统中常用的软件</p>\n<h2><a href=\"https://github.com/syl20bnr/spacemacs\" target=\"_blank\" rel=\"noopener\">Spacemacs</a></h2>\n<ul>\n<li><a href=\"http://orgmode.org/\" target=\"_blank\" rel=\"noopener\">org-mode</a></li>\n</ul>\n<h2><a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">oh-my-zsh</a></h2>\n<ul>\n<li><a href=\"https://github.com/wting/autojump\" target=\"_blank\" rel=\"noopener\">autojump</a></li>\n</ul>\n<h2><a href=\"https://github.com/tmux/tmux\" target=\"_blank\" rel=\"noopener\">tmux</a></h2>\n<h2><a href=\"https://github.com/mooz/percol\" target=\"_blank\" rel=\"noopener\">percol</a></h2>\n<h2><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Nodejs</a></h2>\n","site":{"data":{}},"excerpt":"","more":"<p>总结一些在 *nix 操作系统中常用的软件</p>\n<h2><a href=\"https://github.com/syl20bnr/spacemacs\" target=\"_blank\" rel=\"noopener\">Spacemacs</a></h2>\n<ul>\n<li><a href=\"http://orgmode.org/\" target=\"_blank\" rel=\"noopener\">org-mode</a></li>\n</ul>\n<h2><a href=\"https://github.com/robbyrussell/oh-my-zsh\" target=\"_blank\" rel=\"noopener\">oh-my-zsh</a></h2>\n<ul>\n<li><a href=\"https://github.com/wting/autojump\" target=\"_blank\" rel=\"noopener\">autojump</a></li>\n</ul>\n<h2><a href=\"https://github.com/tmux/tmux\" target=\"_blank\" rel=\"noopener\">tmux</a></h2>\n<h2><a href=\"https://github.com/mooz/percol\" target=\"_blank\" rel=\"noopener\">percol</a></h2>\n<h2><a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"noopener\">Nodejs</a></h2>\n"},{"title":"Ramda 源码分析（一） 柯里化curry","date":"2016-10-21T01:34:59.000Z","_content":"\n## Ramda 目录说明\n\n[Ramda](http://ramdajs.com) API 的源码都在 src/ 文件夹中，src/ 下包含一个 internal/ 文件夹和若干外部模块。直接在 **src/** 下编写的模块（函数）供**外部调用**，在 **internal/** 下编写的模块仅供**内部使用**，属于帮助函数，**内部函数以下划线 \"_\" 开头**。\n\n本次源码分析使用版本号为：Ramda v0.22.1。\n\n## 源码分析\n- \\_\\_ 占位符\n\n  占位符是一个 “普通的” object ，key 为 `@@functional/placeholder` ，value 为 true。\n  \n  ```js\n  module.exports = {'@@functional/placeholder': true};\n  ```\n  配合柯里化函数使用，可以使柯里化函数传入实参不在限于从左往右依次传入，大大增强了柯里化函数的能力。\n  \n  举例如下，g 是一个柯里化的 ternary（三元）函数，\\_ 代表 R.\\_\\_ ，下面的写法是等价的。\n  \n  ```js\n  g(1, 2, 3)\n  g(_, 2, 3)(1)\n  g(_, _, 3)(1)(2)\n  g(_, _, 3)(1, 2)\n  g(_, 2, _)(1, 3)\n  g(_, 2)(1)(3)\n  g(_, 2)(1, 3)\n  g(_, 2)(_, 3)(1)\n  ```\n  \n- \\_isPlaceholder\n  \n  判断实参是否为占位符（R.\\_\\_），在柯里化函数中使用。\n  \n  ```js\n  module.exports = function _isPlaceholder(a) {\n    return a != null &&\n\t     typeof a === 'object' &&\n\t     a['@@functional/placeholder'] === true;\n  };\n  ```\n  \n- \\_curry1\n  \n  优化的内部单参数柯里化函数：对单参数函数`fn` 进行柯里化，返回柯里化了的 fn' → f1。\n  \n  当传入参数为空或者传入的是占位符，返回 f1；否则执行 f1 ，并返回执行结果。\n  \n  柯里化用到了闭包。\\_curry1/\\_curry2/\\_curry3 是为了柯里化 ramda API 优化用的。因为 ramda API 都是原生柯里化的，且参数一般不超过3个，所以用到上述3个内部优化的柯里化函数，以提高效率。\n  \n  ```js\n  module.exports = function _curry1(fn) {\n    return function f1(a) {\n      if (arguments.length === 0 || _isPlaceholder(a)) {\n        return f1;\n      } else {\n        return fn.apply(this, arguments);\n      }\n    };\n  };\n  ```\n  \n- \\_curry2\n\n  优化的内部双参数柯里化函数：对双参数函数 `fn` 进行柯里化，返回柯里化了的 fn' → f2。\n  \n  原理讲解：\n  \n  1. 当无参数传入时，返回 f2；\n  2. 当有一个参数（a）传入时，判断该参数是否为 R.\\_\\_ ：是则返回 f2，否则返回加持一个参数（a）的单参数柯里化函数；\n  3. 当传入两个参数时，若都是占位符，返回 f2，若有一个占位符则返回加持一个参数的单参数柯里化函数，若无占位符，则执行 fn。\n  \n  ```js\n  module.exports = function _curry2(fn) {\n    return function f2(a, b) {\n      switch (arguments.length) {\n        case 0:\n          return f2;\n        case 1:\n          return _isPlaceholder(a) ? f2\n               : _curry1(function(_b) { return fn(a, _b); });\n        default:\n          return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n               : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a,   b); })\n               : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n               : fn(a, b);\n      }\n    };\n  };\n  ```\n\n- \\_arity\n\n  没有看出来 \\_arity 是干嘛用的，控制（限制）函数参数的个数？\n\n  ```js\n  module.exports = function _arity(n, fn) {\n    /* eslint-disable no-unused-vars */\n    switch (n) {\n      case 0: return function() { return fn.apply(this, arguments); };\n      case 1: return function(a0) { return fn.apply(this, arguments); };\n      case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n      case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n      case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n      case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n      case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n      case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n      case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n      case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n      case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n      default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n    }\n  };\n  ```\n\n- curryN\n\n  length：待柯里化函数参数的个数，fn：带柯里化函数\n\n  参数个数为1，用 \\_curry1 对 fn 柯里化；参数个数范围为 (1，10] ，用 \\_curryN。\n\n  ```js\n  module.exports = _curry2(function curryN(length, fn) {\n    if (length === 1) {\n      return _curry1(fn);\n    }\n    return _arity(length, _curryN(length, [], fn));\n  });\n  ```\n- curry\n\n  平时实际用到的柯里化函数\n\n  ```js\n  module.exports = _curry1(function curry(fn) {\n    return curryN(fn.length, fn);\n  });\n  ```\n","source":"_posts/Ramda-SourceCode-Analyze.md","raw":"---\ntitle: Ramda 源码分析（一） 柯里化curry\ndate: 2016-10-21 09:34:59\ntags:\n---\n\n## Ramda 目录说明\n\n[Ramda](http://ramdajs.com) API 的源码都在 src/ 文件夹中，src/ 下包含一个 internal/ 文件夹和若干外部模块。直接在 **src/** 下编写的模块（函数）供**外部调用**，在 **internal/** 下编写的模块仅供**内部使用**，属于帮助函数，**内部函数以下划线 \"_\" 开头**。\n\n本次源码分析使用版本号为：Ramda v0.22.1。\n\n## 源码分析\n- \\_\\_ 占位符\n\n  占位符是一个 “普通的” object ，key 为 `@@functional/placeholder` ，value 为 true。\n  \n  ```js\n  module.exports = {'@@functional/placeholder': true};\n  ```\n  配合柯里化函数使用，可以使柯里化函数传入实参不在限于从左往右依次传入，大大增强了柯里化函数的能力。\n  \n  举例如下，g 是一个柯里化的 ternary（三元）函数，\\_ 代表 R.\\_\\_ ，下面的写法是等价的。\n  \n  ```js\n  g(1, 2, 3)\n  g(_, 2, 3)(1)\n  g(_, _, 3)(1)(2)\n  g(_, _, 3)(1, 2)\n  g(_, 2, _)(1, 3)\n  g(_, 2)(1)(3)\n  g(_, 2)(1, 3)\n  g(_, 2)(_, 3)(1)\n  ```\n  \n- \\_isPlaceholder\n  \n  判断实参是否为占位符（R.\\_\\_），在柯里化函数中使用。\n  \n  ```js\n  module.exports = function _isPlaceholder(a) {\n    return a != null &&\n\t     typeof a === 'object' &&\n\t     a['@@functional/placeholder'] === true;\n  };\n  ```\n  \n- \\_curry1\n  \n  优化的内部单参数柯里化函数：对单参数函数`fn` 进行柯里化，返回柯里化了的 fn' → f1。\n  \n  当传入参数为空或者传入的是占位符，返回 f1；否则执行 f1 ，并返回执行结果。\n  \n  柯里化用到了闭包。\\_curry1/\\_curry2/\\_curry3 是为了柯里化 ramda API 优化用的。因为 ramda API 都是原生柯里化的，且参数一般不超过3个，所以用到上述3个内部优化的柯里化函数，以提高效率。\n  \n  ```js\n  module.exports = function _curry1(fn) {\n    return function f1(a) {\n      if (arguments.length === 0 || _isPlaceholder(a)) {\n        return f1;\n      } else {\n        return fn.apply(this, arguments);\n      }\n    };\n  };\n  ```\n  \n- \\_curry2\n\n  优化的内部双参数柯里化函数：对双参数函数 `fn` 进行柯里化，返回柯里化了的 fn' → f2。\n  \n  原理讲解：\n  \n  1. 当无参数传入时，返回 f2；\n  2. 当有一个参数（a）传入时，判断该参数是否为 R.\\_\\_ ：是则返回 f2，否则返回加持一个参数（a）的单参数柯里化函数；\n  3. 当传入两个参数时，若都是占位符，返回 f2，若有一个占位符则返回加持一个参数的单参数柯里化函数，若无占位符，则执行 fn。\n  \n  ```js\n  module.exports = function _curry2(fn) {\n    return function f2(a, b) {\n      switch (arguments.length) {\n        case 0:\n          return f2;\n        case 1:\n          return _isPlaceholder(a) ? f2\n               : _curry1(function(_b) { return fn(a, _b); });\n        default:\n          return _isPlaceholder(a) && _isPlaceholder(b) ? f2\n               : _isPlaceholder(a) ? _curry1(function(_a) { return fn(_a,   b); })\n               : _isPlaceholder(b) ? _curry1(function(_b) { return fn(a, _b); })\n               : fn(a, b);\n      }\n    };\n  };\n  ```\n\n- \\_arity\n\n  没有看出来 \\_arity 是干嘛用的，控制（限制）函数参数的个数？\n\n  ```js\n  module.exports = function _arity(n, fn) {\n    /* eslint-disable no-unused-vars */\n    switch (n) {\n      case 0: return function() { return fn.apply(this, arguments); };\n      case 1: return function(a0) { return fn.apply(this, arguments); };\n      case 2: return function(a0, a1) { return fn.apply(this, arguments); };\n      case 3: return function(a0, a1, a2) { return fn.apply(this, arguments); };\n      case 4: return function(a0, a1, a2, a3) { return fn.apply(this, arguments); };\n      case 5: return function(a0, a1, a2, a3, a4) { return fn.apply(this, arguments); };\n      case 6: return function(a0, a1, a2, a3, a4, a5) { return fn.apply(this, arguments); };\n      case 7: return function(a0, a1, a2, a3, a4, a5, a6) { return fn.apply(this, arguments); };\n      case 8: return function(a0, a1, a2, a3, a4, a5, a6, a7) { return fn.apply(this, arguments); };\n      case 9: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8) { return fn.apply(this, arguments); };\n      case 10: return function(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) { return fn.apply(this, arguments); };\n      default: throw new Error('First argument to _arity must be a non-negative integer no greater than ten');\n    }\n  };\n  ```\n\n- curryN\n\n  length：待柯里化函数参数的个数，fn：带柯里化函数\n\n  参数个数为1，用 \\_curry1 对 fn 柯里化；参数个数范围为 (1，10] ，用 \\_curryN。\n\n  ```js\n  module.exports = _curry2(function curryN(length, fn) {\n    if (length === 1) {\n      return _curry1(fn);\n    }\n    return _arity(length, _curryN(length, [], fn));\n  });\n  ```\n- curry\n\n  平时实际用到的柯里化函数\n\n  ```js\n  module.exports = _curry1(function curry(fn) {\n    return curryN(fn.length, fn);\n  });\n  ```\n","slug":"Ramda-SourceCode-Analyze","published":1,"updated":"2020-06-06T14:44:04.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitq000mf6mjg53kjb9n","content":"<h2>Ramda 目录说明</h2>\n<p><a href=\"http://ramdajs.com\" target=\"_blank\" rel=\"noopener\">Ramda</a> API 的源码都在 src/ 文件夹中，src/ 下包含一个 internal/ 文件夹和若干外部模块。直接在 <strong>src/</strong> 下编写的模块（函数）供<strong>外部调用</strong>，在 <strong>internal/</strong> 下编写的模块仅供<strong>内部使用</strong>，属于帮助函数，<strong>内部函数以下划线 &quot;_&quot; 开头</strong>。</p>\n<p>本次源码分析使用版本号为：Ramda v0.22.1。</p>\n<h2>源码分析</h2>\n<ul>\n<li>\n<p>__ 占位符</p>\n<p>占位符是一个 “普通的” object ，key 为 <code>@@functional/placeholder</code> ，value 为 true。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;<span class=\"string\">'@@functional/placeholder'</span>: <span class=\"literal\">true</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>配合柯里化函数使用，可以使柯里化函数传入实参不在限于从左往右依次传入，大大增强了柯里化函数的能力。</p>\n<p>举例如下，g 是一个柯里化的 ternary（三元）函数，_ 代表 R.__ ，下面的写法是等价的。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>, <span class=\"number\">3</span>)(<span class=\"number\">1</span>)</span><br><span class=\"line\">g(_, _, <span class=\"number\">3</span>)(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)</span><br><span class=\"line\">g(_, _, <span class=\"number\">3</span>)(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>, _)(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>)(<span class=\"number\">1</span>)(<span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>)(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>)(_, <span class=\"number\">3</span>)(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<ul>\n<li>\n<p>_isPlaceholder</p>\n<p>判断实参是否为占位符（R.__），在柯里化函数中使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_isPlaceholder</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> a === <span class=\"string\">'object'</span> &amp;&amp;</span><br><span class=\"line\">    a[<span class=\"string\">'@@functional/placeholder'</span>] === <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<ul>\n<li>\n<p>_curry1</p>\n<p>优化的内部单参数柯里化函数：对单参数函数<code>fn</code> 进行柯里化，返回柯里化了的 fn' → f1。</p>\n<p>当传入参数为空或者传入的是占位符，返回 f1；否则执行 f1 ，并返回执行结果。</p>\n<p>柯里化用到了闭包。_curry1/_curry2/_curry3 是为了柯里化 ramda API 优化用的。因为 ramda API 都是原生柯里化的，且参数一般不超过3个，所以用到上述3个内部优化的柯里化函数，以提高效率。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_curry1</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">0</span> || _isPlaceholder(a)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> f1;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<ul>\n<li>\n<p>_curry2</p>\n<p>优化的内部双参数柯里化函数：对双参数函数 <code>fn</code> 进行柯里化，返回柯里化了的 fn' → f2。</p>\n<p>原理讲解：</p>\n<ol>\n<li>当无参数传入时，返回 f2；</li>\n<li>当有一个参数（a）传入时，判断该参数是否为 R.__ ：是则返回 f2，否则返回加持一个参数（a）的单参数柯里化函数；</li>\n<li>当传入两个参数时，若都是占位符，返回 f2，若有一个占位符则返回加持一个参数的单参数柯里化函数，若无占位符，则执行 fn。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_curry2</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">arguments</span>.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _isPlaceholder(a) ? f2</span><br><span class=\"line\">             : _curry1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_b</span>) </span>&#123; <span class=\"keyword\">return</span> fn(a, _b); &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _isPlaceholder(a) &amp;&amp; _isPlaceholder(b) ? f2</span><br><span class=\"line\">             : _isPlaceholder(a) ? _curry1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_a</span>) </span>&#123; <span class=\"keyword\">return</span> fn(_a,   b); &#125;)</span><br><span class=\"line\">             : _isPlaceholder(b) ? _curry1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_b</span>) </span>&#123; <span class=\"keyword\">return</span> fn(a, _b); &#125;)</span><br><span class=\"line\">             : fn(a, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>_arity</p>\n<p>没有看出来 _arity 是干嘛用的，控制（限制）函数参数的个数？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_arity</span>(<span class=\"params\">n, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* eslint-disable no-unused-vars */</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">5</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">6</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">7</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">8</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6, a7</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">9</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6, a7, a8</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">10</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6, a7, a8, a9</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'First argument to _arity must be a non-negative integer no greater than ten'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>curryN</p>\n<p>length：待柯里化函数参数的个数，fn：带柯里化函数</p>\n<p>参数个数为1，用 _curry1 对 fn 柯里化；参数个数范围为 (1，10] ，用 _curryN。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = _curry2(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curryN</span>(<span class=\"params\">length, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _curry1(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _arity(length, _curryN(length, [], fn));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>curry</p>\n<p>平时实际用到的柯里化函数</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = _curry1(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> curryN(fn.length, fn);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2>Ramda 目录说明</h2>\n<p><a href=\"http://ramdajs.com\" target=\"_blank\" rel=\"noopener\">Ramda</a> API 的源码都在 src/ 文件夹中，src/ 下包含一个 internal/ 文件夹和若干外部模块。直接在 <strong>src/</strong> 下编写的模块（函数）供<strong>外部调用</strong>，在 <strong>internal/</strong> 下编写的模块仅供<strong>内部使用</strong>，属于帮助函数，<strong>内部函数以下划线 &quot;_&quot; 开头</strong>。</p>\n<p>本次源码分析使用版本号为：Ramda v0.22.1。</p>\n<h2>源码分析</h2>\n<ul>\n<li>\n<p>__ 占位符</p>\n<p>占位符是一个 “普通的” object ，key 为 <code>@@functional/placeholder</code> ，value 为 true。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;<span class=\"string\">'@@functional/placeholder'</span>: <span class=\"literal\">true</span>&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>配合柯里化函数使用，可以使柯里化函数传入实参不在限于从左往右依次传入，大大增强了柯里化函数的能力。</p>\n<p>举例如下，g 是一个柯里化的 ternary（三元）函数，_ 代表 R.__ ，下面的写法是等价的。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>, <span class=\"number\">3</span>)(<span class=\"number\">1</span>)</span><br><span class=\"line\">g(_, _, <span class=\"number\">3</span>)(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)</span><br><span class=\"line\">g(_, _, <span class=\"number\">3</span>)(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>, _)(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>)(<span class=\"number\">1</span>)(<span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>)(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span><br><span class=\"line\">g(_, <span class=\"number\">2</span>)(_, <span class=\"number\">3</span>)(<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<ul>\n<li>\n<p>_isPlaceholder</p>\n<p>判断实参是否为占位符（R.__），在柯里化函数中使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_isPlaceholder</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a != <span class=\"literal\">null</span> &amp;&amp;</span><br><span class=\"line\">    <span class=\"keyword\">typeof</span> a === <span class=\"string\">'object'</span> &amp;&amp;</span><br><span class=\"line\">    a[<span class=\"string\">'@@functional/placeholder'</span>] === <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<ul>\n<li>\n<p>_curry1</p>\n<p>优化的内部单参数柯里化函数：对单参数函数<code>fn</code> 进行柯里化，返回柯里化了的 fn' → f1。</p>\n<p>当传入参数为空或者传入的是占位符，返回 f1；否则执行 f1 ，并返回执行结果。</p>\n<p>柯里化用到了闭包。_curry1/_curry2/_curry3 是为了柯里化 ramda API 优化用的。因为 ramda API 都是原生柯里化的，且参数一般不超过3个，所以用到上述3个内部优化的柯里化函数，以提高效率。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_curry1</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\">a</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">arguments</span>.length === <span class=\"number\">0</span> || _isPlaceholder(a)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> f1;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n<ul>\n<li>\n<p>_curry2</p>\n<p>优化的内部双参数柯里化函数：对双参数函数 <code>fn</code> 进行柯里化，返回柯里化了的 fn' → f2。</p>\n<p>原理讲解：</p>\n<ol>\n<li>当无参数传入时，返回 f2；</li>\n<li>当有一个参数（a）传入时，判断该参数是否为 R.__ ：是则返回 f2，否则返回加持一个参数（a）的单参数柯里化函数；</li>\n<li>当传入两个参数时，若都是占位符，返回 f2，若有一个占位符则返回加持一个参数的单参数柯里化函数，若无占位符，则执行 fn。</li>\n</ol>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_curry2</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (<span class=\"built_in\">arguments</span>.length) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _isPlaceholder(a) ? f2</span><br><span class=\"line\">             : _curry1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_b</span>) </span>&#123; <span class=\"keyword\">return</span> fn(a, _b); &#125;);</span><br><span class=\"line\">      <span class=\"keyword\">default</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> _isPlaceholder(a) &amp;&amp; _isPlaceholder(b) ? f2</span><br><span class=\"line\">             : _isPlaceholder(a) ? _curry1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_a</span>) </span>&#123; <span class=\"keyword\">return</span> fn(_a,   b); &#125;)</span><br><span class=\"line\">             : _isPlaceholder(b) ? _curry1(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">_b</span>) </span>&#123; <span class=\"keyword\">return</span> fn(a, _b); &#125;)</span><br><span class=\"line\">             : fn(a, b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>_arity</p>\n<p>没有看出来 _arity 是干嘛用的，控制（限制）函数参数的个数？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_arity</span>(<span class=\"params\">n, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* eslint-disable no-unused-vars */</span></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (n) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">0</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">1</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">2</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">3</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">4</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">5</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">6</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">7</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">8</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6, a7</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">9</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6, a7, a8</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"number\">10</span>: <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a0, a1, a2, a3, a4, a5, a6, a7, a8, a9</span>) </span>&#123; <span class=\"keyword\">return</span> fn.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>); &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>: <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'First argument to _arity must be a non-negative integer no greater than ten'</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>curryN</p>\n<p>length：待柯里化函数参数的个数，fn：带柯里化函数</p>\n<p>参数个数为1，用 _curry1 对 fn 柯里化；参数个数范围为 (1，10] ，用 _curryN。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = _curry2(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curryN</span>(<span class=\"params\">length, fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _curry1(fn);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> _arity(length, _curryN(length, [], fn));</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n</li>\n<li>\n<p>curry</p>\n<p>平时实际用到的柯里化函数</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = _curry1(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">curry</span>(<span class=\"params\">fn</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> curryN(fn.length, fn);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n</li>\n</ul>\n"},{"title":"Ramda 源码分析（二） map reduce filter","date":"2016-10-23T01:43:20.000Z","_content":"\nmap、reduce 和 filter 是函数式编程中用到频率非常高的三个函数，对类Array 类型操作非常方便，被称为 FP 中的三板斧。还有几个相关的稍微复杂的函数也一并介绍： chain（flattenMap）、transduce、into、reduced。\n\n## 图解 map/reduce/filter \n\n虽然这是 [Underscore](http://underscorejs.org/) 方式的写法，但不影响对三个概念的理解.\n\n![map/reduce/filter](./mapFilterReduce.jpg)\n\n## 源码分析\n\n- map\n\n  \n  ```js\n  module.exports = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {\n    switch (Object.prototype.toString.call(functor)) {\n      case '[object Function]':\n        return curryN(functor.length, function() {\n          return fn.call(this, functor.apply(this, arguments));\n        });\n      case '[object Object]':\n        return _reduce(function(acc, key) {\n          acc[key] = fn(functor[key]);\n          return acc;\n        }, {}, keys(functor));\n      default:\n        return _map(fn, functor);\n    }\n  }));\n  ```\n","source":"_posts/Ramda-map-filter-reduce-transduce.md","raw":"---\ntitle: Ramda 源码分析（二） map reduce filter\ndate: 2016-10-23 09:43:20\ntags:\n---\n\nmap、reduce 和 filter 是函数式编程中用到频率非常高的三个函数，对类Array 类型操作非常方便，被称为 FP 中的三板斧。还有几个相关的稍微复杂的函数也一并介绍： chain（flattenMap）、transduce、into、reduced。\n\n## 图解 map/reduce/filter \n\n虽然这是 [Underscore](http://underscorejs.org/) 方式的写法，但不影响对三个概念的理解.\n\n![map/reduce/filter](./mapFilterReduce.jpg)\n\n## 源码分析\n\n- map\n\n  \n  ```js\n  module.exports = _curry2(_dispatchable('map', _xmap, function map(fn, functor) {\n    switch (Object.prototype.toString.call(functor)) {\n      case '[object Function]':\n        return curryN(functor.length, function() {\n          return fn.call(this, functor.apply(this, arguments));\n        });\n      case '[object Object]':\n        return _reduce(function(acc, key) {\n          acc[key] = fn(functor[key]);\n          return acc;\n        }, {}, keys(functor));\n      default:\n        return _map(fn, functor);\n    }\n  }));\n  ```\n","slug":"Ramda-map-filter-reduce-transduce","published":1,"updated":"2020-06-06T14:44:04.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfits000pf6mjp4ghuvt1","content":"<p>map、reduce 和 filter 是函数式编程中用到频率非常高的三个函数，对类Array 类型操作非常方便，被称为 FP 中的三板斧。还有几个相关的稍微复杂的函数也一并介绍： chain（flattenMap）、transduce、into、reduced。</p>\n<h2>图解 map/reduce/filter</h2>\n<p>虽然这是 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 方式的写法，但不影响对三个概念的理解.</p>\n<p><img src=\"./mapFilterReduce.jpg\" alt=\"map/reduce/filter\"></p>\n<h2>源码分析</h2>\n<ul>\n<li>map</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = _curry2(_dispatchable(<span class=\"string\">'map'</span>, _xmap, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">fn, functor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(functor)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'[object Function]'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> curryN(functor.length, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.call(<span class=\"keyword\">this</span>, functor.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'[object Object]'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">acc, key</span>) </span>&#123;</span><br><span class=\"line\">        acc[key] = fn(functor[key]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">      &#125;, &#123;&#125;, keys(functor));</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _map(fn, functor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>map、reduce 和 filter 是函数式编程中用到频率非常高的三个函数，对类Array 类型操作非常方便，被称为 FP 中的三板斧。还有几个相关的稍微复杂的函数也一并介绍： chain（flattenMap）、transduce、into、reduced。</p>\n<h2>图解 map/reduce/filter</h2>\n<p>虽然这是 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 方式的写法，但不影响对三个概念的理解.</p>\n<p><img src=\"./mapFilterReduce.jpg\" alt=\"map/reduce/filter\"></p>\n<h2>源码分析</h2>\n<ul>\n<li>map</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = _curry2(_dispatchable(<span class=\"string\">'map'</span>, _xmap, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">map</span>(<span class=\"params\">fn, functor</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(functor)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'[object Function]'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> curryN(functor.length, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.call(<span class=\"keyword\">this</span>, functor.apply(<span class=\"keyword\">this</span>, <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">'[object Object]'</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _reduce(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">acc, key</span>) </span>&#123;</span><br><span class=\"line\">        acc[key] = fn(functor[key]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> acc;</span><br><span class=\"line\">      &#125;, &#123;&#125;, keys(functor));</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">      <span class=\"keyword\">return</span> _map(fn, functor);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure></p>\n"},{"title":"Ramda 的哲学","date":"2017-12-16T13:39:27.000Z","_content":"\n# 目标\n\n我们编写 Ramda 的目的是，用比原生 JavaScript 更好的方式进行编程。给定数据如下：\n\n```js\n// `projects` 是一个以下形式的对象类型的数组\n//     {codename: 'atlas', due: '2013-09-30', budget: 300000, \n//      completed: '2013-10-15', cost: 325000},\n//\n// `assignments` 是将工程名映射到员工名的对象类型的数组，如下所示:\n//     {codename: 'atlas', name: 'abby'},\n//     {codename: 'atlas', name: 'greg'},\n```\n\n我们想按以下形式进行编程：\n\n```js\nvar employeesByProjectName = R.pipe(\n  R.propEq('codename'), \n  R.flip(R.filter)(assignments), \n  R.map(R.prop('name'))\n);\nvar onTime = R.filter(proj => proj.completed <= proj.due);\nvar withinBudget = R.filter(proj => proj.cost <= proj.budget);\nvar topProjects = R.converge(R.intersection, [onTime, withinBudget]);\nvar bonusEligible = R.pipe(\n  topProjects, \n  R.map(R.prop('codename')), \n  R.map(employeesByProjectName), \n  R.flatten, \n  R.uniq\n);\n\nconsole.log(bonusEligible(projects));\n// Live version at https://codepen.io/adispring/pen/WdQjXL?editors=0012\n// 译者注：原文用的 ramda@0.22.1 版本比较旧了，converge 第二个之后的函数未加中括号\n//         本文采用 ramda@0.25.0\n```\n\n这段代码是一段 “函数式” 的 `pipeline`。它是由模块化、可组合的函数构建而成，这些函数拼接在一起形成长长的管道，然后我们可以从管道入口传入待处理的数据。上面的每个 var 变量声明都代表一个单输入单输出的函数。每个函数的输出结果在管道中继续传递下去。\n\n这些函数对数据进行转换并将转换结果传给下一个函数。需要注意的是，这些函数都不会改变输入参数的值。\n\nRamda 的目标是让这种风格的编码在 JavaScript 中更容易些。这就是它的目的，我们的设计决策都是由这个目标驱动的。还有一个唯二值得关注的点：简洁（Simplicity）。我们追求的是简洁（Simple），而不是简单（容易，Easy）。如果你没有看过 Rich Hickey 的 \"Simple Made Easy\"，你应该花点时间看看。简洁，意味着不要将独立的功能点耦合或纠缠到一起。Ramda 努力坚持这个原则。（单一职责原则）\n\n# 座右铭\n\nRamda 自认为是 \"一个实用的 JavaScript 函数式编程库\"。什么意思呢？\n\n在本文接下来的部分，我们将这句话的解释分成几部分，并在下文中分别讨论每部分在 Ramda 中的含义。\n\n# 为 JavaScript 编程人员而设计\n\n## 有些惊讶？\n\nRamda 是为编程人员设计的库。它不是一个学术试验品。它是为一线人员构建系统而准备的，它必须能运行，并且是良好、高效地运行。\n\n我们尽量描述清楚函数的作用，以确保不会因误解而发生意外。不过，我们做的一些事情可能会让很多学术同仁感到惊讶。但只要日常的（工业界）编程人员理解我们，我们就愿意冒这个风险。例如，Ramda 的 `is` 函数可以用来代替 `isArray`、`isNumber`、`isFunction` 等函数。Ramda 版本的类型判断函数接受一个构造函数和一个对象：\n\n```js\nis(Number, 42); //=> true\nis(Function, 42); //=> false\nis(Object, {}); //=> true\n```\n\n这也适用于自定义的构造函数。如果 `Square` 的原型链上包含 `Rectangle`，则可以这样做：\n\n```js\nis(Rectangle, new Square(4)); //=> true\n```\n\n但这也可能引起学术界同仁的疑惑：\n\n```js\nis(Object, 42); //=> false\n```\n\n现实世界的编程人员知道这是完全正确的。字符串、布尔值和数字是原生类型，但它们不是对象。然而学者们可能会坚持，认为包装过的 Number 类型继承自 Object，类比 Square/Rectangle ，也应该返回 true。当然，他们可以那么认为... 在他们自己的库里。这些函数对一线的编程人员才是最有用的。（译者注：Ramda 作者可能被学术界 Nerd 们的絮叨伤害过...）\n\n## 命令式实现\n\n我们并没有非得以函数式的方式实现 Ramda 的函数。许多我们提出的构造，像 folds、maps、filters 只能通过递归进行函数式实现。但由于 JavaScript 并没有对递归进行优化；我们不能用优雅的递归算法来编写这些函数。相反，我们诉诸于丑陋的、命令式的 while 循环。我们来编写令人讨厌的代码，以便（Ramda）用户可以编写更优雅的代码。Ramda 的实现绝不应该被认为是如何编写函数式代码的指导。（译者注：为了效率和实用性的考虑，Ramda 底层实现其实是命令式的）\n\n虽然我们从 Haskell、ML 和 LISP（及其变种的函数式部分）等函数式语言中获得很多灵感，但 Ramda 从不试图实现这些语言的任何部分。\n\nRamda 也没有试图简单地以函数式的方式重写原生 API。机械的生搬硬套没有任何意义。当我们实现 `map` 函数时，我们既不用非得遵循 Array.prototype.map 的 ECMAScript 规范，也没有囿于已有的实现。我们可以自由地为我们的库定义每个函数的功能，它是如何工作的，确切的参数顺序，它会不会更改输入参数等（永远不会！），返回什么，以及它会抛出什么类型的错误等。换句话说，API 是我们自己的。我们确实受到了函数式编程的传统的限制，但如果在 JavaScript 中使用某些东西需要做出妥协，我们可以做出任何被认为实用的选择。（译者注：总之，我们对 Ramda 有绝对的掌控权）\n\n# 作为一个库\n\nRamda 是一个库，一个工具包，或者类比 Underscore ，是一个辅助开发工具。它不是一个决定如何构建应用程序结构的框架（如 React）。相反，它只是一组函数，旨在使之前描述的可组合函数风格的编程更容易一些。这些函数并没有决定你的工作流程。例如，你不必为了使用过滤器而传递 `where` 函数的结果。\n\n## 为什么不使用...\n\nRamda 不可避免的会与 [Underscore](http://underscorejs.org/) 和 [Lodash](http://lodash.com/) 做对比；其所提供的函数在功能和函数名称会有重叠。但是，Ramda 不会成为这些库的替代品。即使有一个神奇的参数顺序调整机制，它仍然不是一个简单的替代品。Ramda 有自身的优势、专注于不同领域。请记住，如果这些库能够很容易地按我们想要的方式进行编程，那么就不需要 Ramda 了。\n\n当我们开始编写该库时，主要的函数式编程库有：\n\n* Oliver Steele 的 [Functional Javascript](http://osteele.com/sources/javascript/functional/), 这是首次使用令人难以置信的方式，展示真的可以在 JavaScript 中用函数式的方式编程。但它也只是个玩具，用生产环境中不想要的技巧进行Hack。\n\n* Reg Braithwaite 的 [allong.es](https://github.com/raganwald/allong.es)，这本书已经出来了，并且这个鲜为人知的库已经可以用了。但这个库自称是 Underscore 或 Lodash 的伴侣，虽然做得很好，但它似乎只是一个支持这本书的最小代码集合，而不是一个完整的库。\n\n* Michael Fogus 的 [Lemonad](https://github.com/fogus/lemonad) 是一个具有前瞻性的实验品，也许是这里面最有趣的一个，它的一些函数在其他 JavaScript 库中是没有的。但它似乎只是一个 playground，基于此，该库基本上被废弃了。\n\n* 当然还有一些大块头，比如 Jeremy Ashkenas 的 [Underscore](http://underscorejs.org/) 和 John-David Dalton 的 [Lodash](http://lodash.com/)。这些库的广泛使用，显示了大量的 JavaScript 开发人员不再害怕函数式构造。它们非常受欢迎，已经包含了许多我们想要的工具。\n\n那么为什么我们不使用 Underscore/Lodash 呢？答案很简单。对于我们想要的编程形式，它们犯了一些根本性的错误：它们传递参数的顺序是错误的。\n\n这听起来很可笑，甚至无足轻重，但是对于这种编程风格来说确实 **必不可少**。为了构建简单可组合的函数，我们需要能正确协同工作的工具。其中最重要的是自动柯里化。为了能正确地进行柯里化，我们必须确保最经常变化的参数 -- 通常是数据 -- 放到最后。\n\n差别很简单。假设我们有这样一个可用的函数：\n\n```js\nvar add = function(a, b) {return a + b;};\n```\n\n并且我们想要一个函数，可以计算一篮子水果的总价格，例如：\n\n```js\nvar basket = [\n    {item: 'apples',  per: .95, count: 3, cost: 2.85},\n    {item: 'peaches', per: .80, count: 2, cost: 1.60},\n    {item: 'plums',   per: .55, count: 4, cost: 2.20}\n];\n```\n\n我们想要这样写：\n\n```js\nvar sum = reduce(add, 0);\n```\n\n并且这样使用：\n\n```js\nvar totalCost = compose(sum, pluck('cost'));\n```\n\n这就是我们想要的效果。注意看 `sum` 和 `totalCost` 是如此的简洁。使用 Underscore 写一个计算总价的函数并不难，但不会如此简洁。\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar totalCost = function(basket) {\n    return sum(_.pluck(basket, 'cost'));\n};\n```\n\n在 Lodash 中可能的实现如下：\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar getCosts = _.partialRight(_.pluck, 'cost');\nvar totalCost = _.compose(sum, getCosts);\n```\n\n或者跳过中间变量：\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar totalCost = _.compose(sum, .partialRight(_.pluck, 'cost'));\n```\n\n虽然这已经非常接近我们想要的效果，但是跟 Ramda 版本的相比，还是有差距的：\n\n```js\nvar sum = R.reduce(add, 0);\nvar total = R.compose(sum, R.pluck('cost'));\n```\n\n在 Ramda 中实现这种风格的秘诀非常简单：我们将函数参数放在第一位，数据参数放到最后，并且将每个函数都柯里化。\n\n来看一下 `pluck`。Ramda 有一个 `pluck` 函数，它和 Underscore 及 Lodash 中的 `pluck` 函数的功能差不多。这些函数接受一个字符串属性名和一个列表；返回由列表元素的属性值组成的列表。但 Underscore 和 Lodash 要求先提供列表，Ramda 希望最后传入列表。当你加入柯里化时，区别非常明显：\n\n```js\nR.pluck('cost'); //=> function :: [Object] -> [costs]\n```\n\n通过简单地暂时不传列表参数给 `pluck`，我们得到一个新函数：接受一个列表，并从新提供的列表中提取 `cost` 属性值。\n\n重申一下，就是这个简单的区别，将数据参数放到最后的自动柯里化函数让这两种风格变得不同：\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar total = function(basket) {\n    return sum(_.pluck(basket, 'cost'));\n};\n```\n\n```js\nvar sum = R.reduce(add, 0);\nvar total = R.compose(sum, R.pluck('cost'));\n```\n\n这就是我们开始编写一个新库的原因。\n\n# 设计选择\n\n接下来的问题是我们想要一个什么类型的库。我们当然知道我们想要一个简洁而又不怪异的 API。但是，这里仍然有一个悬而未决的问题：需要怎样确定 API 的适用广度和深度。\n\nAPI 的广度，仅仅指它想要覆盖多少不同类型的功能。有两百个函数的 API 比只有十个函数的 API 适用范围要广得多。与大多数其他库一样，我们对其广度（适用范围）没有特别的限制。我们添加有用的函数，而不用担心库的规模的增大会导致崩溃。\n\n一个库的深度，可以衡量它的函数们在独立使用时，可以提供多少种的不同的方式。（关于它们如何组合，是另一个完全不同的问题）在这里，我们走向了与 Underscore 及 Lodash 完全不同的方向。因为 JavaScript 不会去检查参数的类型和数量，所以编写根据传入确切参数（参数的类型和数量）而具有多种不同行为的单个函数是相当容易的。Underscore 和 Lodash 使用这种方法让它们的函数更灵活。例如，在 Lodash 中，`pluck` 不仅可以作用在 list 上，还可以作用在 object 和 string 上。从这个意义上讲，Lodash 是一个相当有深度的 API。Ramda 试图保持相对较浅的深度，原因如下：\n\nLodash 提供的功能如下：\n\n```js\n_.pluck('abc', propertyName);\n```\n\n其将字符串拆分成由单字母字符串组成的数组，然后返回从每个字符串中提取的指定属性形成的数组。想找个这样的合适的应用场景是非常困难的：\n\n```js\n_.pluck('abc', 'length'); //=> [1, 1, 1]\n```\n\n如果你真的想要一个元素为 `1` ，且对应字符串中的每个字母的列表，下面这段代码比我的 Ramda 解法要短一些：\n\n```js\nmap(always(1), split('', 'abc'));\n```\n\n但这貌似没什么用，因为唯一另外一个属性是有意义的：\n\n```js\n_.pluck('abc', '0'); //=> ['a', 'b', 'c']\n```\n\n如果 `pluck` 不存在，下面这样也是可以的：\n\n```js\n'abc'.split(''); //=> ['a', 'b', 'c']\n```\n\n所以在字符串上操作并没多大用处。之所以将其（字符串）包含进来，可能是因为所有属于 Lodash \"集合\" 类的函数都应该能同时适用于数组、对象和字符串；这只是一个一致性问题。（令人失望的是，Lodash 没有打算扩展到其他实际的集合中去，比如 Map 和 Set）我们已经理解了 `pluck` 是如何在数组上工作的。它涵盖的另一种类型是对象，如下所示：\n\n```js\nvar flintstones1 = {\n    A: {name: 'fred', age: 30},\n    B: {name: 'wilma', age: 28},\n    C: {name: 'pebbles', age: 2}\n};\n_.pluck(flintstones1, 'age'); //=> [30, 28, 2]\n```\n\n可以创建一个对象，`flintstones2` ，且以下结果为 `true`：\n\n```js\n_.isEqual(flintstones1, flintstones2); //=> true\n```\n\n但下面结果却为 `false`：\n\n```js\n_.pluck(flintstones1, 'age'); == _.pluck(flintstones2, 'age'); //=> false;\n```\n\n下面是一种可能的情况：\n\n```js\nvar flintstones2 = {\n    B: {name: 'wilma', age: 28},\n    A: {name: 'fred', age: 30},\n    C: {name: 'pebbles', age: 2}\n};\n_.pluck(flintstones2, 'age'); //=> [28, 30, 2]\n```\n\n问题在于，[根据规范](http://www.ecma-international.org/ecma-262/5.1/#sec-12.6.4)，对象 keys 的迭代顺序是依赖于实现的；通常它们按照添加到对象中的顺序进行迭代。。\n\n在写本文时，我提交了一个关于这个问题的 issue。在最好的情况下，只有通过记录问题才能解决问题。但这个问题实在影响深远。如果你想统一列表和对象的行为，你将会不断遇到这个问题，除非你实现一个（非常慢的！）统一的顺序对 Object 属性进行迭代。\n\n在 Ramda 中，`pluck` 只作用于列表。它接受一个属性名和一个列表，并返回一个相同长度的新列表。仅此而已。这个 API 深度很浅。（译者注：适用范围不太广）。\n\n你可以将其看作特点，也可以看作是缺点。以 Lodash 的 `filter` 为例: 它接受一个数组、对象或字符串作为第一个集合（参数），然后接受一个函数、对象、字符串或者空作为它的回调，并且还需要一个对象或空作为它的 this 参数。你将一次获得 3 * 4 * 2 = 24 个函数！这要么是一个很大的问题，要么增加了从中找到一个你真正想要的方案的难度，增加了太多复杂性。决定权在于你。\n\n在 Ramda 中，我们认为这种风格会增加不必要的复杂性。我们发现简单的函数签名对于维持简洁是至关重要的。如果我们需要函数既能作用于列表，又能作用于对象，我们会创建各自独立的函数（译者注：一般情况下会这样，但也有特例，比如 `map`）。如果有一个参数我们偶尔会用到，我们不会创建一个可选参数，而是创建两个函数。尽管这扩大了 API 的规模，但是它们保持了一至的浅度。\n\n## API 的增长\n\n有一个我们已经意识到的危险，一个可以用三个字母拼出来的危险：\"PHP\"。我们不希望我们的 API 变成一个不可持续的、功能不一致的怪物。这是真正的威胁，没有强制性的规范来确定我们应该或不应该包含什么。\n\n我们一直在努力；我们不希望包含一个貌似有用的函数。\n\n为了避免变成 “PHP” 风格的庞然大物，我们专注于几件事情。首先，API 为王。虽然我们想要函数实现尽可能优雅，但我们为了即使是轻微的 API 性能改进，而牺牲了大量优雅的实现。我们试图执行严格的一致性标准。例如：像 `somethingBy` 这样的 Ramda 函数，以标准的方式看，与 `somethingWith` 函数是不同的。如 [issue 65](https://github.com/ramda/ramda/issues/65) 所述，我们\n\n> 使用 xxBy 来表示单一属性的比较，无论是对象的自然属性还是合成属性；使用 xxWith 表示更具一般性的函数。\n\n一些使用这种方式的函数的例子包括max / min / sort / uniq / difference。\n\n# 函数式\n\nJavaScript 是一门多范式语言。你可以编写简单的命令式代码，面对对象的代码，或函数式代码。原始命令式的代码非常直白、简单。有很多库可以帮助你将 JavaScript 作为面向对象的语言使用。但是将 JavaScript 作为函数式语言使用的库非常少。Ramda 帮忙填补了这个空缺。\n\n如前所述，我们当然不是第一个。其他库通过各种不同方式让人们可以在 JavaScript 中进行函数式编程（FP）。在我看来，将函数式世界与 JavaScript 结合最成功的可能是 [allong.es](https://github.com/raganwald/allong.es)。但它不是一个流行的库，与 [Underscore](http://underscorejs.org/) 、 [Lodash](http://lodash.com/) 这些库不在一个级别上（就流行程度而言）；并且它有一个与 Ramda 不同的目标：它被设计为一种教学工具，一本书的演示库。\n\nRamda 正在尝试一些不同的东西。它的目标是成为一个能进行日常实际工作的实用的函数式库。\n\n我们从头开始构建这个函数式库，使用了许多其他函数式语言通用的技术，以对 JavaScript 有意义的方式对这些技术进行移植。我们并没有试图弥合与面向对象世界之间的鸿沟，或者复制每一种函数式语言的每一个特性。实际上，我们甚至没有试图复制单一函数式语言的每个特性。它仍然是 JavaScript，甚至还继承了 JavaScript 缺陷。\n\n## 函数式特性\n\n那么，在广阔的函数式编程领域里，哪些部分是我们想要保留的，又有哪些不在我们的考虑范围呢？下面列出了函数式编程的一些主要（不完整）特性：\n\n* 一等函数\n* 高阶函数\n* 词法闭包\n* 引用透明\n* 数据不可变\n* 模式匹配\n* 惰性求值\n* 高效递归（TCO）\n* [同像性（Homoiconic）](https://en.wikipedia.org/w/index.php?title=Homoiconicity&redirect=no)\n\n前几个特性都已经内置在 JavaScript 中了。JavaScript 中的函数是一等公民，意味着我们可以像使用字符串、数字或对象等，对其引用或传递。我们还可以将函数作为参数传递给其他函数，并返回全新的函数，所以 JavaScript 中包含高阶函数。因为返回函数可以访问其在创建时的上下文中的所有变量，所以我们也在语言中构建出了词法闭包。\n\n除此之外，上面列出其他的特性都没有自动包含在 JavaScript 中。有的可以轻易实现，有的只能部分或很难实现，有的则超出了语言的当前能力。\n\nRamda 可以确保在不会导致你的代码出问题的情况下，帮助实现（管理）上面的其他一些特性。例如，Ramda 不会改变你的输入数据。永远也不会！如果使用 `append` 将元素添加到列表的末尾，则会返回包含添加元素的新列表。你的原始列表保持不变。所以，由于 Ramda 不会尝试强行改变不可变的客户端数据，它可以很容易的与不可变数据一起工作。\n\n另一方面，Ramda 强制要求引用透明。这个概念的意思是：可以在不改变整个程序行为的情况下，将表达式替换为其对应的计算值。对于 Ramda 来说，这意味着 Ramda 不会在应用程序中存储内部状态，也不会引用任何全局变量或者内部状态可以变的闭包。简言之，当你使用相同的值调用 Ramda 函数时，总会得到相同的结果。\n\n在撰写本文时，正在讨论 Ramda 的惰性求值问题。一些库如 [Lazy.js](http://danieltao.com/lazy.js/) 和 [Lz.js](https://github.com/goatslacker/lz) ，表明在 JavaScript 中进行惰性求值是可行的。[Transducer](https://github.com/cognitect-labs/transducers-js) 提供了一种模拟惰性求值的方法。Ramda 正在努力增强自己这方面的能力。但这是一个巨大的改变，并不会很快实现。\n\nRamda 还会考虑加入一定程度的模式匹配，但不会像 Erlang 或 Haskell 这样的语言中的那么强大或方便。我们并没有看到会改变语言语法的宏，所以我们最多可以做一些类似于 [Reg Braithwaite 所描述的东西](http://raganwald.com/2014/06/23/multiple-dispatch.html#guarded-functions)。但是这至少在某种程度上讲是一种模式匹配的技术。\n\n其他特性都超出了 Ramda 的能力。虽然有 [trampolining](https://en.wikipedia.org/wiki/Trampoline_(computing)) 技术可以让你在不使用尾递归优化工具的情况下获得递归的一些好处，但是它们由于侵入性太强而不能被普遍使用。所以 Ramda 内部没有使用太多递归，也没有提供任何帮助来实现有效的递归。好消息是它将会被提到下一版语言规范的计划中去。\n\n然后是 **同像性（homoiconicity）** -- 某些语言（LISP、Prolog）的特性：程序的语法可以用一种在自身语言中易于理解和修改的数据结构表示的。这远远超出了 JavaScript 当前的能力，甚至超出了 Ramda 的梦想。\n\n# 组合性\n\nRamda 的目标之一是，允许用户使用小的可组合函数，这是函数式编程的关键。\n\n函数式编程通常涉及一些少量常见的数据结构，以及搭配操作它们的大量函数。这就是 Ramda 的工作原理。\n\n简言之，Ramda 主要进行列表操作。但 JavaScript 没有列表的实现；最接近的模拟是 Array（数组）。这是 Ramda 使用的最基本的数据结构。我们不关心 JavaScript 数组的一些深层次可能的性质。我们忽略稀疏数组。如果你传了一个这样的数组给 Ramda，有可能会得到意想不到的结果。你需要传给 Ramda 以 Array 实现的列表。（如果这对你没有意义，不用担心；这是人们使用 JavaScript 数组的标准方式，你必须非常努力，才能创建出不寻常的情况（译者注：错误的情况））。\n\n许多 Ramda 函数接受列表并且返回列表。这些函数都很容易组合。\n\n```js\n// :: [Comment] -> [Number]  \nvar userRatingForComments = R.compose(\n    R.pluck('rating'),       // [User] -> [Number]\n    R.map(R.propOf(users)),  // [String] -> [User]\n    R.pluck('username')      // [Comment] -> [String]\n);\n```\n\nRamda 还包含 `pipe` 函数，它跟 `compose` 功能相同，但顺序是反的；我个人觉得它更可读一些：\n\n```js\n// :: [Comment] -> [Number]  \nvar userRatingForComments = R.pipe(\n    R.pluck('username'),     // [Comment] -> [String]\n    R.map(R.propOf(users)),  // [String] -> [User]\n    R.pluck('rating')        // [User] -> [Number]\n);\n```\n\n当然，组合可以作用于任何类型。如果下一个函数接受当前函数返回的类型，那么一切都应该没问题。\n\n为了让其工作，Ramda 的函数必须具有足够小的规模。这与 Unix 的哲学不谋而合：大型的工具应该由小工具构建而成，每个工具做且只做一件事情。Ramda 的函数也是如此。理想情况下，这意味着以这些函数为基础的系统的复杂性只是问题自身固有的复杂性，而不是由库增加的附带的复杂性。\n\n## 不变性\n\n需要再次重申，Ramda 函数不会修改输入数据。这是函数式编程的核心原则，也是 Ramda 工作的核心。虽然这些函数可能会改变内部局部变量，但 Ramda 不会改变传递给它的任何数据。\n\n这并不意味着你使用的所有东西都会被复制。Ramda 重用了它所能用到的。因此，在像 `assoc` 和 `assocPath` 这样的函数，返回具有特定更新属性的对象的克隆中，原始数据的所有非原生（non-primitive）属性在新对象中将以引用的方式使用。如果你想要一个对象的完全解耦的副本，Ramda 提供了 `cloneDeep`（译者注：现在 Ramda 只提供 `clone` 用作深拷贝） 函数。\n\n这种不变性对 Ramda 来说是硬性规定。任何牵扯到变更用户数据的 pull request 都会被拒绝。我们认为这是 Ramda 的主要特征之一。\n\n# 实用性\n\n最后，Ramda 的目标是成为一个实用的库。这更难表述，因为实用性就像 “美丽” 一样：总是在旁观者眼中才能反映出来。永远都会有对不符合 Ramda 哲学的功能的要求，在那些提议者心目中，这些功能都是非常实用的。通常这些函数（功能）本身是有用的，但是由于不符合 Ramda 的哲学而被拒绝。\n\n对于 Ramda 而言，实用性意味着一些具体的事情。\n\n## 命令式实现\n\n首先，Ramda 的实现并未遵循 LISP、ML 或者 Haskell 库中的优雅的编码技术。我们使用丑陋的命令式的循环，而不是优雅的递归代码块。一些 Ramda 的作者曾经在一个叫 [Eweda](https://github.com/CrossEye/eweda) 的早起的库中走过这条路，代码非常漂亮，但是在解决实际问题上它却失败了。许多列表函数只能处理一千个左右的条目，而且性能也很糟糕。 JavaScript 的设计没有很好的处理递归，大多数当前的引擎不执行任何尾部调用优化。\n\n而 Ramda 的源代码却使用了乱七八糟的丑陋的 `while` 循环。\n\n这意味着 Ramda 的实现不能作为如何编写功能良好的 JavaScript 的模型（模板）。这太糟糕了。但它是目前的 JavaScript 引擎最实用的一种选择（方案）。\n\n## 合理的 API\n\nRamda 还试图就 API 中应该包含什么做出实用的选择。我们并没有试图移植 Clojure、Haskell 或任何其他函数式语言中的任何特定的函数子集，也没有试图模仿更成熟的 JavaScript 库或规范的 API。我们采纳函数的标准是，它们表现出合理的效用。当然，它们也必须与我们的函数式范式相契合才会被考虑，但这还不够；我们必须确信它们将会被用到，并且它们提供了通过当前函数不容易实现的价值。\n\n后者是比较棘手的。有一个平衡的方案，以确定什么情况下语法糖是可以接受的。在之前，我们讨论了 `compose` 有一个执行顺序相反孪生同胞 `pipe`。有一种观点认为这是一种浪费，我们不应该把 API 因为这些多余的函数而搞乱。毕竟，\n\n```js\nR.pipe(fn1, fn2, ..., fnN)\n```\n\n可以重写为如下形式：\n\n```js\nR.apply(R.compose, R.reverse([fn1, fn2, ..., fnN]));\n```\n\n但是，我们确实选择将 `pipe` 以及其他一些看似多余的函数包含到其中，当它们符合下面的条件时：\n\n* 很有可能会被用到\n* 能更好的表达开发人员的意图\n* 足够简单的实现\n\n## 整洁且一致的 API\n\n对于整体一致 API 的追求，听起来不像是一个现实的考虑，更像是一个纯粹主义者的目标。但事实上，提供简单而一致的 API 使得 Ramda 更易于使用。例如，一旦你习惯了 Ramda 对参数顺序的设定，你将很少需要查阅文档以确定如何构建你的调用。\n\n另外，Ramda 坚决反对可选参数。这个决定有助于形成非常整洁的 API。一个函数应该做什么以及如何调用，通常是非常直观的。\n\n## 并没有 “什么会帮助我” 的建议\n\n最后，向某个人解释这个问题通常是最困难的，那就是一个用户对什么才是实用的概念与整个库的实用性实际上可能只有一点点关系。即使提出的函数有助于解决某个难题，如果问题太过狭隘，或者解决方案偏离了我们的基础哲学，那么它也不会被纳入到 Ramda 中。虽然实用性是在旁观者眼中反映出来的，但那些能够纵观整个库的旁观者会有一个宏观的不同的视野，只有那些能够在整体上提升 Ramda 的改变才会被采纳。\n\n# 结论：生而不同\n\nRamda 的诞生是因为，没有任何其他的库能以我们想要的方式工作。我们想要将可以作用于不可变数据的小型可组合函数，组合成简洁的函数式的 pipeline （管道）。当 Ramda 与类似的库相比较时，这涉及到一些似乎颇具争议的决定。我们并不担心这一点。Ramda 为我们工作的很好，似乎也满足了[社区的需求](https://github.com/ramda/ramda/stargazers)。\n\n我们不再孤单。自从我们开始以来，[FKit](https://github.com/nullobject/fkit) 也萌发了相似的想法。这是一个不太成熟的库，它的工作方式和 [Eweda](https://github.com/CrossEye/eweda) 一样，试图在 API 及其实现上同时保持真正的优雅。在我看来，他们很可能会遇到性能瓶颈。但是，我们无能为力，只能祝福他们。\n\nRamda 正在努力坚持它作为 “JavaScript 开发人员的实用的函数式库” 的座右铭。我们认为我们正在管理和维护 Ramda。但我们也[很乐意倾听](https://github.com/ramda/ramda/issues) 您的想法。\n","source":"_posts/The-Philosophy-of-Ramda.md","raw":"---\ntitle: Ramda 的哲学\ndate: 2017-12-16 21:39:27\ntags: Ramda\n---\n\n# 目标\n\n我们编写 Ramda 的目的是，用比原生 JavaScript 更好的方式进行编程。给定数据如下：\n\n```js\n// `projects` 是一个以下形式的对象类型的数组\n//     {codename: 'atlas', due: '2013-09-30', budget: 300000, \n//      completed: '2013-10-15', cost: 325000},\n//\n// `assignments` 是将工程名映射到员工名的对象类型的数组，如下所示:\n//     {codename: 'atlas', name: 'abby'},\n//     {codename: 'atlas', name: 'greg'},\n```\n\n我们想按以下形式进行编程：\n\n```js\nvar employeesByProjectName = R.pipe(\n  R.propEq('codename'), \n  R.flip(R.filter)(assignments), \n  R.map(R.prop('name'))\n);\nvar onTime = R.filter(proj => proj.completed <= proj.due);\nvar withinBudget = R.filter(proj => proj.cost <= proj.budget);\nvar topProjects = R.converge(R.intersection, [onTime, withinBudget]);\nvar bonusEligible = R.pipe(\n  topProjects, \n  R.map(R.prop('codename')), \n  R.map(employeesByProjectName), \n  R.flatten, \n  R.uniq\n);\n\nconsole.log(bonusEligible(projects));\n// Live version at https://codepen.io/adispring/pen/WdQjXL?editors=0012\n// 译者注：原文用的 ramda@0.22.1 版本比较旧了，converge 第二个之后的函数未加中括号\n//         本文采用 ramda@0.25.0\n```\n\n这段代码是一段 “函数式” 的 `pipeline`。它是由模块化、可组合的函数构建而成，这些函数拼接在一起形成长长的管道，然后我们可以从管道入口传入待处理的数据。上面的每个 var 变量声明都代表一个单输入单输出的函数。每个函数的输出结果在管道中继续传递下去。\n\n这些函数对数据进行转换并将转换结果传给下一个函数。需要注意的是，这些函数都不会改变输入参数的值。\n\nRamda 的目标是让这种风格的编码在 JavaScript 中更容易些。这就是它的目的，我们的设计决策都是由这个目标驱动的。还有一个唯二值得关注的点：简洁（Simplicity）。我们追求的是简洁（Simple），而不是简单（容易，Easy）。如果你没有看过 Rich Hickey 的 \"Simple Made Easy\"，你应该花点时间看看。简洁，意味着不要将独立的功能点耦合或纠缠到一起。Ramda 努力坚持这个原则。（单一职责原则）\n\n# 座右铭\n\nRamda 自认为是 \"一个实用的 JavaScript 函数式编程库\"。什么意思呢？\n\n在本文接下来的部分，我们将这句话的解释分成几部分，并在下文中分别讨论每部分在 Ramda 中的含义。\n\n# 为 JavaScript 编程人员而设计\n\n## 有些惊讶？\n\nRamda 是为编程人员设计的库。它不是一个学术试验品。它是为一线人员构建系统而准备的，它必须能运行，并且是良好、高效地运行。\n\n我们尽量描述清楚函数的作用，以确保不会因误解而发生意外。不过，我们做的一些事情可能会让很多学术同仁感到惊讶。但只要日常的（工业界）编程人员理解我们，我们就愿意冒这个风险。例如，Ramda 的 `is` 函数可以用来代替 `isArray`、`isNumber`、`isFunction` 等函数。Ramda 版本的类型判断函数接受一个构造函数和一个对象：\n\n```js\nis(Number, 42); //=> true\nis(Function, 42); //=> false\nis(Object, {}); //=> true\n```\n\n这也适用于自定义的构造函数。如果 `Square` 的原型链上包含 `Rectangle`，则可以这样做：\n\n```js\nis(Rectangle, new Square(4)); //=> true\n```\n\n但这也可能引起学术界同仁的疑惑：\n\n```js\nis(Object, 42); //=> false\n```\n\n现实世界的编程人员知道这是完全正确的。字符串、布尔值和数字是原生类型，但它们不是对象。然而学者们可能会坚持，认为包装过的 Number 类型继承自 Object，类比 Square/Rectangle ，也应该返回 true。当然，他们可以那么认为... 在他们自己的库里。这些函数对一线的编程人员才是最有用的。（译者注：Ramda 作者可能被学术界 Nerd 们的絮叨伤害过...）\n\n## 命令式实现\n\n我们并没有非得以函数式的方式实现 Ramda 的函数。许多我们提出的构造，像 folds、maps、filters 只能通过递归进行函数式实现。但由于 JavaScript 并没有对递归进行优化；我们不能用优雅的递归算法来编写这些函数。相反，我们诉诸于丑陋的、命令式的 while 循环。我们来编写令人讨厌的代码，以便（Ramda）用户可以编写更优雅的代码。Ramda 的实现绝不应该被认为是如何编写函数式代码的指导。（译者注：为了效率和实用性的考虑，Ramda 底层实现其实是命令式的）\n\n虽然我们从 Haskell、ML 和 LISP（及其变种的函数式部分）等函数式语言中获得很多灵感，但 Ramda 从不试图实现这些语言的任何部分。\n\nRamda 也没有试图简单地以函数式的方式重写原生 API。机械的生搬硬套没有任何意义。当我们实现 `map` 函数时，我们既不用非得遵循 Array.prototype.map 的 ECMAScript 规范，也没有囿于已有的实现。我们可以自由地为我们的库定义每个函数的功能，它是如何工作的，确切的参数顺序，它会不会更改输入参数等（永远不会！），返回什么，以及它会抛出什么类型的错误等。换句话说，API 是我们自己的。我们确实受到了函数式编程的传统的限制，但如果在 JavaScript 中使用某些东西需要做出妥协，我们可以做出任何被认为实用的选择。（译者注：总之，我们对 Ramda 有绝对的掌控权）\n\n# 作为一个库\n\nRamda 是一个库，一个工具包，或者类比 Underscore ，是一个辅助开发工具。它不是一个决定如何构建应用程序结构的框架（如 React）。相反，它只是一组函数，旨在使之前描述的可组合函数风格的编程更容易一些。这些函数并没有决定你的工作流程。例如，你不必为了使用过滤器而传递 `where` 函数的结果。\n\n## 为什么不使用...\n\nRamda 不可避免的会与 [Underscore](http://underscorejs.org/) 和 [Lodash](http://lodash.com/) 做对比；其所提供的函数在功能和函数名称会有重叠。但是，Ramda 不会成为这些库的替代品。即使有一个神奇的参数顺序调整机制，它仍然不是一个简单的替代品。Ramda 有自身的优势、专注于不同领域。请记住，如果这些库能够很容易地按我们想要的方式进行编程，那么就不需要 Ramda 了。\n\n当我们开始编写该库时，主要的函数式编程库有：\n\n* Oliver Steele 的 [Functional Javascript](http://osteele.com/sources/javascript/functional/), 这是首次使用令人难以置信的方式，展示真的可以在 JavaScript 中用函数式的方式编程。但它也只是个玩具，用生产环境中不想要的技巧进行Hack。\n\n* Reg Braithwaite 的 [allong.es](https://github.com/raganwald/allong.es)，这本书已经出来了，并且这个鲜为人知的库已经可以用了。但这个库自称是 Underscore 或 Lodash 的伴侣，虽然做得很好，但它似乎只是一个支持这本书的最小代码集合，而不是一个完整的库。\n\n* Michael Fogus 的 [Lemonad](https://github.com/fogus/lemonad) 是一个具有前瞻性的实验品，也许是这里面最有趣的一个，它的一些函数在其他 JavaScript 库中是没有的。但它似乎只是一个 playground，基于此，该库基本上被废弃了。\n\n* 当然还有一些大块头，比如 Jeremy Ashkenas 的 [Underscore](http://underscorejs.org/) 和 John-David Dalton 的 [Lodash](http://lodash.com/)。这些库的广泛使用，显示了大量的 JavaScript 开发人员不再害怕函数式构造。它们非常受欢迎，已经包含了许多我们想要的工具。\n\n那么为什么我们不使用 Underscore/Lodash 呢？答案很简单。对于我们想要的编程形式，它们犯了一些根本性的错误：它们传递参数的顺序是错误的。\n\n这听起来很可笑，甚至无足轻重，但是对于这种编程风格来说确实 **必不可少**。为了构建简单可组合的函数，我们需要能正确协同工作的工具。其中最重要的是自动柯里化。为了能正确地进行柯里化，我们必须确保最经常变化的参数 -- 通常是数据 -- 放到最后。\n\n差别很简单。假设我们有这样一个可用的函数：\n\n```js\nvar add = function(a, b) {return a + b;};\n```\n\n并且我们想要一个函数，可以计算一篮子水果的总价格，例如：\n\n```js\nvar basket = [\n    {item: 'apples',  per: .95, count: 3, cost: 2.85},\n    {item: 'peaches', per: .80, count: 2, cost: 1.60},\n    {item: 'plums',   per: .55, count: 4, cost: 2.20}\n];\n```\n\n我们想要这样写：\n\n```js\nvar sum = reduce(add, 0);\n```\n\n并且这样使用：\n\n```js\nvar totalCost = compose(sum, pluck('cost'));\n```\n\n这就是我们想要的效果。注意看 `sum` 和 `totalCost` 是如此的简洁。使用 Underscore 写一个计算总价的函数并不难，但不会如此简洁。\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar totalCost = function(basket) {\n    return sum(_.pluck(basket, 'cost'));\n};\n```\n\n在 Lodash 中可能的实现如下：\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar getCosts = _.partialRight(_.pluck, 'cost');\nvar totalCost = _.compose(sum, getCosts);\n```\n\n或者跳过中间变量：\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar totalCost = _.compose(sum, .partialRight(_.pluck, 'cost'));\n```\n\n虽然这已经非常接近我们想要的效果，但是跟 Ramda 版本的相比，还是有差距的：\n\n```js\nvar sum = R.reduce(add, 0);\nvar total = R.compose(sum, R.pluck('cost'));\n```\n\n在 Ramda 中实现这种风格的秘诀非常简单：我们将函数参数放在第一位，数据参数放到最后，并且将每个函数都柯里化。\n\n来看一下 `pluck`。Ramda 有一个 `pluck` 函数，它和 Underscore 及 Lodash 中的 `pluck` 函数的功能差不多。这些函数接受一个字符串属性名和一个列表；返回由列表元素的属性值组成的列表。但 Underscore 和 Lodash 要求先提供列表，Ramda 希望最后传入列表。当你加入柯里化时，区别非常明显：\n\n```js\nR.pluck('cost'); //=> function :: [Object] -> [costs]\n```\n\n通过简单地暂时不传列表参数给 `pluck`，我们得到一个新函数：接受一个列表，并从新提供的列表中提取 `cost` 属性值。\n\n重申一下，就是这个简单的区别，将数据参数放到最后的自动柯里化函数让这两种风格变得不同：\n\n```js\nvar sum = function(list) {\n    return _.reduce(list, add, 0);\n};\nvar total = function(basket) {\n    return sum(_.pluck(basket, 'cost'));\n};\n```\n\n```js\nvar sum = R.reduce(add, 0);\nvar total = R.compose(sum, R.pluck('cost'));\n```\n\n这就是我们开始编写一个新库的原因。\n\n# 设计选择\n\n接下来的问题是我们想要一个什么类型的库。我们当然知道我们想要一个简洁而又不怪异的 API。但是，这里仍然有一个悬而未决的问题：需要怎样确定 API 的适用广度和深度。\n\nAPI 的广度，仅仅指它想要覆盖多少不同类型的功能。有两百个函数的 API 比只有十个函数的 API 适用范围要广得多。与大多数其他库一样，我们对其广度（适用范围）没有特别的限制。我们添加有用的函数，而不用担心库的规模的增大会导致崩溃。\n\n一个库的深度，可以衡量它的函数们在独立使用时，可以提供多少种的不同的方式。（关于它们如何组合，是另一个完全不同的问题）在这里，我们走向了与 Underscore 及 Lodash 完全不同的方向。因为 JavaScript 不会去检查参数的类型和数量，所以编写根据传入确切参数（参数的类型和数量）而具有多种不同行为的单个函数是相当容易的。Underscore 和 Lodash 使用这种方法让它们的函数更灵活。例如，在 Lodash 中，`pluck` 不仅可以作用在 list 上，还可以作用在 object 和 string 上。从这个意义上讲，Lodash 是一个相当有深度的 API。Ramda 试图保持相对较浅的深度，原因如下：\n\nLodash 提供的功能如下：\n\n```js\n_.pluck('abc', propertyName);\n```\n\n其将字符串拆分成由单字母字符串组成的数组，然后返回从每个字符串中提取的指定属性形成的数组。想找个这样的合适的应用场景是非常困难的：\n\n```js\n_.pluck('abc', 'length'); //=> [1, 1, 1]\n```\n\n如果你真的想要一个元素为 `1` ，且对应字符串中的每个字母的列表，下面这段代码比我的 Ramda 解法要短一些：\n\n```js\nmap(always(1), split('', 'abc'));\n```\n\n但这貌似没什么用，因为唯一另外一个属性是有意义的：\n\n```js\n_.pluck('abc', '0'); //=> ['a', 'b', 'c']\n```\n\n如果 `pluck` 不存在，下面这样也是可以的：\n\n```js\n'abc'.split(''); //=> ['a', 'b', 'c']\n```\n\n所以在字符串上操作并没多大用处。之所以将其（字符串）包含进来，可能是因为所有属于 Lodash \"集合\" 类的函数都应该能同时适用于数组、对象和字符串；这只是一个一致性问题。（令人失望的是，Lodash 没有打算扩展到其他实际的集合中去，比如 Map 和 Set）我们已经理解了 `pluck` 是如何在数组上工作的。它涵盖的另一种类型是对象，如下所示：\n\n```js\nvar flintstones1 = {\n    A: {name: 'fred', age: 30},\n    B: {name: 'wilma', age: 28},\n    C: {name: 'pebbles', age: 2}\n};\n_.pluck(flintstones1, 'age'); //=> [30, 28, 2]\n```\n\n可以创建一个对象，`flintstones2` ，且以下结果为 `true`：\n\n```js\n_.isEqual(flintstones1, flintstones2); //=> true\n```\n\n但下面结果却为 `false`：\n\n```js\n_.pluck(flintstones1, 'age'); == _.pluck(flintstones2, 'age'); //=> false;\n```\n\n下面是一种可能的情况：\n\n```js\nvar flintstones2 = {\n    B: {name: 'wilma', age: 28},\n    A: {name: 'fred', age: 30},\n    C: {name: 'pebbles', age: 2}\n};\n_.pluck(flintstones2, 'age'); //=> [28, 30, 2]\n```\n\n问题在于，[根据规范](http://www.ecma-international.org/ecma-262/5.1/#sec-12.6.4)，对象 keys 的迭代顺序是依赖于实现的；通常它们按照添加到对象中的顺序进行迭代。。\n\n在写本文时，我提交了一个关于这个问题的 issue。在最好的情况下，只有通过记录问题才能解决问题。但这个问题实在影响深远。如果你想统一列表和对象的行为，你将会不断遇到这个问题，除非你实现一个（非常慢的！）统一的顺序对 Object 属性进行迭代。\n\n在 Ramda 中，`pluck` 只作用于列表。它接受一个属性名和一个列表，并返回一个相同长度的新列表。仅此而已。这个 API 深度很浅。（译者注：适用范围不太广）。\n\n你可以将其看作特点，也可以看作是缺点。以 Lodash 的 `filter` 为例: 它接受一个数组、对象或字符串作为第一个集合（参数），然后接受一个函数、对象、字符串或者空作为它的回调，并且还需要一个对象或空作为它的 this 参数。你将一次获得 3 * 4 * 2 = 24 个函数！这要么是一个很大的问题，要么增加了从中找到一个你真正想要的方案的难度，增加了太多复杂性。决定权在于你。\n\n在 Ramda 中，我们认为这种风格会增加不必要的复杂性。我们发现简单的函数签名对于维持简洁是至关重要的。如果我们需要函数既能作用于列表，又能作用于对象，我们会创建各自独立的函数（译者注：一般情况下会这样，但也有特例，比如 `map`）。如果有一个参数我们偶尔会用到，我们不会创建一个可选参数，而是创建两个函数。尽管这扩大了 API 的规模，但是它们保持了一至的浅度。\n\n## API 的增长\n\n有一个我们已经意识到的危险，一个可以用三个字母拼出来的危险：\"PHP\"。我们不希望我们的 API 变成一个不可持续的、功能不一致的怪物。这是真正的威胁，没有强制性的规范来确定我们应该或不应该包含什么。\n\n我们一直在努力；我们不希望包含一个貌似有用的函数。\n\n为了避免变成 “PHP” 风格的庞然大物，我们专注于几件事情。首先，API 为王。虽然我们想要函数实现尽可能优雅，但我们为了即使是轻微的 API 性能改进，而牺牲了大量优雅的实现。我们试图执行严格的一致性标准。例如：像 `somethingBy` 这样的 Ramda 函数，以标准的方式看，与 `somethingWith` 函数是不同的。如 [issue 65](https://github.com/ramda/ramda/issues/65) 所述，我们\n\n> 使用 xxBy 来表示单一属性的比较，无论是对象的自然属性还是合成属性；使用 xxWith 表示更具一般性的函数。\n\n一些使用这种方式的函数的例子包括max / min / sort / uniq / difference。\n\n# 函数式\n\nJavaScript 是一门多范式语言。你可以编写简单的命令式代码，面对对象的代码，或函数式代码。原始命令式的代码非常直白、简单。有很多库可以帮助你将 JavaScript 作为面向对象的语言使用。但是将 JavaScript 作为函数式语言使用的库非常少。Ramda 帮忙填补了这个空缺。\n\n如前所述，我们当然不是第一个。其他库通过各种不同方式让人们可以在 JavaScript 中进行函数式编程（FP）。在我看来，将函数式世界与 JavaScript 结合最成功的可能是 [allong.es](https://github.com/raganwald/allong.es)。但它不是一个流行的库，与 [Underscore](http://underscorejs.org/) 、 [Lodash](http://lodash.com/) 这些库不在一个级别上（就流行程度而言）；并且它有一个与 Ramda 不同的目标：它被设计为一种教学工具，一本书的演示库。\n\nRamda 正在尝试一些不同的东西。它的目标是成为一个能进行日常实际工作的实用的函数式库。\n\n我们从头开始构建这个函数式库，使用了许多其他函数式语言通用的技术，以对 JavaScript 有意义的方式对这些技术进行移植。我们并没有试图弥合与面向对象世界之间的鸿沟，或者复制每一种函数式语言的每一个特性。实际上，我们甚至没有试图复制单一函数式语言的每个特性。它仍然是 JavaScript，甚至还继承了 JavaScript 缺陷。\n\n## 函数式特性\n\n那么，在广阔的函数式编程领域里，哪些部分是我们想要保留的，又有哪些不在我们的考虑范围呢？下面列出了函数式编程的一些主要（不完整）特性：\n\n* 一等函数\n* 高阶函数\n* 词法闭包\n* 引用透明\n* 数据不可变\n* 模式匹配\n* 惰性求值\n* 高效递归（TCO）\n* [同像性（Homoiconic）](https://en.wikipedia.org/w/index.php?title=Homoiconicity&redirect=no)\n\n前几个特性都已经内置在 JavaScript 中了。JavaScript 中的函数是一等公民，意味着我们可以像使用字符串、数字或对象等，对其引用或传递。我们还可以将函数作为参数传递给其他函数，并返回全新的函数，所以 JavaScript 中包含高阶函数。因为返回函数可以访问其在创建时的上下文中的所有变量，所以我们也在语言中构建出了词法闭包。\n\n除此之外，上面列出其他的特性都没有自动包含在 JavaScript 中。有的可以轻易实现，有的只能部分或很难实现，有的则超出了语言的当前能力。\n\nRamda 可以确保在不会导致你的代码出问题的情况下，帮助实现（管理）上面的其他一些特性。例如，Ramda 不会改变你的输入数据。永远也不会！如果使用 `append` 将元素添加到列表的末尾，则会返回包含添加元素的新列表。你的原始列表保持不变。所以，由于 Ramda 不会尝试强行改变不可变的客户端数据，它可以很容易的与不可变数据一起工作。\n\n另一方面，Ramda 强制要求引用透明。这个概念的意思是：可以在不改变整个程序行为的情况下，将表达式替换为其对应的计算值。对于 Ramda 来说，这意味着 Ramda 不会在应用程序中存储内部状态，也不会引用任何全局变量或者内部状态可以变的闭包。简言之，当你使用相同的值调用 Ramda 函数时，总会得到相同的结果。\n\n在撰写本文时，正在讨论 Ramda 的惰性求值问题。一些库如 [Lazy.js](http://danieltao.com/lazy.js/) 和 [Lz.js](https://github.com/goatslacker/lz) ，表明在 JavaScript 中进行惰性求值是可行的。[Transducer](https://github.com/cognitect-labs/transducers-js) 提供了一种模拟惰性求值的方法。Ramda 正在努力增强自己这方面的能力。但这是一个巨大的改变，并不会很快实现。\n\nRamda 还会考虑加入一定程度的模式匹配，但不会像 Erlang 或 Haskell 这样的语言中的那么强大或方便。我们并没有看到会改变语言语法的宏，所以我们最多可以做一些类似于 [Reg Braithwaite 所描述的东西](http://raganwald.com/2014/06/23/multiple-dispatch.html#guarded-functions)。但是这至少在某种程度上讲是一种模式匹配的技术。\n\n其他特性都超出了 Ramda 的能力。虽然有 [trampolining](https://en.wikipedia.org/wiki/Trampoline_(computing)) 技术可以让你在不使用尾递归优化工具的情况下获得递归的一些好处，但是它们由于侵入性太强而不能被普遍使用。所以 Ramda 内部没有使用太多递归，也没有提供任何帮助来实现有效的递归。好消息是它将会被提到下一版语言规范的计划中去。\n\n然后是 **同像性（homoiconicity）** -- 某些语言（LISP、Prolog）的特性：程序的语法可以用一种在自身语言中易于理解和修改的数据结构表示的。这远远超出了 JavaScript 当前的能力，甚至超出了 Ramda 的梦想。\n\n# 组合性\n\nRamda 的目标之一是，允许用户使用小的可组合函数，这是函数式编程的关键。\n\n函数式编程通常涉及一些少量常见的数据结构，以及搭配操作它们的大量函数。这就是 Ramda 的工作原理。\n\n简言之，Ramda 主要进行列表操作。但 JavaScript 没有列表的实现；最接近的模拟是 Array（数组）。这是 Ramda 使用的最基本的数据结构。我们不关心 JavaScript 数组的一些深层次可能的性质。我们忽略稀疏数组。如果你传了一个这样的数组给 Ramda，有可能会得到意想不到的结果。你需要传给 Ramda 以 Array 实现的列表。（如果这对你没有意义，不用担心；这是人们使用 JavaScript 数组的标准方式，你必须非常努力，才能创建出不寻常的情况（译者注：错误的情况））。\n\n许多 Ramda 函数接受列表并且返回列表。这些函数都很容易组合。\n\n```js\n// :: [Comment] -> [Number]  \nvar userRatingForComments = R.compose(\n    R.pluck('rating'),       // [User] -> [Number]\n    R.map(R.propOf(users)),  // [String] -> [User]\n    R.pluck('username')      // [Comment] -> [String]\n);\n```\n\nRamda 还包含 `pipe` 函数，它跟 `compose` 功能相同，但顺序是反的；我个人觉得它更可读一些：\n\n```js\n// :: [Comment] -> [Number]  \nvar userRatingForComments = R.pipe(\n    R.pluck('username'),     // [Comment] -> [String]\n    R.map(R.propOf(users)),  // [String] -> [User]\n    R.pluck('rating')        // [User] -> [Number]\n);\n```\n\n当然，组合可以作用于任何类型。如果下一个函数接受当前函数返回的类型，那么一切都应该没问题。\n\n为了让其工作，Ramda 的函数必须具有足够小的规模。这与 Unix 的哲学不谋而合：大型的工具应该由小工具构建而成，每个工具做且只做一件事情。Ramda 的函数也是如此。理想情况下，这意味着以这些函数为基础的系统的复杂性只是问题自身固有的复杂性，而不是由库增加的附带的复杂性。\n\n## 不变性\n\n需要再次重申，Ramda 函数不会修改输入数据。这是函数式编程的核心原则，也是 Ramda 工作的核心。虽然这些函数可能会改变内部局部变量，但 Ramda 不会改变传递给它的任何数据。\n\n这并不意味着你使用的所有东西都会被复制。Ramda 重用了它所能用到的。因此，在像 `assoc` 和 `assocPath` 这样的函数，返回具有特定更新属性的对象的克隆中，原始数据的所有非原生（non-primitive）属性在新对象中将以引用的方式使用。如果你想要一个对象的完全解耦的副本，Ramda 提供了 `cloneDeep`（译者注：现在 Ramda 只提供 `clone` 用作深拷贝） 函数。\n\n这种不变性对 Ramda 来说是硬性规定。任何牵扯到变更用户数据的 pull request 都会被拒绝。我们认为这是 Ramda 的主要特征之一。\n\n# 实用性\n\n最后，Ramda 的目标是成为一个实用的库。这更难表述，因为实用性就像 “美丽” 一样：总是在旁观者眼中才能反映出来。永远都会有对不符合 Ramda 哲学的功能的要求，在那些提议者心目中，这些功能都是非常实用的。通常这些函数（功能）本身是有用的，但是由于不符合 Ramda 的哲学而被拒绝。\n\n对于 Ramda 而言，实用性意味着一些具体的事情。\n\n## 命令式实现\n\n首先，Ramda 的实现并未遵循 LISP、ML 或者 Haskell 库中的优雅的编码技术。我们使用丑陋的命令式的循环，而不是优雅的递归代码块。一些 Ramda 的作者曾经在一个叫 [Eweda](https://github.com/CrossEye/eweda) 的早起的库中走过这条路，代码非常漂亮，但是在解决实际问题上它却失败了。许多列表函数只能处理一千个左右的条目，而且性能也很糟糕。 JavaScript 的设计没有很好的处理递归，大多数当前的引擎不执行任何尾部调用优化。\n\n而 Ramda 的源代码却使用了乱七八糟的丑陋的 `while` 循环。\n\n这意味着 Ramda 的实现不能作为如何编写功能良好的 JavaScript 的模型（模板）。这太糟糕了。但它是目前的 JavaScript 引擎最实用的一种选择（方案）。\n\n## 合理的 API\n\nRamda 还试图就 API 中应该包含什么做出实用的选择。我们并没有试图移植 Clojure、Haskell 或任何其他函数式语言中的任何特定的函数子集，也没有试图模仿更成熟的 JavaScript 库或规范的 API。我们采纳函数的标准是，它们表现出合理的效用。当然，它们也必须与我们的函数式范式相契合才会被考虑，但这还不够；我们必须确信它们将会被用到，并且它们提供了通过当前函数不容易实现的价值。\n\n后者是比较棘手的。有一个平衡的方案，以确定什么情况下语法糖是可以接受的。在之前，我们讨论了 `compose` 有一个执行顺序相反孪生同胞 `pipe`。有一种观点认为这是一种浪费，我们不应该把 API 因为这些多余的函数而搞乱。毕竟，\n\n```js\nR.pipe(fn1, fn2, ..., fnN)\n```\n\n可以重写为如下形式：\n\n```js\nR.apply(R.compose, R.reverse([fn1, fn2, ..., fnN]));\n```\n\n但是，我们确实选择将 `pipe` 以及其他一些看似多余的函数包含到其中，当它们符合下面的条件时：\n\n* 很有可能会被用到\n* 能更好的表达开发人员的意图\n* 足够简单的实现\n\n## 整洁且一致的 API\n\n对于整体一致 API 的追求，听起来不像是一个现实的考虑，更像是一个纯粹主义者的目标。但事实上，提供简单而一致的 API 使得 Ramda 更易于使用。例如，一旦你习惯了 Ramda 对参数顺序的设定，你将很少需要查阅文档以确定如何构建你的调用。\n\n另外，Ramda 坚决反对可选参数。这个决定有助于形成非常整洁的 API。一个函数应该做什么以及如何调用，通常是非常直观的。\n\n## 并没有 “什么会帮助我” 的建议\n\n最后，向某个人解释这个问题通常是最困难的，那就是一个用户对什么才是实用的概念与整个库的实用性实际上可能只有一点点关系。即使提出的函数有助于解决某个难题，如果问题太过狭隘，或者解决方案偏离了我们的基础哲学，那么它也不会被纳入到 Ramda 中。虽然实用性是在旁观者眼中反映出来的，但那些能够纵观整个库的旁观者会有一个宏观的不同的视野，只有那些能够在整体上提升 Ramda 的改变才会被采纳。\n\n# 结论：生而不同\n\nRamda 的诞生是因为，没有任何其他的库能以我们想要的方式工作。我们想要将可以作用于不可变数据的小型可组合函数，组合成简洁的函数式的 pipeline （管道）。当 Ramda 与类似的库相比较时，这涉及到一些似乎颇具争议的决定。我们并不担心这一点。Ramda 为我们工作的很好，似乎也满足了[社区的需求](https://github.com/ramda/ramda/stargazers)。\n\n我们不再孤单。自从我们开始以来，[FKit](https://github.com/nullobject/fkit) 也萌发了相似的想法。这是一个不太成熟的库，它的工作方式和 [Eweda](https://github.com/CrossEye/eweda) 一样，试图在 API 及其实现上同时保持真正的优雅。在我看来，他们很可能会遇到性能瓶颈。但是，我们无能为力，只能祝福他们。\n\nRamda 正在努力坚持它作为 “JavaScript 开发人员的实用的函数式库” 的座右铭。我们认为我们正在管理和维护 Ramda。但我们也[很乐意倾听](https://github.com/ramda/ramda/issues) 您的想法。\n","slug":"The-Philosophy-of-Ramda","published":1,"updated":"2020-06-06T14:44:04.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitt000qf6mjpx6sa4di","content":"<h1>目标</h1>\n<p>我们编写 Ramda 的目的是，用比原生 JavaScript 更好的方式进行编程。给定数据如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `projects` 是一个以下形式的对象类型的数组</span></span><br><span class=\"line\"><span class=\"comment\">//     &#123;codename: 'atlas', due: '2013-09-30', budget: 300000, </span></span><br><span class=\"line\"><span class=\"comment\">//      completed: '2013-10-15', cost: 325000&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// `assignments` 是将工程名映射到员工名的对象类型的数组，如下所示:</span></span><br><span class=\"line\"><span class=\"comment\">//     &#123;codename: 'atlas', name: 'abby'&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//     &#123;codename: 'atlas', name: 'greg'&#125;,</span></span><br></pre></td></tr></table></figure></p>\n<p>我们想按以下形式进行编程：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> employeesByProjectName = R.pipe(</span><br><span class=\"line\">  R.propEq(<span class=\"string\">'codename'</span>), </span><br><span class=\"line\">  R.flip(R.filter)(assignments), </span><br><span class=\"line\">  R.map(R.prop(<span class=\"string\">'name'</span>))</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">var</span> onTime = R.filter(<span class=\"function\"><span class=\"params\">proj</span> =&gt;</span> proj.completed &lt;= proj.due);</span><br><span class=\"line\"><span class=\"keyword\">var</span> withinBudget = R.filter(<span class=\"function\"><span class=\"params\">proj</span> =&gt;</span> proj.cost &lt;= proj.budget);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topProjects = R.converge(R.intersection, [onTime, withinBudget]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bonusEligible = R.pipe(</span><br><span class=\"line\">  topProjects, </span><br><span class=\"line\">  R.map(R.prop(<span class=\"string\">'codename'</span>)), </span><br><span class=\"line\">  R.map(employeesByProjectName), </span><br><span class=\"line\">  R.flatten, </span><br><span class=\"line\">  R.uniq</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bonusEligible(projects));</span><br><span class=\"line\"><span class=\"comment\">// Live version at https://codepen.io/adispring/pen/WdQjXL?editors=0012</span></span><br><span class=\"line\"><span class=\"comment\">// 译者注：原文用的 ramda@0.22.1 版本比较旧了，converge 第二个之后的函数未加中括号</span></span><br><span class=\"line\"><span class=\"comment\">//         本文采用 ramda@0.25.0</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码是一段 “函数式” 的 <code>pipeline</code>。它是由模块化、可组合的函数构建而成，这些函数拼接在一起形成长长的管道，然后我们可以从管道入口传入待处理的数据。上面的每个 var 变量声明都代表一个单输入单输出的函数。每个函数的输出结果在管道中继续传递下去。</p>\n<p>这些函数对数据进行转换并将转换结果传给下一个函数。需要注意的是，这些函数都不会改变输入参数的值。</p>\n<p>Ramda 的目标是让这种风格的编码在 JavaScript 中更容易些。这就是它的目的，我们的设计决策都是由这个目标驱动的。还有一个唯二值得关注的点：简洁（Simplicity）。我们追求的是简洁（Simple），而不是简单（容易，Easy）。如果你没有看过 Rich Hickey 的 &quot;Simple Made Easy&quot;，你应该花点时间看看。简洁，意味着不要将独立的功能点耦合或纠缠到一起。Ramda 努力坚持这个原则。（单一职责原则）</p>\n<h1>座右铭</h1>\n<p>Ramda 自认为是 &quot;一个实用的 JavaScript 函数式编程库&quot;。什么意思呢？</p>\n<p>在本文接下来的部分，我们将这句话的解释分成几部分，并在下文中分别讨论每部分在 Ramda 中的含义。</p>\n<h1>为 JavaScript 编程人员而设计</h1>\n<h2>有些惊讶？</h2>\n<p>Ramda 是为编程人员设计的库。它不是一个学术试验品。它是为一线人员构建系统而准备的，它必须能运行，并且是良好、高效地运行。</p>\n<p>我们尽量描述清楚函数的作用，以确保不会因误解而发生意外。不过，我们做的一些事情可能会让很多学术同仁感到惊讶。但只要日常的（工业界）编程人员理解我们，我们就愿意冒这个风险。例如，Ramda 的 <code>is</code> 函数可以用来代替 <code>isArray</code>、<code>isNumber</code>、<code>isFunction</code> 等函数。Ramda 版本的类型判断函数接受一个构造函数和一个对象：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is(<span class=\"built_in\">Number</span>, <span class=\"number\">42</span>); <span class=\"comment\">//=&gt; true</span></span><br><span class=\"line\">is(<span class=\"built_in\">Function</span>, <span class=\"number\">42</span>); <span class=\"comment\">//=&gt; false</span></span><br><span class=\"line\">is(<span class=\"built_in\">Object</span>, &#123;&#125;); <span class=\"comment\">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>这也适用于自定义的构造函数。如果 <code>Square</code> 的原型链上包含 <code>Rectangle</code>，则可以这样做：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is(Rectangle, <span class=\"keyword\">new</span> Square(<span class=\"number\">4</span>)); <span class=\"comment\">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>但这也可能引起学术界同仁的疑惑：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is(<span class=\"built_in\">Object</span>, <span class=\"number\">42</span>); <span class=\"comment\">//=&gt; false</span></span><br></pre></td></tr></table></figure></p>\n<p>现实世界的编程人员知道这是完全正确的。字符串、布尔值和数字是原生类型，但它们不是对象。然而学者们可能会坚持，认为包装过的 Number 类型继承自 Object，类比 Square/Rectangle ，也应该返回 true。当然，他们可以那么认为... 在他们自己的库里。这些函数对一线的编程人员才是最有用的。（译者注：Ramda 作者可能被学术界 Nerd 们的絮叨伤害过...）</p>\n<h2>命令式实现</h2>\n<p>我们并没有非得以函数式的方式实现 Ramda 的函数。许多我们提出的构造，像 folds、maps、filters 只能通过递归进行函数式实现。但由于 JavaScript 并没有对递归进行优化；我们不能用优雅的递归算法来编写这些函数。相反，我们诉诸于丑陋的、命令式的 while 循环。我们来编写令人讨厌的代码，以便（Ramda）用户可以编写更优雅的代码。Ramda 的实现绝不应该被认为是如何编写函数式代码的指导。（译者注：为了效率和实用性的考虑，Ramda 底层实现其实是命令式的）</p>\n<p>虽然我们从 Haskell、ML 和 LISP（及其变种的函数式部分）等函数式语言中获得很多灵感，但 Ramda 从不试图实现这些语言的任何部分。</p>\n<p>Ramda 也没有试图简单地以函数式的方式重写原生 API。机械的生搬硬套没有任何意义。当我们实现 <code>map</code> 函数时，我们既不用非得遵循 Array.prototype.map 的 ECMAScript 规范，也没有囿于已有的实现。我们可以自由地为我们的库定义每个函数的功能，它是如何工作的，确切的参数顺序，它会不会更改输入参数等（永远不会！），返回什么，以及它会抛出什么类型的错误等。换句话说，API 是我们自己的。我们确实受到了函数式编程的传统的限制，但如果在 JavaScript 中使用某些东西需要做出妥协，我们可以做出任何被认为实用的选择。（译者注：总之，我们对 Ramda 有绝对的掌控权）</p>\n<h1>作为一个库</h1>\n<p>Ramda 是一个库，一个工具包，或者类比 Underscore ，是一个辅助开发工具。它不是一个决定如何构建应用程序结构的框架（如 React）。相反，它只是一组函数，旨在使之前描述的可组合函数风格的编程更容易一些。这些函数并没有决定你的工作流程。例如，你不必为了使用过滤器而传递 <code>where</code> 函数的结果。</p>\n<h2>为什么不使用...</h2>\n<p>Ramda 不可避免的会与 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> 做对比；其所提供的函数在功能和函数名称会有重叠。但是，Ramda 不会成为这些库的替代品。即使有一个神奇的参数顺序调整机制，它仍然不是一个简单的替代品。Ramda 有自身的优势、专注于不同领域。请记住，如果这些库能够很容易地按我们想要的方式进行编程，那么就不需要 Ramda 了。</p>\n<p>当我们开始编写该库时，主要的函数式编程库有：</p>\n<ul>\n<li>\n<p>Oliver Steele 的 <a href=\"http://osteele.com/sources/javascript/functional/\" target=\"_blank\" rel=\"noopener\">Functional Javascript</a>, 这是首次使用令人难以置信的方式，展示真的可以在 JavaScript 中用函数式的方式编程。但它也只是个玩具，用生产环境中不想要的技巧进行Hack。</p>\n</li>\n<li>\n<p>Reg Braithwaite 的 <a href=\"https://github.com/raganwald/allong.es\" target=\"_blank\" rel=\"noopener\">allong.es</a>，这本书已经出来了，并且这个鲜为人知的库已经可以用了。但这个库自称是 Underscore 或 Lodash 的伴侣，虽然做得很好，但它似乎只是一个支持这本书的最小代码集合，而不是一个完整的库。</p>\n</li>\n<li>\n<p>Michael Fogus 的 <a href=\"https://github.com/fogus/lemonad\" target=\"_blank\" rel=\"noopener\">Lemonad</a> 是一个具有前瞻性的实验品，也许是这里面最有趣的一个，它的一些函数在其他 JavaScript 库中是没有的。但它似乎只是一个 playground，基于此，该库基本上被废弃了。</p>\n</li>\n<li>\n<p>当然还有一些大块头，比如 Jeremy Ashkenas 的 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 John-David Dalton 的 <a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a>。这些库的广泛使用，显示了大量的 JavaScript 开发人员不再害怕函数式构造。它们非常受欢迎，已经包含了许多我们想要的工具。</p>\n</li>\n</ul>\n<p>那么为什么我们不使用 Underscore/Lodash 呢？答案很简单。对于我们想要的编程形式，它们犯了一些根本性的错误：它们传递参数的顺序是错误的。</p>\n<p>这听起来很可笑，甚至无足轻重，但是对于这种编程风格来说确实 <strong>必不可少</strong>。为了构建简单可组合的函数，我们需要能正确协同工作的工具。其中最重要的是自动柯里化。为了能正确地进行柯里化，我们必须确保最经常变化的参数 -- 通常是数据 -- 放到最后。</p>\n<p>差别很简单。假设我们有这样一个可用的函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>并且我们想要一个函数，可以计算一篮子水果的总价格，例如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> basket = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">item</span>: <span class=\"string\">'apples'</span>,  <span class=\"attr\">per</span>: <span class=\"number\">.95</span>, <span class=\"attr\">count</span>: <span class=\"number\">3</span>, <span class=\"attr\">cost</span>: <span class=\"number\">2.85</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">item</span>: <span class=\"string\">'peaches'</span>, <span class=\"attr\">per</span>: <span class=\"number\">.80</span>, <span class=\"attr\">count</span>: <span class=\"number\">2</span>, <span class=\"attr\">cost</span>: <span class=\"number\">1.60</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">item</span>: <span class=\"string\">'plums'</span>,   <span class=\"attr\">per</span>: <span class=\"number\">.55</span>, <span class=\"attr\">count</span>: <span class=\"number\">4</span>, <span class=\"attr\">cost</span>: <span class=\"number\">2.20</span>&#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure></p>\n<p>我们想要这样写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = reduce(add, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>并且这样使用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> totalCost = compose(sum, pluck(<span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这就是我们想要的效果。注意看 <code>sum</code> 和 <code>totalCost</code> 是如此的简洁。使用 Underscore 写一个计算总价的函数并不难，但不会如此简洁。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> totalCost = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">basket</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(_.pluck(basket, <span class=\"string\">'cost'</span>));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在 Lodash 中可能的实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getCosts = _.partialRight(_.pluck, <span class=\"string\">'cost'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> totalCost = _.compose(sum, getCosts);</span><br></pre></td></tr></table></figure></p>\n<p>或者跳过中间变量：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> totalCost = _.compose(sum, .partialRight(_.pluck, <span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>虽然这已经非常接近我们想要的效果，但是跟 Ramda 版本的相比，还是有差距的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = R.reduce(add, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = R.compose(sum, R.pluck(<span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>在 Ramda 中实现这种风格的秘诀非常简单：我们将函数参数放在第一位，数据参数放到最后，并且将每个函数都柯里化。</p>\n<p>来看一下 <code>pluck</code>。Ramda 有一个 <code>pluck</code> 函数，它和 Underscore 及 Lodash 中的 <code>pluck</code> 函数的功能差不多。这些函数接受一个字符串属性名和一个列表；返回由列表元素的属性值组成的列表。但 Underscore 和 Lodash 要求先提供列表，Ramda 希望最后传入列表。当你加入柯里化时，区别非常明显：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.pluck(<span class=\"string\">'cost'</span>); <span class=\"comment\">//=&gt; function :: [Object] -&gt; [costs]</span></span><br></pre></td></tr></table></figure></p>\n<p>通过简单地暂时不传列表参数给 <code>pluck</code>，我们得到一个新函数：接受一个列表，并从新提供的列表中提取 <code>cost</code> 属性值。</p>\n<p>重申一下，就是这个简单的区别，将数据参数放到最后的自动柯里化函数让这两种风格变得不同：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">basket</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(_.pluck(basket, <span class=\"string\">'cost'</span>));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = R.reduce(add, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = R.compose(sum, R.pluck(<span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这就是我们开始编写一个新库的原因。</p>\n<h1>设计选择</h1>\n<p>接下来的问题是我们想要一个什么类型的库。我们当然知道我们想要一个简洁而又不怪异的 API。但是，这里仍然有一个悬而未决的问题：需要怎样确定 API 的适用广度和深度。</p>\n<p>API 的广度，仅仅指它想要覆盖多少不同类型的功能。有两百个函数的 API 比只有十个函数的 API 适用范围要广得多。与大多数其他库一样，我们对其广度（适用范围）没有特别的限制。我们添加有用的函数，而不用担心库的规模的增大会导致崩溃。</p>\n<p>一个库的深度，可以衡量它的函数们在独立使用时，可以提供多少种的不同的方式。（关于它们如何组合，是另一个完全不同的问题）在这里，我们走向了与 Underscore 及 Lodash 完全不同的方向。因为 JavaScript 不会去检查参数的类型和数量，所以编写根据传入确切参数（参数的类型和数量）而具有多种不同行为的单个函数是相当容易的。Underscore 和 Lodash 使用这种方法让它们的函数更灵活。例如，在 Lodash 中，<code>pluck</code> 不仅可以作用在 list 上，还可以作用在 object 和 string 上。从这个意义上讲，Lodash 是一个相当有深度的 API。Ramda 试图保持相对较浅的深度，原因如下：</p>\n<p>Lodash 提供的功能如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(<span class=\"string\">'abc'</span>, propertyName);</span><br></pre></td></tr></table></figure></p>\n<p>其将字符串拆分成由单字母字符串组成的数组，然后返回从每个字符串中提取的指定属性形成的数组。想找个这样的合适的应用场景是非常困难的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(<span class=\"string\">'abc'</span>, <span class=\"string\">'length'</span>); <span class=\"comment\">//=&gt; [1, 1, 1]</span></span><br></pre></td></tr></table></figure></p>\n<p>如果你真的想要一个元素为 <code>1</code> ，且对应字符串中的每个字母的列表，下面这段代码比我的 Ramda 解法要短一些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(always(<span class=\"number\">1</span>), split(<span class=\"string\">''</span>, <span class=\"string\">'abc'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>但这貌似没什么用，因为唯一另外一个属性是有意义的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(<span class=\"string\">'abc'</span>, <span class=\"string\">'0'</span>); <span class=\"comment\">//=&gt; ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>pluck</code> 不存在，下面这样也是可以的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.split(<span class=\"string\">''</span>); <span class=\"comment\">//=&gt; ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></p>\n<p>所以在字符串上操作并没多大用处。之所以将其（字符串）包含进来，可能是因为所有属于 Lodash &quot;集合&quot; 类的函数都应该能同时适用于数组、对象和字符串；这只是一个一致性问题。（令人失望的是，Lodash 没有打算扩展到其他实际的集合中去，比如 Map 和 Set）我们已经理解了 <code>pluck</code> 是如何在数组上工作的。它涵盖的另一种类型是对象，如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flintstones1 = &#123;</span><br><span class=\"line\">    A: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'fred'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">    B: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'wilma'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>&#125;,</span><br><span class=\"line\">    C: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'pebbles'</span>, <span class=\"attr\">age</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.pluck(flintstones1, <span class=\"string\">'age'</span>); <span class=\"comment\">//=&gt; [30, 28, 2]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以创建一个对象，<code>flintstones2</code> ，且以下结果为 <code>true</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.isEqual(flintstones1, flintstones2); <span class=\"comment\">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>但下面结果却为 <code>false</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(flintstones1, <span class=\"string\">'age'</span>); == _.pluck(flintstones2, <span class=\"string\">'age'</span>); <span class=\"comment\">//=&gt; false;</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是一种可能的情况：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flintstones2 = &#123;</span><br><span class=\"line\">    B: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'wilma'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>&#125;,</span><br><span class=\"line\">    A: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'fred'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">    C: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'pebbles'</span>, <span class=\"attr\">age</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.pluck(flintstones2, <span class=\"string\">'age'</span>); <span class=\"comment\">//=&gt; [28, 30, 2]</span></span><br></pre></td></tr></table></figure></p>\n<p>问题在于，<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-12.6.4\" target=\"_blank\" rel=\"noopener\">根据规范</a>，对象 keys 的迭代顺序是依赖于实现的；通常它们按照添加到对象中的顺序进行迭代。。</p>\n<p>在写本文时，我提交了一个关于这个问题的 issue。在最好的情况下，只有通过记录问题才能解决问题。但这个问题实在影响深远。如果你想统一列表和对象的行为，你将会不断遇到这个问题，除非你实现一个（非常慢的！）统一的顺序对 Object 属性进行迭代。</p>\n<p>在 Ramda 中，<code>pluck</code> 只作用于列表。它接受一个属性名和一个列表，并返回一个相同长度的新列表。仅此而已。这个 API 深度很浅。（译者注：适用范围不太广）。</p>\n<p>你可以将其看作特点，也可以看作是缺点。以 Lodash 的 <code>filter</code> 为例: 它接受一个数组、对象或字符串作为第一个集合（参数），然后接受一个函数、对象、字符串或者空作为它的回调，并且还需要一个对象或空作为它的 this 参数。你将一次获得 3 * 4 * 2 = 24 个函数！这要么是一个很大的问题，要么增加了从中找到一个你真正想要的方案的难度，增加了太多复杂性。决定权在于你。</p>\n<p>在 Ramda 中，我们认为这种风格会增加不必要的复杂性。我们发现简单的函数签名对于维持简洁是至关重要的。如果我们需要函数既能作用于列表，又能作用于对象，我们会创建各自独立的函数（译者注：一般情况下会这样，但也有特例，比如 <code>map</code>）。如果有一个参数我们偶尔会用到，我们不会创建一个可选参数，而是创建两个函数。尽管这扩大了 API 的规模，但是它们保持了一至的浅度。</p>\n<h2>API 的增长</h2>\n<p>有一个我们已经意识到的危险，一个可以用三个字母拼出来的危险：&quot;PHP&quot;。我们不希望我们的 API 变成一个不可持续的、功能不一致的怪物。这是真正的威胁，没有强制性的规范来确定我们应该或不应该包含什么。</p>\n<p>我们一直在努力；我们不希望包含一个貌似有用的函数。</p>\n<p>为了避免变成 “PHP” 风格的庞然大物，我们专注于几件事情。首先，API 为王。虽然我们想要函数实现尽可能优雅，但我们为了即使是轻微的 API 性能改进，而牺牲了大量优雅的实现。我们试图执行严格的一致性标准。例如：像 <code>somethingBy</code> 这样的 Ramda 函数，以标准的方式看，与 <code>somethingWith</code> 函数是不同的。如 <a href=\"https://github.com/ramda/ramda/issues/65\" target=\"_blank\" rel=\"noopener\">issue 65</a> 所述，我们</p>\n<blockquote>\n<p>使用 xxBy 来表示单一属性的比较，无论是对象的自然属性还是合成属性；使用 xxWith 表示更具一般性的函数。</p>\n</blockquote>\n<p>一些使用这种方式的函数的例子包括max / min / sort / uniq / difference。</p>\n<h1>函数式</h1>\n<p>JavaScript 是一门多范式语言。你可以编写简单的命令式代码，面对对象的代码，或函数式代码。原始命令式的代码非常直白、简单。有很多库可以帮助你将 JavaScript 作为面向对象的语言使用。但是将 JavaScript 作为函数式语言使用的库非常少。Ramda 帮忙填补了这个空缺。</p>\n<p>如前所述，我们当然不是第一个。其他库通过各种不同方式让人们可以在 JavaScript 中进行函数式编程（FP）。在我看来，将函数式世界与 JavaScript 结合最成功的可能是 <a href=\"https://github.com/raganwald/allong.es\" target=\"_blank\" rel=\"noopener\">allong.es</a>。但它不是一个流行的库，与 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 、 <a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> 这些库不在一个级别上（就流行程度而言）；并且它有一个与 Ramda 不同的目标：它被设计为一种教学工具，一本书的演示库。</p>\n<p>Ramda 正在尝试一些不同的东西。它的目标是成为一个能进行日常实际工作的实用的函数式库。</p>\n<p>我们从头开始构建这个函数式库，使用了许多其他函数式语言通用的技术，以对 JavaScript 有意义的方式对这些技术进行移植。我们并没有试图弥合与面向对象世界之间的鸿沟，或者复制每一种函数式语言的每一个特性。实际上，我们甚至没有试图复制单一函数式语言的每个特性。它仍然是 JavaScript，甚至还继承了 JavaScript 缺陷。</p>\n<h2>函数式特性</h2>\n<p>那么，在广阔的函数式编程领域里，哪些部分是我们想要保留的，又有哪些不在我们的考虑范围呢？下面列出了函数式编程的一些主要（不完整）特性：</p>\n<ul>\n<li>一等函数</li>\n<li>高阶函数</li>\n<li>词法闭包</li>\n<li>引用透明</li>\n<li>数据不可变</li>\n<li>模式匹配</li>\n<li>惰性求值</li>\n<li>高效递归（TCO）</li>\n<li><a href=\"https://en.wikipedia.org/w/index.php?title=Homoiconicity&amp;redirect=no\" target=\"_blank\" rel=\"noopener\">同像性（Homoiconic）</a></li>\n</ul>\n<p>前几个特性都已经内置在 JavaScript 中了。JavaScript 中的函数是一等公民，意味着我们可以像使用字符串、数字或对象等，对其引用或传递。我们还可以将函数作为参数传递给其他函数，并返回全新的函数，所以 JavaScript 中包含高阶函数。因为返回函数可以访问其在创建时的上下文中的所有变量，所以我们也在语言中构建出了词法闭包。</p>\n<p>除此之外，上面列出其他的特性都没有自动包含在 JavaScript 中。有的可以轻易实现，有的只能部分或很难实现，有的则超出了语言的当前能力。</p>\n<p>Ramda 可以确保在不会导致你的代码出问题的情况下，帮助实现（管理）上面的其他一些特性。例如，Ramda 不会改变你的输入数据。永远也不会！如果使用 <code>append</code> 将元素添加到列表的末尾，则会返回包含添加元素的新列表。你的原始列表保持不变。所以，由于 Ramda 不会尝试强行改变不可变的客户端数据，它可以很容易的与不可变数据一起工作。</p>\n<p>另一方面，Ramda 强制要求引用透明。这个概念的意思是：可以在不改变整个程序行为的情况下，将表达式替换为其对应的计算值。对于 Ramda 来说，这意味着 Ramda 不会在应用程序中存储内部状态，也不会引用任何全局变量或者内部状态可以变的闭包。简言之，当你使用相同的值调用 Ramda 函数时，总会得到相同的结果。</p>\n<p>在撰写本文时，正在讨论 Ramda 的惰性求值问题。一些库如 <a href=\"http://danieltao.com/lazy.js/\" target=\"_blank\" rel=\"noopener\">Lazy.js</a> 和 <a href=\"https://github.com/goatslacker/lz\" target=\"_blank\" rel=\"noopener\">Lz.js</a> ，表明在 JavaScript 中进行惰性求值是可行的。<a href=\"https://github.com/cognitect-labs/transducers-js\" target=\"_blank\" rel=\"noopener\">Transducer</a> 提供了一种模拟惰性求值的方法。Ramda 正在努力增强自己这方面的能力。但这是一个巨大的改变，并不会很快实现。</p>\n<p>Ramda 还会考虑加入一定程度的模式匹配，但不会像 Erlang 或 Haskell 这样的语言中的那么强大或方便。我们并没有看到会改变语言语法的宏，所以我们最多可以做一些类似于 <a href=\"http://raganwald.com/2014/06/23/multiple-dispatch.html#guarded-functions\" target=\"_blank\" rel=\"noopener\">Reg Braithwaite 所描述的东西</a>。但是这至少在某种程度上讲是一种模式匹配的技术。</p>\n<p>其他特性都超出了 Ramda 的能力。虽然有 <a href=\"https://en.wikipedia.org/wiki/Trampoline_(computing)\" target=\"_blank\" rel=\"noopener\">trampolining</a> 技术可以让你在不使用尾递归优化工具的情况下获得递归的一些好处，但是它们由于侵入性太强而不能被普遍使用。所以 Ramda 内部没有使用太多递归，也没有提供任何帮助来实现有效的递归。好消息是它将会被提到下一版语言规范的计划中去。</p>\n<p>然后是 <strong>同像性（homoiconicity）</strong> -- 某些语言（LISP、Prolog）的特性：程序的语法可以用一种在自身语言中易于理解和修改的数据结构表示的。这远远超出了 JavaScript 当前的能力，甚至超出了 Ramda 的梦想。</p>\n<h1>组合性</h1>\n<p>Ramda 的目标之一是，允许用户使用小的可组合函数，这是函数式编程的关键。</p>\n<p>函数式编程通常涉及一些少量常见的数据结构，以及搭配操作它们的大量函数。这就是 Ramda 的工作原理。</p>\n<p>简言之，Ramda 主要进行列表操作。但 JavaScript 没有列表的实现；最接近的模拟是 Array（数组）。这是 Ramda 使用的最基本的数据结构。我们不关心 JavaScript 数组的一些深层次可能的性质。我们忽略稀疏数组。如果你传了一个这样的数组给 Ramda，有可能会得到意想不到的结果。你需要传给 Ramda 以 Array 实现的列表。（如果这对你没有意义，不用担心；这是人们使用 JavaScript 数组的标准方式，你必须非常努力，才能创建出不寻常的情况（译者注：错误的情况））。</p>\n<p>许多 Ramda 函数接受列表并且返回列表。这些函数都很容易组合。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// :: [Comment] -&gt; [Number]  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userRatingForComments = R.compose(</span><br><span class=\"line\">    R.pluck(<span class=\"string\">'rating'</span>),       <span class=\"comment\">// [User] -&gt; [Number]</span></span><br><span class=\"line\">    R.map(R.propOf(users)),  <span class=\"comment\">// [String] -&gt; [User]</span></span><br><span class=\"line\">    R.pluck(<span class=\"string\">'username'</span>)      <span class=\"comment\">// [Comment] -&gt; [String]</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>Ramda 还包含 <code>pipe</code> 函数，它跟 <code>compose</code> 功能相同，但顺序是反的；我个人觉得它更可读一些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// :: [Comment] -&gt; [Number]  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userRatingForComments = R.pipe(</span><br><span class=\"line\">    R.pluck(<span class=\"string\">'username'</span>),     <span class=\"comment\">// [Comment] -&gt; [String]</span></span><br><span class=\"line\">    R.map(R.propOf(users)),  <span class=\"comment\">// [String] -&gt; [User]</span></span><br><span class=\"line\">    R.pluck(<span class=\"string\">'rating'</span>)        <span class=\"comment\">// [User] -&gt; [Number]</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>当然，组合可以作用于任何类型。如果下一个函数接受当前函数返回的类型，那么一切都应该没问题。</p>\n<p>为了让其工作，Ramda 的函数必须具有足够小的规模。这与 Unix 的哲学不谋而合：大型的工具应该由小工具构建而成，每个工具做且只做一件事情。Ramda 的函数也是如此。理想情况下，这意味着以这些函数为基础的系统的复杂性只是问题自身固有的复杂性，而不是由库增加的附带的复杂性。</p>\n<h2>不变性</h2>\n<p>需要再次重申，Ramda 函数不会修改输入数据。这是函数式编程的核心原则，也是 Ramda 工作的核心。虽然这些函数可能会改变内部局部变量，但 Ramda 不会改变传递给它的任何数据。</p>\n<p>这并不意味着你使用的所有东西都会被复制。Ramda 重用了它所能用到的。因此，在像 <code>assoc</code> 和 <code>assocPath</code> 这样的函数，返回具有特定更新属性的对象的克隆中，原始数据的所有非原生（non-primitive）属性在新对象中将以引用的方式使用。如果你想要一个对象的完全解耦的副本，Ramda 提供了 <code>cloneDeep</code>（译者注：现在 Ramda 只提供 <code>clone</code> 用作深拷贝） 函数。</p>\n<p>这种不变性对 Ramda 来说是硬性规定。任何牵扯到变更用户数据的 pull request 都会被拒绝。我们认为这是 Ramda 的主要特征之一。</p>\n<h1>实用性</h1>\n<p>最后，Ramda 的目标是成为一个实用的库。这更难表述，因为实用性就像 “美丽” 一样：总是在旁观者眼中才能反映出来。永远都会有对不符合 Ramda 哲学的功能的要求，在那些提议者心目中，这些功能都是非常实用的。通常这些函数（功能）本身是有用的，但是由于不符合 Ramda 的哲学而被拒绝。</p>\n<p>对于 Ramda 而言，实用性意味着一些具体的事情。</p>\n<h2>命令式实现</h2>\n<p>首先，Ramda 的实现并未遵循 LISP、ML 或者 Haskell 库中的优雅的编码技术。我们使用丑陋的命令式的循环，而不是优雅的递归代码块。一些 Ramda 的作者曾经在一个叫 <a href=\"https://github.com/CrossEye/eweda\" target=\"_blank\" rel=\"noopener\">Eweda</a> 的早起的库中走过这条路，代码非常漂亮，但是在解决实际问题上它却失败了。许多列表函数只能处理一千个左右的条目，而且性能也很糟糕。 JavaScript 的设计没有很好的处理递归，大多数当前的引擎不执行任何尾部调用优化。</p>\n<p>而 Ramda 的源代码却使用了乱七八糟的丑陋的 <code>while</code> 循环。</p>\n<p>这意味着 Ramda 的实现不能作为如何编写功能良好的 JavaScript 的模型（模板）。这太糟糕了。但它是目前的 JavaScript 引擎最实用的一种选择（方案）。</p>\n<h2>合理的 API</h2>\n<p>Ramda 还试图就 API 中应该包含什么做出实用的选择。我们并没有试图移植 Clojure、Haskell 或任何其他函数式语言中的任何特定的函数子集，也没有试图模仿更成熟的 JavaScript 库或规范的 API。我们采纳函数的标准是，它们表现出合理的效用。当然，它们也必须与我们的函数式范式相契合才会被考虑，但这还不够；我们必须确信它们将会被用到，并且它们提供了通过当前函数不容易实现的价值。</p>\n<p>后者是比较棘手的。有一个平衡的方案，以确定什么情况下语法糖是可以接受的。在之前，我们讨论了 <code>compose</code> 有一个执行顺序相反孪生同胞 <code>pipe</code>。有一种观点认为这是一种浪费，我们不应该把 API 因为这些多余的函数而搞乱。毕竟，</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.pipe(fn1, fn2, ..., fnN)</span><br></pre></td></tr></table></figure></p>\n<p>可以重写为如下形式：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.apply(R.compose, R.reverse([fn1, fn2, ..., fnN]));</span><br></pre></td></tr></table></figure></p>\n<p>但是，我们确实选择将 <code>pipe</code> 以及其他一些看似多余的函数包含到其中，当它们符合下面的条件时：</p>\n<ul>\n<li>很有可能会被用到</li>\n<li>能更好的表达开发人员的意图</li>\n<li>足够简单的实现</li>\n</ul>\n<h2>整洁且一致的 API</h2>\n<p>对于整体一致 API 的追求，听起来不像是一个现实的考虑，更像是一个纯粹主义者的目标。但事实上，提供简单而一致的 API 使得 Ramda 更易于使用。例如，一旦你习惯了 Ramda 对参数顺序的设定，你将很少需要查阅文档以确定如何构建你的调用。</p>\n<p>另外，Ramda 坚决反对可选参数。这个决定有助于形成非常整洁的 API。一个函数应该做什么以及如何调用，通常是非常直观的。</p>\n<h2>并没有 “什么会帮助我” 的建议</h2>\n<p>最后，向某个人解释这个问题通常是最困难的，那就是一个用户对什么才是实用的概念与整个库的实用性实际上可能只有一点点关系。即使提出的函数有助于解决某个难题，如果问题太过狭隘，或者解决方案偏离了我们的基础哲学，那么它也不会被纳入到 Ramda 中。虽然实用性是在旁观者眼中反映出来的，但那些能够纵观整个库的旁观者会有一个宏观的不同的视野，只有那些能够在整体上提升 Ramda 的改变才会被采纳。</p>\n<h1>结论：生而不同</h1>\n<p>Ramda 的诞生是因为，没有任何其他的库能以我们想要的方式工作。我们想要将可以作用于不可变数据的小型可组合函数，组合成简洁的函数式的 pipeline （管道）。当 Ramda 与类似的库相比较时，这涉及到一些似乎颇具争议的决定。我们并不担心这一点。Ramda 为我们工作的很好，似乎也满足了<a href=\"https://github.com/ramda/ramda/stargazers\" target=\"_blank\" rel=\"noopener\">社区的需求</a>。</p>\n<p>我们不再孤单。自从我们开始以来，<a href=\"https://github.com/nullobject/fkit\" target=\"_blank\" rel=\"noopener\">FKit</a> 也萌发了相似的想法。这是一个不太成熟的库，它的工作方式和 <a href=\"https://github.com/CrossEye/eweda\" target=\"_blank\" rel=\"noopener\">Eweda</a> 一样，试图在 API 及其实现上同时保持真正的优雅。在我看来，他们很可能会遇到性能瓶颈。但是，我们无能为力，只能祝福他们。</p>\n<p>Ramda 正在努力坚持它作为 “JavaScript 开发人员的实用的函数式库” 的座右铭。我们认为我们正在管理和维护 Ramda。但我们也<a href=\"https://github.com/ramda/ramda/issues\" target=\"_blank\" rel=\"noopener\">很乐意倾听</a> 您的想法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1>目标</h1>\n<p>我们编写 Ramda 的目的是，用比原生 JavaScript 更好的方式进行编程。给定数据如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// `projects` 是一个以下形式的对象类型的数组</span></span><br><span class=\"line\"><span class=\"comment\">//     &#123;codename: 'atlas', due: '2013-09-30', budget: 300000, </span></span><br><span class=\"line\"><span class=\"comment\">//      completed: '2013-10-15', cost: 325000&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//</span></span><br><span class=\"line\"><span class=\"comment\">// `assignments` 是将工程名映射到员工名的对象类型的数组，如下所示:</span></span><br><span class=\"line\"><span class=\"comment\">//     &#123;codename: 'atlas', name: 'abby'&#125;,</span></span><br><span class=\"line\"><span class=\"comment\">//     &#123;codename: 'atlas', name: 'greg'&#125;,</span></span><br></pre></td></tr></table></figure></p>\n<p>我们想按以下形式进行编程：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> employeesByProjectName = R.pipe(</span><br><span class=\"line\">  R.propEq(<span class=\"string\">'codename'</span>), </span><br><span class=\"line\">  R.flip(R.filter)(assignments), </span><br><span class=\"line\">  R.map(R.prop(<span class=\"string\">'name'</span>))</span><br><span class=\"line\">);</span><br><span class=\"line\"><span class=\"keyword\">var</span> onTime = R.filter(<span class=\"function\"><span class=\"params\">proj</span> =&gt;</span> proj.completed &lt;= proj.due);</span><br><span class=\"line\"><span class=\"keyword\">var</span> withinBudget = R.filter(<span class=\"function\"><span class=\"params\">proj</span> =&gt;</span> proj.cost &lt;= proj.budget);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topProjects = R.converge(R.intersection, [onTime, withinBudget]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> bonusEligible = R.pipe(</span><br><span class=\"line\">  topProjects, </span><br><span class=\"line\">  R.map(R.prop(<span class=\"string\">'codename'</span>)), </span><br><span class=\"line\">  R.map(employeesByProjectName), </span><br><span class=\"line\">  R.flatten, </span><br><span class=\"line\">  R.uniq</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(bonusEligible(projects));</span><br><span class=\"line\"><span class=\"comment\">// Live version at https://codepen.io/adispring/pen/WdQjXL?editors=0012</span></span><br><span class=\"line\"><span class=\"comment\">// 译者注：原文用的 ramda@0.22.1 版本比较旧了，converge 第二个之后的函数未加中括号</span></span><br><span class=\"line\"><span class=\"comment\">//         本文采用 ramda@0.25.0</span></span><br></pre></td></tr></table></figure></p>\n<p>这段代码是一段 “函数式” 的 <code>pipeline</code>。它是由模块化、可组合的函数构建而成，这些函数拼接在一起形成长长的管道，然后我们可以从管道入口传入待处理的数据。上面的每个 var 变量声明都代表一个单输入单输出的函数。每个函数的输出结果在管道中继续传递下去。</p>\n<p>这些函数对数据进行转换并将转换结果传给下一个函数。需要注意的是，这些函数都不会改变输入参数的值。</p>\n<p>Ramda 的目标是让这种风格的编码在 JavaScript 中更容易些。这就是它的目的，我们的设计决策都是由这个目标驱动的。还有一个唯二值得关注的点：简洁（Simplicity）。我们追求的是简洁（Simple），而不是简单（容易，Easy）。如果你没有看过 Rich Hickey 的 &quot;Simple Made Easy&quot;，你应该花点时间看看。简洁，意味着不要将独立的功能点耦合或纠缠到一起。Ramda 努力坚持这个原则。（单一职责原则）</p>\n<h1>座右铭</h1>\n<p>Ramda 自认为是 &quot;一个实用的 JavaScript 函数式编程库&quot;。什么意思呢？</p>\n<p>在本文接下来的部分，我们将这句话的解释分成几部分，并在下文中分别讨论每部分在 Ramda 中的含义。</p>\n<h1>为 JavaScript 编程人员而设计</h1>\n<h2>有些惊讶？</h2>\n<p>Ramda 是为编程人员设计的库。它不是一个学术试验品。它是为一线人员构建系统而准备的，它必须能运行，并且是良好、高效地运行。</p>\n<p>我们尽量描述清楚函数的作用，以确保不会因误解而发生意外。不过，我们做的一些事情可能会让很多学术同仁感到惊讶。但只要日常的（工业界）编程人员理解我们，我们就愿意冒这个风险。例如，Ramda 的 <code>is</code> 函数可以用来代替 <code>isArray</code>、<code>isNumber</code>、<code>isFunction</code> 等函数。Ramda 版本的类型判断函数接受一个构造函数和一个对象：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is(<span class=\"built_in\">Number</span>, <span class=\"number\">42</span>); <span class=\"comment\">//=&gt; true</span></span><br><span class=\"line\">is(<span class=\"built_in\">Function</span>, <span class=\"number\">42</span>); <span class=\"comment\">//=&gt; false</span></span><br><span class=\"line\">is(<span class=\"built_in\">Object</span>, &#123;&#125;); <span class=\"comment\">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>这也适用于自定义的构造函数。如果 <code>Square</code> 的原型链上包含 <code>Rectangle</code>，则可以这样做：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is(Rectangle, <span class=\"keyword\">new</span> Square(<span class=\"number\">4</span>)); <span class=\"comment\">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>但这也可能引起学术界同仁的疑惑：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">is(<span class=\"built_in\">Object</span>, <span class=\"number\">42</span>); <span class=\"comment\">//=&gt; false</span></span><br></pre></td></tr></table></figure></p>\n<p>现实世界的编程人员知道这是完全正确的。字符串、布尔值和数字是原生类型，但它们不是对象。然而学者们可能会坚持，认为包装过的 Number 类型继承自 Object，类比 Square/Rectangle ，也应该返回 true。当然，他们可以那么认为... 在他们自己的库里。这些函数对一线的编程人员才是最有用的。（译者注：Ramda 作者可能被学术界 Nerd 们的絮叨伤害过...）</p>\n<h2>命令式实现</h2>\n<p>我们并没有非得以函数式的方式实现 Ramda 的函数。许多我们提出的构造，像 folds、maps、filters 只能通过递归进行函数式实现。但由于 JavaScript 并没有对递归进行优化；我们不能用优雅的递归算法来编写这些函数。相反，我们诉诸于丑陋的、命令式的 while 循环。我们来编写令人讨厌的代码，以便（Ramda）用户可以编写更优雅的代码。Ramda 的实现绝不应该被认为是如何编写函数式代码的指导。（译者注：为了效率和实用性的考虑，Ramda 底层实现其实是命令式的）</p>\n<p>虽然我们从 Haskell、ML 和 LISP（及其变种的函数式部分）等函数式语言中获得很多灵感，但 Ramda 从不试图实现这些语言的任何部分。</p>\n<p>Ramda 也没有试图简单地以函数式的方式重写原生 API。机械的生搬硬套没有任何意义。当我们实现 <code>map</code> 函数时，我们既不用非得遵循 Array.prototype.map 的 ECMAScript 规范，也没有囿于已有的实现。我们可以自由地为我们的库定义每个函数的功能，它是如何工作的，确切的参数顺序，它会不会更改输入参数等（永远不会！），返回什么，以及它会抛出什么类型的错误等。换句话说，API 是我们自己的。我们确实受到了函数式编程的传统的限制，但如果在 JavaScript 中使用某些东西需要做出妥协，我们可以做出任何被认为实用的选择。（译者注：总之，我们对 Ramda 有绝对的掌控权）</p>\n<h1>作为一个库</h1>\n<p>Ramda 是一个库，一个工具包，或者类比 Underscore ，是一个辅助开发工具。它不是一个决定如何构建应用程序结构的框架（如 React）。相反，它只是一组函数，旨在使之前描述的可组合函数风格的编程更容易一些。这些函数并没有决定你的工作流程。例如，你不必为了使用过滤器而传递 <code>where</code> 函数的结果。</p>\n<h2>为什么不使用...</h2>\n<p>Ramda 不可避免的会与 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> 做对比；其所提供的函数在功能和函数名称会有重叠。但是，Ramda 不会成为这些库的替代品。即使有一个神奇的参数顺序调整机制，它仍然不是一个简单的替代品。Ramda 有自身的优势、专注于不同领域。请记住，如果这些库能够很容易地按我们想要的方式进行编程，那么就不需要 Ramda 了。</p>\n<p>当我们开始编写该库时，主要的函数式编程库有：</p>\n<ul>\n<li>\n<p>Oliver Steele 的 <a href=\"http://osteele.com/sources/javascript/functional/\" target=\"_blank\" rel=\"noopener\">Functional Javascript</a>, 这是首次使用令人难以置信的方式，展示真的可以在 JavaScript 中用函数式的方式编程。但它也只是个玩具，用生产环境中不想要的技巧进行Hack。</p>\n</li>\n<li>\n<p>Reg Braithwaite 的 <a href=\"https://github.com/raganwald/allong.es\" target=\"_blank\" rel=\"noopener\">allong.es</a>，这本书已经出来了，并且这个鲜为人知的库已经可以用了。但这个库自称是 Underscore 或 Lodash 的伴侣，虽然做得很好，但它似乎只是一个支持这本书的最小代码集合，而不是一个完整的库。</p>\n</li>\n<li>\n<p>Michael Fogus 的 <a href=\"https://github.com/fogus/lemonad\" target=\"_blank\" rel=\"noopener\">Lemonad</a> 是一个具有前瞻性的实验品，也许是这里面最有趣的一个，它的一些函数在其他 JavaScript 库中是没有的。但它似乎只是一个 playground，基于此，该库基本上被废弃了。</p>\n</li>\n<li>\n<p>当然还有一些大块头，比如 Jeremy Ashkenas 的 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 John-David Dalton 的 <a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a>。这些库的广泛使用，显示了大量的 JavaScript 开发人员不再害怕函数式构造。它们非常受欢迎，已经包含了许多我们想要的工具。</p>\n</li>\n</ul>\n<p>那么为什么我们不使用 Underscore/Lodash 呢？答案很简单。对于我们想要的编程形式，它们犯了一些根本性的错误：它们传递参数的顺序是错误的。</p>\n<p>这听起来很可笑，甚至无足轻重，但是对于这种编程风格来说确实 <strong>必不可少</strong>。为了构建简单可组合的函数，我们需要能正确协同工作的工具。其中最重要的是自动柯里化。为了能正确地进行柯里化，我们必须确保最经常变化的参数 -- 通常是数据 -- 放到最后。</p>\n<p>差别很简单。假设我们有这样一个可用的函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;<span class=\"keyword\">return</span> a + b;&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>并且我们想要一个函数，可以计算一篮子水果的总价格，例如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> basket = [</span><br><span class=\"line\">    &#123;<span class=\"attr\">item</span>: <span class=\"string\">'apples'</span>,  <span class=\"attr\">per</span>: <span class=\"number\">.95</span>, <span class=\"attr\">count</span>: <span class=\"number\">3</span>, <span class=\"attr\">cost</span>: <span class=\"number\">2.85</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">item</span>: <span class=\"string\">'peaches'</span>, <span class=\"attr\">per</span>: <span class=\"number\">.80</span>, <span class=\"attr\">count</span>: <span class=\"number\">2</span>, <span class=\"attr\">cost</span>: <span class=\"number\">1.60</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"attr\">item</span>: <span class=\"string\">'plums'</span>,   <span class=\"attr\">per</span>: <span class=\"number\">.55</span>, <span class=\"attr\">count</span>: <span class=\"number\">4</span>, <span class=\"attr\">cost</span>: <span class=\"number\">2.20</span>&#125;</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure></p>\n<p>我们想要这样写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = reduce(add, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure></p>\n<p>并且这样使用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> totalCost = compose(sum, pluck(<span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这就是我们想要的效果。注意看 <code>sum</code> 和 <code>totalCost</code> 是如此的简洁。使用 Underscore 写一个计算总价的函数并不难，但不会如此简洁。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> totalCost = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">basket</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(_.pluck(basket, <span class=\"string\">'cost'</span>));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>在 Lodash 中可能的实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> getCosts = _.partialRight(_.pluck, <span class=\"string\">'cost'</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> totalCost = _.compose(sum, getCosts);</span><br></pre></td></tr></table></figure></p>\n<p>或者跳过中间变量：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> totalCost = _.compose(sum, .partialRight(_.pluck, <span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>虽然这已经非常接近我们想要的效果，但是跟 Ramda 版本的相比，还是有差距的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = R.reduce(add, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = R.compose(sum, R.pluck(<span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>在 Ramda 中实现这种风格的秘诀非常简单：我们将函数参数放在第一位，数据参数放到最后，并且将每个函数都柯里化。</p>\n<p>来看一下 <code>pluck</code>。Ramda 有一个 <code>pluck</code> 函数，它和 Underscore 及 Lodash 中的 <code>pluck</code> 函数的功能差不多。这些函数接受一个字符串属性名和一个列表；返回由列表元素的属性值组成的列表。但 Underscore 和 Lodash 要求先提供列表，Ramda 希望最后传入列表。当你加入柯里化时，区别非常明显：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.pluck(<span class=\"string\">'cost'</span>); <span class=\"comment\">//=&gt; function :: [Object] -&gt; [costs]</span></span><br></pre></td></tr></table></figure></p>\n<p>通过简单地暂时不传列表参数给 <code>pluck</code>，我们得到一个新函数：接受一个列表，并从新提供的列表中提取 <code>cost</code> 属性值。</p>\n<p>重申一下，就是这个简单的区别，将数据参数放到最后的自动柯里化函数让这两种风格变得不同：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">list</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _.reduce(list, add, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">basket</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum(_.pluck(basket, <span class=\"string\">'cost'</span>));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum = R.reduce(add, <span class=\"number\">0</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> total = R.compose(sum, R.pluck(<span class=\"string\">'cost'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>这就是我们开始编写一个新库的原因。</p>\n<h1>设计选择</h1>\n<p>接下来的问题是我们想要一个什么类型的库。我们当然知道我们想要一个简洁而又不怪异的 API。但是，这里仍然有一个悬而未决的问题：需要怎样确定 API 的适用广度和深度。</p>\n<p>API 的广度，仅仅指它想要覆盖多少不同类型的功能。有两百个函数的 API 比只有十个函数的 API 适用范围要广得多。与大多数其他库一样，我们对其广度（适用范围）没有特别的限制。我们添加有用的函数，而不用担心库的规模的增大会导致崩溃。</p>\n<p>一个库的深度，可以衡量它的函数们在独立使用时，可以提供多少种的不同的方式。（关于它们如何组合，是另一个完全不同的问题）在这里，我们走向了与 Underscore 及 Lodash 完全不同的方向。因为 JavaScript 不会去检查参数的类型和数量，所以编写根据传入确切参数（参数的类型和数量）而具有多种不同行为的单个函数是相当容易的。Underscore 和 Lodash 使用这种方法让它们的函数更灵活。例如，在 Lodash 中，<code>pluck</code> 不仅可以作用在 list 上，还可以作用在 object 和 string 上。从这个意义上讲，Lodash 是一个相当有深度的 API。Ramda 试图保持相对较浅的深度，原因如下：</p>\n<p>Lodash 提供的功能如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(<span class=\"string\">'abc'</span>, propertyName);</span><br></pre></td></tr></table></figure></p>\n<p>其将字符串拆分成由单字母字符串组成的数组，然后返回从每个字符串中提取的指定属性形成的数组。想找个这样的合适的应用场景是非常困难的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(<span class=\"string\">'abc'</span>, <span class=\"string\">'length'</span>); <span class=\"comment\">//=&gt; [1, 1, 1]</span></span><br></pre></td></tr></table></figure></p>\n<p>如果你真的想要一个元素为 <code>1</code> ，且对应字符串中的每个字母的列表，下面这段代码比我的 Ramda 解法要短一些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(always(<span class=\"number\">1</span>), split(<span class=\"string\">''</span>, <span class=\"string\">'abc'</span>));</span><br></pre></td></tr></table></figure></p>\n<p>但这貌似没什么用，因为唯一另外一个属性是有意义的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(<span class=\"string\">'abc'</span>, <span class=\"string\">'0'</span>); <span class=\"comment\">//=&gt; ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>pluck</code> 不存在，下面这样也是可以的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'abc'</span>.split(<span class=\"string\">''</span>); <span class=\"comment\">//=&gt; ['a', 'b', 'c']</span></span><br></pre></td></tr></table></figure></p>\n<p>所以在字符串上操作并没多大用处。之所以将其（字符串）包含进来，可能是因为所有属于 Lodash &quot;集合&quot; 类的函数都应该能同时适用于数组、对象和字符串；这只是一个一致性问题。（令人失望的是，Lodash 没有打算扩展到其他实际的集合中去，比如 Map 和 Set）我们已经理解了 <code>pluck</code> 是如何在数组上工作的。它涵盖的另一种类型是对象，如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flintstones1 = &#123;</span><br><span class=\"line\">    A: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'fred'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">    B: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'wilma'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>&#125;,</span><br><span class=\"line\">    C: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'pebbles'</span>, <span class=\"attr\">age</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.pluck(flintstones1, <span class=\"string\">'age'</span>); <span class=\"comment\">//=&gt; [30, 28, 2]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以创建一个对象，<code>flintstones2</code> ，且以下结果为 <code>true</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.isEqual(flintstones1, flintstones2); <span class=\"comment\">//=&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p>但下面结果却为 <code>false</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_.pluck(flintstones1, <span class=\"string\">'age'</span>); == _.pluck(flintstones2, <span class=\"string\">'age'</span>); <span class=\"comment\">//=&gt; false;</span></span><br></pre></td></tr></table></figure></p>\n<p>下面是一种可能的情况：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> flintstones2 = &#123;</span><br><span class=\"line\">    B: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'wilma'</span>, <span class=\"attr\">age</span>: <span class=\"number\">28</span>&#125;,</span><br><span class=\"line\">    A: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'fred'</span>, <span class=\"attr\">age</span>: <span class=\"number\">30</span>&#125;,</span><br><span class=\"line\">    C: &#123;<span class=\"attr\">name</span>: <span class=\"string\">'pebbles'</span>, <span class=\"attr\">age</span>: <span class=\"number\">2</span>&#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">_.pluck(flintstones2, <span class=\"string\">'age'</span>); <span class=\"comment\">//=&gt; [28, 30, 2]</span></span><br></pre></td></tr></table></figure></p>\n<p>问题在于，<a href=\"http://www.ecma-international.org/ecma-262/5.1/#sec-12.6.4\" target=\"_blank\" rel=\"noopener\">根据规范</a>，对象 keys 的迭代顺序是依赖于实现的；通常它们按照添加到对象中的顺序进行迭代。。</p>\n<p>在写本文时，我提交了一个关于这个问题的 issue。在最好的情况下，只有通过记录问题才能解决问题。但这个问题实在影响深远。如果你想统一列表和对象的行为，你将会不断遇到这个问题，除非你实现一个（非常慢的！）统一的顺序对 Object 属性进行迭代。</p>\n<p>在 Ramda 中，<code>pluck</code> 只作用于列表。它接受一个属性名和一个列表，并返回一个相同长度的新列表。仅此而已。这个 API 深度很浅。（译者注：适用范围不太广）。</p>\n<p>你可以将其看作特点，也可以看作是缺点。以 Lodash 的 <code>filter</code> 为例: 它接受一个数组、对象或字符串作为第一个集合（参数），然后接受一个函数、对象、字符串或者空作为它的回调，并且还需要一个对象或空作为它的 this 参数。你将一次获得 3 * 4 * 2 = 24 个函数！这要么是一个很大的问题，要么增加了从中找到一个你真正想要的方案的难度，增加了太多复杂性。决定权在于你。</p>\n<p>在 Ramda 中，我们认为这种风格会增加不必要的复杂性。我们发现简单的函数签名对于维持简洁是至关重要的。如果我们需要函数既能作用于列表，又能作用于对象，我们会创建各自独立的函数（译者注：一般情况下会这样，但也有特例，比如 <code>map</code>）。如果有一个参数我们偶尔会用到，我们不会创建一个可选参数，而是创建两个函数。尽管这扩大了 API 的规模，但是它们保持了一至的浅度。</p>\n<h2>API 的增长</h2>\n<p>有一个我们已经意识到的危险，一个可以用三个字母拼出来的危险：&quot;PHP&quot;。我们不希望我们的 API 变成一个不可持续的、功能不一致的怪物。这是真正的威胁，没有强制性的规范来确定我们应该或不应该包含什么。</p>\n<p>我们一直在努力；我们不希望包含一个貌似有用的函数。</p>\n<p>为了避免变成 “PHP” 风格的庞然大物，我们专注于几件事情。首先，API 为王。虽然我们想要函数实现尽可能优雅，但我们为了即使是轻微的 API 性能改进，而牺牲了大量优雅的实现。我们试图执行严格的一致性标准。例如：像 <code>somethingBy</code> 这样的 Ramda 函数，以标准的方式看，与 <code>somethingWith</code> 函数是不同的。如 <a href=\"https://github.com/ramda/ramda/issues/65\" target=\"_blank\" rel=\"noopener\">issue 65</a> 所述，我们</p>\n<blockquote>\n<p>使用 xxBy 来表示单一属性的比较，无论是对象的自然属性还是合成属性；使用 xxWith 表示更具一般性的函数。</p>\n</blockquote>\n<p>一些使用这种方式的函数的例子包括max / min / sort / uniq / difference。</p>\n<h1>函数式</h1>\n<p>JavaScript 是一门多范式语言。你可以编写简单的命令式代码，面对对象的代码，或函数式代码。原始命令式的代码非常直白、简单。有很多库可以帮助你将 JavaScript 作为面向对象的语言使用。但是将 JavaScript 作为函数式语言使用的库非常少。Ramda 帮忙填补了这个空缺。</p>\n<p>如前所述，我们当然不是第一个。其他库通过各种不同方式让人们可以在 JavaScript 中进行函数式编程（FP）。在我看来，将函数式世界与 JavaScript 结合最成功的可能是 <a href=\"https://github.com/raganwald/allong.es\" target=\"_blank\" rel=\"noopener\">allong.es</a>。但它不是一个流行的库，与 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 、 <a href=\"http://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a> 这些库不在一个级别上（就流行程度而言）；并且它有一个与 Ramda 不同的目标：它被设计为一种教学工具，一本书的演示库。</p>\n<p>Ramda 正在尝试一些不同的东西。它的目标是成为一个能进行日常实际工作的实用的函数式库。</p>\n<p>我们从头开始构建这个函数式库，使用了许多其他函数式语言通用的技术，以对 JavaScript 有意义的方式对这些技术进行移植。我们并没有试图弥合与面向对象世界之间的鸿沟，或者复制每一种函数式语言的每一个特性。实际上，我们甚至没有试图复制单一函数式语言的每个特性。它仍然是 JavaScript，甚至还继承了 JavaScript 缺陷。</p>\n<h2>函数式特性</h2>\n<p>那么，在广阔的函数式编程领域里，哪些部分是我们想要保留的，又有哪些不在我们的考虑范围呢？下面列出了函数式编程的一些主要（不完整）特性：</p>\n<ul>\n<li>一等函数</li>\n<li>高阶函数</li>\n<li>词法闭包</li>\n<li>引用透明</li>\n<li>数据不可变</li>\n<li>模式匹配</li>\n<li>惰性求值</li>\n<li>高效递归（TCO）</li>\n<li><a href=\"https://en.wikipedia.org/w/index.php?title=Homoiconicity&amp;redirect=no\" target=\"_blank\" rel=\"noopener\">同像性（Homoiconic）</a></li>\n</ul>\n<p>前几个特性都已经内置在 JavaScript 中了。JavaScript 中的函数是一等公民，意味着我们可以像使用字符串、数字或对象等，对其引用或传递。我们还可以将函数作为参数传递给其他函数，并返回全新的函数，所以 JavaScript 中包含高阶函数。因为返回函数可以访问其在创建时的上下文中的所有变量，所以我们也在语言中构建出了词法闭包。</p>\n<p>除此之外，上面列出其他的特性都没有自动包含在 JavaScript 中。有的可以轻易实现，有的只能部分或很难实现，有的则超出了语言的当前能力。</p>\n<p>Ramda 可以确保在不会导致你的代码出问题的情况下，帮助实现（管理）上面的其他一些特性。例如，Ramda 不会改变你的输入数据。永远也不会！如果使用 <code>append</code> 将元素添加到列表的末尾，则会返回包含添加元素的新列表。你的原始列表保持不变。所以，由于 Ramda 不会尝试强行改变不可变的客户端数据，它可以很容易的与不可变数据一起工作。</p>\n<p>另一方面，Ramda 强制要求引用透明。这个概念的意思是：可以在不改变整个程序行为的情况下，将表达式替换为其对应的计算值。对于 Ramda 来说，这意味着 Ramda 不会在应用程序中存储内部状态，也不会引用任何全局变量或者内部状态可以变的闭包。简言之，当你使用相同的值调用 Ramda 函数时，总会得到相同的结果。</p>\n<p>在撰写本文时，正在讨论 Ramda 的惰性求值问题。一些库如 <a href=\"http://danieltao.com/lazy.js/\" target=\"_blank\" rel=\"noopener\">Lazy.js</a> 和 <a href=\"https://github.com/goatslacker/lz\" target=\"_blank\" rel=\"noopener\">Lz.js</a> ，表明在 JavaScript 中进行惰性求值是可行的。<a href=\"https://github.com/cognitect-labs/transducers-js\" target=\"_blank\" rel=\"noopener\">Transducer</a> 提供了一种模拟惰性求值的方法。Ramda 正在努力增强自己这方面的能力。但这是一个巨大的改变，并不会很快实现。</p>\n<p>Ramda 还会考虑加入一定程度的模式匹配，但不会像 Erlang 或 Haskell 这样的语言中的那么强大或方便。我们并没有看到会改变语言语法的宏，所以我们最多可以做一些类似于 <a href=\"http://raganwald.com/2014/06/23/multiple-dispatch.html#guarded-functions\" target=\"_blank\" rel=\"noopener\">Reg Braithwaite 所描述的东西</a>。但是这至少在某种程度上讲是一种模式匹配的技术。</p>\n<p>其他特性都超出了 Ramda 的能力。虽然有 <a href=\"https://en.wikipedia.org/wiki/Trampoline_(computing)\" target=\"_blank\" rel=\"noopener\">trampolining</a> 技术可以让你在不使用尾递归优化工具的情况下获得递归的一些好处，但是它们由于侵入性太强而不能被普遍使用。所以 Ramda 内部没有使用太多递归，也没有提供任何帮助来实现有效的递归。好消息是它将会被提到下一版语言规范的计划中去。</p>\n<p>然后是 <strong>同像性（homoiconicity）</strong> -- 某些语言（LISP、Prolog）的特性：程序的语法可以用一种在自身语言中易于理解和修改的数据结构表示的。这远远超出了 JavaScript 当前的能力，甚至超出了 Ramda 的梦想。</p>\n<h1>组合性</h1>\n<p>Ramda 的目标之一是，允许用户使用小的可组合函数，这是函数式编程的关键。</p>\n<p>函数式编程通常涉及一些少量常见的数据结构，以及搭配操作它们的大量函数。这就是 Ramda 的工作原理。</p>\n<p>简言之，Ramda 主要进行列表操作。但 JavaScript 没有列表的实现；最接近的模拟是 Array（数组）。这是 Ramda 使用的最基本的数据结构。我们不关心 JavaScript 数组的一些深层次可能的性质。我们忽略稀疏数组。如果你传了一个这样的数组给 Ramda，有可能会得到意想不到的结果。你需要传给 Ramda 以 Array 实现的列表。（如果这对你没有意义，不用担心；这是人们使用 JavaScript 数组的标准方式，你必须非常努力，才能创建出不寻常的情况（译者注：错误的情况））。</p>\n<p>许多 Ramda 函数接受列表并且返回列表。这些函数都很容易组合。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// :: [Comment] -&gt; [Number]  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userRatingForComments = R.compose(</span><br><span class=\"line\">    R.pluck(<span class=\"string\">'rating'</span>),       <span class=\"comment\">// [User] -&gt; [Number]</span></span><br><span class=\"line\">    R.map(R.propOf(users)),  <span class=\"comment\">// [String] -&gt; [User]</span></span><br><span class=\"line\">    R.pluck(<span class=\"string\">'username'</span>)      <span class=\"comment\">// [Comment] -&gt; [String]</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>Ramda 还包含 <code>pipe</code> 函数，它跟 <code>compose</code> 功能相同，但顺序是反的；我个人觉得它更可读一些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// :: [Comment] -&gt; [Number]  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> userRatingForComments = R.pipe(</span><br><span class=\"line\">    R.pluck(<span class=\"string\">'username'</span>),     <span class=\"comment\">// [Comment] -&gt; [String]</span></span><br><span class=\"line\">    R.map(R.propOf(users)),  <span class=\"comment\">// [String] -&gt; [User]</span></span><br><span class=\"line\">    R.pluck(<span class=\"string\">'rating'</span>)        <span class=\"comment\">// [User] -&gt; [Number]</span></span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>当然，组合可以作用于任何类型。如果下一个函数接受当前函数返回的类型，那么一切都应该没问题。</p>\n<p>为了让其工作，Ramda 的函数必须具有足够小的规模。这与 Unix 的哲学不谋而合：大型的工具应该由小工具构建而成，每个工具做且只做一件事情。Ramda 的函数也是如此。理想情况下，这意味着以这些函数为基础的系统的复杂性只是问题自身固有的复杂性，而不是由库增加的附带的复杂性。</p>\n<h2>不变性</h2>\n<p>需要再次重申，Ramda 函数不会修改输入数据。这是函数式编程的核心原则，也是 Ramda 工作的核心。虽然这些函数可能会改变内部局部变量，但 Ramda 不会改变传递给它的任何数据。</p>\n<p>这并不意味着你使用的所有东西都会被复制。Ramda 重用了它所能用到的。因此，在像 <code>assoc</code> 和 <code>assocPath</code> 这样的函数，返回具有特定更新属性的对象的克隆中，原始数据的所有非原生（non-primitive）属性在新对象中将以引用的方式使用。如果你想要一个对象的完全解耦的副本，Ramda 提供了 <code>cloneDeep</code>（译者注：现在 Ramda 只提供 <code>clone</code> 用作深拷贝） 函数。</p>\n<p>这种不变性对 Ramda 来说是硬性规定。任何牵扯到变更用户数据的 pull request 都会被拒绝。我们认为这是 Ramda 的主要特征之一。</p>\n<h1>实用性</h1>\n<p>最后，Ramda 的目标是成为一个实用的库。这更难表述，因为实用性就像 “美丽” 一样：总是在旁观者眼中才能反映出来。永远都会有对不符合 Ramda 哲学的功能的要求，在那些提议者心目中，这些功能都是非常实用的。通常这些函数（功能）本身是有用的，但是由于不符合 Ramda 的哲学而被拒绝。</p>\n<p>对于 Ramda 而言，实用性意味着一些具体的事情。</p>\n<h2>命令式实现</h2>\n<p>首先，Ramda 的实现并未遵循 LISP、ML 或者 Haskell 库中的优雅的编码技术。我们使用丑陋的命令式的循环，而不是优雅的递归代码块。一些 Ramda 的作者曾经在一个叫 <a href=\"https://github.com/CrossEye/eweda\" target=\"_blank\" rel=\"noopener\">Eweda</a> 的早起的库中走过这条路，代码非常漂亮，但是在解决实际问题上它却失败了。许多列表函数只能处理一千个左右的条目，而且性能也很糟糕。 JavaScript 的设计没有很好的处理递归，大多数当前的引擎不执行任何尾部调用优化。</p>\n<p>而 Ramda 的源代码却使用了乱七八糟的丑陋的 <code>while</code> 循环。</p>\n<p>这意味着 Ramda 的实现不能作为如何编写功能良好的 JavaScript 的模型（模板）。这太糟糕了。但它是目前的 JavaScript 引擎最实用的一种选择（方案）。</p>\n<h2>合理的 API</h2>\n<p>Ramda 还试图就 API 中应该包含什么做出实用的选择。我们并没有试图移植 Clojure、Haskell 或任何其他函数式语言中的任何特定的函数子集，也没有试图模仿更成熟的 JavaScript 库或规范的 API。我们采纳函数的标准是，它们表现出合理的效用。当然，它们也必须与我们的函数式范式相契合才会被考虑，但这还不够；我们必须确信它们将会被用到，并且它们提供了通过当前函数不容易实现的价值。</p>\n<p>后者是比较棘手的。有一个平衡的方案，以确定什么情况下语法糖是可以接受的。在之前，我们讨论了 <code>compose</code> 有一个执行顺序相反孪生同胞 <code>pipe</code>。有一种观点认为这是一种浪费，我们不应该把 API 因为这些多余的函数而搞乱。毕竟，</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.pipe(fn1, fn2, ..., fnN)</span><br></pre></td></tr></table></figure></p>\n<p>可以重写为如下形式：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">R.apply(R.compose, R.reverse([fn1, fn2, ..., fnN]));</span><br></pre></td></tr></table></figure></p>\n<p>但是，我们确实选择将 <code>pipe</code> 以及其他一些看似多余的函数包含到其中，当它们符合下面的条件时：</p>\n<ul>\n<li>很有可能会被用到</li>\n<li>能更好的表达开发人员的意图</li>\n<li>足够简单的实现</li>\n</ul>\n<h2>整洁且一致的 API</h2>\n<p>对于整体一致 API 的追求，听起来不像是一个现实的考虑，更像是一个纯粹主义者的目标。但事实上，提供简单而一致的 API 使得 Ramda 更易于使用。例如，一旦你习惯了 Ramda 对参数顺序的设定，你将很少需要查阅文档以确定如何构建你的调用。</p>\n<p>另外，Ramda 坚决反对可选参数。这个决定有助于形成非常整洁的 API。一个函数应该做什么以及如何调用，通常是非常直观的。</p>\n<h2>并没有 “什么会帮助我” 的建议</h2>\n<p>最后，向某个人解释这个问题通常是最困难的，那就是一个用户对什么才是实用的概念与整个库的实用性实际上可能只有一点点关系。即使提出的函数有助于解决某个难题，如果问题太过狭隘，或者解决方案偏离了我们的基础哲学，那么它也不会被纳入到 Ramda 中。虽然实用性是在旁观者眼中反映出来的，但那些能够纵观整个库的旁观者会有一个宏观的不同的视野，只有那些能够在整体上提升 Ramda 的改变才会被采纳。</p>\n<h1>结论：生而不同</h1>\n<p>Ramda 的诞生是因为，没有任何其他的库能以我们想要的方式工作。我们想要将可以作用于不可变数据的小型可组合函数，组合成简洁的函数式的 pipeline （管道）。当 Ramda 与类似的库相比较时，这涉及到一些似乎颇具争议的决定。我们并不担心这一点。Ramda 为我们工作的很好，似乎也满足了<a href=\"https://github.com/ramda/ramda/stargazers\" target=\"_blank\" rel=\"noopener\">社区的需求</a>。</p>\n<p>我们不再孤单。自从我们开始以来，<a href=\"https://github.com/nullobject/fkit\" target=\"_blank\" rel=\"noopener\">FKit</a> 也萌发了相似的想法。这是一个不太成熟的库，它的工作方式和 <a href=\"https://github.com/CrossEye/eweda\" target=\"_blank\" rel=\"noopener\">Eweda</a> 一样，试图在 API 及其实现上同时保持真正的优雅。在我看来，他们很可能会遇到性能瓶颈。但是，我们无能为力，只能祝福他们。</p>\n<p>Ramda 正在努力坚持它作为 “JavaScript 开发人员的实用的函数式库” 的座右铭。我们认为我们正在管理和维护 Ramda。但我们也<a href=\"https://github.com/ramda/ramda/issues\" target=\"_blank\" rel=\"noopener\">很乐意倾听</a> 您的想法。</p>\n"},{"title":"Thinking in Ramda: 声明式编程","date":"2017-06-11T12:27:38.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Declarative Programming](http://randycoulman.com/blog/2016/06/14/thinking-in-ramda-declarative-programming/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第四篇。\n\n在[第三节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/)中，讨论了使用 \"部分应用\" 和 \"柯里化\" 技术来组合多元（多参数）函数。\n\n当我们开始编写小的函数式构建块并组合它们时，发现必须写好多函数来包裹 JavaScript 操作符，比如算术、比较、逻辑操作符和控制流。这可能比较乏味，但 Ramda 将我们拉了回来，让事情变得有趣起来。\n\n开始之前，先介绍一些背景知识。\n\n## 命令式 vs 声明式\n\n存在很多编程语言分类的方式，如静态语言和动态语言，解释型语言和编译型语言，底层和高层语言等等。\n\n另一种划分的方式是命令式编程和声明式编程。\n\n简单地说，命令式编程中，程序员需要告诉计算机怎么做来完成任务。命令式编程带给我们每天会用到的大量的基本结构：控制流（`if`-`then`-`else` 语句和循环），算术运算符（`+`、`-`、`*`、`/`），比较运算符（`===`、`>`、`<` 等），和逻辑运算符（`&&`、`||`、`!`）。\n\n而声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。\n\n其中一种经典的声明式编程语言是 Prolog。在 Prolog 中，程序是由一组 \"facts\" (谓词) 和 一组 \"rules\" (规则) 组成。可以通过提问来启动程序。Prolog 的推理机使用 facts 和 rules 来回答问题。\n\n函数式编程被认为是声明式编程的一个子集。在一段函数式程序中，我们定义函数，然后通过组合这些函数告诉计算机做什么。\n\n即使在声明式程序中，也需要做一些命令式程序中的工作。控制流，算术、比较和逻辑操作仍然是必须使用的基本构建块。但我们需要找到一种声明式的方式来描述这些基本构建块。\n\n## 声明式替换\n\n由于我们使用 JavaScript （一种命令式语言）编程，所以在编写 \"普通\" JavaScript 代码时，使用标准的命令式结构也是正常的。\n\n但当使用 \"pipeline\" 或类似的结构编写函数式变换时，命令式的结构并不能很好的工作。\n\n## 算术\n\n在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) ，我们实现了一系列算术变换来演示 \"pipeline\"：\n\n```js\nconst multiply = (a, b) => a * b\nconst addOne = x => x + 1\nconst square = x => x * x\n \nconst operate = pipe(\n  multiply,\n  addOne,\n  square\n)\n \noperate(3, 4) // => ((3 * 4) + 1)^2 => (12 + 1)^2 => 13^2 => 169\n```\n注意我们是如何编写函数来实现我们想要的基本构建块的。\n\nRamda 提供了 `add`、`subtract`、`multiply` 和 `divide` 函数来替代标准的算术运算符。所以我们可以使用 Ramda 的 `multiply` 来代替我们自己实现的乘法，可以利用 Ramda 的柯里化 `add` 函数的优势来取代我们的 `addOne`，也可以利用 `multiply` 来编写 `square`：\n\n```js\nconst square = x => multiply(x, x)\n \nconst operate = pipe(\n  multiply,\n  add(1),\n  square\n)\n```\n\n`add(1)` 与增量运算符（`++`）非常相似，但 `++` 修改了被操作的值，因此它是 \"mutation\" 的。正如在 [第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/) 中所讲，Immutability 是函数式编程的核心原则，所以我们不想使用 `++` 或 `--`。\n\n可以使用 `add(1)` 和 `subtract(1)` 来做递增和递减操作，但由于这两个操作非常常用，所以 Ramda 专门提供了 `inc` 和 `dec`。\n\n所以可以进一步简化我们的 \"pipeline\"：\n\n```js\nconst square = x => multiply(x, x)\n \nconst operate = pipe(\n  multiply,\n  inc,\n  square\n)\n```\n\n`subtract` 是二元操作符 `-` 的替代，但还有一个表示取反的一元操作符 `-`。我们可以使用 `multiply(-1)`，但 Ramda 也提供了 `negate` 来实现相同的功能。\n\n## Comparison (比较)\n\n还是在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/)，我们写了一些函数来确定一个人是否有资格投票。该代码的最终版本如下所示：\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = either(wasBornInCountry, wasNaturalized)\n \nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\n注意，上面的一些函数使用了标准比较运算符（`===` 和 `>=`）。正如你现在所怀疑的，Ramda 也提供了这些运算符的替代。\n\n我们来修改一下代码：使用 `equals` 代替 `===`，使用 `gte` 替代 `>=`。\n\n```js\nconst wasBornInCountry = person => equals(person.birthCountry, OUR_COUNTRY)\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => gte(person.age, 18)\n \nconst isCitizen = either(wasBornInCountry, wasNaturalized)\n \nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\nRamda 还提供了其他比较运算符的替代：`gt` 对应 `>`，`lt` 对应 `<`，`lte` 对应 `<=`。\n\n注意，这些函数保持正常的参数顺序（`gt` 表示第一个参数是否大于第二个参数）。这在单独使用时没有问题，但在组合函数时，可能会让人产生困惑。这些函数似乎违反了 Ramda 的 \"待处理数据放在最后\" 的原则，所以我们在 pipeline 或类似的情况下使用它们时，要格外小心。这时，`flip` 和 占位符 (`__`) 就派上了用场。\n\n除了 `equals`，还有一个 `identical`，可以用来判断两个值是否引用了同一块内存。\n\n`===` 还有一些其他的用途：可以检测字符串或数组是否为空（`str === ''` 或 `arr.length === 0`），也可以检查变量是否为 `null` 或 `undefined`。Ramda 为这两种情况提供了方便的判断函数：`isEmpty` 和 `isNil`。\n\n## Logic (逻辑)\n\n在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 中（参见上面的相关代码）。我们使用 `both` 和 `either` 来代替 `&&` 和 `||` 运算符。我们还提到使用 `complement` 代替 `!`。\n\n当组合的函数作用于同一份输入值时，这些组合函数帮助很大。上述示例中，`wasBornInCountry`、`wasNaturalized` 和 `isOver18` 都作用于同一个人上。\n\n但有时我们需要将 `&&`、`||` 和 `!` 作用于不同的数值。对于这些情况， Ramda 提供了 `and`、`or` 和 `not` 函数。我以下列方式进行分类：`and`、`or` 和 `not` 用于处理数值；`both`、`either` 和 `complement` 用于处理函数。\n\n经常用 `||` 来提供默认值。例如，我们可能会编写如下代码：\n\n```js\nconst lineWidth = settings.lineWidth || 80\n```\n\n这是一个常见的用法，大部分情况下都能正常工作，但依赖于 JavaScript 对 \"falsy\" 值的定义。假设 `0` 是一个合法的设置选项呢？由于 `0` 是 \"falsy\" 值，所以我们最终会得到的行宽为 80 。\n\n我们可以使用上面刚学到的 `isNil` 函数，但 Ramda 提供了一个更好的选择：`defaultTo`。\n\n```js\nconst lineWidth = defaultTo(80, settings.lineWidth)\n```\n\n`defaultTo` 检查第二个参数是否为空（`isNil`）。如果非空，则返回该值；否则返回第一个值。\n\n## Conditionals (条件)\n\n控制流在函数式编程中不是必要的，但偶尔也会有些用处。在 [第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/) 中讨论的集合迭代函数在大部分情况下都可以很好的取代循环，但 \"条件\" 仍然非常重要。\n\n## ifElse\n\n我们来写一个函数，`forever21`，接受一个年龄，并返回下一个年龄。但正如名字所示，一旦成长到 21 岁，就一直保持这样。\n\n```js\nconst forever21 = age => age >= 21 ? 21 : age + 1\n```\n\n注意，条件（`age >= 21`）和第二个分支（`age + 1`）都可以写作 `age` 的函数。第一个分支（`21`）也可以重写成一个常量函数（`() => 21`）。现在我们有三个接受（或忽略）`age` 为参数的函数。\n\n现在可以使用 Ramda 的 `ifElse` 函数了，这是一个相当于 `if...then...else` 或 `?:` 的函数。\n\n```js\nconst forever21 = age => ifElse(gte(__, 21), () => 21, inc)(age)\n```\n\n如上所示，比较函数在进行组合时，可能并不是以我们想要的形式进行工作。所以在这里被迫引入了占位符（`__`）。我们也可以使用 `lte`：\n\n```js\nconst forever21 = age => ifElse(lte(21), () => 21, inc)(age)\n```\n\n在这种情况下，我们不得不读作：\"21岁小于或等于给定年龄\"。但这样可读性很低、比较乱，所以我坚持使用占位符版本的函数。\n\n## constants (常量)\n\n常量函数在这种情形下非常有用。你可能已经想到了，Ramda 为我们提供了一些便捷的方法。本例中，这个方法是 `always`。\n\n```js\nconst forever21 = age => ifElse(gte(__, 21), always(21), inc)(age)\n```\n\nRamda 还提供了 `T` 和 `F`，作为 `always(true) 和 always(false)` 的缩写。\n\n## identity (恒等)\n\n再来写一个函数：`alwaysDrivingAge`。该函数接受一个年龄，如果 `gte` 16，则将该年龄返回；但如果小于 16，则返回 16。这样任何人都可以伪造他们的驾驶年龄了，即使他们还没有达到。\n\n```js\nconst alwaysDrivingAge = age => ifElse(lt(__, 16), always(16), a => a)(age)\n```\n\n条件中的第二个分支（`a => a`）是函数式编程中的另一种常见的模式。它被称为恒等函数。也即，输出永远等于输入的函数。\n\n正如你所想的，Ramda 为我们提供了 `identity` 函数。\n\n```js\nconst alwaysDrivingAge = age => ifElse(lt(__, 16), always(16), identity)(age)\n```\n\n`identity` 可以接受多个参数，但总是返回首个参数。如果想要返回除首个参数之外的参数，可以使用更通用的 `nthArg` 函数。但 `nthArg` 不如 `identity` 用的频繁。\n\n## when 和 unless\n\n在 `ifElse` 代码中，其中一个条件分支为 `identity` 也很常见。所以 Ramda 也提供了便捷的方法。\n\n如果像上例所示，第二个分支是 `identity`，可以用 `when` 代替 `ifElse`：\n\n```js\nconst alwaysDrivingAge = age => when(lt(__, 16), always(16))(age)\n```\n\n如果第一个条件分支是 `identity`，可以用 `unless`。借助 `gte(__, 16)` 来翻转一下我们的条件，便可以使用 `unless` 了。\n\n```js\nconst alwaysDrivingAge = age => unless(gte(__, 16), always(16))(age)\n```\n\n## cond\n\nRamda 还提供了 `cond` 函数，来代替 `switch` 语句或链式的 `if...then...else` 语句。\n\n这里采用 Ramda 文档中的例子来展示 `cond` 的用法：\n\n```js\nconst water = temperature => cond([\n  [equals(0),   always('water freezes at 0°C')],\n  [equals(100), always('water boils at 100°C')],\n  [T,           temp => `nothing special happens at ${temp}°C`]\n])(temperature)\n```\n\n我目前还不需要在 Ramda 代码中使用 `cond`。但我很多年前编写过 Common Lisp 代码，所以 `cond` 函数感觉就像是位老朋友。\n\n## 结论\n\n本节中展示了很多将命令式代码转为函数声明式代码的 Ramda 函数。\n\n## 下一节\n\n你可能已经注意到了，最后我们编写的几个函数（`forever21`、`alwaysDrivingAge` 和 `water`）都接受一个参数，构建一个新函数，然后将该函数作用于参数。\n\n这也是一种常见的模式，并且 Ramda 照例提供了一些简化这些代码的便捷方法。下一节中，[Pointfree Style](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/) 将演示如何简化符合这种模式的代码。\n","source":"_posts/Thinking-in-Ramda-Declarative-Programming.md","raw":"---\ntitle: 'Thinking in Ramda: 声明式编程'\ndate: 2017-06-11 20:27:38\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Declarative Programming](http://randycoulman.com/blog/2016/06/14/thinking-in-ramda-declarative-programming/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第四篇。\n\n在[第三节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/)中，讨论了使用 \"部分应用\" 和 \"柯里化\" 技术来组合多元（多参数）函数。\n\n当我们开始编写小的函数式构建块并组合它们时，发现必须写好多函数来包裹 JavaScript 操作符，比如算术、比较、逻辑操作符和控制流。这可能比较乏味，但 Ramda 将我们拉了回来，让事情变得有趣起来。\n\n开始之前，先介绍一些背景知识。\n\n## 命令式 vs 声明式\n\n存在很多编程语言分类的方式，如静态语言和动态语言，解释型语言和编译型语言，底层和高层语言等等。\n\n另一种划分的方式是命令式编程和声明式编程。\n\n简单地说，命令式编程中，程序员需要告诉计算机怎么做来完成任务。命令式编程带给我们每天会用到的大量的基本结构：控制流（`if`-`then`-`else` 语句和循环），算术运算符（`+`、`-`、`*`、`/`），比较运算符（`===`、`>`、`<` 等），和逻辑运算符（`&&`、`||`、`!`）。\n\n而声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。\n\n其中一种经典的声明式编程语言是 Prolog。在 Prolog 中，程序是由一组 \"facts\" (谓词) 和 一组 \"rules\" (规则) 组成。可以通过提问来启动程序。Prolog 的推理机使用 facts 和 rules 来回答问题。\n\n函数式编程被认为是声明式编程的一个子集。在一段函数式程序中，我们定义函数，然后通过组合这些函数告诉计算机做什么。\n\n即使在声明式程序中，也需要做一些命令式程序中的工作。控制流，算术、比较和逻辑操作仍然是必须使用的基本构建块。但我们需要找到一种声明式的方式来描述这些基本构建块。\n\n## 声明式替换\n\n由于我们使用 JavaScript （一种命令式语言）编程，所以在编写 \"普通\" JavaScript 代码时，使用标准的命令式结构也是正常的。\n\n但当使用 \"pipeline\" 或类似的结构编写函数式变换时，命令式的结构并不能很好的工作。\n\n## 算术\n\n在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) ，我们实现了一系列算术变换来演示 \"pipeline\"：\n\n```js\nconst multiply = (a, b) => a * b\nconst addOne = x => x + 1\nconst square = x => x * x\n \nconst operate = pipe(\n  multiply,\n  addOne,\n  square\n)\n \noperate(3, 4) // => ((3 * 4) + 1)^2 => (12 + 1)^2 => 13^2 => 169\n```\n注意我们是如何编写函数来实现我们想要的基本构建块的。\n\nRamda 提供了 `add`、`subtract`、`multiply` 和 `divide` 函数来替代标准的算术运算符。所以我们可以使用 Ramda 的 `multiply` 来代替我们自己实现的乘法，可以利用 Ramda 的柯里化 `add` 函数的优势来取代我们的 `addOne`，也可以利用 `multiply` 来编写 `square`：\n\n```js\nconst square = x => multiply(x, x)\n \nconst operate = pipe(\n  multiply,\n  add(1),\n  square\n)\n```\n\n`add(1)` 与增量运算符（`++`）非常相似，但 `++` 修改了被操作的值，因此它是 \"mutation\" 的。正如在 [第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/) 中所讲，Immutability 是函数式编程的核心原则，所以我们不想使用 `++` 或 `--`。\n\n可以使用 `add(1)` 和 `subtract(1)` 来做递增和递减操作，但由于这两个操作非常常用，所以 Ramda 专门提供了 `inc` 和 `dec`。\n\n所以可以进一步简化我们的 \"pipeline\"：\n\n```js\nconst square = x => multiply(x, x)\n \nconst operate = pipe(\n  multiply,\n  inc,\n  square\n)\n```\n\n`subtract` 是二元操作符 `-` 的替代，但还有一个表示取反的一元操作符 `-`。我们可以使用 `multiply(-1)`，但 Ramda 也提供了 `negate` 来实现相同的功能。\n\n## Comparison (比较)\n\n还是在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/)，我们写了一些函数来确定一个人是否有资格投票。该代码的最终版本如下所示：\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = either(wasBornInCountry, wasNaturalized)\n \nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\n注意，上面的一些函数使用了标准比较运算符（`===` 和 `>=`）。正如你现在所怀疑的，Ramda 也提供了这些运算符的替代。\n\n我们来修改一下代码：使用 `equals` 代替 `===`，使用 `gte` 替代 `>=`。\n\n```js\nconst wasBornInCountry = person => equals(person.birthCountry, OUR_COUNTRY)\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => gte(person.age, 18)\n \nconst isCitizen = either(wasBornInCountry, wasNaturalized)\n \nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\nRamda 还提供了其他比较运算符的替代：`gt` 对应 `>`，`lt` 对应 `<`，`lte` 对应 `<=`。\n\n注意，这些函数保持正常的参数顺序（`gt` 表示第一个参数是否大于第二个参数）。这在单独使用时没有问题，但在组合函数时，可能会让人产生困惑。这些函数似乎违反了 Ramda 的 \"待处理数据放在最后\" 的原则，所以我们在 pipeline 或类似的情况下使用它们时，要格外小心。这时，`flip` 和 占位符 (`__`) 就派上了用场。\n\n除了 `equals`，还有一个 `identical`，可以用来判断两个值是否引用了同一块内存。\n\n`===` 还有一些其他的用途：可以检测字符串或数组是否为空（`str === ''` 或 `arr.length === 0`），也可以检查变量是否为 `null` 或 `undefined`。Ramda 为这两种情况提供了方便的判断函数：`isEmpty` 和 `isNil`。\n\n## Logic (逻辑)\n\n在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 中（参见上面的相关代码）。我们使用 `both` 和 `either` 来代替 `&&` 和 `||` 运算符。我们还提到使用 `complement` 代替 `!`。\n\n当组合的函数作用于同一份输入值时，这些组合函数帮助很大。上述示例中，`wasBornInCountry`、`wasNaturalized` 和 `isOver18` 都作用于同一个人上。\n\n但有时我们需要将 `&&`、`||` 和 `!` 作用于不同的数值。对于这些情况， Ramda 提供了 `and`、`or` 和 `not` 函数。我以下列方式进行分类：`and`、`or` 和 `not` 用于处理数值；`both`、`either` 和 `complement` 用于处理函数。\n\n经常用 `||` 来提供默认值。例如，我们可能会编写如下代码：\n\n```js\nconst lineWidth = settings.lineWidth || 80\n```\n\n这是一个常见的用法，大部分情况下都能正常工作，但依赖于 JavaScript 对 \"falsy\" 值的定义。假设 `0` 是一个合法的设置选项呢？由于 `0` 是 \"falsy\" 值，所以我们最终会得到的行宽为 80 。\n\n我们可以使用上面刚学到的 `isNil` 函数，但 Ramda 提供了一个更好的选择：`defaultTo`。\n\n```js\nconst lineWidth = defaultTo(80, settings.lineWidth)\n```\n\n`defaultTo` 检查第二个参数是否为空（`isNil`）。如果非空，则返回该值；否则返回第一个值。\n\n## Conditionals (条件)\n\n控制流在函数式编程中不是必要的，但偶尔也会有些用处。在 [第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/) 中讨论的集合迭代函数在大部分情况下都可以很好的取代循环，但 \"条件\" 仍然非常重要。\n\n## ifElse\n\n我们来写一个函数，`forever21`，接受一个年龄，并返回下一个年龄。但正如名字所示，一旦成长到 21 岁，就一直保持这样。\n\n```js\nconst forever21 = age => age >= 21 ? 21 : age + 1\n```\n\n注意，条件（`age >= 21`）和第二个分支（`age + 1`）都可以写作 `age` 的函数。第一个分支（`21`）也可以重写成一个常量函数（`() => 21`）。现在我们有三个接受（或忽略）`age` 为参数的函数。\n\n现在可以使用 Ramda 的 `ifElse` 函数了，这是一个相当于 `if...then...else` 或 `?:` 的函数。\n\n```js\nconst forever21 = age => ifElse(gte(__, 21), () => 21, inc)(age)\n```\n\n如上所示，比较函数在进行组合时，可能并不是以我们想要的形式进行工作。所以在这里被迫引入了占位符（`__`）。我们也可以使用 `lte`：\n\n```js\nconst forever21 = age => ifElse(lte(21), () => 21, inc)(age)\n```\n\n在这种情况下，我们不得不读作：\"21岁小于或等于给定年龄\"。但这样可读性很低、比较乱，所以我坚持使用占位符版本的函数。\n\n## constants (常量)\n\n常量函数在这种情形下非常有用。你可能已经想到了，Ramda 为我们提供了一些便捷的方法。本例中，这个方法是 `always`。\n\n```js\nconst forever21 = age => ifElse(gte(__, 21), always(21), inc)(age)\n```\n\nRamda 还提供了 `T` 和 `F`，作为 `always(true) 和 always(false)` 的缩写。\n\n## identity (恒等)\n\n再来写一个函数：`alwaysDrivingAge`。该函数接受一个年龄，如果 `gte` 16，则将该年龄返回；但如果小于 16，则返回 16。这样任何人都可以伪造他们的驾驶年龄了，即使他们还没有达到。\n\n```js\nconst alwaysDrivingAge = age => ifElse(lt(__, 16), always(16), a => a)(age)\n```\n\n条件中的第二个分支（`a => a`）是函数式编程中的另一种常见的模式。它被称为恒等函数。也即，输出永远等于输入的函数。\n\n正如你所想的，Ramda 为我们提供了 `identity` 函数。\n\n```js\nconst alwaysDrivingAge = age => ifElse(lt(__, 16), always(16), identity)(age)\n```\n\n`identity` 可以接受多个参数，但总是返回首个参数。如果想要返回除首个参数之外的参数，可以使用更通用的 `nthArg` 函数。但 `nthArg` 不如 `identity` 用的频繁。\n\n## when 和 unless\n\n在 `ifElse` 代码中，其中一个条件分支为 `identity` 也很常见。所以 Ramda 也提供了便捷的方法。\n\n如果像上例所示，第二个分支是 `identity`，可以用 `when` 代替 `ifElse`：\n\n```js\nconst alwaysDrivingAge = age => when(lt(__, 16), always(16))(age)\n```\n\n如果第一个条件分支是 `identity`，可以用 `unless`。借助 `gte(__, 16)` 来翻转一下我们的条件，便可以使用 `unless` 了。\n\n```js\nconst alwaysDrivingAge = age => unless(gte(__, 16), always(16))(age)\n```\n\n## cond\n\nRamda 还提供了 `cond` 函数，来代替 `switch` 语句或链式的 `if...then...else` 语句。\n\n这里采用 Ramda 文档中的例子来展示 `cond` 的用法：\n\n```js\nconst water = temperature => cond([\n  [equals(0),   always('water freezes at 0°C')],\n  [equals(100), always('water boils at 100°C')],\n  [T,           temp => `nothing special happens at ${temp}°C`]\n])(temperature)\n```\n\n我目前还不需要在 Ramda 代码中使用 `cond`。但我很多年前编写过 Common Lisp 代码，所以 `cond` 函数感觉就像是位老朋友。\n\n## 结论\n\n本节中展示了很多将命令式代码转为函数声明式代码的 Ramda 函数。\n\n## 下一节\n\n你可能已经注意到了，最后我们编写的几个函数（`forever21`、`alwaysDrivingAge` 和 `water`）都接受一个参数，构建一个新函数，然后将该函数作用于参数。\n\n这也是一种常见的模式，并且 Ramda 照例提供了一些简化这些代码的便捷方法。下一节中，[Pointfree Style](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/) 将演示如何简化符合这种模式的代码。\n","slug":"Thinking-in-Ramda-Declarative-Programming","published":1,"updated":"2020-06-06T14:44:04.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitu000sf6mja06kr3da","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/14/thinking-in-ramda-declarative-programming/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Declarative Programming</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第四篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">第三节</a>中，讨论了使用 &quot;部分应用&quot; 和 &quot;柯里化&quot; 技术来组合多元（多参数）函数。</p>\n<p>当我们开始编写小的函数式构建块并组合它们时，发现必须写好多函数来包裹 JavaScript 操作符，比如算术、比较、逻辑操作符和控制流。这可能比较乏味，但 Ramda 将我们拉了回来，让事情变得有趣起来。</p>\n<p>开始之前，先介绍一些背景知识。</p>\n<h2>命令式 vs 声明式</h2>\n<p>存在很多编程语言分类的方式，如静态语言和动态语言，解释型语言和编译型语言，底层和高层语言等等。</p>\n<p>另一种划分的方式是命令式编程和声明式编程。</p>\n<p>简单地说，命令式编程中，程序员需要告诉计算机怎么做来完成任务。命令式编程带给我们每天会用到的大量的基本结构：控制流（<code>if</code>-<code>then</code>-<code>else</code> 语句和循环），算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>），比较运算符（<code>===</code>、<code>&gt;</code>、<code>&lt;</code> 等），和逻辑运算符（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）。</p>\n<p>而声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。</p>\n<p>其中一种经典的声明式编程语言是 Prolog。在 Prolog 中，程序是由一组 &quot;facts&quot; (谓词) 和 一组 &quot;rules&quot; (规则) 组成。可以通过提问来启动程序。Prolog 的推理机使用 facts 和 rules 来回答问题。</p>\n<p>函数式编程被认为是声明式编程的一个子集。在一段函数式程序中，我们定义函数，然后通过组合这些函数告诉计算机做什么。</p>\n<p>即使在声明式程序中，也需要做一些命令式程序中的工作。控制流，算术、比较和逻辑操作仍然是必须使用的基本构建块。但我们需要找到一种声明式的方式来描述这些基本构建块。</p>\n<h2>声明式替换</h2>\n<p>由于我们使用 JavaScript （一种命令式语言）编程，所以在编写 &quot;普通&quot; JavaScript 代码时，使用标准的命令式结构也是正常的。</p>\n<p>但当使用 &quot;pipeline&quot; 或类似的结构编写函数式变换时，命令式的结构并不能很好的工作。</p>\n<h2>算术</h2>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> ，我们实现了一系列算术变换来演示 &quot;pipeline&quot;：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> multiply = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a * b</span><br><span class=\"line\"><span class=\"keyword\">const</span> addOne = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  addOne,</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\">operate(<span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></span><br></pre></td></tr></table></figure></p>\n<p>注意我们是如何编写函数来实现我们想要的基本构建块的。</p>\n<p>Ramda 提供了 <code>add</code>、<code>subtract</code>、<code>multiply</code> 和 <code>divide</code> 函数来替代标准的算术运算符。所以我们可以使用 Ramda 的 <code>multiply</code> 来代替我们自己实现的乘法，可以利用 Ramda 的柯里化 <code>add</code> 函数的优势来取代我们的 <code>addOne</code>，也可以利用 <code>multiply</code> 来编写 <code>square</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> multiply(x, x)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  add(<span class=\"number\">1</span>),</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>add(1)</code> 与增量运算符（<code>++</code>）非常相似，但 <code>++</code> 修改了被操作的值，因此它是 &quot;mutation&quot; 的。正如在 <a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一节</a> 中所讲，Immutability 是函数式编程的核心原则，所以我们不想使用 <code>++</code> 或 <code>--</code>。</p>\n<p>可以使用 <code>add(1)</code> 和 <code>subtract(1)</code> 来做递增和递减操作，但由于这两个操作非常常用，所以 Ramda 专门提供了 <code>inc</code> 和 <code>dec</code>。</p>\n<p>所以可以进一步简化我们的 &quot;pipeline&quot;：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> multiply(x, x)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  inc,</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>subtract</code> 是二元操作符 <code>-</code> 的替代，但还有一个表示取反的一元操作符 <code>-</code>。我们可以使用 <code>multiply(-1)</code>，但 Ramda 也提供了 <code>negate</code> 来实现相同的功能。</p>\n<h2>Comparison (比较)</h2>\n<p>还是在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a>，我们写了一些函数来确定一个人是否有资格投票。该代码的最终版本如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>注意，上面的一些函数使用了标准比较运算符（<code>===</code> 和 <code>&gt;=</code>）。正如你现在所怀疑的，Ramda 也提供了这些运算符的替代。</p>\n<p>我们来修改一下代码：使用 <code>equals</code> 代替 <code>===</code>，使用 <code>gte</code> 替代 <code>&gt;=</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(person.age, <span class=\"number\">18</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>Ramda 还提供了其他比较运算符的替代：<code>gt</code> 对应 <code>&gt;</code>，<code>lt</code> 对应 <code>&lt;</code>，<code>lte</code> 对应 <code>&lt;=</code>。</p>\n<p>注意，这些函数保持正常的参数顺序（<code>gt</code> 表示第一个参数是否大于第二个参数）。这在单独使用时没有问题，但在组合函数时，可能会让人产生困惑。这些函数似乎违反了 Ramda 的 &quot;待处理数据放在最后&quot; 的原则，所以我们在 pipeline 或类似的情况下使用它们时，要格外小心。这时，<code>flip</code> 和 占位符 (<code>__</code>) 就派上了用场。</p>\n<p>除了 <code>equals</code>，还有一个 <code>identical</code>，可以用来判断两个值是否引用了同一块内存。</p>\n<p><code>===</code> 还有一些其他的用途：可以检测字符串或数组是否为空（<code>str === ''</code> 或 <code>arr.length === 0</code>），也可以检查变量是否为 <code>null</code> 或 <code>undefined</code>。Ramda 为这两种情况提供了方便的判断函数：<code>isEmpty</code> 和 <code>isNil</code>。</p>\n<h2>Logic (逻辑)</h2>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> 中（参见上面的相关代码）。我们使用 <code>both</code> 和 <code>either</code> 来代替 <code>&amp;&amp;</code> 和 <code>||</code> 运算符。我们还提到使用 <code>complement</code> 代替 <code>!</code>。</p>\n<p>当组合的函数作用于同一份输入值时，这些组合函数帮助很大。上述示例中，<code>wasBornInCountry</code>、<code>wasNaturalized</code> 和 <code>isOver18</code> 都作用于同一个人上。</p>\n<p>但有时我们需要将 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 作用于不同的数值。对于这些情况， Ramda 提供了 <code>and</code>、<code>or</code> 和 <code>not</code> 函数。我以下列方式进行分类：<code>and</code>、<code>or</code> 和 <code>not</code> 用于处理数值；<code>both</code>、<code>either</code> 和 <code>complement</code> 用于处理函数。</p>\n<p>经常用 <code>||</code> 来提供默认值。例如，我们可能会编写如下代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lineWidth = settings.lineWidth || <span class=\"number\">80</span></span><br></pre></td></tr></table></figure></p>\n<p>这是一个常见的用法，大部分情况下都能正常工作，但依赖于 JavaScript 对 &quot;falsy&quot; 值的定义。假设 <code>0</code> 是一个合法的设置选项呢？由于 <code>0</code> 是 &quot;falsy&quot; 值，所以我们最终会得到的行宽为 80 。</p>\n<p>我们可以使用上面刚学到的 <code>isNil</code> 函数，但 Ramda 提供了一个更好的选择：<code>defaultTo</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lineWidth = defaultTo(<span class=\"number\">80</span>, settings.lineWidth)</span><br></pre></td></tr></table></figure></p>\n<p><code>defaultTo</code> 检查第二个参数是否为空（<code>isNil</code>）。如果非空，则返回该值；否则返回第一个值。</p>\n<h2>Conditionals (条件)</h2>\n<p>控制流在函数式编程中不是必要的，但偶尔也会有些用处。在 <a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一节</a> 中讨论的集合迭代函数在大部分情况下都可以很好的取代循环，但 &quot;条件&quot; 仍然非常重要。</p>\n<h2>ifElse</h2>\n<p>我们来写一个函数，<code>forever21</code>，接受一个年龄，并返回下一个年龄。但正如名字所示，一旦成长到 21 岁，就一直保持这样。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> age &gt;= <span class=\"number\">21</span> ? <span class=\"number\">21</span> : age + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，条件（<code>age &gt;= 21</code>）和第二个分支（<code>age + 1</code>）都可以写作 <code>age</code> 的函数。第一个分支（<code>21</code>）也可以重写成一个常量函数（<code>() =&gt; 21</code>）。现在我们有三个接受（或忽略）<code>age</code> 为参数的函数。</p>\n<p>现在可以使用 Ramda 的 <code>ifElse</code> 函数了，这是一个相当于 <code>if...then...else</code> 或 <code>?:</code> 的函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(gte(__, <span class=\"number\">21</span>), () =&gt; <span class=\"number\">21</span>, inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>如上所示，比较函数在进行组合时，可能并不是以我们想要的形式进行工作。所以在这里被迫引入了占位符（<code>__</code>）。我们也可以使用 <code>lte</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lte(<span class=\"number\">21</span>), () =&gt; <span class=\"number\">21</span>, inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>在这种情况下，我们不得不读作：&quot;21岁小于或等于给定年龄&quot;。但这样可读性很低、比较乱，所以我坚持使用占位符版本的函数。</p>\n<h2>constants (常量)</h2>\n<p>常量函数在这种情形下非常有用。你可能已经想到了，Ramda 为我们提供了一些便捷的方法。本例中，这个方法是 <code>always</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(gte(__, <span class=\"number\">21</span>), always(<span class=\"number\">21</span>), inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>Ramda 还提供了 <code>T</code> 和 <code>F</code>，作为 <code>always(true) 和 always(false)</code> 的缩写。</p>\n<h2>identity (恒等)</h2>\n<p>再来写一个函数：<code>alwaysDrivingAge</code>。该函数接受一个年龄，如果 <code>gte</code> 16，则将该年龄返回；但如果小于 16，则返回 16。这样任何人都可以伪造他们的驾驶年龄了，即使他们还没有达到。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>), a =&gt; a)(age)</span><br></pre></td></tr></table></figure></p>\n<p>条件中的第二个分支（<code>a =&gt; a</code>）是函数式编程中的另一种常见的模式。它被称为恒等函数。也即，输出永远等于输入的函数。</p>\n<p>正如你所想的，Ramda 为我们提供了 <code>identity</code> 函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>), identity)(age)</span><br></pre></td></tr></table></figure></p>\n<p><code>identity</code> 可以接受多个参数，但总是返回首个参数。如果想要返回除首个参数之外的参数，可以使用更通用的 <code>nthArg</code> 函数。但 <code>nthArg</code> 不如 <code>identity</code> 用的频繁。</p>\n<h2>when 和 unless</h2>\n<p>在 <code>ifElse</code> 代码中，其中一个条件分支为 <code>identity</code> 也很常见。所以 Ramda 也提供了便捷的方法。</p>\n<p>如果像上例所示，第二个分支是 <code>identity</code>，可以用 <code>when</code> 代替 <code>ifElse</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> when(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>))(age)</span><br></pre></td></tr></table></figure></p>\n<p>如果第一个条件分支是 <code>identity</code>，可以用 <code>unless</code>。借助 <code>gte(__, 16)</code> 来翻转一下我们的条件，便可以使用 <code>unless</code> 了。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> unless(gte(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>))(age)</span><br></pre></td></tr></table></figure></p>\n<h2>cond</h2>\n<p>Ramda 还提供了 <code>cond</code> 函数，来代替 <code>switch</code> 语句或链式的 <code>if...then...else</code> 语句。</p>\n<p>这里采用 Ramda 文档中的例子来展示 <code>cond</code> 的用法：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> water = <span class=\"function\"><span class=\"params\">temperature</span> =&gt;</span> cond([</span><br><span class=\"line\">  [equals(<span class=\"number\">0</span>),   always(<span class=\"string\">'water freezes at 0°C'</span>)],</span><br><span class=\"line\">  [equals(<span class=\"number\">100</span>), always(<span class=\"string\">'water boils at 100°C'</span>)],</span><br><span class=\"line\">  [T,           temp =&gt; <span class=\"string\">`nothing special happens at <span class=\"subst\">$&#123;temp&#125;</span>°C`</span>]</span><br><span class=\"line\">])(temperature)</span><br></pre></td></tr></table></figure></p>\n<p>我目前还不需要在 Ramda 代码中使用 <code>cond</code>。但我很多年前编写过 Common Lisp 代码，所以 <code>cond</code> 函数感觉就像是位老朋友。</p>\n<h2>结论</h2>\n<p>本节中展示了很多将命令式代码转为函数声明式代码的 Ramda 函数。</p>\n<h2>下一节</h2>\n<p>你可能已经注意到了，最后我们编写的几个函数（<code>forever21</code>、<code>alwaysDrivingAge</code> 和 <code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于参数。</p>\n<p>这也是一种常见的模式，并且 Ramda 照例提供了一些简化这些代码的便捷方法。下一节中，<a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">Pointfree Style</a> 将演示如何简化符合这种模式的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/14/thinking-in-ramda-declarative-programming/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Declarative Programming</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第四篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">第三节</a>中，讨论了使用 &quot;部分应用&quot; 和 &quot;柯里化&quot; 技术来组合多元（多参数）函数。</p>\n<p>当我们开始编写小的函数式构建块并组合它们时，发现必须写好多函数来包裹 JavaScript 操作符，比如算术、比较、逻辑操作符和控制流。这可能比较乏味，但 Ramda 将我们拉了回来，让事情变得有趣起来。</p>\n<p>开始之前，先介绍一些背景知识。</p>\n<h2>命令式 vs 声明式</h2>\n<p>存在很多编程语言分类的方式，如静态语言和动态语言，解释型语言和编译型语言，底层和高层语言等等。</p>\n<p>另一种划分的方式是命令式编程和声明式编程。</p>\n<p>简单地说，命令式编程中，程序员需要告诉计算机怎么做来完成任务。命令式编程带给我们每天会用到的大量的基本结构：控制流（<code>if</code>-<code>then</code>-<code>else</code> 语句和循环），算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>），比较运算符（<code>===</code>、<code>&gt;</code>、<code>&lt;</code> 等），和逻辑运算符（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）。</p>\n<p>而声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。</p>\n<p>其中一种经典的声明式编程语言是 Prolog。在 Prolog 中，程序是由一组 &quot;facts&quot; (谓词) 和 一组 &quot;rules&quot; (规则) 组成。可以通过提问来启动程序。Prolog 的推理机使用 facts 和 rules 来回答问题。</p>\n<p>函数式编程被认为是声明式编程的一个子集。在一段函数式程序中，我们定义函数，然后通过组合这些函数告诉计算机做什么。</p>\n<p>即使在声明式程序中，也需要做一些命令式程序中的工作。控制流，算术、比较和逻辑操作仍然是必须使用的基本构建块。但我们需要找到一种声明式的方式来描述这些基本构建块。</p>\n<h2>声明式替换</h2>\n<p>由于我们使用 JavaScript （一种命令式语言）编程，所以在编写 &quot;普通&quot; JavaScript 代码时，使用标准的命令式结构也是正常的。</p>\n<p>但当使用 &quot;pipeline&quot; 或类似的结构编写函数式变换时，命令式的结构并不能很好的工作。</p>\n<h2>算术</h2>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> ，我们实现了一系列算术变换来演示 &quot;pipeline&quot;：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> multiply = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a * b</span><br><span class=\"line\"><span class=\"keyword\">const</span> addOne = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  addOne,</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br><span class=\"line\"> </span><br><span class=\"line\">operate(<span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></span><br></pre></td></tr></table></figure></p>\n<p>注意我们是如何编写函数来实现我们想要的基本构建块的。</p>\n<p>Ramda 提供了 <code>add</code>、<code>subtract</code>、<code>multiply</code> 和 <code>divide</code> 函数来替代标准的算术运算符。所以我们可以使用 Ramda 的 <code>multiply</code> 来代替我们自己实现的乘法，可以利用 Ramda 的柯里化 <code>add</code> 函数的优势来取代我们的 <code>addOne</code>，也可以利用 <code>multiply</code> 来编写 <code>square</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> multiply(x, x)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  add(<span class=\"number\">1</span>),</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>add(1)</code> 与增量运算符（<code>++</code>）非常相似，但 <code>++</code> 修改了被操作的值，因此它是 &quot;mutation&quot; 的。正如在 <a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一节</a> 中所讲，Immutability 是函数式编程的核心原则，所以我们不想使用 <code>++</code> 或 <code>--</code>。</p>\n<p>可以使用 <code>add(1)</code> 和 <code>subtract(1)</code> 来做递增和递减操作，但由于这两个操作非常常用，所以 Ramda 专门提供了 <code>inc</code> 和 <code>dec</code>。</p>\n<p>所以可以进一步简化我们的 &quot;pipeline&quot;：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> multiply(x, x)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  inc,</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p><code>subtract</code> 是二元操作符 <code>-</code> 的替代，但还有一个表示取反的一元操作符 <code>-</code>。我们可以使用 <code>multiply(-1)</code>，但 Ramda 也提供了 <code>negate</code> 来实现相同的功能。</p>\n<h2>Comparison (比较)</h2>\n<p>还是在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a>，我们写了一些函数来确定一个人是否有资格投票。该代码的最终版本如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>注意，上面的一些函数使用了标准比较运算符（<code>===</code> 和 <code>&gt;=</code>）。正如你现在所怀疑的，Ramda 也提供了这些运算符的替代。</p>\n<p>我们来修改一下代码：使用 <code>equals</code> 代替 <code>===</code>，使用 <code>gte</code> 替代 <code>&gt;=</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(person.age, <span class=\"number\">18</span>)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>Ramda 还提供了其他比较运算符的替代：<code>gt</code> 对应 <code>&gt;</code>，<code>lt</code> 对应 <code>&lt;</code>，<code>lte</code> 对应 <code>&lt;=</code>。</p>\n<p>注意，这些函数保持正常的参数顺序（<code>gt</code> 表示第一个参数是否大于第二个参数）。这在单独使用时没有问题，但在组合函数时，可能会让人产生困惑。这些函数似乎违反了 Ramda 的 &quot;待处理数据放在最后&quot; 的原则，所以我们在 pipeline 或类似的情况下使用它们时，要格外小心。这时，<code>flip</code> 和 占位符 (<code>__</code>) 就派上了用场。</p>\n<p>除了 <code>equals</code>，还有一个 <code>identical</code>，可以用来判断两个值是否引用了同一块内存。</p>\n<p><code>===</code> 还有一些其他的用途：可以检测字符串或数组是否为空（<code>str === ''</code> 或 <code>arr.length === 0</code>），也可以检查变量是否为 <code>null</code> 或 <code>undefined</code>。Ramda 为这两种情况提供了方便的判断函数：<code>isEmpty</code> 和 <code>isNil</code>。</p>\n<h2>Logic (逻辑)</h2>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> 中（参见上面的相关代码）。我们使用 <code>both</code> 和 <code>either</code> 来代替 <code>&amp;&amp;</code> 和 <code>||</code> 运算符。我们还提到使用 <code>complement</code> 代替 <code>!</code>。</p>\n<p>当组合的函数作用于同一份输入值时，这些组合函数帮助很大。上述示例中，<code>wasBornInCountry</code>、<code>wasNaturalized</code> 和 <code>isOver18</code> 都作用于同一个人上。</p>\n<p>但有时我们需要将 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 作用于不同的数值。对于这些情况， Ramda 提供了 <code>and</code>、<code>or</code> 和 <code>not</code> 函数。我以下列方式进行分类：<code>and</code>、<code>or</code> 和 <code>not</code> 用于处理数值；<code>both</code>、<code>either</code> 和 <code>complement</code> 用于处理函数。</p>\n<p>经常用 <code>||</code> 来提供默认值。例如，我们可能会编写如下代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lineWidth = settings.lineWidth || <span class=\"number\">80</span></span><br></pre></td></tr></table></figure></p>\n<p>这是一个常见的用法，大部分情况下都能正常工作，但依赖于 JavaScript 对 &quot;falsy&quot; 值的定义。假设 <code>0</code> 是一个合法的设置选项呢？由于 <code>0</code> 是 &quot;falsy&quot; 值，所以我们最终会得到的行宽为 80 。</p>\n<p>我们可以使用上面刚学到的 <code>isNil</code> 函数，但 Ramda 提供了一个更好的选择：<code>defaultTo</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> lineWidth = defaultTo(<span class=\"number\">80</span>, settings.lineWidth)</span><br></pre></td></tr></table></figure></p>\n<p><code>defaultTo</code> 检查第二个参数是否为空（<code>isNil</code>）。如果非空，则返回该值；否则返回第一个值。</p>\n<h2>Conditionals (条件)</h2>\n<p>控制流在函数式编程中不是必要的，但偶尔也会有些用处。在 <a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一节</a> 中讨论的集合迭代函数在大部分情况下都可以很好的取代循环，但 &quot;条件&quot; 仍然非常重要。</p>\n<h2>ifElse</h2>\n<p>我们来写一个函数，<code>forever21</code>，接受一个年龄，并返回下一个年龄。但正如名字所示，一旦成长到 21 岁，就一直保持这样。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> age &gt;= <span class=\"number\">21</span> ? <span class=\"number\">21</span> : age + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，条件（<code>age &gt;= 21</code>）和第二个分支（<code>age + 1</code>）都可以写作 <code>age</code> 的函数。第一个分支（<code>21</code>）也可以重写成一个常量函数（<code>() =&gt; 21</code>）。现在我们有三个接受（或忽略）<code>age</code> 为参数的函数。</p>\n<p>现在可以使用 Ramda 的 <code>ifElse</code> 函数了，这是一个相当于 <code>if...then...else</code> 或 <code>?:</code> 的函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(gte(__, <span class=\"number\">21</span>), () =&gt; <span class=\"number\">21</span>, inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>如上所示，比较函数在进行组合时，可能并不是以我们想要的形式进行工作。所以在这里被迫引入了占位符（<code>__</code>）。我们也可以使用 <code>lte</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lte(<span class=\"number\">21</span>), () =&gt; <span class=\"number\">21</span>, inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>在这种情况下，我们不得不读作：&quot;21岁小于或等于给定年龄&quot;。但这样可读性很低、比较乱，所以我坚持使用占位符版本的函数。</p>\n<h2>constants (常量)</h2>\n<p>常量函数在这种情形下非常有用。你可能已经想到了，Ramda 为我们提供了一些便捷的方法。本例中，这个方法是 <code>always</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(gte(__, <span class=\"number\">21</span>), always(<span class=\"number\">21</span>), inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>Ramda 还提供了 <code>T</code> 和 <code>F</code>，作为 <code>always(true) 和 always(false)</code> 的缩写。</p>\n<h2>identity (恒等)</h2>\n<p>再来写一个函数：<code>alwaysDrivingAge</code>。该函数接受一个年龄，如果 <code>gte</code> 16，则将该年龄返回；但如果小于 16，则返回 16。这样任何人都可以伪造他们的驾驶年龄了，即使他们还没有达到。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>), a =&gt; a)(age)</span><br></pre></td></tr></table></figure></p>\n<p>条件中的第二个分支（<code>a =&gt; a</code>）是函数式编程中的另一种常见的模式。它被称为恒等函数。也即，输出永远等于输入的函数。</p>\n<p>正如你所想的，Ramda 为我们提供了 <code>identity</code> 函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>), identity)(age)</span><br></pre></td></tr></table></figure></p>\n<p><code>identity</code> 可以接受多个参数，但总是返回首个参数。如果想要返回除首个参数之外的参数，可以使用更通用的 <code>nthArg</code> 函数。但 <code>nthArg</code> 不如 <code>identity</code> 用的频繁。</p>\n<h2>when 和 unless</h2>\n<p>在 <code>ifElse</code> 代码中，其中一个条件分支为 <code>identity</code> 也很常见。所以 Ramda 也提供了便捷的方法。</p>\n<p>如果像上例所示，第二个分支是 <code>identity</code>，可以用 <code>when</code> 代替 <code>ifElse</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> when(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>))(age)</span><br></pre></td></tr></table></figure></p>\n<p>如果第一个条件分支是 <code>identity</code>，可以用 <code>unless</code>。借助 <code>gte(__, 16)</code> 来翻转一下我们的条件，便可以使用 <code>unless</code> 了。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> unless(gte(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>))(age)</span><br></pre></td></tr></table></figure></p>\n<h2>cond</h2>\n<p>Ramda 还提供了 <code>cond</code> 函数，来代替 <code>switch</code> 语句或链式的 <code>if...then...else</code> 语句。</p>\n<p>这里采用 Ramda 文档中的例子来展示 <code>cond</code> 的用法：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> water = <span class=\"function\"><span class=\"params\">temperature</span> =&gt;</span> cond([</span><br><span class=\"line\">  [equals(<span class=\"number\">0</span>),   always(<span class=\"string\">'water freezes at 0°C'</span>)],</span><br><span class=\"line\">  [equals(<span class=\"number\">100</span>), always(<span class=\"string\">'water boils at 100°C'</span>)],</span><br><span class=\"line\">  [T,           temp =&gt; <span class=\"string\">`nothing special happens at <span class=\"subst\">$&#123;temp&#125;</span>°C`</span>]</span><br><span class=\"line\">])(temperature)</span><br></pre></td></tr></table></figure></p>\n<p>我目前还不需要在 Ramda 代码中使用 <code>cond</code>。但我很多年前编写过 Common Lisp 代码，所以 <code>cond</code> 函数感觉就像是位老朋友。</p>\n<h2>结论</h2>\n<p>本节中展示了很多将命令式代码转为函数声明式代码的 Ramda 函数。</p>\n<h2>下一节</h2>\n<p>你可能已经注意到了，最后我们编写的几个函数（<code>forever21</code>、<code>alwaysDrivingAge</code> 和 <code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于参数。</p>\n<p>这也是一种常见的模式，并且 Ramda 照例提供了一些简化这些代码的便捷方法。下一节中，<a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">Pointfree Style</a> 将演示如何简化符合这种模式的代码。</p>\n"},{"title":"Thinking in Ramda: 数据不变性和数组","date":"2017-06-17T14:21:48.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Immutability and Arrays](http://randycoulman.com/blog/2016/07/05/thinking-in-ramda-immutability-and-arrays/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第七篇。\n\n在 [第六节](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/) 中，讨论了以函数式和数据不变性（immutable）的方式来处理 JavaScript 对象。\n\n本节将继续用相同的方式讨论数组。\n\n## 读取数组元素\n\n在 [第六节](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/) 中，展示了许多读取对象属性的 Ramda 函数，包括 `prop`、`pick` 和 `has`。Ramda 有更多的方法来读取数组的元素。\n\n数组中与 `prop` 类似的是 `nth`；与 `pick` 类似的是 `slice`，跟 `has` 类似的是 `contains`。来看一些例子。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nnth(3, numbers) // => 40  (0-based indexing)\n \nnth(-2, numbers) // => 50 (negative numbers start from the right)\n \nslice(2, 5, numbers) // => [30, 40, 50] (see below)\n \ncontains(20, numbers) // => true\n```\n\n`slice` 接受两个索引，返回从第 1 个索引开始（以 0 为起始）到第 2 个索引结束（不包含）的所有元素组成的子数组。\n\n经常会访问首个（`nth(0)`）和最后一个（`nth(-1)`）元素，所以 Ramda 为这两种特殊情形提供的便捷方法：`head` 和 `last`。还提供了访问除首个元素之外的所有元素的函数：`tail`，除最后一个元素之外的所有元素的方法：`init`，前 `N` 个元素：`take(N)`，后 `N` 个元素：`takeLast(N)`。来看看这些函数的实例。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nhead(numbers) // => 10\ntail(numbers) // => [20, 30, 40, 50, 60]\n \nlast(numbers) // => 60\ninit(numbers) // => [10, 20, 30, 40, 50]\n \ntake(3, numbers) // => [10, 20, 30]\ntakeLast(3, numbers) // => [40, 50, 60]\n```\n\n## 增、删、改数组元素\n\n对于对象，我们已经学了对其属性进行增、删、改的函数：`assoc`、`dissoc`、`evolve` 等。\n\n但数组是有序数据结构，有好多函数与 `assoc` 类似。最常用的是 `insert` 和 `update`，Ramda 还提供了 `append` 和 `prepend` 来在数组头部或尾部添加元素。`insert`、`append` 和 `prepend` 会给数组添加新元素；`update` 使用新值替换已有元素。\n\n正如一般函数式库应该具备的，所有这些函数都返回修改后的新数组，原有数组保持不变。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \ninsert(3, 35, numbers) // => [10, 20, 30, 35, 40, 50, 60]\n \nappend(70, numbers) // => [10, 20, 30, 40, 50, 60, 70]\n \nprepend(0, numbers) // => [0, 10, 20, 30, 40, 50, 60]\n \nupdate(1, 15, numbers) // => [10, 15, 30, 40, 50, 60]\n```\n\n为了将两个对象合并为一个，我们学习了 `merge`；Ramda 为数组合并提供了 `concat`。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nconcat(numbers, [70, 80, 90]) // => [10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n注意，第二个数组添加到第一个数组之后。当单独使用 `concat` 时，可以很好的工作；但类似于 `merge`，在 pipeline 中可能并不像预期的那样工作。可以为在 pipeline 中使用定义一个辅助函数 `concatAfter`：`const concatAfter = flip(concat)`。\n\nRamda 还提供了几个删除元素的函数。`remove` 删除指定索引处的元素，`without` 通过值删除元素。还有常用到的删除前 `N` 或 后 `N` 个元素的函数：`drop` 和 `dropLast`。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nremove(2, 3, numbers) // => [10, 20, 60]\n \nwithout([30, 40, 50], numbers) // => [10, 20, 60]\n \ndrop(3, numbers) // => [40, 50, 60]\n \ndropLast(3, numbers) // => [10, 20, 30]\n```\n\n注意，`remove` 接受一个索引和一个删除元素的数量，而 `slice` 接受两个索引。如果你不知道这种不一致，可能会造成使用上的困扰。\n\n## 变换元素\n\n与对象一样，我们可能希望通过将函数应用于元素的原始值来更新数组元素。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nupdate(2, multiply(10, nth(2, numbers)), numbers) // => [10, 20, 300, 40, 50, 60]\n```\n\n为了简化这个常见的用例， Ramda 提供了 `adjust`，其工作方式类似于操作对象的 `evolve`。与 `evolve` 不同的是， `adjust` 只能作用于数组的单个元素。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nadjust(multiply(10), 2, numbers)\n```\n\n注意，与 `update` 相比，`adjust` 将前两个参数的位置交换了一下。这可能会引起困扰，但当进行部分应用时，这样做还是很有道理的。你可能会先提供一个调整函数，比如 `adjust(multiply(10))` ，然后再决定要调整的索引和数组。\n\n## 结论\n\n我们现在有了以声明式和不变式操作对象和数组的一系列方法。这允许我们在不改变已有数据的情况下，从较小的、函数式的构建模块来构建程序，通过对函数进行组合来实现我们想要的功能。\n\n## 下一节\n\n我们学习了读取、更新和转换对象属性和数组元素的方法。Ramda 提供了更通用的进行这些操作的工具：lens（透镜）。[Lenses](https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/) 向我们演示了它们的工作原理和方式。\n","source":"_posts/Thinking-in-Ramda-Immutability-and-Arrays.md","raw":"---\ntitle: 'Thinking in Ramda: 数据不变性和数组'\ndate: 2017-06-17 22:21:48\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Immutability and Arrays](http://randycoulman.com/blog/2016/07/05/thinking-in-ramda-immutability-and-arrays/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第七篇。\n\n在 [第六节](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/) 中，讨论了以函数式和数据不变性（immutable）的方式来处理 JavaScript 对象。\n\n本节将继续用相同的方式讨论数组。\n\n## 读取数组元素\n\n在 [第六节](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/) 中，展示了许多读取对象属性的 Ramda 函数，包括 `prop`、`pick` 和 `has`。Ramda 有更多的方法来读取数组的元素。\n\n数组中与 `prop` 类似的是 `nth`；与 `pick` 类似的是 `slice`，跟 `has` 类似的是 `contains`。来看一些例子。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nnth(3, numbers) // => 40  (0-based indexing)\n \nnth(-2, numbers) // => 50 (negative numbers start from the right)\n \nslice(2, 5, numbers) // => [30, 40, 50] (see below)\n \ncontains(20, numbers) // => true\n```\n\n`slice` 接受两个索引，返回从第 1 个索引开始（以 0 为起始）到第 2 个索引结束（不包含）的所有元素组成的子数组。\n\n经常会访问首个（`nth(0)`）和最后一个（`nth(-1)`）元素，所以 Ramda 为这两种特殊情形提供的便捷方法：`head` 和 `last`。还提供了访问除首个元素之外的所有元素的函数：`tail`，除最后一个元素之外的所有元素的方法：`init`，前 `N` 个元素：`take(N)`，后 `N` 个元素：`takeLast(N)`。来看看这些函数的实例。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nhead(numbers) // => 10\ntail(numbers) // => [20, 30, 40, 50, 60]\n \nlast(numbers) // => 60\ninit(numbers) // => [10, 20, 30, 40, 50]\n \ntake(3, numbers) // => [10, 20, 30]\ntakeLast(3, numbers) // => [40, 50, 60]\n```\n\n## 增、删、改数组元素\n\n对于对象，我们已经学了对其属性进行增、删、改的函数：`assoc`、`dissoc`、`evolve` 等。\n\n但数组是有序数据结构，有好多函数与 `assoc` 类似。最常用的是 `insert` 和 `update`，Ramda 还提供了 `append` 和 `prepend` 来在数组头部或尾部添加元素。`insert`、`append` 和 `prepend` 会给数组添加新元素；`update` 使用新值替换已有元素。\n\n正如一般函数式库应该具备的，所有这些函数都返回修改后的新数组，原有数组保持不变。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \ninsert(3, 35, numbers) // => [10, 20, 30, 35, 40, 50, 60]\n \nappend(70, numbers) // => [10, 20, 30, 40, 50, 60, 70]\n \nprepend(0, numbers) // => [0, 10, 20, 30, 40, 50, 60]\n \nupdate(1, 15, numbers) // => [10, 15, 30, 40, 50, 60]\n```\n\n为了将两个对象合并为一个，我们学习了 `merge`；Ramda 为数组合并提供了 `concat`。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nconcat(numbers, [70, 80, 90]) // => [10, 20, 30, 40, 50, 60, 70, 80, 90]\n```\n\n注意，第二个数组添加到第一个数组之后。当单独使用 `concat` 时，可以很好的工作；但类似于 `merge`，在 pipeline 中可能并不像预期的那样工作。可以为在 pipeline 中使用定义一个辅助函数 `concatAfter`：`const concatAfter = flip(concat)`。\n\nRamda 还提供了几个删除元素的函数。`remove` 删除指定索引处的元素，`without` 通过值删除元素。还有常用到的删除前 `N` 或 后 `N` 个元素的函数：`drop` 和 `dropLast`。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nremove(2, 3, numbers) // => [10, 20, 60]\n \nwithout([30, 40, 50], numbers) // => [10, 20, 60]\n \ndrop(3, numbers) // => [40, 50, 60]\n \ndropLast(3, numbers) // => [10, 20, 30]\n```\n\n注意，`remove` 接受一个索引和一个删除元素的数量，而 `slice` 接受两个索引。如果你不知道这种不一致，可能会造成使用上的困扰。\n\n## 变换元素\n\n与对象一样，我们可能希望通过将函数应用于元素的原始值来更新数组元素。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nupdate(2, multiply(10, nth(2, numbers)), numbers) // => [10, 20, 300, 40, 50, 60]\n```\n\n为了简化这个常见的用例， Ramda 提供了 `adjust`，其工作方式类似于操作对象的 `evolve`。与 `evolve` 不同的是， `adjust` 只能作用于数组的单个元素。\n\n```js\nconst numbers = [10, 20, 30, 40, 50, 60]\n \nadjust(multiply(10), 2, numbers)\n```\n\n注意，与 `update` 相比，`adjust` 将前两个参数的位置交换了一下。这可能会引起困扰，但当进行部分应用时，这样做还是很有道理的。你可能会先提供一个调整函数，比如 `adjust(multiply(10))` ，然后再决定要调整的索引和数组。\n\n## 结论\n\n我们现在有了以声明式和不变式操作对象和数组的一系列方法。这允许我们在不改变已有数据的情况下，从较小的、函数式的构建模块来构建程序，通过对函数进行组合来实现我们想要的功能。\n\n## 下一节\n\n我们学习了读取、更新和转换对象属性和数组元素的方法。Ramda 提供了更通用的进行这些操作的工具：lens（透镜）。[Lenses](https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/) 向我们演示了它们的工作原理和方式。\n","slug":"Thinking-in-Ramda-Immutability-and-Arrays","published":1,"updated":"2020-06-06T14:44:04.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitv000uf6mjqp323z8p","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/07/05/thinking-in-ramda-immutability-and-arrays/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Immutability and Arrays</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第七篇。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">第六节</a> 中，讨论了以函数式和数据不变性（immutable）的方式来处理 JavaScript 对象。</p>\n<p>本节将继续用相同的方式讨论数组。</p>\n<h2>读取数组元素</h2>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">第六节</a> 中，展示了许多读取对象属性的 Ramda 函数，包括 <code>prop</code>、<code>pick</code> 和 <code>has</code>。Ramda 有更多的方法来读取数组的元素。</p>\n<p>数组中与 <code>prop</code> 类似的是 <code>nth</code>；与 <code>pick</code> 类似的是 <code>slice</code>，跟 <code>has</code> 类似的是 <code>contains</code>。来看一些例子。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">nth(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; 40  (0-based indexing)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">nth(<span class=\"number\">-2</span>, numbers) <span class=\"comment\">// =&gt; 50 (negative numbers start from the right)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">slice(<span class=\"number\">2</span>, <span class=\"number\">5</span>, numbers) <span class=\"comment\">// =&gt; [30, 40, 50] (see below)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">contains(<span class=\"number\">20</span>, numbers) <span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p><code>slice</code> 接受两个索引，返回从第 1 个索引开始（以 0 为起始）到第 2 个索引结束（不包含）的所有元素组成的子数组。</p>\n<p>经常会访问首个（<code>nth(0)</code>）和最后一个（<code>nth(-1)</code>）元素，所以 Ramda 为这两种特殊情形提供的便捷方法：<code>head</code> 和 <code>last</code>。还提供了访问除首个元素之外的所有元素的函数：<code>tail</code>，除最后一个元素之外的所有元素的方法：<code>init</code>，前 <code>N</code> 个元素：<code>take(N)</code>，后 <code>N</code> 个元素：<code>takeLast(N)</code>。来看看这些函数的实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">head(numbers) <span class=\"comment\">// =&gt; 10</span></span><br><span class=\"line\">tail(numbers) <span class=\"comment\">// =&gt; [20, 30, 40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">last(numbers) <span class=\"comment\">// =&gt; 60</span></span><br><span class=\"line\">init(numbers) <span class=\"comment\">// =&gt; [10, 20, 30, 40, 50]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">take(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30]</span></span><br><span class=\"line\">takeLast(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [40, 50, 60]</span></span><br></pre></td></tr></table></figure></p>\n<h2>增、删、改数组元素</h2>\n<p>对于对象，我们已经学了对其属性进行增、删、改的函数：<code>assoc</code>、<code>dissoc</code>、<code>evolve</code> 等。</p>\n<p>但数组是有序数据结构，有好多函数与 <code>assoc</code> 类似。最常用的是 <code>insert</code> 和 <code>update</code>，Ramda 还提供了 <code>append</code> 和 <code>prepend</code> 来在数组头部或尾部添加元素。<code>insert</code>、<code>append</code> 和 <code>prepend</code> 会给数组添加新元素；<code>update</code> 使用新值替换已有元素。</p>\n<p>正如一般函数式库应该具备的，所有这些函数都返回修改后的新数组，原有数组保持不变。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">insert(<span class=\"number\">3</span>, <span class=\"number\">35</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30, 35, 40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">append(<span class=\"number\">70</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30, 40, 50, 60, 70]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">prepend(<span class=\"number\">0</span>, numbers) <span class=\"comment\">// =&gt; [0, 10, 20, 30, 40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">update(<span class=\"number\">1</span>, <span class=\"number\">15</span>, numbers) <span class=\"comment\">// =&gt; [10, 15, 30, 40, 50, 60]</span></span><br></pre></td></tr></table></figure></p>\n<p>为了将两个对象合并为一个，我们学习了 <code>merge</code>；Ramda 为数组合并提供了 <code>concat</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">concat(numbers, [<span class=\"number\">70</span>, <span class=\"number\">80</span>, <span class=\"number\">90</span>]) <span class=\"comment\">// =&gt; [10, 20, 30, 40, 50, 60, 70, 80, 90]</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，第二个数组添加到第一个数组之后。当单独使用 <code>concat</code> 时，可以很好的工作；但类似于 <code>merge</code>，在 pipeline 中可能并不像预期的那样工作。可以为在 pipeline 中使用定义一个辅助函数 <code>concatAfter</code>：<code>const concatAfter = flip(concat)</code>。</p>\n<p>Ramda 还提供了几个删除元素的函数。<code>remove</code> 删除指定索引处的元素，<code>without</code> 通过值删除元素。还有常用到的删除前 <code>N</code> 或 后 <code>N</code> 个元素的函数：<code>drop</code> 和 <code>dropLast</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">remove(<span class=\"number\">2</span>, <span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">without([<span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>], numbers) <span class=\"comment\">// =&gt; [10, 20, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">drop(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">dropLast(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>remove</code> 接受一个索引和一个删除元素的数量，而 <code>slice</code> 接受两个索引。如果你不知道这种不一致，可能会造成使用上的困扰。</p>\n<h2>变换元素</h2>\n<p>与对象一样，我们可能希望通过将函数应用于元素的原始值来更新数组元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">update(<span class=\"number\">2</span>, multiply(<span class=\"number\">10</span>, nth(<span class=\"number\">2</span>, numbers)), numbers) <span class=\"comment\">// =&gt; [10, 20, 300, 40, 50, 60]</span></span><br></pre></td></tr></table></figure></p>\n<p>为了简化这个常见的用例， Ramda 提供了 <code>adjust</code>，其工作方式类似于操作对象的 <code>evolve</code>。与 <code>evolve</code> 不同的是， <code>adjust</code> 只能作用于数组的单个元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">adjust(multiply(<span class=\"number\">10</span>), <span class=\"number\">2</span>, numbers)</span><br></pre></td></tr></table></figure></p>\n<p>注意，与 <code>update</code> 相比，<code>adjust</code> 将前两个参数的位置交换了一下。这可能会引起困扰，但当进行部分应用时，这样做还是很有道理的。你可能会先提供一个调整函数，比如 <code>adjust(multiply(10))</code> ，然后再决定要调整的索引和数组。</p>\n<h2>结论</h2>\n<p>我们现在有了以声明式和不变式操作对象和数组的一系列方法。这允许我们在不改变已有数据的情况下，从较小的、函数式的构建模块来构建程序，通过对函数进行组合来实现我们想要的功能。</p>\n<h2>下一节</h2>\n<p>我们学习了读取、更新和转换对象属性和数组元素的方法。Ramda 提供了更通用的进行这些操作的工具：lens（透镜）。<a href=\"https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/\" target=\"_blank\" rel=\"noopener\">Lenses</a> 向我们演示了它们的工作原理和方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/07/05/thinking-in-ramda-immutability-and-arrays/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Immutability and Arrays</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第七篇。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">第六节</a> 中，讨论了以函数式和数据不变性（immutable）的方式来处理 JavaScript 对象。</p>\n<p>本节将继续用相同的方式讨论数组。</p>\n<h2>读取数组元素</h2>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">第六节</a> 中，展示了许多读取对象属性的 Ramda 函数，包括 <code>prop</code>、<code>pick</code> 和 <code>has</code>。Ramda 有更多的方法来读取数组的元素。</p>\n<p>数组中与 <code>prop</code> 类似的是 <code>nth</code>；与 <code>pick</code> 类似的是 <code>slice</code>，跟 <code>has</code> 类似的是 <code>contains</code>。来看一些例子。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">nth(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; 40  (0-based indexing)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">nth(<span class=\"number\">-2</span>, numbers) <span class=\"comment\">// =&gt; 50 (negative numbers start from the right)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">slice(<span class=\"number\">2</span>, <span class=\"number\">5</span>, numbers) <span class=\"comment\">// =&gt; [30, 40, 50] (see below)</span></span><br><span class=\"line\"> </span><br><span class=\"line\">contains(<span class=\"number\">20</span>, numbers) <span class=\"comment\">// =&gt; true</span></span><br></pre></td></tr></table></figure></p>\n<p><code>slice</code> 接受两个索引，返回从第 1 个索引开始（以 0 为起始）到第 2 个索引结束（不包含）的所有元素组成的子数组。</p>\n<p>经常会访问首个（<code>nth(0)</code>）和最后一个（<code>nth(-1)</code>）元素，所以 Ramda 为这两种特殊情形提供的便捷方法：<code>head</code> 和 <code>last</code>。还提供了访问除首个元素之外的所有元素的函数：<code>tail</code>，除最后一个元素之外的所有元素的方法：<code>init</code>，前 <code>N</code> 个元素：<code>take(N)</code>，后 <code>N</code> 个元素：<code>takeLast(N)</code>。来看看这些函数的实例。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">head(numbers) <span class=\"comment\">// =&gt; 10</span></span><br><span class=\"line\">tail(numbers) <span class=\"comment\">// =&gt; [20, 30, 40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">last(numbers) <span class=\"comment\">// =&gt; 60</span></span><br><span class=\"line\">init(numbers) <span class=\"comment\">// =&gt; [10, 20, 30, 40, 50]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">take(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30]</span></span><br><span class=\"line\">takeLast(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [40, 50, 60]</span></span><br></pre></td></tr></table></figure></p>\n<h2>增、删、改数组元素</h2>\n<p>对于对象，我们已经学了对其属性进行增、删、改的函数：<code>assoc</code>、<code>dissoc</code>、<code>evolve</code> 等。</p>\n<p>但数组是有序数据结构，有好多函数与 <code>assoc</code> 类似。最常用的是 <code>insert</code> 和 <code>update</code>，Ramda 还提供了 <code>append</code> 和 <code>prepend</code> 来在数组头部或尾部添加元素。<code>insert</code>、<code>append</code> 和 <code>prepend</code> 会给数组添加新元素；<code>update</code> 使用新值替换已有元素。</p>\n<p>正如一般函数式库应该具备的，所有这些函数都返回修改后的新数组，原有数组保持不变。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">insert(<span class=\"number\">3</span>, <span class=\"number\">35</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30, 35, 40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">append(<span class=\"number\">70</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30, 40, 50, 60, 70]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">prepend(<span class=\"number\">0</span>, numbers) <span class=\"comment\">// =&gt; [0, 10, 20, 30, 40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">update(<span class=\"number\">1</span>, <span class=\"number\">15</span>, numbers) <span class=\"comment\">// =&gt; [10, 15, 30, 40, 50, 60]</span></span><br></pre></td></tr></table></figure></p>\n<p>为了将两个对象合并为一个，我们学习了 <code>merge</code>；Ramda 为数组合并提供了 <code>concat</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">concat(numbers, [<span class=\"number\">70</span>, <span class=\"number\">80</span>, <span class=\"number\">90</span>]) <span class=\"comment\">// =&gt; [10, 20, 30, 40, 50, 60, 70, 80, 90]</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，第二个数组添加到第一个数组之后。当单独使用 <code>concat</code> 时，可以很好的工作；但类似于 <code>merge</code>，在 pipeline 中可能并不像预期的那样工作。可以为在 pipeline 中使用定义一个辅助函数 <code>concatAfter</code>：<code>const concatAfter = flip(concat)</code>。</p>\n<p>Ramda 还提供了几个删除元素的函数。<code>remove</code> 删除指定索引处的元素，<code>without</code> 通过值删除元素。还有常用到的删除前 <code>N</code> 或 后 <code>N</code> 个元素的函数：<code>drop</code> 和 <code>dropLast</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">remove(<span class=\"number\">2</span>, <span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">without([<span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>], numbers) <span class=\"comment\">// =&gt; [10, 20, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">drop(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [40, 50, 60]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">dropLast(<span class=\"number\">3</span>, numbers) <span class=\"comment\">// =&gt; [10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>remove</code> 接受一个索引和一个删除元素的数量，而 <code>slice</code> 接受两个索引。如果你不知道这种不一致，可能会造成使用上的困扰。</p>\n<h2>变换元素</h2>\n<p>与对象一样，我们可能希望通过将函数应用于元素的原始值来更新数组元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">update(<span class=\"number\">2</span>, multiply(<span class=\"number\">10</span>, nth(<span class=\"number\">2</span>, numbers)), numbers) <span class=\"comment\">// =&gt; [10, 20, 300, 40, 50, 60]</span></span><br></pre></td></tr></table></figure></p>\n<p>为了简化这个常见的用例， Ramda 提供了 <code>adjust</code>，其工作方式类似于操作对象的 <code>evolve</code>。与 <code>evolve</code> 不同的是， <code>adjust</code> 只能作用于数组的单个元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> numbers = [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>]</span><br><span class=\"line\"> </span><br><span class=\"line\">adjust(multiply(<span class=\"number\">10</span>), <span class=\"number\">2</span>, numbers)</span><br></pre></td></tr></table></figure></p>\n<p>注意，与 <code>update</code> 相比，<code>adjust</code> 将前两个参数的位置交换了一下。这可能会引起困扰，但当进行部分应用时，这样做还是很有道理的。你可能会先提供一个调整函数，比如 <code>adjust(multiply(10))</code> ，然后再决定要调整的索引和数组。</p>\n<h2>结论</h2>\n<p>我们现在有了以声明式和不变式操作对象和数组的一系列方法。这允许我们在不改变已有数据的情况下，从较小的、函数式的构建模块来构建程序，通过对函数进行组合来实现我们想要的功能。</p>\n<h2>下一节</h2>\n<p>我们学习了读取、更新和转换对象属性和数组元素的方法。Ramda 提供了更通用的进行这些操作的工具：lens（透镜）。<a href=\"https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/\" target=\"_blank\" rel=\"noopener\">Lenses</a> 向我们演示了它们的工作原理和方式。</p>\n"},{"title":"Thinking in Ramda: 数据不变性和对象","date":"2017-06-16T15:00:08.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Immutability and Objects](http://randycoulman.com/blog/2016/06/28/thinking-in-ramda-immutability-and-objects/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第六篇。\n\n在 [第五节](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/) 中，我们讨论了如何以 \"pointfree\" 或 \"tacit\" 风格来编写函数：函数的参数不会显式的出现。\n\n那时候，因为缺少一些工具，我们还无法将所有的函数转换为 \"pointfree\" 的风格。现在我们就来学习这些工具。\n\n## 读取对象属性\n\n再来回顾一下 [第五节](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/) 已经重构过的 \"合格选民\" 的例子：\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = either(wasBornInCountry, wasNaturalized)\nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\n如上所示，我们已经将 `isCitizen` 和 `isEligibleToVote` 变为 \"pointfree\" 风格的了，但前三个函数还没有 \"pointfree\" 化。\n\n正如 [第四节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/) 所学，可以使用 `equals` 和 `gte` 来让函数更 \"声明式\" 一些。我们就此开始：\n\n```js\nconst wasBornInCountry = person => equals(person.birthCountry, OUR_COUNTRY)\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => gte(person.age, 18)\n```\n\n为了让这些函数变为 \"pointfree\" 的，需要一种方法来使构建出来的函数的 `person` 参数排在参数列表的最后。问题是，我们需要访问 `person` 的属性，现有唯一的方法却是命令式的。\n\n## prop\n\n幸运的是， Ramda 为我们提供了访问对象属性的辅助函数：`prop`。\n\n使用 `prop`，可以将 `person.birthCountry` 转换为 `prop('birthCountry', person)`。现在来试试。\n\n```js\nconst wasBornInCountry = person => equals(prop('birthCountry', person), OUR_COUNTRY)\nconst wasNaturalized = person => Boolean(prop('naturalizationDate', person))\nconst isOver18 = person => gte(prop('age', person), 18)\n```\n\n哇！现在看起来更糟了，还需要继续重构。首先，需要交换传递给 `equals` 的参数的顺序，这样可以将 `prop` 放到最后。`equals` 在任意顺序下都能正常工作。\n\n```js\nconst wasBornInCountry = person => equals(OUR_COUNTRY, prop('birthCountry', person))\nconst wasNaturalized = person => Boolean(prop('naturalizationDate', person))\nconst isOver18 = person => gte(prop('age', person), 18)\n```\n\n接下来，使用 `equals` 和 `gte` 的柯里化特性来创建新函数，新函数可以作用于 `prop` 输出的结果上。\n\n```js\nconst wasBornInCountry = person => equals(OUR_COUNTRY)(prop('birthCountry', person))\nconst wasNaturalized = person => Boolean(prop('naturalizationDate', person))\nconst isOver18 = person => gte(__, 18)(prop('age', person))\n```\n\n还是不太好，还需要继续优化。我们继续利用柯里化的特性来优化 `prop` 的调用。\n\n```js\nconst wasBornInCountry = person => equals(OUR_COUNTRY)(prop('birthCountry')(person))\nconst wasNaturalized = person => Boolean(prop('naturalizationDate')(person))\nconst isOver18 = person => gte(__, 18)(prop('age')(person))\n```\n\n又变糟了。但现在我们看到了一种熟悉的模式，所有的三个函数都具有相同的形式：`g(f(person))`。由 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions) 可知，这等价于 `compose(g, f)(person)`。\n\n我们来利用这一点。\n\n```js\nconst wasBornInCountry = person => compose(equals(OUR_COUNTRY), prop('birthCountry'))(person)\nconst wasNaturalized = person => compose(Boolean, prop('naturalizationDate'))(person)\nconst isOver18 = person => compose(gte(__, 18), prop('age'))(person)\n```\n\n现在好一些了，三个函数的形式变成了 `person => f(person)`。由 [第五节](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style) 可知，现在可以将这三个函数写成 \"pointfree\" 的了。\n\n```js\nconst wasBornInCountry = compose(equals(OUR_COUNTRY), prop('birthCountry'))\nconst wasNaturalized = compose(Boolean, prop('naturalizationDate'))\nconst isOver18 = compose(gte(__, 18), prop('age'))\n```\n\n未重构前，并不能明显看出我们的方法是在做两件事情。它们都先访问对象的属性，然后对该属性的值进行一些操作。重构为 \"pointfree\" 风格后，程序的表意变得清晰了许多。\n\n我们来展示更多 Ramda 处理对象的函数。\n\n## pick\n\n`prop` 用来读取并返回对象的单个属性，而 `pick` 读取对象的多个属性，然后返回有这些属性组成的新对象。\n\n例如，如果想同时获取一个人的名字和年龄，可以使用：`pick(['name', 'age'], person)`。\n\n## has\n\n在不读取属性值的情况下，想知道对象中是否包含该属性，可以使用 `has` 来检测对象是否拥有该属性，如 `has('name' ,person)`；还可以使用 `hasIn` 来检测原型链上的属性。\n\n## path\n\n`prop` 用来读取对象的属性，`path` 可以读取对象的嵌套属性。例如，我们可以从更深层的结构中访问邮编：`path(['address', 'zipCode'], person)`。\n\n注意，`path` 容错性更强。如果路径上的任意属性为 `null` 或 `undefined`，则 `path` 返回 `undefined`，而 `prop` 会引发错误。\n\n## propOr / pathOr\n\n`propOr` 和 `pathOr` 像是 `prop`/`path` 与 `defaultTo` 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值。\n\n例如，当我们不知道某人的姓名时，可以提供一个占位符：`propOr('<Unnamed>', 'name', person)`。注意，与 `prop` 不同，如果 `person` 为 `null` 或 `undefined` 时，`propOr` 不会引发错误，而是会返回一个默认值。\n\n## keys / values\n\n`keys` 返回一个包含对象中所有属性名称的数组。`values` 返回这些属性的值组成的数组。当与 [第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8) 中提到集合迭代函数结合使用时，这两个函数会非常有用。\n\n## 对属性增、删、改、查\n\n现在已经有很多对对象进行声明式读取的函数，但如果想要进行更改操作呢？\n\n由于数据不变性很重要，我们不想直接更改对象。相反，我们想要更改后形成的新对象。\n\nRamda 再次为我们提供了很多辅助函数。\n\n## assoc / assocPath\n\n在命令式编程时，可以使用赋值操作符设置或更改一个人的名字：`person.name = 'New name'`。\n\n在函数式、数据不变的世界里，可以使用 `assoc` 来代替：`const updatedPerson = assoc('name', 'New name', person)`。\n\n`assoc` 返回一个添加或修改属性的新对象，原对象保持不变。\n\n还有用于更新嵌套属性的方法：`assocPath`：`const updatedPerson = assocPath(['address', 'zipcode'], '97504', person)`。\n\n## dissoc / dissocPath / omit\n\n如何删除属性呢？我们可能想删除 `person.age` 。在 Ramda 中，可以使用 `dissoc`：`const updatedPerson = dissoc('age', person)`。\n\n`dissocPath` 类似于 `dissoc`，但可以作用于对象的嵌套属性：`dissocPath(['address', 'zipCode'], person)`。\n\n还有一个 `omit`，用于一次删除多个属性。`const updatedPerson = omit(['age', 'birthCountry'], person)`。\n\n注意，`pick` 与 `omit` 的操作很像，两者是互补的关系。它们能辅助实现白名单（使用 `pick` 保留想要的属性集）和黑名单（使用 `omit` 删除不想要的属性集）的功能。\n\n## 属性转换\n\n我们现在已经知道如何利用声明式和数据不变性的方式来处理对象。我们来写一个函数：`celebrateBirthday`，在生日当前更新他的年龄。\n\n```js\nconst nextAge = compose(inc, prop('age'))\nconst celebrateBirthday = person => assoc('age', nextAge(person), person)\n```\n\n这是一种很常见的模式。如上所示，我们并不想用给定的新值覆盖已有属性值，而是想通过函数作用于属性的旧值来对其进行转换。\n\n就目前已知的方法，我尚未找到一种以更少重复代码和 pointfree 的形式来优化该段代码的方式。\n\nRamda 使用 `evolve` 方法再次拯救了我们。我在 [之前的文章](http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/) 中也提到过 `evolve`。\n\n`evolve` 接受一个对象，其中包含对每个需要转换属性的转换函数。我们来使用 `evolve` 来重构 `celebrateBirthday`：\n\n```js\nconst celebrateBirthday = evolve({ age: inc })\n```\n\n这段代码通过将 `evolve` 参数对象属性对应的函数作用于被变换对象相同属性值上，来转换已有对象的属性。本例中使用 `inc` 对 `person` 的 `age` 属性进行加 1 操作，并返回 `age` 更新后的新 `person` 对象。\n\n`evolve` 可以一次转换多个属性，还可以进行嵌套转换。\"转换函数对象\"（包含转换函数的对象）与被转换对象具有基本相同的结构，`evolve` 会递归地遍历这两个对象，然后将转换函数作用于对应的属性值上。\n\n注意，`evolve` 不会添加新属性，如果为目标对象不存在的属性指定转换函数，`evolve` 会将其忽略。\n\n`evolve` 已经很快成为我编程时的主力。\n\n## 合并对象\n\n有时，需要合并两个对象。一种常见的情形是当使用含有 \"options\" 配置项的函数时，常常需要将这些配置项与一组默认配置项进行组合。Ramda 为此提供了 `merge` 方法。\n\n```js\nfunction f(a, b, options = {}) {\n  const defaultOptions = { value: 42, local: true }\n  const finalOptions = merge(defaultOptions, options)\n}\n```\n\n`merge` 返回一个包含两个对象的所有属性和值的新对象。如果两个对象具有相同的属性，则采用第二个对象参数的属性值。\n\n在单独使用 `merge` 时，采用第二个参数的属性值作为最终值是非常有用的；但在 pipeline 中可能没什么用。在 pipeline 中，通常会对一个对象进行一系列转换，其中一个转换是合并一些新的属性值到对象中。这种情况，可能需要第一个参数中的属性值作为最终值。\n\n如果只是在 pipeline 中简单地使用 `merge(newValues)`，可能不会得到你想要的结果。\n\n对于这种情况，我通常会定义一个辅助函数 `reverseMerge`：`const reverseMerge = flip(merge)`。回想一下，`flip` 会翻转函数前两个参数的位置。\n\n`merge` 执行的是浅合并。如果被合并的对象存在属性值为对象的属性，子对象并不会继续嵌套合并。如果想递归地进行 \"深合并\"，可以使用 Ramda 的 `mergeDeep` 系列函数。（译者注：作者在写这篇文章时，Ramda 还没有 `mergeDeep` 系列函数，`mergeDeep` 系列函数是在 v0.24.0 中加入的）\n\n注意，`merge` 只接受两个参数。如果想要将多个对象合并为一个对象，可以使用 `mergeAll`，它接受一个需要被合并对象的数组作为参数。\n\n## 结论\n\n本文展示了 Ramda 中一系列很好的以声明式和数据不变方式处理对象的方法。我们现在可以对对象进行增、删、改、查，而不会改变原有的对象。并且也可以在组合函数时使用这些方法来做这些事情。\n\n## 下一节\n\n现在可以以 Immutable 的方式处理对象，那么数组呢？[数据不变性和数组](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/) 将演示对数组的处理。\n\n","source":"_posts/Thinking-in-Ramda-Immutability-and-Objects.md","raw":"---\ntitle: 'Thinking in Ramda: 数据不变性和对象'\ndate: 2017-06-16 23:00:08\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Immutability and Objects](http://randycoulman.com/blog/2016/06/28/thinking-in-ramda-immutability-and-objects/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第六篇。\n\n在 [第五节](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/) 中，我们讨论了如何以 \"pointfree\" 或 \"tacit\" 风格来编写函数：函数的参数不会显式的出现。\n\n那时候，因为缺少一些工具，我们还无法将所有的函数转换为 \"pointfree\" 的风格。现在我们就来学习这些工具。\n\n## 读取对象属性\n\n再来回顾一下 [第五节](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/) 已经重构过的 \"合格选民\" 的例子：\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = either(wasBornInCountry, wasNaturalized)\nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\n如上所示，我们已经将 `isCitizen` 和 `isEligibleToVote` 变为 \"pointfree\" 风格的了，但前三个函数还没有 \"pointfree\" 化。\n\n正如 [第四节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/) 所学，可以使用 `equals` 和 `gte` 来让函数更 \"声明式\" 一些。我们就此开始：\n\n```js\nconst wasBornInCountry = person => equals(person.birthCountry, OUR_COUNTRY)\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => gte(person.age, 18)\n```\n\n为了让这些函数变为 \"pointfree\" 的，需要一种方法来使构建出来的函数的 `person` 参数排在参数列表的最后。问题是，我们需要访问 `person` 的属性，现有唯一的方法却是命令式的。\n\n## prop\n\n幸运的是， Ramda 为我们提供了访问对象属性的辅助函数：`prop`。\n\n使用 `prop`，可以将 `person.birthCountry` 转换为 `prop('birthCountry', person)`。现在来试试。\n\n```js\nconst wasBornInCountry = person => equals(prop('birthCountry', person), OUR_COUNTRY)\nconst wasNaturalized = person => Boolean(prop('naturalizationDate', person))\nconst isOver18 = person => gte(prop('age', person), 18)\n```\n\n哇！现在看起来更糟了，还需要继续重构。首先，需要交换传递给 `equals` 的参数的顺序，这样可以将 `prop` 放到最后。`equals` 在任意顺序下都能正常工作。\n\n```js\nconst wasBornInCountry = person => equals(OUR_COUNTRY, prop('birthCountry', person))\nconst wasNaturalized = person => Boolean(prop('naturalizationDate', person))\nconst isOver18 = person => gte(prop('age', person), 18)\n```\n\n接下来，使用 `equals` 和 `gte` 的柯里化特性来创建新函数，新函数可以作用于 `prop` 输出的结果上。\n\n```js\nconst wasBornInCountry = person => equals(OUR_COUNTRY)(prop('birthCountry', person))\nconst wasNaturalized = person => Boolean(prop('naturalizationDate', person))\nconst isOver18 = person => gte(__, 18)(prop('age', person))\n```\n\n还是不太好，还需要继续优化。我们继续利用柯里化的特性来优化 `prop` 的调用。\n\n```js\nconst wasBornInCountry = person => equals(OUR_COUNTRY)(prop('birthCountry')(person))\nconst wasNaturalized = person => Boolean(prop('naturalizationDate')(person))\nconst isOver18 = person => gte(__, 18)(prop('age')(person))\n```\n\n又变糟了。但现在我们看到了一种熟悉的模式，所有的三个函数都具有相同的形式：`g(f(person))`。由 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions) 可知，这等价于 `compose(g, f)(person)`。\n\n我们来利用这一点。\n\n```js\nconst wasBornInCountry = person => compose(equals(OUR_COUNTRY), prop('birthCountry'))(person)\nconst wasNaturalized = person => compose(Boolean, prop('naturalizationDate'))(person)\nconst isOver18 = person => compose(gte(__, 18), prop('age'))(person)\n```\n\n现在好一些了，三个函数的形式变成了 `person => f(person)`。由 [第五节](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style) 可知，现在可以将这三个函数写成 \"pointfree\" 的了。\n\n```js\nconst wasBornInCountry = compose(equals(OUR_COUNTRY), prop('birthCountry'))\nconst wasNaturalized = compose(Boolean, prop('naturalizationDate'))\nconst isOver18 = compose(gte(__, 18), prop('age'))\n```\n\n未重构前，并不能明显看出我们的方法是在做两件事情。它们都先访问对象的属性，然后对该属性的值进行一些操作。重构为 \"pointfree\" 风格后，程序的表意变得清晰了许多。\n\n我们来展示更多 Ramda 处理对象的函数。\n\n## pick\n\n`prop` 用来读取并返回对象的单个属性，而 `pick` 读取对象的多个属性，然后返回有这些属性组成的新对象。\n\n例如，如果想同时获取一个人的名字和年龄，可以使用：`pick(['name', 'age'], person)`。\n\n## has\n\n在不读取属性值的情况下，想知道对象中是否包含该属性，可以使用 `has` 来检测对象是否拥有该属性，如 `has('name' ,person)`；还可以使用 `hasIn` 来检测原型链上的属性。\n\n## path\n\n`prop` 用来读取对象的属性，`path` 可以读取对象的嵌套属性。例如，我们可以从更深层的结构中访问邮编：`path(['address', 'zipCode'], person)`。\n\n注意，`path` 容错性更强。如果路径上的任意属性为 `null` 或 `undefined`，则 `path` 返回 `undefined`，而 `prop` 会引发错误。\n\n## propOr / pathOr\n\n`propOr` 和 `pathOr` 像是 `prop`/`path` 与 `defaultTo` 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值。\n\n例如，当我们不知道某人的姓名时，可以提供一个占位符：`propOr('<Unnamed>', 'name', person)`。注意，与 `prop` 不同，如果 `person` 为 `null` 或 `undefined` 时，`propOr` 不会引发错误，而是会返回一个默认值。\n\n## keys / values\n\n`keys` 返回一个包含对象中所有属性名称的数组。`values` 返回这些属性的值组成的数组。当与 [第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8) 中提到集合迭代函数结合使用时，这两个函数会非常有用。\n\n## 对属性增、删、改、查\n\n现在已经有很多对对象进行声明式读取的函数，但如果想要进行更改操作呢？\n\n由于数据不变性很重要，我们不想直接更改对象。相反，我们想要更改后形成的新对象。\n\nRamda 再次为我们提供了很多辅助函数。\n\n## assoc / assocPath\n\n在命令式编程时，可以使用赋值操作符设置或更改一个人的名字：`person.name = 'New name'`。\n\n在函数式、数据不变的世界里，可以使用 `assoc` 来代替：`const updatedPerson = assoc('name', 'New name', person)`。\n\n`assoc` 返回一个添加或修改属性的新对象，原对象保持不变。\n\n还有用于更新嵌套属性的方法：`assocPath`：`const updatedPerson = assocPath(['address', 'zipcode'], '97504', person)`。\n\n## dissoc / dissocPath / omit\n\n如何删除属性呢？我们可能想删除 `person.age` 。在 Ramda 中，可以使用 `dissoc`：`const updatedPerson = dissoc('age', person)`。\n\n`dissocPath` 类似于 `dissoc`，但可以作用于对象的嵌套属性：`dissocPath(['address', 'zipCode'], person)`。\n\n还有一个 `omit`，用于一次删除多个属性。`const updatedPerson = omit(['age', 'birthCountry'], person)`。\n\n注意，`pick` 与 `omit` 的操作很像，两者是互补的关系。它们能辅助实现白名单（使用 `pick` 保留想要的属性集）和黑名单（使用 `omit` 删除不想要的属性集）的功能。\n\n## 属性转换\n\n我们现在已经知道如何利用声明式和数据不变性的方式来处理对象。我们来写一个函数：`celebrateBirthday`，在生日当前更新他的年龄。\n\n```js\nconst nextAge = compose(inc, prop('age'))\nconst celebrateBirthday = person => assoc('age', nextAge(person), person)\n```\n\n这是一种很常见的模式。如上所示，我们并不想用给定的新值覆盖已有属性值，而是想通过函数作用于属性的旧值来对其进行转换。\n\n就目前已知的方法，我尚未找到一种以更少重复代码和 pointfree 的形式来优化该段代码的方式。\n\nRamda 使用 `evolve` 方法再次拯救了我们。我在 [之前的文章](http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/) 中也提到过 `evolve`。\n\n`evolve` 接受一个对象，其中包含对每个需要转换属性的转换函数。我们来使用 `evolve` 来重构 `celebrateBirthday`：\n\n```js\nconst celebrateBirthday = evolve({ age: inc })\n```\n\n这段代码通过将 `evolve` 参数对象属性对应的函数作用于被变换对象相同属性值上，来转换已有对象的属性。本例中使用 `inc` 对 `person` 的 `age` 属性进行加 1 操作，并返回 `age` 更新后的新 `person` 对象。\n\n`evolve` 可以一次转换多个属性，还可以进行嵌套转换。\"转换函数对象\"（包含转换函数的对象）与被转换对象具有基本相同的结构，`evolve` 会递归地遍历这两个对象，然后将转换函数作用于对应的属性值上。\n\n注意，`evolve` 不会添加新属性，如果为目标对象不存在的属性指定转换函数，`evolve` 会将其忽略。\n\n`evolve` 已经很快成为我编程时的主力。\n\n## 合并对象\n\n有时，需要合并两个对象。一种常见的情形是当使用含有 \"options\" 配置项的函数时，常常需要将这些配置项与一组默认配置项进行组合。Ramda 为此提供了 `merge` 方法。\n\n```js\nfunction f(a, b, options = {}) {\n  const defaultOptions = { value: 42, local: true }\n  const finalOptions = merge(defaultOptions, options)\n}\n```\n\n`merge` 返回一个包含两个对象的所有属性和值的新对象。如果两个对象具有相同的属性，则采用第二个对象参数的属性值。\n\n在单独使用 `merge` 时，采用第二个参数的属性值作为最终值是非常有用的；但在 pipeline 中可能没什么用。在 pipeline 中，通常会对一个对象进行一系列转换，其中一个转换是合并一些新的属性值到对象中。这种情况，可能需要第一个参数中的属性值作为最终值。\n\n如果只是在 pipeline 中简单地使用 `merge(newValues)`，可能不会得到你想要的结果。\n\n对于这种情况，我通常会定义一个辅助函数 `reverseMerge`：`const reverseMerge = flip(merge)`。回想一下，`flip` 会翻转函数前两个参数的位置。\n\n`merge` 执行的是浅合并。如果被合并的对象存在属性值为对象的属性，子对象并不会继续嵌套合并。如果想递归地进行 \"深合并\"，可以使用 Ramda 的 `mergeDeep` 系列函数。（译者注：作者在写这篇文章时，Ramda 还没有 `mergeDeep` 系列函数，`mergeDeep` 系列函数是在 v0.24.0 中加入的）\n\n注意，`merge` 只接受两个参数。如果想要将多个对象合并为一个对象，可以使用 `mergeAll`，它接受一个需要被合并对象的数组作为参数。\n\n## 结论\n\n本文展示了 Ramda 中一系列很好的以声明式和数据不变方式处理对象的方法。我们现在可以对对象进行增、删、改、查，而不会改变原有的对象。并且也可以在组合函数时使用这些方法来做这些事情。\n\n## 下一节\n\n现在可以以 Immutable 的方式处理对象，那么数组呢？[数据不变性和数组](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/) 将演示对数组的处理。\n\n","slug":"Thinking-in-Ramda-Immutability-and-Objects","published":1,"updated":"2020-06-06T14:44:04.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitx000wf6mja3b1v58a","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/28/thinking-in-ramda-immutability-and-objects/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Immutability and Objects</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第六篇。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">第五节</a> 中，我们讨论了如何以 &quot;pointfree&quot; 或 &quot;tacit&quot; 风格来编写函数：函数的参数不会显式的出现。</p>\n<p>那时候，因为缺少一些工具，我们还无法将所有的函数转换为 &quot;pointfree&quot; 的风格。现在我们就来学习这些工具。</p>\n<h2>读取对象属性</h2>\n<p>再来回顾一下 <a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">第五节</a> 已经重构过的 &quot;合格选民&quot; 的例子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>如上所示，我们已经将 <code>isCitizen</code> 和 <code>isEligibleToVote</code> 变为 &quot;pointfree&quot; 风格的了，但前三个函数还没有 &quot;pointfree&quot; 化。</p>\n<p>正如 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">第四节</a> 所学，可以使用 <code>equals</code> 和 <code>gte</code> 来让函数更 &quot;声明式&quot; 一些。我们就此开始：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(person.age, <span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<p>为了让这些函数变为 &quot;pointfree&quot; 的，需要一种方法来使构建出来的函数的 <code>person</code> 参数排在参数列表的最后。问题是，我们需要访问 <code>person</code> 的属性，现有唯一的方法却是命令式的。</p>\n<h2>prop</h2>\n<p>幸运的是， Ramda 为我们提供了访问对象属性的辅助函数：<code>prop</code>。</p>\n<p>使用 <code>prop</code>，可以将 <code>person.birthCountry</code> 转换为 <code>prop('birthCountry', person)</code>。现在来试试。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(prop(<span class=\"string\">'birthCountry'</span>, person), OUR_COUNTRY)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(prop(<span class=\"string\">'age'</span>, person), <span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<p>哇！现在看起来更糟了，还需要继续重构。首先，需要交换传递给 <code>equals</code> 的参数的顺序，这样可以将 <code>prop</code> 放到最后。<code>equals</code> 在任意顺序下都能正常工作。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(OUR_COUNTRY, prop(<span class=\"string\">'birthCountry'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(prop(<span class=\"string\">'age'</span>, person), <span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<p>接下来，使用 <code>equals</code> 和 <code>gte</code> 的柯里化特性来创建新函数，新函数可以作用于 <code>prop</code> 输出的结果上。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class=\"string\">'birthCountry'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(__, <span class=\"number\">18</span>)(prop(<span class=\"string\">'age'</span>, person))</span><br></pre></td></tr></table></figure></p>\n<p>还是不太好，还需要继续优化。我们继续利用柯里化的特性来优化 <code>prop</code> 的调用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class=\"string\">'birthCountry'</span>)(person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>)(person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(__, <span class=\"number\">18</span>)(prop(<span class=\"string\">'age'</span>)(person))</span><br></pre></td></tr></table></figure></p>\n<p>又变糟了。但现在我们看到了一种熟悉的模式，所有的三个函数都具有相同的形式：<code>g(f(person))</code>。由 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions\" target=\"_blank\" rel=\"noopener\">第二节</a> 可知，这等价于 <code>compose(g, f)(person)</code>。</p>\n<p>我们来利用这一点。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> compose(equals(OUR_COUNTRY), prop(<span class=\"string\">'birthCountry'</span>))(person)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> compose(<span class=\"built_in\">Boolean</span>, prop(<span class=\"string\">'naturalizationDate'</span>))(person)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> compose(gte(__, <span class=\"number\">18</span>), prop(<span class=\"string\">'age'</span>))(person)</span><br></pre></td></tr></table></figure></p>\n<p>现在好一些了，三个函数的形式变成了 <code>person =&gt; f(person)</code>。由 <a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style\" target=\"_blank\" rel=\"noopener\">第五节</a> 可知，现在可以将这三个函数写成 &quot;pointfree&quot; 的了。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = compose(equals(OUR_COUNTRY), prop(<span class=\"string\">'birthCountry'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = compose(<span class=\"built_in\">Boolean</span>, prop(<span class=\"string\">'naturalizationDate'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = compose(gte(__, <span class=\"number\">18</span>), prop(<span class=\"string\">'age'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>未重构前，并不能明显看出我们的方法是在做两件事情。它们都先访问对象的属性，然后对该属性的值进行一些操作。重构为 &quot;pointfree&quot; 风格后，程序的表意变得清晰了许多。</p>\n<p>我们来展示更多 Ramda 处理对象的函数。</p>\n<h2>pick</h2>\n<p><code>prop</code> 用来读取并返回对象的单个属性，而 <code>pick</code> 读取对象的多个属性，然后返回有这些属性组成的新对象。</p>\n<p>例如，如果想同时获取一个人的名字和年龄，可以使用：<code>pick(['name', 'age'], person)</code>。</p>\n<h2>has</h2>\n<p>在不读取属性值的情况下，想知道对象中是否包含该属性，可以使用 <code>has</code> 来检测对象是否拥有该属性，如 <code>has('name' ,person)</code>；还可以使用 <code>hasIn</code> 来检测原型链上的属性。</p>\n<h2>path</h2>\n<p><code>prop</code> 用来读取对象的属性，<code>path</code> 可以读取对象的嵌套属性。例如，我们可以从更深层的结构中访问邮编：<code>path(['address', 'zipCode'], person)</code>。</p>\n<p>注意，<code>path</code> 容错性更强。如果路径上的任意属性为 <code>null</code> 或 <code>undefined</code>，则 <code>path</code> 返回 <code>undefined</code>，而 <code>prop</code> 会引发错误。</p>\n<h2>propOr / pathOr</h2>\n<p><code>propOr</code> 和 <code>pathOr</code> 像是 <code>prop</code>/<code>path</code> 与 <code>defaultTo</code> 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值。</p>\n<p>例如，当我们不知道某人的姓名时，可以提供一个占位符：<code>propOr('&lt;Unnamed&gt;', 'name', person)</code>。注意，与 <code>prop</code> 不同，如果 <code>person</code> 为 <code>null</code> 或 <code>undefined</code> 时，<code>propOr</code> 不会引发错误，而是会返回一个默认值。</p>\n<h2>keys / values</h2>\n<p><code>keys</code> 返回一个包含对象中所有属性名称的数组。<code>values</code> 返回这些属性的值组成的数组。当与 <a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8\" target=\"_blank\" rel=\"noopener\">第一节</a> 中提到集合迭代函数结合使用时，这两个函数会非常有用。</p>\n<h2>对属性增、删、改、查</h2>\n<p>现在已经有很多对对象进行声明式读取的函数，但如果想要进行更改操作呢？</p>\n<p>由于数据不变性很重要，我们不想直接更改对象。相反，我们想要更改后形成的新对象。</p>\n<p>Ramda 再次为我们提供了很多辅助函数。</p>\n<h2>assoc / assocPath</h2>\n<p>在命令式编程时，可以使用赋值操作符设置或更改一个人的名字：<code>person.name = 'New name'</code>。</p>\n<p>在函数式、数据不变的世界里，可以使用 <code>assoc</code> 来代替：<code>const updatedPerson = assoc('name', 'New name', person)</code>。</p>\n<p><code>assoc</code> 返回一个添加或修改属性的新对象，原对象保持不变。</p>\n<p>还有用于更新嵌套属性的方法：<code>assocPath</code>：<code>const updatedPerson = assocPath(['address', 'zipcode'], '97504', person)</code>。</p>\n<h2>dissoc / dissocPath / omit</h2>\n<p>如何删除属性呢？我们可能想删除 <code>person.age</code> 。在 Ramda 中，可以使用 <code>dissoc</code>：<code>const updatedPerson = dissoc('age', person)</code>。</p>\n<p><code>dissocPath</code> 类似于 <code>dissoc</code>，但可以作用于对象的嵌套属性：<code>dissocPath(['address', 'zipCode'], person)</code>。</p>\n<p>还有一个 <code>omit</code>，用于一次删除多个属性。<code>const updatedPerson = omit(['age', 'birthCountry'], person)</code>。</p>\n<p>注意，<code>pick</code> 与 <code>omit</code> 的操作很像，两者是互补的关系。它们能辅助实现白名单（使用 <code>pick</code> 保留想要的属性集）和黑名单（使用 <code>omit</code> 删除不想要的属性集）的功能。</p>\n<h2>属性转换</h2>\n<p>我们现在已经知道如何利用声明式和数据不变性的方式来处理对象。我们来写一个函数：<code>celebrateBirthday</code>，在生日当前更新他的年龄。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nextAge = compose(inc, prop(<span class=\"string\">'age'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> celebrateBirthday = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> assoc(<span class=\"string\">'age'</span>, nextAge(person), person)</span><br></pre></td></tr></table></figure></p>\n<p>这是一种很常见的模式。如上所示，我们并不想用给定的新值覆盖已有属性值，而是想通过函数作用于属性的旧值来对其进行转换。</p>\n<p>就目前已知的方法，我尚未找到一种以更少重复代码和 pointfree 的形式来优化该段代码的方式。</p>\n<p>Ramda 使用 <code>evolve</code> 方法再次拯救了我们。我在 <a href=\"http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/\" target=\"_blank\" rel=\"noopener\">之前的文章</a> 中也提到过 <code>evolve</code>。</p>\n<p><code>evolve</code> 接受一个对象，其中包含对每个需要转换属性的转换函数。我们来使用 <code>evolve</code> 来重构 <code>celebrateBirthday</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> celebrateBirthday = evolve(&#123; <span class=\"attr\">age</span>: inc &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码通过将 <code>evolve</code> 参数对象属性对应的函数作用于被变换对象相同属性值上，来转换已有对象的属性。本例中使用 <code>inc</code> 对 <code>person</code> 的 <code>age</code> 属性进行加 1 操作，并返回 <code>age</code> 更新后的新 <code>person</code> 对象。</p>\n<p><code>evolve</code> 可以一次转换多个属性，还可以进行嵌套转换。&quot;转换函数对象&quot;（包含转换函数的对象）与被转换对象具有基本相同的结构，<code>evolve</code> 会递归地遍历这两个对象，然后将转换函数作用于对应的属性值上。</p>\n<p>注意，<code>evolve</code> 不会添加新属性，如果为目标对象不存在的属性指定转换函数，<code>evolve</code> 会将其忽略。</p>\n<p><code>evolve</code> 已经很快成为我编程时的主力。</p>\n<h2>合并对象</h2>\n<p>有时，需要合并两个对象。一种常见的情形是当使用含有 &quot;options&quot; 配置项的函数时，常常需要将这些配置项与一组默认配置项进行组合。Ramda 为此提供了 <code>merge</code> 方法。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, b, options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> defaultOptions = &#123; <span class=\"attr\">value</span>: <span class=\"number\">42</span>, <span class=\"attr\">local</span>: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalOptions = merge(defaultOptions, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>merge</code> 返回一个包含两个对象的所有属性和值的新对象。如果两个对象具有相同的属性，则采用第二个对象参数的属性值。</p>\n<p>在单独使用 <code>merge</code> 时，采用第二个参数的属性值作为最终值是非常有用的；但在 pipeline 中可能没什么用。在 pipeline 中，通常会对一个对象进行一系列转换，其中一个转换是合并一些新的属性值到对象中。这种情况，可能需要第一个参数中的属性值作为最终值。</p>\n<p>如果只是在 pipeline 中简单地使用 <code>merge(newValues)</code>，可能不会得到你想要的结果。</p>\n<p>对于这种情况，我通常会定义一个辅助函数 <code>reverseMerge</code>：<code>const reverseMerge = flip(merge)</code>。回想一下，<code>flip</code> 会翻转函数前两个参数的位置。</p>\n<p><code>merge</code> 执行的是浅合并。如果被合并的对象存在属性值为对象的属性，子对象并不会继续嵌套合并。如果想递归地进行 &quot;深合并&quot;，可以使用 Ramda 的 <code>mergeDeep</code> 系列函数。（译者注：作者在写这篇文章时，Ramda 还没有 <code>mergeDeep</code> 系列函数，<code>mergeDeep</code> 系列函数是在 v0.24.0 中加入的）</p>\n<p>注意，<code>merge</code> 只接受两个参数。如果想要将多个对象合并为一个对象，可以使用 <code>mergeAll</code>，它接受一个需要被合并对象的数组作为参数。</p>\n<h2>结论</h2>\n<p>本文展示了 Ramda 中一系列很好的以声明式和数据不变方式处理对象的方法。我们现在可以对对象进行增、删、改、查，而不会改变原有的对象。并且也可以在组合函数时使用这些方法来做这些事情。</p>\n<h2>下一节</h2>\n<p>现在可以以 Immutable 的方式处理对象，那么数组呢？<a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">数据不变性和数组</a> 将演示对数组的处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/28/thinking-in-ramda-immutability-and-objects/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Immutability and Objects</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第六篇。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">第五节</a> 中，我们讨论了如何以 &quot;pointfree&quot; 或 &quot;tacit&quot; 风格来编写函数：函数的参数不会显式的出现。</p>\n<p>那时候，因为缺少一些工具，我们还无法将所有的函数转换为 &quot;pointfree&quot; 的风格。现在我们就来学习这些工具。</p>\n<h2>读取对象属性</h2>\n<p>再来回顾一下 <a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">第五节</a> 已经重构过的 &quot;合格选民&quot; 的例子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>如上所示，我们已经将 <code>isCitizen</code> 和 <code>isEligibleToVote</code> 变为 &quot;pointfree&quot; 风格的了，但前三个函数还没有 &quot;pointfree&quot; 化。</p>\n<p>正如 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">第四节</a> 所学，可以使用 <code>equals</code> 和 <code>gte</code> 来让函数更 &quot;声明式&quot; 一些。我们就此开始：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(person.age, <span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<p>为了让这些函数变为 &quot;pointfree&quot; 的，需要一种方法来使构建出来的函数的 <code>person</code> 参数排在参数列表的最后。问题是，我们需要访问 <code>person</code> 的属性，现有唯一的方法却是命令式的。</p>\n<h2>prop</h2>\n<p>幸运的是， Ramda 为我们提供了访问对象属性的辅助函数：<code>prop</code>。</p>\n<p>使用 <code>prop</code>，可以将 <code>person.birthCountry</code> 转换为 <code>prop('birthCountry', person)</code>。现在来试试。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(prop(<span class=\"string\">'birthCountry'</span>, person), OUR_COUNTRY)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(prop(<span class=\"string\">'age'</span>, person), <span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<p>哇！现在看起来更糟了，还需要继续重构。首先，需要交换传递给 <code>equals</code> 的参数的顺序，这样可以将 <code>prop</code> 放到最后。<code>equals</code> 在任意顺序下都能正常工作。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(OUR_COUNTRY, prop(<span class=\"string\">'birthCountry'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(prop(<span class=\"string\">'age'</span>, person), <span class=\"number\">18</span>)</span><br></pre></td></tr></table></figure></p>\n<p>接下来，使用 <code>equals</code> 和 <code>gte</code> 的柯里化特性来创建新函数，新函数可以作用于 <code>prop</code> 输出的结果上。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class=\"string\">'birthCountry'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>, person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(__, <span class=\"number\">18</span>)(prop(<span class=\"string\">'age'</span>, person))</span><br></pre></td></tr></table></figure></p>\n<p>还是不太好，还需要继续优化。我们继续利用柯里化的特性来优化 <code>prop</code> 的调用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class=\"string\">'birthCountry'</span>)(person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(prop(<span class=\"string\">'naturalizationDate'</span>)(person))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> gte(__, <span class=\"number\">18</span>)(prop(<span class=\"string\">'age'</span>)(person))</span><br></pre></td></tr></table></figure></p>\n<p>又变糟了。但现在我们看到了一种熟悉的模式，所有的三个函数都具有相同的形式：<code>g(f(person))</code>。由 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions\" target=\"_blank\" rel=\"noopener\">第二节</a> 可知，这等价于 <code>compose(g, f)(person)</code>。</p>\n<p>我们来利用这一点。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> compose(equals(OUR_COUNTRY), prop(<span class=\"string\">'birthCountry'</span>))(person)</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> compose(<span class=\"built_in\">Boolean</span>, prop(<span class=\"string\">'naturalizationDate'</span>))(person)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> compose(gte(__, <span class=\"number\">18</span>), prop(<span class=\"string\">'age'</span>))(person)</span><br></pre></td></tr></table></figure></p>\n<p>现在好一些了，三个函数的形式变成了 <code>person =&gt; f(person)</code>。由 <a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style\" target=\"_blank\" rel=\"noopener\">第五节</a> 可知，现在可以将这三个函数写成 &quot;pointfree&quot; 的了。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = compose(equals(OUR_COUNTRY), prop(<span class=\"string\">'birthCountry'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = compose(<span class=\"built_in\">Boolean</span>, prop(<span class=\"string\">'naturalizationDate'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = compose(gte(__, <span class=\"number\">18</span>), prop(<span class=\"string\">'age'</span>))</span><br></pre></td></tr></table></figure></p>\n<p>未重构前，并不能明显看出我们的方法是在做两件事情。它们都先访问对象的属性，然后对该属性的值进行一些操作。重构为 &quot;pointfree&quot; 风格后，程序的表意变得清晰了许多。</p>\n<p>我们来展示更多 Ramda 处理对象的函数。</p>\n<h2>pick</h2>\n<p><code>prop</code> 用来读取并返回对象的单个属性，而 <code>pick</code> 读取对象的多个属性，然后返回有这些属性组成的新对象。</p>\n<p>例如，如果想同时获取一个人的名字和年龄，可以使用：<code>pick(['name', 'age'], person)</code>。</p>\n<h2>has</h2>\n<p>在不读取属性值的情况下，想知道对象中是否包含该属性，可以使用 <code>has</code> 来检测对象是否拥有该属性，如 <code>has('name' ,person)</code>；还可以使用 <code>hasIn</code> 来检测原型链上的属性。</p>\n<h2>path</h2>\n<p><code>prop</code> 用来读取对象的属性，<code>path</code> 可以读取对象的嵌套属性。例如，我们可以从更深层的结构中访问邮编：<code>path(['address', 'zipCode'], person)</code>。</p>\n<p>注意，<code>path</code> 容错性更强。如果路径上的任意属性为 <code>null</code> 或 <code>undefined</code>，则 <code>path</code> 返回 <code>undefined</code>，而 <code>prop</code> 会引发错误。</p>\n<h2>propOr / pathOr</h2>\n<p><code>propOr</code> 和 <code>pathOr</code> 像是 <code>prop</code>/<code>path</code> 与 <code>defaultTo</code> 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值。</p>\n<p>例如，当我们不知道某人的姓名时，可以提供一个占位符：<code>propOr('&lt;Unnamed&gt;', 'name', person)</code>。注意，与 <code>prop</code> 不同，如果 <code>person</code> 为 <code>null</code> 或 <code>undefined</code> 时，<code>propOr</code> 不会引发错误，而是会返回一个默认值。</p>\n<h2>keys / values</h2>\n<p><code>keys</code> 返回一个包含对象中所有属性名称的数组。<code>values</code> 返回这些属性的值组成的数组。当与 <a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8\" target=\"_blank\" rel=\"noopener\">第一节</a> 中提到集合迭代函数结合使用时，这两个函数会非常有用。</p>\n<h2>对属性增、删、改、查</h2>\n<p>现在已经有很多对对象进行声明式读取的函数，但如果想要进行更改操作呢？</p>\n<p>由于数据不变性很重要，我们不想直接更改对象。相反，我们想要更改后形成的新对象。</p>\n<p>Ramda 再次为我们提供了很多辅助函数。</p>\n<h2>assoc / assocPath</h2>\n<p>在命令式编程时，可以使用赋值操作符设置或更改一个人的名字：<code>person.name = 'New name'</code>。</p>\n<p>在函数式、数据不变的世界里，可以使用 <code>assoc</code> 来代替：<code>const updatedPerson = assoc('name', 'New name', person)</code>。</p>\n<p><code>assoc</code> 返回一个添加或修改属性的新对象，原对象保持不变。</p>\n<p>还有用于更新嵌套属性的方法：<code>assocPath</code>：<code>const updatedPerson = assocPath(['address', 'zipcode'], '97504', person)</code>。</p>\n<h2>dissoc / dissocPath / omit</h2>\n<p>如何删除属性呢？我们可能想删除 <code>person.age</code> 。在 Ramda 中，可以使用 <code>dissoc</code>：<code>const updatedPerson = dissoc('age', person)</code>。</p>\n<p><code>dissocPath</code> 类似于 <code>dissoc</code>，但可以作用于对象的嵌套属性：<code>dissocPath(['address', 'zipCode'], person)</code>。</p>\n<p>还有一个 <code>omit</code>，用于一次删除多个属性。<code>const updatedPerson = omit(['age', 'birthCountry'], person)</code>。</p>\n<p>注意，<code>pick</code> 与 <code>omit</code> 的操作很像，两者是互补的关系。它们能辅助实现白名单（使用 <code>pick</code> 保留想要的属性集）和黑名单（使用 <code>omit</code> 删除不想要的属性集）的功能。</p>\n<h2>属性转换</h2>\n<p>我们现在已经知道如何利用声明式和数据不变性的方式来处理对象。我们来写一个函数：<code>celebrateBirthday</code>，在生日当前更新他的年龄。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nextAge = compose(inc, prop(<span class=\"string\">'age'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> celebrateBirthday = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> assoc(<span class=\"string\">'age'</span>, nextAge(person), person)</span><br></pre></td></tr></table></figure></p>\n<p>这是一种很常见的模式。如上所示，我们并不想用给定的新值覆盖已有属性值，而是想通过函数作用于属性的旧值来对其进行转换。</p>\n<p>就目前已知的方法，我尚未找到一种以更少重复代码和 pointfree 的形式来优化该段代码的方式。</p>\n<p>Ramda 使用 <code>evolve</code> 方法再次拯救了我们。我在 <a href=\"http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/\" target=\"_blank\" rel=\"noopener\">之前的文章</a> 中也提到过 <code>evolve</code>。</p>\n<p><code>evolve</code> 接受一个对象，其中包含对每个需要转换属性的转换函数。我们来使用 <code>evolve</code> 来重构 <code>celebrateBirthday</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> celebrateBirthday = evolve(&#123; <span class=\"attr\">age</span>: inc &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>这段代码通过将 <code>evolve</code> 参数对象属性对应的函数作用于被变换对象相同属性值上，来转换已有对象的属性。本例中使用 <code>inc</code> 对 <code>person</code> 的 <code>age</code> 属性进行加 1 操作，并返回 <code>age</code> 更新后的新 <code>person</code> 对象。</p>\n<p><code>evolve</code> 可以一次转换多个属性，还可以进行嵌套转换。&quot;转换函数对象&quot;（包含转换函数的对象）与被转换对象具有基本相同的结构，<code>evolve</code> 会递归地遍历这两个对象，然后将转换函数作用于对应的属性值上。</p>\n<p>注意，<code>evolve</code> 不会添加新属性，如果为目标对象不存在的属性指定转换函数，<code>evolve</code> 会将其忽略。</p>\n<p><code>evolve</code> 已经很快成为我编程时的主力。</p>\n<h2>合并对象</h2>\n<p>有时，需要合并两个对象。一种常见的情形是当使用含有 &quot;options&quot; 配置项的函数时，常常需要将这些配置项与一组默认配置项进行组合。Ramda 为此提供了 <code>merge</code> 方法。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, b, options = &#123;&#125;</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> defaultOptions = &#123; <span class=\"attr\">value</span>: <span class=\"number\">42</span>, <span class=\"attr\">local</span>: <span class=\"literal\">true</span> &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> finalOptions = merge(defaultOptions, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>merge</code> 返回一个包含两个对象的所有属性和值的新对象。如果两个对象具有相同的属性，则采用第二个对象参数的属性值。</p>\n<p>在单独使用 <code>merge</code> 时，采用第二个参数的属性值作为最终值是非常有用的；但在 pipeline 中可能没什么用。在 pipeline 中，通常会对一个对象进行一系列转换，其中一个转换是合并一些新的属性值到对象中。这种情况，可能需要第一个参数中的属性值作为最终值。</p>\n<p>如果只是在 pipeline 中简单地使用 <code>merge(newValues)</code>，可能不会得到你想要的结果。</p>\n<p>对于这种情况，我通常会定义一个辅助函数 <code>reverseMerge</code>：<code>const reverseMerge = flip(merge)</code>。回想一下，<code>flip</code> 会翻转函数前两个参数的位置。</p>\n<p><code>merge</code> 执行的是浅合并。如果被合并的对象存在属性值为对象的属性，子对象并不会继续嵌套合并。如果想递归地进行 &quot;深合并&quot;，可以使用 Ramda 的 <code>mergeDeep</code> 系列函数。（译者注：作者在写这篇文章时，Ramda 还没有 <code>mergeDeep</code> 系列函数，<code>mergeDeep</code> 系列函数是在 v0.24.0 中加入的）</p>\n<p>注意，<code>merge</code> 只接受两个参数。如果想要将多个对象合并为一个对象，可以使用 <code>mergeAll</code>，它接受一个需要被合并对象的数组作为参数。</p>\n<h2>结论</h2>\n<p>本文展示了 Ramda 中一系列很好的以声明式和数据不变方式处理对象的方法。我们现在可以对对象进行增、删、改、查，而不会改变原有的对象。并且也可以在组合函数时使用这些方法来做这些事情。</p>\n<h2>下一节</h2>\n<p>现在可以以 Immutable 的方式处理对象，那么数组呢？<a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">数据不变性和数组</a> 将演示对数组的处理。</p>\n"},{"title":"Thinking in Ramda: 函数组合","date":"2017-06-10T07:38:05.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Combining Functions](http://randycoulman.com/blog/2016/05/31/thinking-in-ramda-combining-functions/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第二篇。\n\n在[第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/)中，介绍了 Ramda 和函数式编程的一些基本思想，如函数、纯函数和数据不变性。并介绍了如何入门：可以从集合迭代函数（如 `forEach`、`map`、`reduce`）开始。\n\n## 简单组合\n\n一旦熟悉了可以将函数传递给其他函数，你可能会开始找将多个函数组合在一起的场景。\n\nRamda 为简单的函数组合提供了一些函数。我们来看看。\n\n## Complement\n\n在上一节，我们使用 `find` 来查找列表中的首个偶数。\n\n```js\nconst isEven = x => x % 2 === 0\nfind(isEven, [1, 2, 3, 4]) //=> 2 \n```\n\n如果想找首个奇数呢？我们可以随手写一个 `isOdd` 函数并使用它。但我们知道任何非偶整数都是奇数，所以可以重用 `isEven` 函数。\n\nRamda 提供了一个更高阶的函数：`complement`，给它传入一个函数，返回一个新的函数：当原函数返回 \"假值\" 时，新函数返回 `true`；原函数返回 \"真值\" 时，新函数返回 `false`，即新函数是原函数的补函数。\n\n```js\nconst isEven = x => x % 2 === 0\n \nfind(complement(isEven), [1, 2, 3, 4]) // --> 1\n```\n\n更进一步，可以给 `complement` 过的函数起个名字，这样新函数便可以复用：\n\n```js\nconst isEven = x => x % 2 === 0\nconst isOdd = complement(isEven)\n \nfind(isOdd, [1, 2, 3, 4]) // --> 1\n```\n\n注意，`complement` 以函数的方式实现了逻辑非操作（`!`， not）的功能。\n\n`Both/Either`\n\n假设我们正在开发一个投票系统，给定一个人，我们希望能够确定其是否有资格投票。根据现有知识，一个人必须年满 18 岁并且是本国公民，才有资格投票。成为公民的条件：在本国出生，或者后来加入该国国籍。\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = person => wasBornInCountry(person) || wasNaturalized(person)\n \nconst isEligibleToVote = person => isOver18(person) && isCitizen(person)\n```\n\n上面代码实现了我们的需求，但 Ramda 提供了一些方便的函数，以帮助我们精简代码。\n\n`both` 接受两个函数，返回一个新函数：当两个传入函数都返回 `truthy` 值时，新函数返回 `true`，否则返回 `false`\n\n`either` 接受两个函数，返回一个新函数：当两个传入函数任意一个返回 `truthy` 值时，新函数返回 `true`，否则返回 `false`\n\n我们可以使用这两个函数来简化 `isCitizen` 和 `isEligibleToVote`。\n```js\nconst isCitizen = either(wasBornInCountry, wasNaturalized)\nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n注意，`both` 以函数的方式实现了逻辑与（`&&`）的功能，`either` 实现了逻辑或（`||`）的功能。\n\nRamda 还提供了 `allPass` 和 `anyPass`，接受由任意多个函数组成的数组作为参数。如名称所示，`allPass` 类似于 `both`，而 `anyPass` 类似于 `either`。\n\n## Pipelines(管道)\n\n有时我们需要以 pipeline 的方式将多个函数依次作用于某些数据。例如，接受两个数字，将它们相乘，加 1 ，然后平方。我们可以这样写：\n\n```js\nconst multiply = (a, b) => a * b\nconst addOne = x => x + 1\nconst square = x => x * x\n \nconst operate = (x, y) => {\n  const product = multiply(x, y)\n  const incremented = addOne(product)\n  const squared = square(incremented)\n \n  return squared\n}\n \noperate(3, 4) // => ((3 * 4) + 1)^2 => (12 + 1)^2 => 13^2 => 169\n```\n\n注意，每次操作是对上次操作的结果进行处理。\n\n## pipe\n\nRamda 提供了 `pipe` 函数：接受一系列函数，并返回一个新函数。\n\n新函数的元数与第一个传入函数的元数相同（元数：接受参数的个数），然后顺次通过 \"管道\" 中的函数对输入参数进行处理。它将第一个函数作用于参数，返回结果作为下一个函数的入参，依次进行下去。\"管道\" 中最后一个函数的结果作为 `pipe` 调用的最终结果。\n\n注意，除首个函数外，其余的函数都是一元函数。\n\n了解这些后，我们可以使用 `pipe` 来简化我们的 `operate` 函数：\n\n```js\nconst operate = pipe(\n  multiply,\n  addOne,\n  square\n)\n```\n\n当调用 `operate(3, 4)` 时，`pipe` 将 `3` 和 `4` 传给 `multiply` 函数，输出 `12`，然后将 `12` 传给 `addOne`，返回 `13`，然后将 `13` 传给 `square`，返回 `169`，并将 `169` 作为最终 `operate` 的最终结果返回。\n\n## compose\n\n另一种编写原始 `operate` 函数的方式是内联所有暂时变量：\n\n```js\nconst operate = (x, y) => square(addOne(multiply(x, y)))\n```\n\n这样更紧凑，但也更不便于阅读。然而这种形式可以使用 Ramda 的 `compose` 函数进行重写。\n\n`compose` 的工作方式跟 `pipe` 基本相同，除了其调用函数的顺序是从右到左，而不是从左到右。下面使用 `compose` 来重写 `operate`：\n\n```js\nconst operate = compose(\n  square,\n  addOne,\n  multiply\n)\n```\n\n这与上面的 `pipe` 几乎一样，除了函数的顺序是相反的。实际上，Ramda 中的 `compose` 函数的内部是用 `pipe` 实现的。\n\n我一直这样思考 `compose` 的工作方式：`compose(f, g)(value)` 等价于 `f(g(value))`。\n\n注意，与 `pipe` 类似，`compose` 中的函数除最后一个外，其余都是一元函数。\n\n## compose 还是 pipe？\n\n具有命令式编程背景的人可能觉得 `pipe` 更容易理解，因为可以按照从左往右的顺序进行阅读。但 `compose` 更容易对如上所示的嵌套函数进行转换。\n\n我也不太清楚什么时候该用 `compose`，什么时候该用 `pipe`。由于它们在 Ramda 中基本等价，所以选择用哪个可能并不重要。只要根据自己的情况选择合适的即可。\n\n## 结论\n\n通过特定的方式进行函数组合，我们已经可以开始编写更强的函数了。\n\n## 下一节\n\n你可能已经注意到了，在进行函数组合时，我们多数情况下都可以省略函数参数。只有在最终调用组合好的函数时，才传入参数。\n\n这在函数式编程中非常常见，我们将在下一节 [`Partial Application` (部分应用)](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/)进行更多详细介绍。我们还会讨论如何组合多元（多参数）函数。\n","source":"_posts/Thinking-in-Ramda-Combining-Functions.md","raw":"---\ntitle: 'Thinking in Ramda: 函数组合'\ndate: 2017-06-10 15:38:05\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Combining Functions](http://randycoulman.com/blog/2016/05/31/thinking-in-ramda-combining-functions/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第二篇。\n\n在[第一节](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/)中，介绍了 Ramda 和函数式编程的一些基本思想，如函数、纯函数和数据不变性。并介绍了如何入门：可以从集合迭代函数（如 `forEach`、`map`、`reduce`）开始。\n\n## 简单组合\n\n一旦熟悉了可以将函数传递给其他函数，你可能会开始找将多个函数组合在一起的场景。\n\nRamda 为简单的函数组合提供了一些函数。我们来看看。\n\n## Complement\n\n在上一节，我们使用 `find` 来查找列表中的首个偶数。\n\n```js\nconst isEven = x => x % 2 === 0\nfind(isEven, [1, 2, 3, 4]) //=> 2 \n```\n\n如果想找首个奇数呢？我们可以随手写一个 `isOdd` 函数并使用它。但我们知道任何非偶整数都是奇数，所以可以重用 `isEven` 函数。\n\nRamda 提供了一个更高阶的函数：`complement`，给它传入一个函数，返回一个新的函数：当原函数返回 \"假值\" 时，新函数返回 `true`；原函数返回 \"真值\" 时，新函数返回 `false`，即新函数是原函数的补函数。\n\n```js\nconst isEven = x => x % 2 === 0\n \nfind(complement(isEven), [1, 2, 3, 4]) // --> 1\n```\n\n更进一步，可以给 `complement` 过的函数起个名字，这样新函数便可以复用：\n\n```js\nconst isEven = x => x % 2 === 0\nconst isOdd = complement(isEven)\n \nfind(isOdd, [1, 2, 3, 4]) // --> 1\n```\n\n注意，`complement` 以函数的方式实现了逻辑非操作（`!`， not）的功能。\n\n`Both/Either`\n\n假设我们正在开发一个投票系统，给定一个人，我们希望能够确定其是否有资格投票。根据现有知识，一个人必须年满 18 岁并且是本国公民，才有资格投票。成为公民的条件：在本国出生，或者后来加入该国国籍。\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = person => wasBornInCountry(person) || wasNaturalized(person)\n \nconst isEligibleToVote = person => isOver18(person) && isCitizen(person)\n```\n\n上面代码实现了我们的需求，但 Ramda 提供了一些方便的函数，以帮助我们精简代码。\n\n`both` 接受两个函数，返回一个新函数：当两个传入函数都返回 `truthy` 值时，新函数返回 `true`，否则返回 `false`\n\n`either` 接受两个函数，返回一个新函数：当两个传入函数任意一个返回 `truthy` 值时，新函数返回 `true`，否则返回 `false`\n\n我们可以使用这两个函数来简化 `isCitizen` 和 `isEligibleToVote`。\n```js\nconst isCitizen = either(wasBornInCountry, wasNaturalized)\nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n注意，`both` 以函数的方式实现了逻辑与（`&&`）的功能，`either` 实现了逻辑或（`||`）的功能。\n\nRamda 还提供了 `allPass` 和 `anyPass`，接受由任意多个函数组成的数组作为参数。如名称所示，`allPass` 类似于 `both`，而 `anyPass` 类似于 `either`。\n\n## Pipelines(管道)\n\n有时我们需要以 pipeline 的方式将多个函数依次作用于某些数据。例如，接受两个数字，将它们相乘，加 1 ，然后平方。我们可以这样写：\n\n```js\nconst multiply = (a, b) => a * b\nconst addOne = x => x + 1\nconst square = x => x * x\n \nconst operate = (x, y) => {\n  const product = multiply(x, y)\n  const incremented = addOne(product)\n  const squared = square(incremented)\n \n  return squared\n}\n \noperate(3, 4) // => ((3 * 4) + 1)^2 => (12 + 1)^2 => 13^2 => 169\n```\n\n注意，每次操作是对上次操作的结果进行处理。\n\n## pipe\n\nRamda 提供了 `pipe` 函数：接受一系列函数，并返回一个新函数。\n\n新函数的元数与第一个传入函数的元数相同（元数：接受参数的个数），然后顺次通过 \"管道\" 中的函数对输入参数进行处理。它将第一个函数作用于参数，返回结果作为下一个函数的入参，依次进行下去。\"管道\" 中最后一个函数的结果作为 `pipe` 调用的最终结果。\n\n注意，除首个函数外，其余的函数都是一元函数。\n\n了解这些后，我们可以使用 `pipe` 来简化我们的 `operate` 函数：\n\n```js\nconst operate = pipe(\n  multiply,\n  addOne,\n  square\n)\n```\n\n当调用 `operate(3, 4)` 时，`pipe` 将 `3` 和 `4` 传给 `multiply` 函数，输出 `12`，然后将 `12` 传给 `addOne`，返回 `13`，然后将 `13` 传给 `square`，返回 `169`，并将 `169` 作为最终 `operate` 的最终结果返回。\n\n## compose\n\n另一种编写原始 `operate` 函数的方式是内联所有暂时变量：\n\n```js\nconst operate = (x, y) => square(addOne(multiply(x, y)))\n```\n\n这样更紧凑，但也更不便于阅读。然而这种形式可以使用 Ramda 的 `compose` 函数进行重写。\n\n`compose` 的工作方式跟 `pipe` 基本相同，除了其调用函数的顺序是从右到左，而不是从左到右。下面使用 `compose` 来重写 `operate`：\n\n```js\nconst operate = compose(\n  square,\n  addOne,\n  multiply\n)\n```\n\n这与上面的 `pipe` 几乎一样，除了函数的顺序是相反的。实际上，Ramda 中的 `compose` 函数的内部是用 `pipe` 实现的。\n\n我一直这样思考 `compose` 的工作方式：`compose(f, g)(value)` 等价于 `f(g(value))`。\n\n注意，与 `pipe` 类似，`compose` 中的函数除最后一个外，其余都是一元函数。\n\n## compose 还是 pipe？\n\n具有命令式编程背景的人可能觉得 `pipe` 更容易理解，因为可以按照从左往右的顺序进行阅读。但 `compose` 更容易对如上所示的嵌套函数进行转换。\n\n我也不太清楚什么时候该用 `compose`，什么时候该用 `pipe`。由于它们在 Ramda 中基本等价，所以选择用哪个可能并不重要。只要根据自己的情况选择合适的即可。\n\n## 结论\n\n通过特定的方式进行函数组合，我们已经可以开始编写更强的函数了。\n\n## 下一节\n\n你可能已经注意到了，在进行函数组合时，我们多数情况下都可以省略函数参数。只有在最终调用组合好的函数时，才传入参数。\n\n这在函数式编程中非常常见，我们将在下一节 [`Partial Application` (部分应用)](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/)进行更多详细介绍。我们还会讨论如何组合多元（多参数）函数。\n","slug":"Thinking-in-Ramda-Combining-Functions","published":1,"updated":"2020-06-06T14:44:04.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfity000yf6mjf5muppkm","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/05/31/thinking-in-ramda-combining-functions/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Combining Functions</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第二篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一节</a>中，介绍了 Ramda 和函数式编程的一些基本思想，如函数、纯函数和数据不变性。并介绍了如何入门：可以从集合迭代函数（如 <code>forEach</code>、<code>map</code>、<code>reduce</code>）开始。</p>\n<h2>简单组合</h2>\n<p>一旦熟悉了可以将函数传递给其他函数，你可能会开始找将多个函数组合在一起的场景。</p>\n<p>Ramda 为简单的函数组合提供了一些函数。我们来看看。</p>\n<h2>Complement</h2>\n<p>在上一节，我们使用 <code>find</code> 来查找列表中的首个偶数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\">find(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<p>如果想找首个奇数呢？我们可以随手写一个 <code>isOdd</code> 函数并使用它。但我们知道任何非偶整数都是奇数，所以可以重用 <code>isEven</code> 函数。</p>\n<p>Ramda 提供了一个更高阶的函数：<code>complement</code>，给它传入一个函数，返回一个新的函数：当原函数返回 &quot;假值&quot; 时，新函数返回 <code>true</code>；原函数返回 &quot;真值&quot; 时，新函数返回 <code>false</code>，即新函数是原函数的补函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\"> </span><br><span class=\"line\">find(complement(isEven), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">// --&gt; 1</span></span><br></pre></td></tr></table></figure></p>\n<p>更进一步，可以给 <code>complement</code> 过的函数起个名字，这样新函数便可以复用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd = complement(isEven)</span><br><span class=\"line\"> </span><br><span class=\"line\">find(isOdd, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">// --&gt; 1</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>complement</code> 以函数的方式实现了逻辑非操作（<code>!</code>， not）的功能。</p>\n<p><code>Both/Either</code></p>\n<p>假设我们正在开发一个投票系统，给定一个人，我们希望能够确定其是否有资格投票。根据现有知识，一个人必须年满 18 岁并且是本国公民，才有资格投票。成为公民的条件：在本国出生，或者后来加入该国国籍。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码实现了我们的需求，但 Ramda 提供了一些方便的函数，以帮助我们精简代码。</p>\n<p><code>both</code> 接受两个函数，返回一个新函数：当两个传入函数都返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>\n<p><code>either</code> 接受两个函数，返回一个新函数：当两个传入函数任意一个返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>\n<p>我们可以使用这两个函数来简化 <code>isCitizen</code> 和 <code>isEligibleToVote</code>。\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>both</code> 以函数的方式实现了逻辑与（<code>&amp;&amp;</code>）的功能，<code>either</code> 实现了逻辑或（<code>||</code>）的功能。</p>\n<p>Ramda 还提供了 <code>allPass</code> 和 <code>anyPass</code>，接受由任意多个函数组成的数组作为参数。如名称所示，<code>allPass</code> 类似于 <code>both</code>，而 <code>anyPass</code> 类似于 <code>either</code>。</p>\n<h2>Pipelines(管道)</h2>\n<p>有时我们需要以 pipeline 的方式将多个函数依次作用于某些数据。例如，接受两个数字，将它们相乘，加 1 ，然后平方。我们可以这样写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> multiply = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a * b</span><br><span class=\"line\"><span class=\"keyword\">const</span> addOne = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> product = multiply(x, y)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> incremented = addOne(product)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> squared = square(incremented)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> squared</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">operate(<span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，每次操作是对上次操作的结果进行处理。</p>\n<h2>pipe</h2>\n<p>Ramda 提供了 <code>pipe</code> 函数：接受一系列函数，并返回一个新函数。</p>\n<p>新函数的元数与第一个传入函数的元数相同（元数：接受参数的个数），然后顺次通过 &quot;管道&quot; 中的函数对输入参数进行处理。它将第一个函数作用于参数，返回结果作为下一个函数的入参，依次进行下去。&quot;管道&quot; 中最后一个函数的结果作为 <code>pipe</code> 调用的最终结果。</p>\n<p>注意，除首个函数外，其余的函数都是一元函数。</p>\n<p>了解这些后，我们可以使用 <code>pipe</code> 来简化我们的 <code>operate</code> 函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  addOne,</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>当调用 <code>operate(3, 4)</code> 时，<code>pipe</code> 将 <code>3</code> 和 <code>4</code> 传给 <code>multiply</code> 函数，输出 <code>12</code>，然后将 <code>12</code> 传给 <code>addOne</code>，返回 <code>13</code>，然后将 <code>13</code> 传给 <code>square</code>，返回 <code>169</code>，并将 <code>169</code> 作为最终 <code>operate</code> 的最终结果返回。</p>\n<h2>compose</h2>\n<p>另一种编写原始 <code>operate</code> 函数的方式是内联所有暂时变量：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> operate = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> square(addOne(multiply(x, y)))</span><br></pre></td></tr></table></figure></p>\n<p>这样更紧凑，但也更不便于阅读。然而这种形式可以使用 Ramda 的 <code>compose</code> 函数进行重写。</p>\n<p><code>compose</code> 的工作方式跟 <code>pipe</code> 基本相同，除了其调用函数的顺序是从右到左，而不是从左到右。下面使用 <code>compose</code> 来重写 <code>operate</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> operate = compose(</span><br><span class=\"line\">  square,</span><br><span class=\"line\">  addOne,</span><br><span class=\"line\">  multiply</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>这与上面的 <code>pipe</code> 几乎一样，除了函数的顺序是相反的。实际上，Ramda 中的 <code>compose</code> 函数的内部是用 <code>pipe</code> 实现的。</p>\n<p>我一直这样思考 <code>compose</code> 的工作方式：<code>compose(f, g)(value)</code> 等价于 <code>f(g(value))</code>。</p>\n<p>注意，与 <code>pipe</code> 类似，<code>compose</code> 中的函数除最后一个外，其余都是一元函数。</p>\n<h2>compose 还是 pipe？</h2>\n<p>具有命令式编程背景的人可能觉得 <code>pipe</code> 更容易理解，因为可以按照从左往右的顺序进行阅读。但 <code>compose</code> 更容易对如上所示的嵌套函数进行转换。</p>\n<p>我也不太清楚什么时候该用 <code>compose</code>，什么时候该用 <code>pipe</code>。由于它们在 Ramda 中基本等价，所以选择用哪个可能并不重要。只要根据自己的情况选择合适的即可。</p>\n<h2>结论</h2>\n<p>通过特定的方式进行函数组合，我们已经可以开始编写更强的函数了。</p>\n<h2>下一节</h2>\n<p>你可能已经注意到了，在进行函数组合时，我们多数情况下都可以省略函数参数。只有在最终调用组合好的函数时，才传入参数。</p>\n<p>这在函数式编程中非常常见，我们将在下一节 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\"><code>Partial Application</code> (部分应用)</a>进行更多详细介绍。我们还会讨论如何组合多元（多参数）函数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/05/31/thinking-in-ramda-combining-functions/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Combining Functions</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第二篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一节</a>中，介绍了 Ramda 和函数式编程的一些基本思想，如函数、纯函数和数据不变性。并介绍了如何入门：可以从集合迭代函数（如 <code>forEach</code>、<code>map</code>、<code>reduce</code>）开始。</p>\n<h2>简单组合</h2>\n<p>一旦熟悉了可以将函数传递给其他函数，你可能会开始找将多个函数组合在一起的场景。</p>\n<p>Ramda 为简单的函数组合提供了一些函数。我们来看看。</p>\n<h2>Complement</h2>\n<p>在上一节，我们使用 <code>find</code> 来查找列表中的首个偶数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\">find(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<p>如果想找首个奇数呢？我们可以随手写一个 <code>isOdd</code> 函数并使用它。但我们知道任何非偶整数都是奇数，所以可以重用 <code>isEven</code> 函数。</p>\n<p>Ramda 提供了一个更高阶的函数：<code>complement</code>，给它传入一个函数，返回一个新的函数：当原函数返回 &quot;假值&quot; 时，新函数返回 <code>true</code>；原函数返回 &quot;真值&quot; 时，新函数返回 <code>false</code>，即新函数是原函数的补函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\"> </span><br><span class=\"line\">find(complement(isEven), [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">// --&gt; 1</span></span><br></pre></td></tr></table></figure></p>\n<p>更进一步，可以给 <code>complement</code> 过的函数起个名字，这样新函数便可以复用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isOdd = complement(isEven)</span><br><span class=\"line\"> </span><br><span class=\"line\">find(isOdd, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">// --&gt; 1</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>complement</code> 以函数的方式实现了逻辑非操作（<code>!</code>， not）的功能。</p>\n<p><code>Both/Either</code></p>\n<p>假设我们正在开发一个投票系统，给定一个人，我们希望能够确定其是否有资格投票。根据现有知识，一个人必须年满 18 岁并且是本国公民，才有资格投票。成为公民的条件：在本国出生，或者后来加入该国国籍。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码实现了我们的需求，但 Ramda 提供了一些方便的函数，以帮助我们精简代码。</p>\n<p><code>both</code> 接受两个函数，返回一个新函数：当两个传入函数都返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>\n<p><code>either</code> 接受两个函数，返回一个新函数：当两个传入函数任意一个返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>\n<p>我们可以使用这两个函数来简化 <code>isCitizen</code> 和 <code>isEligibleToVote</code>。\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>both</code> 以函数的方式实现了逻辑与（<code>&amp;&amp;</code>）的功能，<code>either</code> 实现了逻辑或（<code>||</code>）的功能。</p>\n<p>Ramda 还提供了 <code>allPass</code> 和 <code>anyPass</code>，接受由任意多个函数组成的数组作为参数。如名称所示，<code>allPass</code> 类似于 <code>both</code>，而 <code>anyPass</code> 类似于 <code>either</code>。</p>\n<h2>Pipelines(管道)</h2>\n<p>有时我们需要以 pipeline 的方式将多个函数依次作用于某些数据。例如，接受两个数字，将它们相乘，加 1 ，然后平方。我们可以这样写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> multiply = <span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> a * b</span><br><span class=\"line\"><span class=\"keyword\">const</span> addOne = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> square = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * x</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> operate = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> product = multiply(x, y)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> incremented = addOne(product)</span><br><span class=\"line\">  <span class=\"keyword\">const</span> squared = square(incremented)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> squared</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">operate(<span class=\"number\">3</span>, <span class=\"number\">4</span>) <span class=\"comment\">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，每次操作是对上次操作的结果进行处理。</p>\n<h2>pipe</h2>\n<p>Ramda 提供了 <code>pipe</code> 函数：接受一系列函数，并返回一个新函数。</p>\n<p>新函数的元数与第一个传入函数的元数相同（元数：接受参数的个数），然后顺次通过 &quot;管道&quot; 中的函数对输入参数进行处理。它将第一个函数作用于参数，返回结果作为下一个函数的入参，依次进行下去。&quot;管道&quot; 中最后一个函数的结果作为 <code>pipe</code> 调用的最终结果。</p>\n<p>注意，除首个函数外，其余的函数都是一元函数。</p>\n<p>了解这些后，我们可以使用 <code>pipe</code> 来简化我们的 <code>operate</code> 函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> operate = pipe(</span><br><span class=\"line\">  multiply,</span><br><span class=\"line\">  addOne,</span><br><span class=\"line\">  square</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>当调用 <code>operate(3, 4)</code> 时，<code>pipe</code> 将 <code>3</code> 和 <code>4</code> 传给 <code>multiply</code> 函数，输出 <code>12</code>，然后将 <code>12</code> 传给 <code>addOne</code>，返回 <code>13</code>，然后将 <code>13</code> 传给 <code>square</code>，返回 <code>169</code>，并将 <code>169</code> 作为最终 <code>operate</code> 的最终结果返回。</p>\n<h2>compose</h2>\n<p>另一种编写原始 <code>operate</code> 函数的方式是内联所有暂时变量：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> operate = <span class=\"function\">(<span class=\"params\">x, y</span>) =&gt;</span> square(addOne(multiply(x, y)))</span><br></pre></td></tr></table></figure></p>\n<p>这样更紧凑，但也更不便于阅读。然而这种形式可以使用 Ramda 的 <code>compose</code> 函数进行重写。</p>\n<p><code>compose</code> 的工作方式跟 <code>pipe</code> 基本相同，除了其调用函数的顺序是从右到左，而不是从左到右。下面使用 <code>compose</code> 来重写 <code>operate</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> operate = compose(</span><br><span class=\"line\">  square,</span><br><span class=\"line\">  addOne,</span><br><span class=\"line\">  multiply</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>这与上面的 <code>pipe</code> 几乎一样，除了函数的顺序是相反的。实际上，Ramda 中的 <code>compose</code> 函数的内部是用 <code>pipe</code> 实现的。</p>\n<p>我一直这样思考 <code>compose</code> 的工作方式：<code>compose(f, g)(value)</code> 等价于 <code>f(g(value))</code>。</p>\n<p>注意，与 <code>pipe</code> 类似，<code>compose</code> 中的函数除最后一个外，其余都是一元函数。</p>\n<h2>compose 还是 pipe？</h2>\n<p>具有命令式编程背景的人可能觉得 <code>pipe</code> 更容易理解，因为可以按照从左往右的顺序进行阅读。但 <code>compose</code> 更容易对如上所示的嵌套函数进行转换。</p>\n<p>我也不太清楚什么时候该用 <code>compose</code>，什么时候该用 <code>pipe</code>。由于它们在 Ramda 中基本等价，所以选择用哪个可能并不重要。只要根据自己的情况选择合适的即可。</p>\n<h2>结论</h2>\n<p>通过特定的方式进行函数组合，我们已经可以开始编写更强的函数了。</p>\n<h2>下一节</h2>\n<p>你可能已经注意到了，在进行函数组合时，我们多数情况下都可以省略函数参数。只有在最终调用组合好的函数时，才传入参数。</p>\n<p>这在函数式编程中非常常见，我们将在下一节 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\"><code>Partial Application</code> (部分应用)</a>进行更多详细介绍。我们还会讨论如何组合多元（多参数）函数。</p>\n"},{"title":"Thinking in Ramda: 部分应用","date":"2017-06-10T22:01:57.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Partial Application](http://randycoulman.com/blog/2016/06/07/thinking-in-ramda-partial-application/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第三篇。\n\n在[第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/)中，讨论了各种函数组合的方式。最后，演示了 `compose` 和 `pipe`， 可以以 \"pipeline\" （管道）的形式对一系列函数进行调用。\n\n在上篇文章中，简单的函数链式调用（\"pipeline\"）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？\n\n例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。可以使用 Ramda 的集合迭代函数完成该需求：\n\n```js\nconst publishedInYear = (book, year) => book.year === year\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(book => publishedInYear(book, year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n如果能将 `filter` 和 `map` 组合成 \"pipeline\" 就好了，但我们并不知道该如何处理，因为 `filter` 和 `map` 都是二元函数。\n\n如果不需要在 `filter` 中使用箭头函数会更好些。先来解决这个问题，并借此展示一些制作 \"pipeline\" 的知识。\n\n## 高阶函数\n\n在本系列文章的[第一篇](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/)中，我们将函数视为 \"一等结构\"。一等函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。我们一直在使用前者，但还没有见过后者（函数作为其他函数的返回值）。\n\n获取或返回其他函数的函数称为 \"高阶函数\"。\n\n在上面的示例中，我们传递了一个箭头函数给 `filter`：`book => publishedInYear(book, year)`，但我们想去掉箭头函数。为了做到这点，需要一个函数：输入一本书，若该书是在指定年份出版的则返回 `true`。但还需要一个指定的年份，让该操作更加灵活。\n\n为了解决这个问题，可以将 `publishedInYear` 变为返回另一个函数的函数。我将使用普通的语法来实现该函数，以便能够清晰地展示其内部具体实现，然后使用箭头函数实现一个更短版本的函数：\n\n```js\n// Full function version:\nfunction publishedInYear(year) {\n  return function(book) {\n    return book.year === year\n  }\n}\n \n// Arrow function version:\nconst publishedInYear = year => book => book.year === year\n```\n\n利用新实现的 `publishedInYear`，可以重写 `filter` 调用，从而消除箭头函数：\n\n```js\nconst publishedInYear = year => book => book.year === year\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n现在，当调用 `filter` 时，`publishedInYear(year)` 会立即调用，并返回一个接受 `book` 为参数的函数，这正是 `filter` 需要的。\n\n## 部分应用函数\n\n可以按上面的方式重写任何多参数函数。但我们不可能拥有所有我们想要的函数的源码；另外，很多情况下，我们可能还是希望以普通的方式调用多参数函数。\n\n例如，在其他一些代码中，只是想检查一本书是否是在指定年份出版的，我们可能想要 `publishedInYear(book, 2012)`，但现在不能再那么做了。相反，我们必须要用这种方式：`publishedInYear(book)(2012)`。这样做降低了代码的可读性，也很烦人。\n\n幸运的是，Ramda 提供了两个函数：`partial` 和 `partialRight`，来帮我们解决这个问题。\n\n这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。\n\n`partial` 和 `partialRight` 的区别在于参数传递的顺序：`partial` 先传递原函数左侧的参数，而 `partialRight` 先传递右侧的参数。\n\n回到刚开始的例子，使用上面的一个函数来代替原来对 `publishedInYear` 的重写。由于刚开始我们只需要最右侧的参数：`year`，所以需要使用 `partialRight`.\n\n```js\nconst publishedInYear = (book, year) => book.year === year\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(partialRight(publishedInYear, [year]), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n如果 `pubilshedInYear` 原本参数的顺序为 `(year, book)` ，而非 `(book, year)` ，则需要用 `partial` 代替 `partialRight`。\n\n注意，为被 `partial` 和 `partialRight` 包裹的函数提供的参数必须包裹在数组中，即使只有一个参数。我不会告诉你我已经忘记了多少次，导致出现令人困惑的错误信息：\n\n```bash\nFirst argument to _arity must be a non-negative integer no greater than ten\n```\n\n## 柯里化(Curry)\n\n如果到处使用 `partial` 和 `partialRight` 的话，会让代码变得冗长乏味；但是，将多元函数以一系列一元函数的形式调用同样不好。\n\n幸运的是，Ramda 给我们提供了一个解决方案：`curry`。\n\n[Currying（柯里化）](https://en.wikipedia.org/wiki/Currying) 是函数式编程的另一个核心概念。从技术角度讲，一个柯里化了的函数是一系列高阶一元函数，这也是我刚刚抱怨过的。在纯函数式语言中，柯里化函数在调用时，语法上看起来和调用多个参数没有什么区别。\n\n但由于 Ramda 是一个 JavaScript 库，而 JavaScript 并没有很好的语法来支持一系列一元函数的调用，所以作者对传统柯里化的定义放宽了一些。\n\n在 Ramda 中，一个柯里化的函数只能用其参数的子集来调用，它会返回一个接受其余参数的新函数。当使用它的所有参数调用，真正的原函数将被调用。\n\n柯里化的函数在下列两种情况下工作的都很好：\n\n1. 可以按正常情况下使用所有参数调用它，它可以像普通函数一样正常工作；\n2. 也可以使用部分参数来调用它，这时它会像使用 `partial` 一样工作。\n\n注意，这种灵活性带来了一些性能上的损失，因为 `curry` 需要搞清楚函数的调用方式，然后确定该做什么。一般来说，我只有需要在多个地方对同一个函数使用 `partial` 的时候，才会对函数进行柯里化。\n\n接下来写一个柯里化版本的 `publishedInYear` 函数。注意，`curry` 会像 `partial` 一样工作；并且没有 `partialRight` 版本的 `curry` 函数。对这方面后续会有更多讨论，但现在我们需要将 `publishedInYear` 的参数翻转一下，以便让参数 `year` 在最前面。\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n现在可以只使用参数 `year` 来调用 `publishedInYear`，并返回一个新函数，该函数接受参数 `book` 并执行原函数。但是，仍然可以按普通方式对它调用：`publishedInYear(2012, book)`，不需要写烦人的语法 `)(`。所以，柯里化的函数在两种情况下都能很好地工作。\n\n## 参数的顺序\n\n注意，为了让 `curry` 工作，我们不得不对参数的顺序进行翻转。这在函数式编程中非常常见，所以几乎所有的 Ramda 函数都将待处理的数据放到参数列表的最后面。\n\n你可以将先期传入的参数看作对操作的配置。所以，对于 `publishedInYear`，参数 `year` 作为配置（需要查找的年份），而参数 `book` 作为被处理的数据（被查找的对象）。\n\n我们已经在集合迭代函数中见过这样的例子。它们都将集合作为最后一个参数，这样可以使这种风格的编程更容易些。\n\n## 顺序错误的参数\n\n如果不改变 `publishedInYear` 的顺序，还可以继续使用柯里化特性的优势吗？\n\n当然可以了，Ramda 提供了几个选择。\n\n## flip\n\n第一个选择是 `flip`。`flip` 接受一个多元函数（元数 >= 2），返回一个元数相同的新函数，但前 2 个参数的顺序调换了。它主要用于二元函数，但也可以用于一般函数。\n\n使用 `flip`，我们可以恢复 `publishedInYear` 参数的初始的顺序：\n\n```js\nconst publishedInYear = curry((book, year) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(flip(publishedInYear)(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n多数情况下，我更喜欢使用方便的参数顺序，但如果用到不能自己掌控的函数，`flip` 是一个好的选择。\n\n## placeholder (占位符)\n\n更通用的选择是使用 \"placeholder\" 参数（`__`）\n\n假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 \"占位符\" 作为中间参数：\n\n```js\nconst threeArgs = curry((a, b, c) => { /* ... */ })\n \nconst middleArgumentLater = threeArgs('value for a', __, 'value for c')\n```\n\n可以在函数调用中多次使用 \"占位符\"。例如，如果只想传递中间参数呢？\n\n```js\nconst threeArgs = curry((a, b, c) => { /* ... */ })\n \nconst middleArgumentOnly = threeArgs(__, 'value for b', __)\n```\n\n也可以使用 \"占位符\" 代替 `flip`：\n\n```js\nconst publishedInYear = curry((book, year) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(__, year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n我觉得这个版本的可读性更好，但如果需要频繁使用参数顺序翻转的 `publishedInYear`，我可能会使用 `flip` 定义一个辅助函数，然后在任何用到它的地方使用辅助函数。在后续文章中会看到一些示例。 \n\n注意， `__` 仅适用于柯里化的函数，而 `partial`、`partialRight` 和 `flip` 适用于任何函数。如果需要对某个普通函数使用 `__`，可以先用 `curry` 将其包裹起来。\n\n## 来做一条管道（pipeline）\n\n现在看看能否将我们的 `filter` 和 `map` 调用放入 \"pipeline\" (管道)中？下面是代码当前的状态，使用了方便的参数顺序的 `publishedInYear`：\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n在上一节中，我们了解了 `pipe` 和 `compose`，但我们还需要另一部分信息，以便能够使用上面所学的知识。\n\n缺少的信息是：几乎所有的 Ramda 函数都是默认柯里化的，包括 `filter` 和 `map`。所以 `filter(publishedInYear(year))` 是完全合法的，它会返回一个新函数，该函数等待我们传递 `books` 给它，`map(book => book.title)` 也是如此。\n\n现在可以编写 \"pipeline\" 了：\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = (books, year) =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )(books)\n```\n\n我们来更进一步，将 `titlesForYear` 的参数顺序也调换一下，这样更符合 Ramda 中待处理数据放在最后的约定。也可以将该函数进行柯里化，以便其在后续的 \"pipeline\" 中使用。\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = curry((year, books) =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )(books)\n)\n```\n\n## 结论\n\n本文可能是这个系列中讲解最深的一篇。部分应用和柯里化可能需要花一些时间和精力来熟悉和掌握。但一旦学会，他们会以一种强大的方式将数据处理变得更加函数式。\n\n它们引导你通过创建包含许多小而简单代码块的 \"pipeline\" 的方式，来构建数据处理程序。\n\n## 下一节\n\n为了以函数式的方式编写代码，我们需要用 \"声明式\" 的思维代替 \"命令式\" 思维。要做到这点，需要找到一种函数式的方式来表示命令式的结构。[声明式编程](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/) 将会讨论这些想法。\n","source":"_posts/Thinking-in-Ramda-Partial-Application.md","raw":"---\ntitle: 'Thinking in Ramda: 部分应用'\ndate: 2017-06-11 06:01:57\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Partial Application](http://randycoulman.com/blog/2016/06/07/thinking-in-ramda-partial-application/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第三篇。\n\n在[第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/)中，讨论了各种函数组合的方式。最后，演示了 `compose` 和 `pipe`， 可以以 \"pipeline\" （管道）的形式对一系列函数进行调用。\n\n在上篇文章中，简单的函数链式调用（\"pipeline\"）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？\n\n例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。可以使用 Ramda 的集合迭代函数完成该需求：\n\n```js\nconst publishedInYear = (book, year) => book.year === year\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(book => publishedInYear(book, year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n如果能将 `filter` 和 `map` 组合成 \"pipeline\" 就好了，但我们并不知道该如何处理，因为 `filter` 和 `map` 都是二元函数。\n\n如果不需要在 `filter` 中使用箭头函数会更好些。先来解决这个问题，并借此展示一些制作 \"pipeline\" 的知识。\n\n## 高阶函数\n\n在本系列文章的[第一篇](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/)中，我们将函数视为 \"一等结构\"。一等函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。我们一直在使用前者，但还没有见过后者（函数作为其他函数的返回值）。\n\n获取或返回其他函数的函数称为 \"高阶函数\"。\n\n在上面的示例中，我们传递了一个箭头函数给 `filter`：`book => publishedInYear(book, year)`，但我们想去掉箭头函数。为了做到这点，需要一个函数：输入一本书，若该书是在指定年份出版的则返回 `true`。但还需要一个指定的年份，让该操作更加灵活。\n\n为了解决这个问题，可以将 `publishedInYear` 变为返回另一个函数的函数。我将使用普通的语法来实现该函数，以便能够清晰地展示其内部具体实现，然后使用箭头函数实现一个更短版本的函数：\n\n```js\n// Full function version:\nfunction publishedInYear(year) {\n  return function(book) {\n    return book.year === year\n  }\n}\n \n// Arrow function version:\nconst publishedInYear = year => book => book.year === year\n```\n\n利用新实现的 `publishedInYear`，可以重写 `filter` 调用，从而消除箭头函数：\n\n```js\nconst publishedInYear = year => book => book.year === year\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n现在，当调用 `filter` 时，`publishedInYear(year)` 会立即调用，并返回一个接受 `book` 为参数的函数，这正是 `filter` 需要的。\n\n## 部分应用函数\n\n可以按上面的方式重写任何多参数函数。但我们不可能拥有所有我们想要的函数的源码；另外，很多情况下，我们可能还是希望以普通的方式调用多参数函数。\n\n例如，在其他一些代码中，只是想检查一本书是否是在指定年份出版的，我们可能想要 `publishedInYear(book, 2012)`，但现在不能再那么做了。相反，我们必须要用这种方式：`publishedInYear(book)(2012)`。这样做降低了代码的可读性，也很烦人。\n\n幸运的是，Ramda 提供了两个函数：`partial` 和 `partialRight`，来帮我们解决这个问题。\n\n这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。\n\n`partial` 和 `partialRight` 的区别在于参数传递的顺序：`partial` 先传递原函数左侧的参数，而 `partialRight` 先传递右侧的参数。\n\n回到刚开始的例子，使用上面的一个函数来代替原来对 `publishedInYear` 的重写。由于刚开始我们只需要最右侧的参数：`year`，所以需要使用 `partialRight`.\n\n```js\nconst publishedInYear = (book, year) => book.year === year\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(partialRight(publishedInYear, [year]), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n如果 `pubilshedInYear` 原本参数的顺序为 `(year, book)` ，而非 `(book, year)` ，则需要用 `partial` 代替 `partialRight`。\n\n注意，为被 `partial` 和 `partialRight` 包裹的函数提供的参数必须包裹在数组中，即使只有一个参数。我不会告诉你我已经忘记了多少次，导致出现令人困惑的错误信息：\n\n```bash\nFirst argument to _arity must be a non-negative integer no greater than ten\n```\n\n## 柯里化(Curry)\n\n如果到处使用 `partial` 和 `partialRight` 的话，会让代码变得冗长乏味；但是，将多元函数以一系列一元函数的形式调用同样不好。\n\n幸运的是，Ramda 给我们提供了一个解决方案：`curry`。\n\n[Currying（柯里化）](https://en.wikipedia.org/wiki/Currying) 是函数式编程的另一个核心概念。从技术角度讲，一个柯里化了的函数是一系列高阶一元函数，这也是我刚刚抱怨过的。在纯函数式语言中，柯里化函数在调用时，语法上看起来和调用多个参数没有什么区别。\n\n但由于 Ramda 是一个 JavaScript 库，而 JavaScript 并没有很好的语法来支持一系列一元函数的调用，所以作者对传统柯里化的定义放宽了一些。\n\n在 Ramda 中，一个柯里化的函数只能用其参数的子集来调用，它会返回一个接受其余参数的新函数。当使用它的所有参数调用，真正的原函数将被调用。\n\n柯里化的函数在下列两种情况下工作的都很好：\n\n1. 可以按正常情况下使用所有参数调用它，它可以像普通函数一样正常工作；\n2. 也可以使用部分参数来调用它，这时它会像使用 `partial` 一样工作。\n\n注意，这种灵活性带来了一些性能上的损失，因为 `curry` 需要搞清楚函数的调用方式，然后确定该做什么。一般来说，我只有需要在多个地方对同一个函数使用 `partial` 的时候，才会对函数进行柯里化。\n\n接下来写一个柯里化版本的 `publishedInYear` 函数。注意，`curry` 会像 `partial` 一样工作；并且没有 `partialRight` 版本的 `curry` 函数。对这方面后续会有更多讨论，但现在我们需要将 `publishedInYear` 的参数翻转一下，以便让参数 `year` 在最前面。\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n现在可以只使用参数 `year` 来调用 `publishedInYear`，并返回一个新函数，该函数接受参数 `book` 并执行原函数。但是，仍然可以按普通方式对它调用：`publishedInYear(2012, book)`，不需要写烦人的语法 `)(`。所以，柯里化的函数在两种情况下都能很好地工作。\n\n## 参数的顺序\n\n注意，为了让 `curry` 工作，我们不得不对参数的顺序进行翻转。这在函数式编程中非常常见，所以几乎所有的 Ramda 函数都将待处理的数据放到参数列表的最后面。\n\n你可以将先期传入的参数看作对操作的配置。所以，对于 `publishedInYear`，参数 `year` 作为配置（需要查找的年份），而参数 `book` 作为被处理的数据（被查找的对象）。\n\n我们已经在集合迭代函数中见过这样的例子。它们都将集合作为最后一个参数，这样可以使这种风格的编程更容易些。\n\n## 顺序错误的参数\n\n如果不改变 `publishedInYear` 的顺序，还可以继续使用柯里化特性的优势吗？\n\n当然可以了，Ramda 提供了几个选择。\n\n## flip\n\n第一个选择是 `flip`。`flip` 接受一个多元函数（元数 >= 2），返回一个元数相同的新函数，但前 2 个参数的顺序调换了。它主要用于二元函数，但也可以用于一般函数。\n\n使用 `flip`，我们可以恢复 `publishedInYear` 参数的初始的顺序：\n\n```js\nconst publishedInYear = curry((book, year) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(flip(publishedInYear)(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n多数情况下，我更喜欢使用方便的参数顺序，但如果用到不能自己掌控的函数，`flip` 是一个好的选择。\n\n## placeholder (占位符)\n\n更通用的选择是使用 \"placeholder\" 参数（`__`）\n\n假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 \"占位符\" 作为中间参数：\n\n```js\nconst threeArgs = curry((a, b, c) => { /* ... */ })\n \nconst middleArgumentLater = threeArgs('value for a', __, 'value for c')\n```\n\n可以在函数调用中多次使用 \"占位符\"。例如，如果只想传递中间参数呢？\n\n```js\nconst threeArgs = curry((a, b, c) => { /* ... */ })\n \nconst middleArgumentOnly = threeArgs(__, 'value for b', __)\n```\n\n也可以使用 \"占位符\" 代替 `flip`：\n\n```js\nconst publishedInYear = curry((book, year) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(__, year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n我觉得这个版本的可读性更好，但如果需要频繁使用参数顺序翻转的 `publishedInYear`，我可能会使用 `flip` 定义一个辅助函数，然后在任何用到它的地方使用辅助函数。在后续文章中会看到一些示例。 \n\n注意， `__` 仅适用于柯里化的函数，而 `partial`、`partialRight` 和 `flip` 适用于任何函数。如果需要对某个普通函数使用 `__`，可以先用 `curry` 将其包裹起来。\n\n## 来做一条管道（pipeline）\n\n现在看看能否将我们的 `filter` 和 `map` 调用放入 \"pipeline\" (管道)中？下面是代码当前的状态，使用了方便的参数顺序的 `publishedInYear`：\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = (books, year) => {\n  const selected = filter(publishedInYear(year), books)\n \n  return map(book => book.title, selected)\n}\n```\n\n在上一节中，我们了解了 `pipe` 和 `compose`，但我们还需要另一部分信息，以便能够使用上面所学的知识。\n\n缺少的信息是：几乎所有的 Ramda 函数都是默认柯里化的，包括 `filter` 和 `map`。所以 `filter(publishedInYear(year))` 是完全合法的，它会返回一个新函数，该函数等待我们传递 `books` 给它，`map(book => book.title)` 也是如此。\n\n现在可以编写 \"pipeline\" 了：\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = (books, year) =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )(books)\n```\n\n我们来更进一步，将 `titlesForYear` 的参数顺序也调换一下，这样更符合 Ramda 中待处理数据放在最后的约定。也可以将该函数进行柯里化，以便其在后续的 \"pipeline\" 中使用。\n\n```js\nconst publishedInYear = curry((year, book) => book.year === year)\n \nconst titlesForYear = curry((year, books) =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )(books)\n)\n```\n\n## 结论\n\n本文可能是这个系列中讲解最深的一篇。部分应用和柯里化可能需要花一些时间和精力来熟悉和掌握。但一旦学会，他们会以一种强大的方式将数据处理变得更加函数式。\n\n它们引导你通过创建包含许多小而简单代码块的 \"pipeline\" 的方式，来构建数据处理程序。\n\n## 下一节\n\n为了以函数式的方式编写代码，我们需要用 \"声明式\" 的思维代替 \"命令式\" 思维。要做到这点，需要找到一种函数式的方式来表示命令式的结构。[声明式编程](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/) 将会讨论这些想法。\n","slug":"Thinking-in-Ramda-Partial-Application","published":1,"updated":"2020-06-06T14:44:04.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfitz0010f6mj2br64yk2","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/07/thinking-in-ramda-partial-application/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Partial Application</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第三篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a>中，讨论了各种函数组合的方式。最后，演示了 <code>compose</code> 和 <code>pipe</code>， 可以以 &quot;pipeline&quot; （管道）的形式对一系列函数进行调用。</p>\n<p>在上篇文章中，简单的函数链式调用（&quot;pipeline&quot;）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？</p>\n<p>例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。可以使用 Ramda 的集合迭代函数完成该需求：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> publishedInYear(book, year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果能将 <code>filter</code> 和 <code>map</code> 组合成 &quot;pipeline&quot; 就好了，但我们并不知道该如何处理，因为 <code>filter</code> 和 <code>map</code> 都是二元函数。</p>\n<p>如果不需要在 <code>filter</code> 中使用箭头函数会更好些。先来解决这个问题，并借此展示一些制作 &quot;pipeline&quot; 的知识。</p>\n<h2>高阶函数</h2>\n<p>在本系列文章的<a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一篇</a>中，我们将函数视为 &quot;一等结构&quot;。一等函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。我们一直在使用前者，但还没有见过后者（函数作为其他函数的返回值）。</p>\n<p>获取或返回其他函数的函数称为 &quot;高阶函数&quot;。</p>\n<p>在上面的示例中，我们传递了一个箭头函数给 <code>filter</code>：<code>book =&gt; publishedInYear(book, year)</code>，但我们想去掉箭头函数。为了做到这点，需要一个函数：输入一本书，若该书是在指定年份出版的则返回 <code>true</code>。但还需要一个指定的年份，让该操作更加灵活。</p>\n<p>为了解决这个问题，可以将 <code>publishedInYear</code> 变为返回另一个函数的函数。我将使用普通的语法来实现该函数，以便能够清晰地展示其内部具体实现，然后使用箭头函数实现一个更短版本的函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Full function version:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">publishedInYear</span>(<span class=\"params\">year</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> book.year === year</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Arrow function version:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\"><span class=\"params\">year</span> =&gt;</span> <span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.year === year</span><br></pre></td></tr></table></figure></p>\n<p>利用新实现的 <code>publishedInYear</code>，可以重写 <code>filter</code> 调用，从而消除箭头函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\"><span class=\"params\">year</span> =&gt;</span> <span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.year === year</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在，当调用 <code>filter</code> 时，<code>publishedInYear(year)</code> 会立即调用，并返回一个接受 <code>book</code> 为参数的函数，这正是 <code>filter</code> 需要的。</p>\n<h2>部分应用函数</h2>\n<p>可以按上面的方式重写任何多参数函数。但我们不可能拥有所有我们想要的函数的源码；另外，很多情况下，我们可能还是希望以普通的方式调用多参数函数。</p>\n<p>例如，在其他一些代码中，只是想检查一本书是否是在指定年份出版的，我们可能想要 <code>publishedInYear(book, 2012)</code>，但现在不能再那么做了。相反，我们必须要用这种方式：<code>publishedInYear(book)(2012)</code>。这样做降低了代码的可读性，也很烦人。</p>\n<p>幸运的是，Ramda 提供了两个函数：<code>partial</code> 和 <code>partialRight</code>，来帮我们解决这个问题。</p>\n<p>这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。</p>\n<p><code>partial</code> 和 <code>partialRight</code> 的区别在于参数传递的顺序：<code>partial</code> 先传递原函数左侧的参数，而 <code>partialRight</code> 先传递右侧的参数。</p>\n<p>回到刚开始的例子，使用上面的一个函数来代替原来对 <code>publishedInYear</code> 的重写。由于刚开始我们只需要最右侧的参数：<code>year</code>，所以需要使用 <code>partialRight</code>.</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(partialRight(publishedInYear, [year]), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>pubilshedInYear</code> 原本参数的顺序为 <code>(year, book)</code> ，而非 <code>(book, year)</code> ，则需要用 <code>partial</code> 代替 <code>partialRight</code>。</p>\n<p>注意，为被 <code>partial</code> 和 <code>partialRight</code> 包裹的函数提供的参数必须包裹在数组中，即使只有一个参数。我不会告诉你我已经忘记了多少次，导致出现令人困惑的错误信息：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">First argument to _arity must be a non-negative <span class=\"built_in\">integer</span> no greater than ten</span><br></pre></td></tr></table></figure></p>\n<h2>柯里化(Curry)</h2>\n<p>如果到处使用 <code>partial</code> 和 <code>partialRight</code> 的话，会让代码变得冗长乏味；但是，将多元函数以一系列一元函数的形式调用同样不好。</p>\n<p>幸运的是，Ramda 给我们提供了一个解决方案：<code>curry</code>。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Currying\" target=\"_blank\" rel=\"noopener\">Currying（柯里化）</a> 是函数式编程的另一个核心概念。从技术角度讲，一个柯里化了的函数是一系列高阶一元函数，这也是我刚刚抱怨过的。在纯函数式语言中，柯里化函数在调用时，语法上看起来和调用多个参数没有什么区别。</p>\n<p>但由于 Ramda 是一个 JavaScript 库，而 JavaScript 并没有很好的语法来支持一系列一元函数的调用，所以作者对传统柯里化的定义放宽了一些。</p>\n<p>在 Ramda 中，一个柯里化的函数只能用其参数的子集来调用，它会返回一个接受其余参数的新函数。当使用它的所有参数调用，真正的原函数将被调用。</p>\n<p>柯里化的函数在下列两种情况下工作的都很好：</p>\n<ol>\n<li>可以按正常情况下使用所有参数调用它，它可以像普通函数一样正常工作；</li>\n<li>也可以使用部分参数来调用它，这时它会像使用 <code>partial</code> 一样工作。</li>\n</ol>\n<p>注意，这种灵活性带来了一些性能上的损失，因为 <code>curry</code> 需要搞清楚函数的调用方式，然后确定该做什么。一般来说，我只有需要在多个地方对同一个函数使用 <code>partial</code> 的时候，才会对函数进行柯里化。</p>\n<p>接下来写一个柯里化版本的 <code>publishedInYear</code> 函数。注意，<code>curry</code> 会像 <code>partial</code> 一样工作；并且没有 <code>partialRight</code> 版本的 <code>curry</code> 函数。对这方面后续会有更多讨论，但现在我们需要将 <code>publishedInYear</code> 的参数翻转一下，以便让参数 <code>year</code> 在最前面。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在可以只使用参数 <code>year</code> 来调用 <code>publishedInYear</code>，并返回一个新函数，该函数接受参数 <code>book</code> 并执行原函数。但是，仍然可以按普通方式对它调用：<code>publishedInYear(2012, book)</code>，不需要写烦人的语法 <code>)(</code>。所以，柯里化的函数在两种情况下都能很好地工作。</p>\n<h2>参数的顺序</h2>\n<p>注意，为了让 <code>curry</code> 工作，我们不得不对参数的顺序进行翻转。这在函数式编程中非常常见，所以几乎所有的 Ramda 函数都将待处理的数据放到参数列表的最后面。</p>\n<p>你可以将先期传入的参数看作对操作的配置。所以，对于 <code>publishedInYear</code>，参数 <code>year</code> 作为配置（需要查找的年份），而参数 <code>book</code> 作为被处理的数据（被查找的对象）。</p>\n<p>我们已经在集合迭代函数中见过这样的例子。它们都将集合作为最后一个参数，这样可以使这种风格的编程更容易些。</p>\n<h2>顺序错误的参数</h2>\n<p>如果不改变 <code>publishedInYear</code> 的顺序，还可以继续使用柯里化特性的优势吗？</p>\n<p>当然可以了，Ramda 提供了几个选择。</p>\n<h2>flip</h2>\n<p>第一个选择是 <code>flip</code>。<code>flip</code> 接受一个多元函数（元数 &gt;= 2），返回一个元数相同的新函数，但前 2 个参数的顺序调换了。它主要用于二元函数，但也可以用于一般函数。</p>\n<p>使用 <code>flip</code>，我们可以恢复 <code>publishedInYear</code> 参数的初始的顺序：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(flip(publishedInYear)(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多数情况下，我更喜欢使用方便的参数顺序，但如果用到不能自己掌控的函数，<code>flip</code> 是一个好的选择。</p>\n<h2>placeholder (占位符)</h2>\n<p>更通用的选择是使用 &quot;placeholder&quot; 参数（<code>__</code>）</p>\n<p>假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 &quot;占位符&quot; 作为中间参数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> threeArgs = curry(<span class=\"function\">(<span class=\"params\">a, b, c</span>) =&gt;</span> &#123; <span class=\"comment\">/* ... */</span> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> middleArgumentLater = threeArgs(<span class=\"string\">'value for a'</span>, __, <span class=\"string\">'value for c'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可以在函数调用中多次使用 &quot;占位符&quot;。例如，如果只想传递中间参数呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> threeArgs = curry(<span class=\"function\">(<span class=\"params\">a, b, c</span>) =&gt;</span> &#123; <span class=\"comment\">/* ... */</span> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> middleArgumentOnly = threeArgs(__, <span class=\"string\">'value for b'</span>, __)</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 &quot;占位符&quot; 代替 <code>flip</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(__, year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我觉得这个版本的可读性更好，但如果需要频繁使用参数顺序翻转的 <code>publishedInYear</code>，我可能会使用 <code>flip</code> 定义一个辅助函数，然后在任何用到它的地方使用辅助函数。在后续文章中会看到一些示例。</p>\n<p>注意， <code>__</code> 仅适用于柯里化的函数，而 <code>partial</code>、<code>partialRight</code> 和 <code>flip</code> 适用于任何函数。如果需要对某个普通函数使用 <code>__</code>，可以先用 <code>curry</code> 将其包裹起来。</p>\n<h2>来做一条管道（pipeline）</h2>\n<p>现在看看能否将我们的 <code>filter</code> 和 <code>map</code> 调用放入 &quot;pipeline&quot; (管道)中？下面是代码当前的状态，使用了方便的参数顺序的 <code>publishedInYear</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上一节中，我们了解了 <code>pipe</code> 和 <code>compose</code>，但我们还需要另一部分信息，以便能够使用上面所学的知识。</p>\n<p>缺少的信息是：几乎所有的 Ramda 函数都是默认柯里化的，包括 <code>filter</code> 和 <code>map</code>。所以 <code>filter(publishedInYear(year))</code> 是完全合法的，它会返回一个新函数，该函数等待我们传递 <code>books</code> 给它，<code>map(book =&gt; book.title)</code> 也是如此。</p>\n<p>现在可以编写 &quot;pipeline&quot; 了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )(books)</span><br></pre></td></tr></table></figure></p>\n<p>我们来更进一步，将 <code>titlesForYear</code> 的参数顺序也调换一下，这样更符合 Ramda 中待处理数据放在最后的约定。也可以将该函数进行柯里化，以便其在后续的 &quot;pipeline&quot; 中使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = curry(<span class=\"function\">(<span class=\"params\">year, books</span>) =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )(books)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2>结论</h2>\n<p>本文可能是这个系列中讲解最深的一篇。部分应用和柯里化可能需要花一些时间和精力来熟悉和掌握。但一旦学会，他们会以一种强大的方式将数据处理变得更加函数式。</p>\n<p>它们引导你通过创建包含许多小而简单代码块的 &quot;pipeline&quot; 的方式，来构建数据处理程序。</p>\n<h2>下一节</h2>\n<p>为了以函数式的方式编写代码，我们需要用 &quot;声明式&quot; 的思维代替 &quot;命令式&quot; 思维。要做到这点，需要找到一种函数式的方式来表示命令式的结构。<a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">声明式编程</a> 将会讨论这些想法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/07/thinking-in-ramda-partial-application/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Partial Application</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第三篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a>中，讨论了各种函数组合的方式。最后，演示了 <code>compose</code> 和 <code>pipe</code>， 可以以 &quot;pipeline&quot; （管道）的形式对一系列函数进行调用。</p>\n<p>在上篇文章中，简单的函数链式调用（&quot;pipeline&quot;）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？</p>\n<p>例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。可以使用 Ramda 的集合迭代函数完成该需求：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> publishedInYear(book, year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果能将 <code>filter</code> 和 <code>map</code> 组合成 &quot;pipeline&quot; 就好了，但我们并不知道该如何处理，因为 <code>filter</code> 和 <code>map</code> 都是二元函数。</p>\n<p>如果不需要在 <code>filter</code> 中使用箭头函数会更好些。先来解决这个问题，并借此展示一些制作 &quot;pipeline&quot; 的知识。</p>\n<h2>高阶函数</h2>\n<p>在本系列文章的<a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">第一篇</a>中，我们将函数视为 &quot;一等结构&quot;。一等函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。我们一直在使用前者，但还没有见过后者（函数作为其他函数的返回值）。</p>\n<p>获取或返回其他函数的函数称为 &quot;高阶函数&quot;。</p>\n<p>在上面的示例中，我们传递了一个箭头函数给 <code>filter</code>：<code>book =&gt; publishedInYear(book, year)</code>，但我们想去掉箭头函数。为了做到这点，需要一个函数：输入一本书，若该书是在指定年份出版的则返回 <code>true</code>。但还需要一个指定的年份，让该操作更加灵活。</p>\n<p>为了解决这个问题，可以将 <code>publishedInYear</code> 变为返回另一个函数的函数。我将使用普通的语法来实现该函数，以便能够清晰地展示其内部具体实现，然后使用箭头函数实现一个更短版本的函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Full function version:</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">publishedInYear</span>(<span class=\"params\">year</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">book</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> book.year === year</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// Arrow function version:</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\"><span class=\"params\">year</span> =&gt;</span> <span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.year === year</span><br></pre></td></tr></table></figure></p>\n<p>利用新实现的 <code>publishedInYear</code>，可以重写 <code>filter</code> 调用，从而消除箭头函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\"><span class=\"params\">year</span> =&gt;</span> <span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.year === year</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在，当调用 <code>filter</code> 时，<code>publishedInYear(year)</code> 会立即调用，并返回一个接受 <code>book</code> 为参数的函数，这正是 <code>filter</code> 需要的。</p>\n<h2>部分应用函数</h2>\n<p>可以按上面的方式重写任何多参数函数。但我们不可能拥有所有我们想要的函数的源码；另外，很多情况下，我们可能还是希望以普通的方式调用多参数函数。</p>\n<p>例如，在其他一些代码中，只是想检查一本书是否是在指定年份出版的，我们可能想要 <code>publishedInYear(book, 2012)</code>，但现在不能再那么做了。相反，我们必须要用这种方式：<code>publishedInYear(book)(2012)</code>。这样做降低了代码的可读性，也很烦人。</p>\n<p>幸运的是，Ramda 提供了两个函数：<code>partial</code> 和 <code>partialRight</code>，来帮我们解决这个问题。</p>\n<p>这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。</p>\n<p><code>partial</code> 和 <code>partialRight</code> 的区别在于参数传递的顺序：<code>partial</code> 先传递原函数左侧的参数，而 <code>partialRight</code> 先传递右侧的参数。</p>\n<p>回到刚开始的例子，使用上面的一个函数来代替原来对 <code>publishedInYear</code> 的重写。由于刚开始我们只需要最右侧的参数：<code>year</code>，所以需要使用 <code>partialRight</code>.</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = <span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(partialRight(publishedInYear, [year]), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果 <code>pubilshedInYear</code> 原本参数的顺序为 <code>(year, book)</code> ，而非 <code>(book, year)</code> ，则需要用 <code>partial</code> 代替 <code>partialRight</code>。</p>\n<p>注意，为被 <code>partial</code> 和 <code>partialRight</code> 包裹的函数提供的参数必须包裹在数组中，即使只有一个参数。我不会告诉你我已经忘记了多少次，导致出现令人困惑的错误信息：</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">First argument to _arity must be a non-negative <span class=\"built_in\">integer</span> no greater than ten</span><br></pre></td></tr></table></figure></p>\n<h2>柯里化(Curry)</h2>\n<p>如果到处使用 <code>partial</code> 和 <code>partialRight</code> 的话，会让代码变得冗长乏味；但是，将多元函数以一系列一元函数的形式调用同样不好。</p>\n<p>幸运的是，Ramda 给我们提供了一个解决方案：<code>curry</code>。</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Currying\" target=\"_blank\" rel=\"noopener\">Currying（柯里化）</a> 是函数式编程的另一个核心概念。从技术角度讲，一个柯里化了的函数是一系列高阶一元函数，这也是我刚刚抱怨过的。在纯函数式语言中，柯里化函数在调用时，语法上看起来和调用多个参数没有什么区别。</p>\n<p>但由于 Ramda 是一个 JavaScript 库，而 JavaScript 并没有很好的语法来支持一系列一元函数的调用，所以作者对传统柯里化的定义放宽了一些。</p>\n<p>在 Ramda 中，一个柯里化的函数只能用其参数的子集来调用，它会返回一个接受其余参数的新函数。当使用它的所有参数调用，真正的原函数将被调用。</p>\n<p>柯里化的函数在下列两种情况下工作的都很好：</p>\n<ol>\n<li>可以按正常情况下使用所有参数调用它，它可以像普通函数一样正常工作；</li>\n<li>也可以使用部分参数来调用它，这时它会像使用 <code>partial</code> 一样工作。</li>\n</ol>\n<p>注意，这种灵活性带来了一些性能上的损失，因为 <code>curry</code> 需要搞清楚函数的调用方式，然后确定该做什么。一般来说，我只有需要在多个地方对同一个函数使用 <code>partial</code> 的时候，才会对函数进行柯里化。</p>\n<p>接下来写一个柯里化版本的 <code>publishedInYear</code> 函数。注意，<code>curry</code> 会像 <code>partial</code> 一样工作；并且没有 <code>partialRight</code> 版本的 <code>curry</code> 函数。对这方面后续会有更多讨论，但现在我们需要将 <code>publishedInYear</code> 的参数翻转一下，以便让参数 <code>year</code> 在最前面。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在可以只使用参数 <code>year</code> 来调用 <code>publishedInYear</code>，并返回一个新函数，该函数接受参数 <code>book</code> 并执行原函数。但是，仍然可以按普通方式对它调用：<code>publishedInYear(2012, book)</code>，不需要写烦人的语法 <code>)(</code>。所以，柯里化的函数在两种情况下都能很好地工作。</p>\n<h2>参数的顺序</h2>\n<p>注意，为了让 <code>curry</code> 工作，我们不得不对参数的顺序进行翻转。这在函数式编程中非常常见，所以几乎所有的 Ramda 函数都将待处理的数据放到参数列表的最后面。</p>\n<p>你可以将先期传入的参数看作对操作的配置。所以，对于 <code>publishedInYear</code>，参数 <code>year</code> 作为配置（需要查找的年份），而参数 <code>book</code> 作为被处理的数据（被查找的对象）。</p>\n<p>我们已经在集合迭代函数中见过这样的例子。它们都将集合作为最后一个参数，这样可以使这种风格的编程更容易些。</p>\n<h2>顺序错误的参数</h2>\n<p>如果不改变 <code>publishedInYear</code> 的顺序，还可以继续使用柯里化特性的优势吗？</p>\n<p>当然可以了，Ramda 提供了几个选择。</p>\n<h2>flip</h2>\n<p>第一个选择是 <code>flip</code>。<code>flip</code> 接受一个多元函数（元数 &gt;= 2），返回一个元数相同的新函数，但前 2 个参数的顺序调换了。它主要用于二元函数，但也可以用于一般函数。</p>\n<p>使用 <code>flip</code>，我们可以恢复 <code>publishedInYear</code> 参数的初始的顺序：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(flip(publishedInYear)(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>多数情况下，我更喜欢使用方便的参数顺序，但如果用到不能自己掌控的函数，<code>flip</code> 是一个好的选择。</p>\n<h2>placeholder (占位符)</h2>\n<p>更通用的选择是使用 &quot;placeholder&quot; 参数（<code>__</code>）</p>\n<p>假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 &quot;占位符&quot; 作为中间参数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> threeArgs = curry(<span class=\"function\">(<span class=\"params\">a, b, c</span>) =&gt;</span> &#123; <span class=\"comment\">/* ... */</span> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> middleArgumentLater = threeArgs(<span class=\"string\">'value for a'</span>, __, <span class=\"string\">'value for c'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可以在函数调用中多次使用 &quot;占位符&quot;。例如，如果只想传递中间参数呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> threeArgs = curry(<span class=\"function\">(<span class=\"params\">a, b, c</span>) =&gt;</span> &#123; <span class=\"comment\">/* ... */</span> &#125;)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> middleArgumentOnly = threeArgs(__, <span class=\"string\">'value for b'</span>, __)</span><br></pre></td></tr></table></figure></p>\n<p>也可以使用 &quot;占位符&quot; 代替 <code>flip</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">book, year</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(__, year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我觉得这个版本的可读性更好，但如果需要频繁使用参数顺序翻转的 <code>publishedInYear</code>，我可能会使用 <code>flip</code> 定义一个辅助函数，然后在任何用到它的地方使用辅助函数。在后续文章中会看到一些示例。</p>\n<p>注意， <code>__</code> 仅适用于柯里化的函数，而 <code>partial</code>、<code>partialRight</code> 和 <code>flip</code> 适用于任何函数。如果需要对某个普通函数使用 <code>__</code>，可以先用 <code>curry</code> 将其包裹起来。</p>\n<h2>来做一条管道（pipeline）</h2>\n<p>现在看看能否将我们的 <code>filter</code> 和 <code>map</code> 调用放入 &quot;pipeline&quot; (管道)中？下面是代码当前的状态，使用了方便的参数顺序的 <code>publishedInYear</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> selected = filter(publishedInYear(year), books)</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">return</span> map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title, selected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>在上一节中，我们了解了 <code>pipe</code> 和 <code>compose</code>，但我们还需要另一部分信息，以便能够使用上面所学的知识。</p>\n<p>缺少的信息是：几乎所有的 Ramda 函数都是默认柯里化的，包括 <code>filter</code> 和 <code>map</code>。所以 <code>filter(publishedInYear(year))</code> 是完全合法的，它会返回一个新函数，该函数等待我们传递 <code>books</code> 给它，<code>map(book =&gt; book.title)</code> 也是如此。</p>\n<p>现在可以编写 &quot;pipeline&quot; 了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\">(<span class=\"params\">books, year</span>) =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )(books)</span><br></pre></td></tr></table></figure></p>\n<p>我们来更进一步，将 <code>titlesForYear</code> 的参数顺序也调换一下，这样更符合 Ramda 中待处理数据放在最后的约定。也可以将该函数进行柯里化，以便其在后续的 &quot;pipeline&quot; 中使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> publishedInYear = curry(<span class=\"function\">(<span class=\"params\">year, book</span>) =&gt;</span> book.year === year)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = curry(<span class=\"function\">(<span class=\"params\">year, books</span>) =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )(books)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<h2>结论</h2>\n<p>本文可能是这个系列中讲解最深的一篇。部分应用和柯里化可能需要花一些时间和精力来熟悉和掌握。但一旦学会，他们会以一种强大的方式将数据处理变得更加函数式。</p>\n<p>它们引导你通过创建包含许多小而简单代码块的 &quot;pipeline&quot; 的方式，来构建数据处理程序。</p>\n<h2>下一节</h2>\n<p>为了以函数式的方式编写代码，我们需要用 &quot;声明式&quot; 的思维代替 &quot;命令式&quot; 思维。要做到这点，需要找到一种函数式的方式来表示命令式的结构。<a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">声明式编程</a> 将会讨论这些想法。</p>\n"},{"title":"Thinking in Ramda: 透镜（Lenses）","date":"2017-06-17T23:27:42.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Lenses](http://randycoulman.com/blog/2016/07/12/thinking-in-ramda-lenses/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第八篇。\n\n在 [第六节](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/)  和 [第七节](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/) 中，我们学习了如何以声明式和不变式来读取、更新和转换对象的属性和数组的元素。\n\nRamda 提供了一个更通用的工具：透镜（lens），来进行这些操作。\n\n## 什么是透镜？\n\n透镜将 \"getter\" 和 \"setter\" 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。\n\n可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。\n\n## 如何创建透镜\n\n在 Ramda 中，最常见的创建透镜的方法是 `lens` 函数。`lens` 接受一个 \"getter\" 函数和一个 \"setter\" 函数，然后返回一个新透镜。\n\n```js\nconst person = {\n  name: 'Randy',\n  socialMedia: {\n    github: 'randycoulman',\n    twitter: '@randycoulman'\n  }\n}\n \nconst nameLens = lens(prop('name'), assoc('name'))\nconst twitterLens = lens(\n  path(['socialMedia', 'twitter']),\n  assocPath(['socialMedia', 'twitter'])\n)\n```\n\n这里使用 `prop` 和 `path` 作为 \"getter\" 方法；`assoc` 和 `assocPath` 作为 \"setter\" 方法。\n\n注意，上面实现不得不重复传递属性和路径参数给 \"getter\" 和 \"setter\" 方法。幸运的是，Ramda 为最常见类型的透镜提供了便捷方法：`lensProp`、`lensPath` 和 `lensIndex`。\n\n* `LensProp`：创建关注对象某一属性的透镜。\n* `lensPath`: 创建关注对象某一嵌套属性的透镜。\n* `lensIndex`: 创建关注数组某一索引的透镜。\n\n可以用 `lensProp` 和 `lensPath` 来重写上述示例：\n\n```js\nconst nameLens = lensProp('name')\nconst twitterLens = lensPath(['socialMedia', 'twitter'])\n```\n\n这样便摆脱了向 \"getter\" 和 \"setter\" 重复输入两次相同参数的烦扰，变得简洁多了。在实际工作中，我发现我几乎从来不需要使用通用的 `lens` 函数。\n\n## 我能用它做什么呢？\n\n我们创建了一些透镜，可以用它们做些什么呢？\n\nRamda 提供了三个配合透镜一起使用的的函数：\n\n* `view`：读取透镜的值。\n* `set`：更新透镜的值。\n* `over`：将变换函数作用于透镜。\n\n```js\nview(nameLens, person) // => 'Randy'\n \nset(twitterLens, '@randy', person)\n// => {\n//   name: 'Randy',\n//   socialMedia: {\n//     github: 'randycoulman',\n//     twitter: '@randy'\n//   }\n// }\n \nover(nameLens, toUpper, person)\n// => {\n//   name: 'RANDY',\n//   socialMedia: {\n//     github: 'randycoulman',\n//     twitter: '@randycoulman'\n//   }\n// }\n```\n\n注意，`set` 和 `over` 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。\n\n## 结论\n\n如果想从复杂数据结构的操作中抽象出简单、通用的方法，透镜可以提供很多帮助。我们只需暴露透镜；而不需要暴露整个数据结构、或者为每个可访问属性都提供 \"setter\"、\"getter\" 和 变换方法。\n\n## 下一节\n\n我们现在已经了解了许多 Ramda 提供的方法，已经足以应对大部分编程需要。[总结](https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Wrap-Up/) 将回顾整个系列的内容，并会提到一些可能需要自己进一步探索的其他主题。\n","source":"_posts/Thinking-in-Ramda-Lenses.md","raw":"---\ntitle: 'Thinking in Ramda: 透镜（Lenses）'\ndate: 2017-06-18 07:27:42\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Lenses](http://randycoulman.com/blog/2016/07/12/thinking-in-ramda-lenses/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第八篇。\n\n在 [第六节](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/)  和 [第七节](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/) 中，我们学习了如何以声明式和不变式来读取、更新和转换对象的属性和数组的元素。\n\nRamda 提供了一个更通用的工具：透镜（lens），来进行这些操作。\n\n## 什么是透镜？\n\n透镜将 \"getter\" 和 \"setter\" 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。\n\n可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。\n\n## 如何创建透镜\n\n在 Ramda 中，最常见的创建透镜的方法是 `lens` 函数。`lens` 接受一个 \"getter\" 函数和一个 \"setter\" 函数，然后返回一个新透镜。\n\n```js\nconst person = {\n  name: 'Randy',\n  socialMedia: {\n    github: 'randycoulman',\n    twitter: '@randycoulman'\n  }\n}\n \nconst nameLens = lens(prop('name'), assoc('name'))\nconst twitterLens = lens(\n  path(['socialMedia', 'twitter']),\n  assocPath(['socialMedia', 'twitter'])\n)\n```\n\n这里使用 `prop` 和 `path` 作为 \"getter\" 方法；`assoc` 和 `assocPath` 作为 \"setter\" 方法。\n\n注意，上面实现不得不重复传递属性和路径参数给 \"getter\" 和 \"setter\" 方法。幸运的是，Ramda 为最常见类型的透镜提供了便捷方法：`lensProp`、`lensPath` 和 `lensIndex`。\n\n* `LensProp`：创建关注对象某一属性的透镜。\n* `lensPath`: 创建关注对象某一嵌套属性的透镜。\n* `lensIndex`: 创建关注数组某一索引的透镜。\n\n可以用 `lensProp` 和 `lensPath` 来重写上述示例：\n\n```js\nconst nameLens = lensProp('name')\nconst twitterLens = lensPath(['socialMedia', 'twitter'])\n```\n\n这样便摆脱了向 \"getter\" 和 \"setter\" 重复输入两次相同参数的烦扰，变得简洁多了。在实际工作中，我发现我几乎从来不需要使用通用的 `lens` 函数。\n\n## 我能用它做什么呢？\n\n我们创建了一些透镜，可以用它们做些什么呢？\n\nRamda 提供了三个配合透镜一起使用的的函数：\n\n* `view`：读取透镜的值。\n* `set`：更新透镜的值。\n* `over`：将变换函数作用于透镜。\n\n```js\nview(nameLens, person) // => 'Randy'\n \nset(twitterLens, '@randy', person)\n// => {\n//   name: 'Randy',\n//   socialMedia: {\n//     github: 'randycoulman',\n//     twitter: '@randy'\n//   }\n// }\n \nover(nameLens, toUpper, person)\n// => {\n//   name: 'RANDY',\n//   socialMedia: {\n//     github: 'randycoulman',\n//     twitter: '@randycoulman'\n//   }\n// }\n```\n\n注意，`set` 和 `over` 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。\n\n## 结论\n\n如果想从复杂数据结构的操作中抽象出简单、通用的方法，透镜可以提供很多帮助。我们只需暴露透镜；而不需要暴露整个数据结构、或者为每个可访问属性都提供 \"setter\"、\"getter\" 和 变换方法。\n\n## 下一节\n\n我们现在已经了解了许多 Ramda 提供的方法，已经足以应对大部分编程需要。[总结](https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Wrap-Up/) 将回顾整个系列的内容，并会提到一些可能需要自己进一步探索的其他主题。\n","slug":"Thinking-in-Ramda-Lenses","published":1,"updated":"2020-06-06T14:44:04.091Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu00012f6mjbylhfco6","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/07/12/thinking-in-ramda-lenses/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Lenses</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第八篇。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">第六节</a>  和 <a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">第七节</a> 中，我们学习了如何以声明式和不变式来读取、更新和转换对象的属性和数组的元素。</p>\n<p>Ramda 提供了一个更通用的工具：透镜（lens），来进行这些操作。</p>\n<h2>什么是透镜？</h2>\n<p>透镜将 &quot;getter&quot; 和 &quot;setter&quot; 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。</p>\n<p>可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。</p>\n<h2>如何创建透镜</h2>\n<p>在 Ramda 中，最常见的创建透镜的方法是 <code>lens</code> 函数。<code>lens</code> 接受一个 &quot;getter&quot; 函数和一个 &quot;setter&quot; 函数，然后返回一个新透镜。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Randy'</span>,</span><br><span class=\"line\">  socialMedia: &#123;</span><br><span class=\"line\">    github: <span class=\"string\">'randycoulman'</span>,</span><br><span class=\"line\">    twitter: <span class=\"string\">'@randycoulman'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> nameLens = lens(prop(<span class=\"string\">'name'</span>), assoc(<span class=\"string\">'name'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> twitterLens = lens(</span><br><span class=\"line\">  path([<span class=\"string\">'socialMedia'</span>, <span class=\"string\">'twitter'</span>]),</span><br><span class=\"line\">  assocPath([<span class=\"string\">'socialMedia'</span>, <span class=\"string\">'twitter'</span>])</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>这里使用 <code>prop</code> 和 <code>path</code> 作为 &quot;getter&quot; 方法；<code>assoc</code> 和 <code>assocPath</code> 作为 &quot;setter&quot; 方法。</p>\n<p>注意，上面实现不得不重复传递属性和路径参数给 &quot;getter&quot; 和 &quot;setter&quot; 方法。幸运的是，Ramda 为最常见类型的透镜提供了便捷方法：<code>lensProp</code>、<code>lensPath</code> 和 <code>lensIndex</code>。</p>\n<ul>\n<li><code>LensProp</code>：创建关注对象某一属性的透镜。</li>\n<li><code>lensPath</code>: 创建关注对象某一嵌套属性的透镜。</li>\n<li><code>lensIndex</code>: 创建关注数组某一索引的透镜。</li>\n</ul>\n<p>可以用 <code>lensProp</code> 和 <code>lensPath</code> 来重写上述示例：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nameLens = lensProp(<span class=\"string\">'name'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> twitterLens = lensPath([<span class=\"string\">'socialMedia'</span>, <span class=\"string\">'twitter'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>这样便摆脱了向 &quot;getter&quot; 和 &quot;setter&quot; 重复输入两次相同参数的烦扰，变得简洁多了。在实际工作中，我发现我几乎从来不需要使用通用的 <code>lens</code> 函数。</p>\n<h2>我能用它做什么呢？</h2>\n<p>我们创建了一些透镜，可以用它们做些什么呢？</p>\n<p>Ramda 提供了三个配合透镜一起使用的的函数：</p>\n<ul>\n<li><code>view</code>：读取透镜的值。</li>\n<li><code>set</code>：更新透镜的值。</li>\n<li><code>over</code>：将变换函数作用于透镜。</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view(nameLens, person) <span class=\"comment\">// =&gt; 'Randy'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">set</span>(twitterLens, '@randy', person)</span><br><span class=\"line\">// =&gt; &#123;</span><br><span class=\"line\"><span class=\"comment\">//   name: 'Randy',</span></span><br><span class=\"line\"><span class=\"comment\">//   socialMedia: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     github: 'randycoulman',</span></span><br><span class=\"line\"><span class=\"comment\">//     twitter: '@randy'</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">over(nameLens, toUpper, person)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: 'RANDY',</span></span><br><span class=\"line\"><span class=\"comment\">//   socialMedia: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     github: 'randycoulman',</span></span><br><span class=\"line\"><span class=\"comment\">//     twitter: '@randycoulman'</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>set</code> 和 <code>over</code> 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。</p>\n<h2>结论</h2>\n<p>如果想从复杂数据结构的操作中抽象出简单、通用的方法，透镜可以提供很多帮助。我们只需暴露透镜；而不需要暴露整个数据结构、或者为每个可访问属性都提供 &quot;setter&quot;、&quot;getter&quot; 和 变换方法。</p>\n<h2>下一节</h2>\n<p>我们现在已经了解了许多 Ramda 提供的方法，已经足以应对大部分编程需要。<a href=\"https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Wrap-Up/\" target=\"_blank\" rel=\"noopener\">总结</a> 将回顾整个系列的内容，并会提到一些可能需要自己进一步探索的其他主题。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/07/12/thinking-in-ramda-lenses/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Lenses</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第八篇。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">第六节</a>  和 <a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">第七节</a> 中，我们学习了如何以声明式和不变式来读取、更新和转换对象的属性和数组的元素。</p>\n<p>Ramda 提供了一个更通用的工具：透镜（lens），来进行这些操作。</p>\n<h2>什么是透镜？</h2>\n<p>透镜将 &quot;getter&quot; 和 &quot;setter&quot; 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。</p>\n<p>可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。</p>\n<h2>如何创建透镜</h2>\n<p>在 Ramda 中，最常见的创建透镜的方法是 <code>lens</code> 函数。<code>lens</code> 接受一个 &quot;getter&quot; 函数和一个 &quot;setter&quot; 函数，然后返回一个新透镜。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = &#123;</span><br><span class=\"line\">  name: <span class=\"string\">'Randy'</span>,</span><br><span class=\"line\">  socialMedia: &#123;</span><br><span class=\"line\">    github: <span class=\"string\">'randycoulman'</span>,</span><br><span class=\"line\">    twitter: <span class=\"string\">'@randycoulman'</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> nameLens = lens(prop(<span class=\"string\">'name'</span>), assoc(<span class=\"string\">'name'</span>))</span><br><span class=\"line\"><span class=\"keyword\">const</span> twitterLens = lens(</span><br><span class=\"line\">  path([<span class=\"string\">'socialMedia'</span>, <span class=\"string\">'twitter'</span>]),</span><br><span class=\"line\">  assocPath([<span class=\"string\">'socialMedia'</span>, <span class=\"string\">'twitter'</span>])</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>这里使用 <code>prop</code> 和 <code>path</code> 作为 &quot;getter&quot; 方法；<code>assoc</code> 和 <code>assocPath</code> 作为 &quot;setter&quot; 方法。</p>\n<p>注意，上面实现不得不重复传递属性和路径参数给 &quot;getter&quot; 和 &quot;setter&quot; 方法。幸运的是，Ramda 为最常见类型的透镜提供了便捷方法：<code>lensProp</code>、<code>lensPath</code> 和 <code>lensIndex</code>。</p>\n<ul>\n<li><code>LensProp</code>：创建关注对象某一属性的透镜。</li>\n<li><code>lensPath</code>: 创建关注对象某一嵌套属性的透镜。</li>\n<li><code>lensIndex</code>: 创建关注数组某一索引的透镜。</li>\n</ul>\n<p>可以用 <code>lensProp</code> 和 <code>lensPath</code> 来重写上述示例：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> nameLens = lensProp(<span class=\"string\">'name'</span>)</span><br><span class=\"line\"><span class=\"keyword\">const</span> twitterLens = lensPath([<span class=\"string\">'socialMedia'</span>, <span class=\"string\">'twitter'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>这样便摆脱了向 &quot;getter&quot; 和 &quot;setter&quot; 重复输入两次相同参数的烦扰，变得简洁多了。在实际工作中，我发现我几乎从来不需要使用通用的 <code>lens</code> 函数。</p>\n<h2>我能用它做什么呢？</h2>\n<p>我们创建了一些透镜，可以用它们做些什么呢？</p>\n<p>Ramda 提供了三个配合透镜一起使用的的函数：</p>\n<ul>\n<li><code>view</code>：读取透镜的值。</li>\n<li><code>set</code>：更新透镜的值。</li>\n<li><code>over</code>：将变换函数作用于透镜。</li>\n</ul>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">view(nameLens, person) <span class=\"comment\">// =&gt; 'Randy'</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">set</span>(twitterLens, '@randy', person)</span><br><span class=\"line\">// =&gt; &#123;</span><br><span class=\"line\"><span class=\"comment\">//   name: 'Randy',</span></span><br><span class=\"line\"><span class=\"comment\">//   socialMedia: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     github: 'randycoulman',</span></span><br><span class=\"line\"><span class=\"comment\">//     twitter: '@randy'</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"> </span><br><span class=\"line\">over(nameLens, toUpper, person)</span><br><span class=\"line\"><span class=\"comment\">// =&gt; &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   name: 'RANDY',</span></span><br><span class=\"line\"><span class=\"comment\">//   socialMedia: &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//     github: 'randycoulman',</span></span><br><span class=\"line\"><span class=\"comment\">//     twitter: '@randycoulman'</span></span><br><span class=\"line\"><span class=\"comment\">//   &#125;</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>set</code> 和 <code>over</code> 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。</p>\n<h2>结论</h2>\n<p>如果想从复杂数据结构的操作中抽象出简单、通用的方法，透镜可以提供很多帮助。我们只需暴露透镜；而不需要暴露整个数据结构、或者为每个可访问属性都提供 &quot;setter&quot;、&quot;getter&quot; 和 变换方法。</p>\n<h2>下一节</h2>\n<p>我们现在已经了解了许多 Ramda 提供的方法，已经足以应对大部分编程需要。<a href=\"https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Wrap-Up/\" target=\"_blank\" rel=\"noopener\">总结</a> 将回顾整个系列的内容，并会提到一些可能需要自己进一步探索的其他主题。</p>\n"},{"title":"Thinking in Ramda: 无参数风格编程 (Pointfree Style)","date":"2017-06-13T13:27:05.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Pointfree Style](http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第五篇。\n\n在[第四节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/)中，我们讨论了如何用声明式编程（告诉计算机做什么，我们想要什么）代替命令式编程（告诉计算机该怎么做，详细的执行步骤）来编写代码。\n\n你可能已经注意到了，我们编写的几个函数（如 `forever21`、`alwaysDrivingAge`、`water`）都接受一个参数，构建一个新函数，然后将该函数作用于该参数。\n\n这是函数式编程里非常常见的一种模式，Ramda 同样提供了优化这种模式的方法。\n\n## Pointfree 风格（无参数风格）\n\n我们在 [第三节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/) 中讨论了 Ramda 的两个指导原则：\n\n* 将数据放到参数列表的最后面。\n* 柯里化所有的东西。\n\n这两个原则衍生出了一种被函数式程序员称为 \"pointfree\" 的风格。我喜欢将 pointfree 的代码看作：\"数据？什么数据？这里没有数据！\"\n\n有一篇很好的博客：[Why Ramda?](http://fr.umio.us/why-ramda/)，展示了 pointfree 风格 真得不错。具体来说，它有一些有趣的标题，例如：\"数据在哪里？\"，\"好了，已经有了！\"，\"那么我可以看看数据吗？\" 和 \"拜托，我只是想要我的数据\"。\n\n我们还没有使用需要的工具来让所有的例子都变成完全 \"pointfree\" 的，现在就开始吧。\n\n再看一下 `forever21`：\n\n```js\nconst forever21 = age => ifElse(gte(__, 21), always(21), inc)(age)\n```\n\n注意，参数 `age` 出现了两次：一次在参数列表中；一次在函数的最后面：我们将由 `ifElse` 返回的新函数作用于 `age`。\n\n在使用 Ramda 编程时稍加留意，就会发现很多这种模式的代码。这也意味着，总应该有一种方法将这些函数转成 \"pointfree\" 风格。\n\n我们来看看这会是什么样子：\n\n```js\nconst forever21 = ifElse(gte(__, 21), always(21), inc)\n```\n\n嘭~~！我们刚刚让 `age` 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 `age` 参数。\n\n可以对 `alwaysDrivingAge` 和 `water` 进行相同的处理。\n\n原来的 `alwaysDrivingAge` 如下所示：\n\n```js\nconst alwaysDrivingAge = age => ifElse(lt(__, 16), always(16), identity)(age)\n```\n\n可以使用相同的方法使其变为 pointfree 的。\n\n```js\nconst alwaysDrivingAge = when(lt(__, 16), always(16))\n```\n\n下面是 `water` 原来的形式：\n\n```js\nconst water = temperature => cond([\n  [equals(0),   always('water freezes at 0°C')],\n  [equals(100), always('water boils at 100°C')],\n  [T,           temp => `nothing special happens at ${temp}°C`]\n])(temperature)\n```\n\n现在将其变为 pointfree 风格的：\n\n```js\nconst water = cond([\n  [equals(0),   always('water freezes at 0°C')],\n  [equals(100), always('water boils at 100°C')],\n  [T,           temp => `nothing special happens at ${temp}°C`]\n])\n```\n\n## 多元函数（多参数函数）\n\n如果函数接受多个参数会怎样呢？回顾一下 [第三节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/) 中的例子：`titlesForYear`。\n\n```js\nconst titlesForYear = curry((year, books) =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )(books)\n)\n```\n\n注意，`books` 出现了两次：一次作为参数列表的最后一个参数（最后一个数据！）；一次出现在函数最后，当我们将其传入 pipeline 的时候。这跟我们之前看到参数为 `age` 的模式类似，所以可以对它进行相同的转换：\n\n```js\nconst titlesForYear = year =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )\n```\n\n可以了！我们现在有了一个 pointfree 版本的 `titlesFroYear`。\n\n其实，这种情况下，我可能不会刻意追求 pointfree 风格，因为就像之前文章讨论过的：JavaScript 在调用一系列单参数函数方面并不方便。\n\n在 pipeline 中使用 `titleForYear` 是很方便，如我们可以很轻松的调用 `titlesForYear(2012)`，但当想要单独使用它时，我们就不得不回到之前文章里看到的形式 `)(`，对我而言，并不值得做出这种妥协（没必要为了 pointfree 而 pointfree）。\n\n但只要有如上形式的单参数函数（或者可能以后会被重构），我几乎总是写成 pointfree 风格的。\n\n## 重构为 pointfree 风格的代码\n\n有时我们的代码不会遵循这种模式。我们可能会在同一函数内多次对数据进行操作。\n\n在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 的几个例子中便是这种情形。我们使用诸如 `both`、`either`、`pipe`、`compose` 来重构代码。一旦我们这样做了，便会很容易让函数转换为 pointfree 风格的。\n\n我们来回顾一下 `isEligibleToVote` 这个例子，代码如下：\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = person => wasBornInCountry(person) || wasNaturalized(person)\n \nconst isEligibleToVote = person => isOver18(person) && isCitizen(person)\n```\n\n先从 `isCitizen` 开始。它接受一个 `person`, 然后将两个函数作用于该 `person`，将结果使用 `||` 组合起来。正如在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 中学到的，可以使用 `either` 将两个函数组合成一个新函数，然后将该组合函数作用于该 `person`。\n\n```js\nconst isCitizen = person => either(wasBornInCountry, wasNaturalized)(person)\n```\n\n可以使用 `both` 对 `isEligibleToVote` 做类似的处理。\n\n```js\nconst isEligibleToVote = person => both(isOver18, isCitizen)(person)\n```\n\n现在我们已经完成了这些重构，可以看到，这两个函数都遵循上面提到的模式：`person` 出现了两次，一次作为函数参数；一次放到最后，将组合函数作用其上。现在可以将它们重构为 pointfree 风格的代码：\n\n```js\nconst isCitizen = either(wasBornInCountry, wasNaturalized)\nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\n## 为什么要这么做？\n\nPointfree 风格需要一定的时间才能习惯。可能并不需要所有的地方都没有参数。有时候知道某些 Ramda 函数需要多少参数，也是很重要的。\n\n但是，一旦习惯了这种方式，它将变得非常强大：可以以非常有趣的方式将很多小的 pointfree 函数组合起来。\n\nPointfree 风格的优点是什么呢？人们可能会认为，这只不过是为了让函数式编程赢得 \"优点徽章\" 的学术活动而已（实际上并没有什么用处）。然而，我认为还是有一些优点的，即使需要花一些时间来习惯这种方式也是值得的：\n\n* 它让编程更简单、精练。这并不总是一件好事，但大部分情况下是这样的。\n* 它让算法更清晰。通过只关注正在组合的函数，我们可以在没有参数的干扰下，更好地了解发生了什么。\n* 它促使我们更专注于正在做的转换的本身，而不是正被转换的数据。\n* 它可以帮助我们将函数视为可以作用于不同数据的通用构建模块，而非对特定类型数据的操作。如果给数据一个名字，我们的思想便会被[禁锢](https://en.wikipedia.org/wiki/Anchoring)在：\"需要在哪里使用我们的函数\"；如果去掉参数，便会使我们更有创造力。\n\n## 结论\n\nPointfree 风格也被成为 [tacit 式编程](https://en.wikipedia.org/wiki/Tacit_programming)(隐含式编程)，可以使代码更清晰、更易于理解。通过代码重构将所有的转换组合成单一函数，我们最终会得到可以在更多地方使用的更小的构建块（函数）。\n\n## 下一节\n\n在当前示例中，我们尚未将所有代码都重构为 pointfree 的风格。还有一些代码是命令式的。大部分这种代码是处理对象和数组的。\n\n我们需要找到声明式的方式来处理对象和数组。Immutability (不变性) 怎么样？我们如何以 \"不变\" (immutable) 的方式来操作对象和数组呢？\n\n本系列的下一节，[数据不变性和对象](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/) 将讨论如何以函数式和 immutable 的方式来处理对象。紧随其后的章节：[数据不变性和数组](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/) 对数组也是相同的处理方式。\n","source":"_posts/Thinking-in-Ramda-Pointfree-Style.md","raw":"---\ntitle: 'Thinking in Ramda: 无参数风格编程 (Pointfree Style)'\ndate: 2017-06-13 21:27:05\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Pointfree Style](http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第五篇。\n\n在[第四节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/)中，我们讨论了如何用声明式编程（告诉计算机做什么，我们想要什么）代替命令式编程（告诉计算机该怎么做，详细的执行步骤）来编写代码。\n\n你可能已经注意到了，我们编写的几个函数（如 `forever21`、`alwaysDrivingAge`、`water`）都接受一个参数，构建一个新函数，然后将该函数作用于该参数。\n\n这是函数式编程里非常常见的一种模式，Ramda 同样提供了优化这种模式的方法。\n\n## Pointfree 风格（无参数风格）\n\n我们在 [第三节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/) 中讨论了 Ramda 的两个指导原则：\n\n* 将数据放到参数列表的最后面。\n* 柯里化所有的东西。\n\n这两个原则衍生出了一种被函数式程序员称为 \"pointfree\" 的风格。我喜欢将 pointfree 的代码看作：\"数据？什么数据？这里没有数据！\"\n\n有一篇很好的博客：[Why Ramda?](http://fr.umio.us/why-ramda/)，展示了 pointfree 风格 真得不错。具体来说，它有一些有趣的标题，例如：\"数据在哪里？\"，\"好了，已经有了！\"，\"那么我可以看看数据吗？\" 和 \"拜托，我只是想要我的数据\"。\n\n我们还没有使用需要的工具来让所有的例子都变成完全 \"pointfree\" 的，现在就开始吧。\n\n再看一下 `forever21`：\n\n```js\nconst forever21 = age => ifElse(gte(__, 21), always(21), inc)(age)\n```\n\n注意，参数 `age` 出现了两次：一次在参数列表中；一次在函数的最后面：我们将由 `ifElse` 返回的新函数作用于 `age`。\n\n在使用 Ramda 编程时稍加留意，就会发现很多这种模式的代码。这也意味着，总应该有一种方法将这些函数转成 \"pointfree\" 风格。\n\n我们来看看这会是什么样子：\n\n```js\nconst forever21 = ifElse(gte(__, 21), always(21), inc)\n```\n\n嘭~~！我们刚刚让 `age` 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 `age` 参数。\n\n可以对 `alwaysDrivingAge` 和 `water` 进行相同的处理。\n\n原来的 `alwaysDrivingAge` 如下所示：\n\n```js\nconst alwaysDrivingAge = age => ifElse(lt(__, 16), always(16), identity)(age)\n```\n\n可以使用相同的方法使其变为 pointfree 的。\n\n```js\nconst alwaysDrivingAge = when(lt(__, 16), always(16))\n```\n\n下面是 `water` 原来的形式：\n\n```js\nconst water = temperature => cond([\n  [equals(0),   always('water freezes at 0°C')],\n  [equals(100), always('water boils at 100°C')],\n  [T,           temp => `nothing special happens at ${temp}°C`]\n])(temperature)\n```\n\n现在将其变为 pointfree 风格的：\n\n```js\nconst water = cond([\n  [equals(0),   always('water freezes at 0°C')],\n  [equals(100), always('water boils at 100°C')],\n  [T,           temp => `nothing special happens at ${temp}°C`]\n])\n```\n\n## 多元函数（多参数函数）\n\n如果函数接受多个参数会怎样呢？回顾一下 [第三节](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/) 中的例子：`titlesForYear`。\n\n```js\nconst titlesForYear = curry((year, books) =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )(books)\n)\n```\n\n注意，`books` 出现了两次：一次作为参数列表的最后一个参数（最后一个数据！）；一次出现在函数最后，当我们将其传入 pipeline 的时候。这跟我们之前看到参数为 `age` 的模式类似，所以可以对它进行相同的转换：\n\n```js\nconst titlesForYear = year =>\n  pipe(\n    filter(publishedInYear(year)),\n    map(book => book.title)\n  )\n```\n\n可以了！我们现在有了一个 pointfree 版本的 `titlesFroYear`。\n\n其实，这种情况下，我可能不会刻意追求 pointfree 风格，因为就像之前文章讨论过的：JavaScript 在调用一系列单参数函数方面并不方便。\n\n在 pipeline 中使用 `titleForYear` 是很方便，如我们可以很轻松的调用 `titlesForYear(2012)`，但当想要单独使用它时，我们就不得不回到之前文章里看到的形式 `)(`，对我而言，并不值得做出这种妥协（没必要为了 pointfree 而 pointfree）。\n\n但只要有如上形式的单参数函数（或者可能以后会被重构），我几乎总是写成 pointfree 风格的。\n\n## 重构为 pointfree 风格的代码\n\n有时我们的代码不会遵循这种模式。我们可能会在同一函数内多次对数据进行操作。\n\n在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 的几个例子中便是这种情形。我们使用诸如 `both`、`either`、`pipe`、`compose` 来重构代码。一旦我们这样做了，便会很容易让函数转换为 pointfree 风格的。\n\n我们来回顾一下 `isEligibleToVote` 这个例子，代码如下：\n\n```js\nconst wasBornInCountry = person => person.birthCountry === OUR_COUNTRY\nconst wasNaturalized = person => Boolean(person.naturalizationDate)\nconst isOver18 = person => person.age >= 18\n \nconst isCitizen = person => wasBornInCountry(person) || wasNaturalized(person)\n \nconst isEligibleToVote = person => isOver18(person) && isCitizen(person)\n```\n\n先从 `isCitizen` 开始。它接受一个 `person`, 然后将两个函数作用于该 `person`，将结果使用 `||` 组合起来。正如在 [第二节](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 中学到的，可以使用 `either` 将两个函数组合成一个新函数，然后将该组合函数作用于该 `person`。\n\n```js\nconst isCitizen = person => either(wasBornInCountry, wasNaturalized)(person)\n```\n\n可以使用 `both` 对 `isEligibleToVote` 做类似的处理。\n\n```js\nconst isEligibleToVote = person => both(isOver18, isCitizen)(person)\n```\n\n现在我们已经完成了这些重构，可以看到，这两个函数都遵循上面提到的模式：`person` 出现了两次，一次作为函数参数；一次放到最后，将组合函数作用其上。现在可以将它们重构为 pointfree 风格的代码：\n\n```js\nconst isCitizen = either(wasBornInCountry, wasNaturalized)\nconst isEligibleToVote = both(isOver18, isCitizen)\n```\n\n## 为什么要这么做？\n\nPointfree 风格需要一定的时间才能习惯。可能并不需要所有的地方都没有参数。有时候知道某些 Ramda 函数需要多少参数，也是很重要的。\n\n但是，一旦习惯了这种方式，它将变得非常强大：可以以非常有趣的方式将很多小的 pointfree 函数组合起来。\n\nPointfree 风格的优点是什么呢？人们可能会认为，这只不过是为了让函数式编程赢得 \"优点徽章\" 的学术活动而已（实际上并没有什么用处）。然而，我认为还是有一些优点的，即使需要花一些时间来习惯这种方式也是值得的：\n\n* 它让编程更简单、精练。这并不总是一件好事，但大部分情况下是这样的。\n* 它让算法更清晰。通过只关注正在组合的函数，我们可以在没有参数的干扰下，更好地了解发生了什么。\n* 它促使我们更专注于正在做的转换的本身，而不是正被转换的数据。\n* 它可以帮助我们将函数视为可以作用于不同数据的通用构建模块，而非对特定类型数据的操作。如果给数据一个名字，我们的思想便会被[禁锢](https://en.wikipedia.org/wiki/Anchoring)在：\"需要在哪里使用我们的函数\"；如果去掉参数，便会使我们更有创造力。\n\n## 结论\n\nPointfree 风格也被成为 [tacit 式编程](https://en.wikipedia.org/wiki/Tacit_programming)(隐含式编程)，可以使代码更清晰、更易于理解。通过代码重构将所有的转换组合成单一函数，我们最终会得到可以在更多地方使用的更小的构建块（函数）。\n\n## 下一节\n\n在当前示例中，我们尚未将所有代码都重构为 pointfree 的风格。还有一些代码是命令式的。大部分这种代码是处理对象和数组的。\n\n我们需要找到声明式的方式来处理对象和数组。Immutability (不变性) 怎么样？我们如何以 \"不变\" (immutable) 的方式来操作对象和数组呢？\n\n本系列的下一节，[数据不变性和对象](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/) 将讨论如何以函数式和 immutable 的方式来处理对象。紧随其后的章节：[数据不变性和数组](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/) 对数组也是相同的处理方式。\n","slug":"Thinking-in-Ramda-Pointfree-Style","published":1,"updated":"2020-06-06T14:44:04.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu10013f6mjwvffcvh5","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Pointfree Style</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第五篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">第四节</a>中，我们讨论了如何用声明式编程（告诉计算机做什么，我们想要什么）代替命令式编程（告诉计算机该怎么做，详细的执行步骤）来编写代码。</p>\n<p>你可能已经注意到了，我们编写的几个函数（如 <code>forever21</code>、<code>alwaysDrivingAge</code>、<code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于该参数。</p>\n<p>这是函数式编程里非常常见的一种模式，Ramda 同样提供了优化这种模式的方法。</p>\n<h2>Pointfree 风格（无参数风格）</h2>\n<p>我们在 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">第三节</a> 中讨论了 Ramda 的两个指导原则：</p>\n<ul>\n<li>将数据放到参数列表的最后面。</li>\n<li>柯里化所有的东西。</li>\n</ul>\n<p>这两个原则衍生出了一种被函数式程序员称为 &quot;pointfree&quot; 的风格。我喜欢将 pointfree 的代码看作：&quot;数据？什么数据？这里没有数据！&quot;</p>\n<p>有一篇很好的博客：<a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">Why Ramda?</a>，展示了 pointfree 风格 真得不错。具体来说，它有一些有趣的标题，例如：&quot;数据在哪里？&quot;，&quot;好了，已经有了！&quot;，&quot;那么我可以看看数据吗？&quot; 和 &quot;拜托，我只是想要我的数据&quot;。</p>\n<p>我们还没有使用需要的工具来让所有的例子都变成完全 &quot;pointfree&quot; 的，现在就开始吧。</p>\n<p>再看一下 <code>forever21</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(gte(__, <span class=\"number\">21</span>), always(<span class=\"number\">21</span>), inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>注意，参数 <code>age</code> 出现了两次：一次在参数列表中；一次在函数的最后面：我们将由 <code>ifElse</code> 返回的新函数作用于 <code>age</code>。</p>\n<p>在使用 Ramda 编程时稍加留意，就会发现很多这种模式的代码。这也意味着，总应该有一种方法将这些函数转成 &quot;pointfree&quot; 风格。</p>\n<p>我们来看看这会是什么样子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = ifElse(gte(__, <span class=\"number\">21</span>), always(<span class=\"number\">21</span>), inc)</span><br></pre></td></tr></table></figure></p>\n<p>嘭~~！我们刚刚让 <code>age</code> 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 <code>age</code> 参数。</p>\n<p>可以对 <code>alwaysDrivingAge</code> 和 <code>water</code> 进行相同的处理。</p>\n<p>原来的 <code>alwaysDrivingAge</code> 如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>), identity)(age)</span><br></pre></td></tr></table></figure></p>\n<p>可以使用相同的方法使其变为 pointfree 的。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = when(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>))</span><br></pre></td></tr></table></figure></p>\n<p>下面是 <code>water</code> 原来的形式：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> water = <span class=\"function\"><span class=\"params\">temperature</span> =&gt;</span> cond([</span><br><span class=\"line\">  [equals(<span class=\"number\">0</span>),   always(<span class=\"string\">'water freezes at 0°C'</span>)],</span><br><span class=\"line\">  [equals(<span class=\"number\">100</span>), always(<span class=\"string\">'water boils at 100°C'</span>)],</span><br><span class=\"line\">  [T,           temp =&gt; <span class=\"string\">`nothing special happens at <span class=\"subst\">$&#123;temp&#125;</span>°C`</span>]</span><br><span class=\"line\">])(temperature)</span><br></pre></td></tr></table></figure></p>\n<p>现在将其变为 pointfree 风格的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> water = cond([</span><br><span class=\"line\">  [equals(<span class=\"number\">0</span>),   always(<span class=\"string\">'water freezes at 0°C'</span>)],</span><br><span class=\"line\">  [equals(<span class=\"number\">100</span>), always(<span class=\"string\">'water boils at 100°C'</span>)],</span><br><span class=\"line\">  [T,           temp =&gt; <span class=\"string\">`nothing special happens at <span class=\"subst\">$&#123;temp&#125;</span>°C`</span>]</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></p>\n<h2>多元函数（多参数函数）</h2>\n<p>如果函数接受多个参数会怎样呢？回顾一下 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">第三节</a> 中的例子：<code>titlesForYear</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = curry(<span class=\"function\">(<span class=\"params\">year, books</span>) =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )(books)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>books</code> 出现了两次：一次作为参数列表的最后一个参数（最后一个数据！）；一次出现在函数最后，当我们将其传入 pipeline 的时候。这跟我们之前看到参数为 <code>age</code> 的模式类似，所以可以对它进行相同的转换：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\"><span class=\"params\">year</span> =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure></p>\n<p>可以了！我们现在有了一个 pointfree 版本的 <code>titlesFroYear</code>。</p>\n<p>其实，这种情况下，我可能不会刻意追求 pointfree 风格，因为就像之前文章讨论过的：JavaScript 在调用一系列单参数函数方面并不方便。</p>\n<p>在 pipeline 中使用 <code>titleForYear</code> 是很方便，如我们可以很轻松的调用 <code>titlesForYear(2012)</code>，但当想要单独使用它时，我们就不得不回到之前文章里看到的形式 <code>)(</code>，对我而言，并不值得做出这种妥协（没必要为了 pointfree 而 pointfree）。</p>\n<p>但只要有如上形式的单参数函数（或者可能以后会被重构），我几乎总是写成 pointfree 风格的。</p>\n<h2>重构为 pointfree 风格的代码</h2>\n<p>有时我们的代码不会遵循这种模式。我们可能会在同一函数内多次对数据进行操作。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> 的几个例子中便是这种情形。我们使用诸如 <code>both</code>、<code>either</code>、<code>pipe</code>、<code>compose</code> 来重构代码。一旦我们这样做了，便会很容易让函数转换为 pointfree 风格的。</p>\n<p>我们来回顾一下 <code>isEligibleToVote</code> 这个例子，代码如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</span><br></pre></td></tr></table></figure></p>\n<p>先从 <code>isCitizen</code> 开始。它接受一个 <code>person</code>, 然后将两个函数作用于该 <code>person</code>，将结果使用 <code>||</code> 组合起来。正如在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> 中学到的，可以使用 <code>either</code> 将两个函数组合成一个新函数，然后将该组合函数作用于该 <code>person</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> either(wasBornInCountry, wasNaturalized)(person)</span><br></pre></td></tr></table></figure></p>\n<p>可以使用 <code>both</code> 对 <code>isEligibleToVote</code> 做类似的处理。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> both(isOver18, isCitizen)(person)</span><br></pre></td></tr></table></figure></p>\n<p>现在我们已经完成了这些重构，可以看到，这两个函数都遵循上面提到的模式：<code>person</code> 出现了两次，一次作为函数参数；一次放到最后，将组合函数作用其上。现在可以将它们重构为 pointfree 风格的代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<h2>为什么要这么做？</h2>\n<p>Pointfree 风格需要一定的时间才能习惯。可能并不需要所有的地方都没有参数。有时候知道某些 Ramda 函数需要多少参数，也是很重要的。</p>\n<p>但是，一旦习惯了这种方式，它将变得非常强大：可以以非常有趣的方式将很多小的 pointfree 函数组合起来。</p>\n<p>Pointfree 风格的优点是什么呢？人们可能会认为，这只不过是为了让函数式编程赢得 &quot;优点徽章&quot; 的学术活动而已（实际上并没有什么用处）。然而，我认为还是有一些优点的，即使需要花一些时间来习惯这种方式也是值得的：</p>\n<ul>\n<li>它让编程更简单、精练。这并不总是一件好事，但大部分情况下是这样的。</li>\n<li>它让算法更清晰。通过只关注正在组合的函数，我们可以在没有参数的干扰下，更好地了解发生了什么。</li>\n<li>它促使我们更专注于正在做的转换的本身，而不是正被转换的数据。</li>\n<li>它可以帮助我们将函数视为可以作用于不同数据的通用构建模块，而非对特定类型数据的操作。如果给数据一个名字，我们的思想便会被<a href=\"https://en.wikipedia.org/wiki/Anchoring\" target=\"_blank\" rel=\"noopener\">禁锢</a>在：&quot;需要在哪里使用我们的函数&quot;；如果去掉参数，便会使我们更有创造力。</li>\n</ul>\n<h2>结论</h2>\n<p>Pointfree 风格也被成为 <a href=\"https://en.wikipedia.org/wiki/Tacit_programming\" target=\"_blank\" rel=\"noopener\">tacit 式编程</a>(隐含式编程)，可以使代码更清晰、更易于理解。通过代码重构将所有的转换组合成单一函数，我们最终会得到可以在更多地方使用的更小的构建块（函数）。</p>\n<h2>下一节</h2>\n<p>在当前示例中，我们尚未将所有代码都重构为 pointfree 的风格。还有一些代码是命令式的。大部分这种代码是处理对象和数组的。</p>\n<p>我们需要找到声明式的方式来处理对象和数组。Immutability (不变性) 怎么样？我们如何以 &quot;不变&quot; (immutable) 的方式来操作对象和数组呢？</p>\n<p>本系列的下一节，<a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">数据不变性和对象</a> 将讨论如何以函数式和 immutable 的方式来处理对象。紧随其后的章节：<a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">数据不变性和数组</a> 对数组也是相同的处理方式。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Pointfree Style</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第五篇。</p>\n<p>在<a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">第四节</a>中，我们讨论了如何用声明式编程（告诉计算机做什么，我们想要什么）代替命令式编程（告诉计算机该怎么做，详细的执行步骤）来编写代码。</p>\n<p>你可能已经注意到了，我们编写的几个函数（如 <code>forever21</code>、<code>alwaysDrivingAge</code>、<code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于该参数。</p>\n<p>这是函数式编程里非常常见的一种模式，Ramda 同样提供了优化这种模式的方法。</p>\n<h2>Pointfree 风格（无参数风格）</h2>\n<p>我们在 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">第三节</a> 中讨论了 Ramda 的两个指导原则：</p>\n<ul>\n<li>将数据放到参数列表的最后面。</li>\n<li>柯里化所有的东西。</li>\n</ul>\n<p>这两个原则衍生出了一种被函数式程序员称为 &quot;pointfree&quot; 的风格。我喜欢将 pointfree 的代码看作：&quot;数据？什么数据？这里没有数据！&quot;</p>\n<p>有一篇很好的博客：<a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">Why Ramda?</a>，展示了 pointfree 风格 真得不错。具体来说，它有一些有趣的标题，例如：&quot;数据在哪里？&quot;，&quot;好了，已经有了！&quot;，&quot;那么我可以看看数据吗？&quot; 和 &quot;拜托，我只是想要我的数据&quot;。</p>\n<p>我们还没有使用需要的工具来让所有的例子都变成完全 &quot;pointfree&quot; 的，现在就开始吧。</p>\n<p>再看一下 <code>forever21</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(gte(__, <span class=\"number\">21</span>), always(<span class=\"number\">21</span>), inc)(age)</span><br></pre></td></tr></table></figure></p>\n<p>注意，参数 <code>age</code> 出现了两次：一次在参数列表中；一次在函数的最后面：我们将由 <code>ifElse</code> 返回的新函数作用于 <code>age</code>。</p>\n<p>在使用 Ramda 编程时稍加留意，就会发现很多这种模式的代码。这也意味着，总应该有一种方法将这些函数转成 &quot;pointfree&quot; 风格。</p>\n<p>我们来看看这会是什么样子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> forever21 = ifElse(gte(__, <span class=\"number\">21</span>), always(<span class=\"number\">21</span>), inc)</span><br></pre></td></tr></table></figure></p>\n<p>嘭~~！我们刚刚让 <code>age</code> 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 <code>age</code> 参数。</p>\n<p>可以对 <code>alwaysDrivingAge</code> 和 <code>water</code> 进行相同的处理。</p>\n<p>原来的 <code>alwaysDrivingAge</code> 如下所示：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = <span class=\"function\"><span class=\"params\">age</span> =&gt;</span> ifElse(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>), identity)(age)</span><br></pre></td></tr></table></figure></p>\n<p>可以使用相同的方法使其变为 pointfree 的。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> alwaysDrivingAge = when(lt(__, <span class=\"number\">16</span>), always(<span class=\"number\">16</span>))</span><br></pre></td></tr></table></figure></p>\n<p>下面是 <code>water</code> 原来的形式：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> water = <span class=\"function\"><span class=\"params\">temperature</span> =&gt;</span> cond([</span><br><span class=\"line\">  [equals(<span class=\"number\">0</span>),   always(<span class=\"string\">'water freezes at 0°C'</span>)],</span><br><span class=\"line\">  [equals(<span class=\"number\">100</span>), always(<span class=\"string\">'water boils at 100°C'</span>)],</span><br><span class=\"line\">  [T,           temp =&gt; <span class=\"string\">`nothing special happens at <span class=\"subst\">$&#123;temp&#125;</span>°C`</span>]</span><br><span class=\"line\">])(temperature)</span><br></pre></td></tr></table></figure></p>\n<p>现在将其变为 pointfree 风格的：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> water = cond([</span><br><span class=\"line\">  [equals(<span class=\"number\">0</span>),   always(<span class=\"string\">'water freezes at 0°C'</span>)],</span><br><span class=\"line\">  [equals(<span class=\"number\">100</span>), always(<span class=\"string\">'water boils at 100°C'</span>)],</span><br><span class=\"line\">  [T,           temp =&gt; <span class=\"string\">`nothing special happens at <span class=\"subst\">$&#123;temp&#125;</span>°C`</span>]</span><br><span class=\"line\">])</span><br></pre></td></tr></table></figure></p>\n<h2>多元函数（多参数函数）</h2>\n<p>如果函数接受多个参数会怎样呢？回顾一下 <a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">第三节</a> 中的例子：<code>titlesForYear</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = curry(<span class=\"function\">(<span class=\"params\">year, books</span>) =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )(books)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>books</code> 出现了两次：一次作为参数列表的最后一个参数（最后一个数据！）；一次出现在函数最后，当我们将其传入 pipeline 的时候。这跟我们之前看到参数为 <code>age</code> 的模式类似，所以可以对它进行相同的转换：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> titlesForYear = <span class=\"function\"><span class=\"params\">year</span> =&gt;</span></span><br><span class=\"line\">  pipe(</span><br><span class=\"line\">    filter(publishedInYear(year)),</span><br><span class=\"line\">    map(<span class=\"function\"><span class=\"params\">book</span> =&gt;</span> book.title)</span><br><span class=\"line\">  )</span><br></pre></td></tr></table></figure></p>\n<p>可以了！我们现在有了一个 pointfree 版本的 <code>titlesFroYear</code>。</p>\n<p>其实，这种情况下，我可能不会刻意追求 pointfree 风格，因为就像之前文章讨论过的：JavaScript 在调用一系列单参数函数方面并不方便。</p>\n<p>在 pipeline 中使用 <code>titleForYear</code> 是很方便，如我们可以很轻松的调用 <code>titlesForYear(2012)</code>，但当想要单独使用它时，我们就不得不回到之前文章里看到的形式 <code>)(</code>，对我而言，并不值得做出这种妥协（没必要为了 pointfree 而 pointfree）。</p>\n<p>但只要有如上形式的单参数函数（或者可能以后会被重构），我几乎总是写成 pointfree 风格的。</p>\n<h2>重构为 pointfree 风格的代码</h2>\n<p>有时我们的代码不会遵循这种模式。我们可能会在同一函数内多次对数据进行操作。</p>\n<p>在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> 的几个例子中便是这种情形。我们使用诸如 <code>both</code>、<code>either</code>、<code>pipe</code>、<code>compose</code> 来重构代码。一旦我们这样做了，便会很容易让函数转换为 pointfree 风格的。</p>\n<p>我们来回顾一下 <code>isEligibleToVote</code> 这个例子，代码如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> wasBornInCountry = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</span><br><span class=\"line\"><span class=\"keyword\">const</span> wasNaturalized = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> <span class=\"built_in\">Boolean</span>(person.naturalizationDate)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isOver18 = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> person.age &gt;= <span class=\"number\">18</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</span><br></pre></td></tr></table></figure></p>\n<p>先从 <code>isCitizen</code> 开始。它接受一个 <code>person</code>, 然后将两个函数作用于该 <code>person</code>，将结果使用 <code>||</code> 组合起来。正如在 <a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">第二节</a> 中学到的，可以使用 <code>either</code> 将两个函数组合成一个新函数，然后将该组合函数作用于该 <code>person</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> either(wasBornInCountry, wasNaturalized)(person)</span><br></pre></td></tr></table></figure></p>\n<p>可以使用 <code>both</code> 对 <code>isEligibleToVote</code> 做类似的处理。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = <span class=\"function\"><span class=\"params\">person</span> =&gt;</span> both(isOver18, isCitizen)(person)</span><br></pre></td></tr></table></figure></p>\n<p>现在我们已经完成了这些重构，可以看到，这两个函数都遵循上面提到的模式：<code>person</code> 出现了两次，一次作为函数参数；一次放到最后，将组合函数作用其上。现在可以将它们重构为 pointfree 风格的代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</span><br><span class=\"line\"><span class=\"keyword\">const</span> isEligibleToVote = both(isOver18, isCitizen)</span><br></pre></td></tr></table></figure></p>\n<h2>为什么要这么做？</h2>\n<p>Pointfree 风格需要一定的时间才能习惯。可能并不需要所有的地方都没有参数。有时候知道某些 Ramda 函数需要多少参数，也是很重要的。</p>\n<p>但是，一旦习惯了这种方式，它将变得非常强大：可以以非常有趣的方式将很多小的 pointfree 函数组合起来。</p>\n<p>Pointfree 风格的优点是什么呢？人们可能会认为，这只不过是为了让函数式编程赢得 &quot;优点徽章&quot; 的学术活动而已（实际上并没有什么用处）。然而，我认为还是有一些优点的，即使需要花一些时间来习惯这种方式也是值得的：</p>\n<ul>\n<li>它让编程更简单、精练。这并不总是一件好事，但大部分情况下是这样的。</li>\n<li>它让算法更清晰。通过只关注正在组合的函数，我们可以在没有参数的干扰下，更好地了解发生了什么。</li>\n<li>它促使我们更专注于正在做的转换的本身，而不是正被转换的数据。</li>\n<li>它可以帮助我们将函数视为可以作用于不同数据的通用构建模块，而非对特定类型数据的操作。如果给数据一个名字，我们的思想便会被<a href=\"https://en.wikipedia.org/wiki/Anchoring\" target=\"_blank\" rel=\"noopener\">禁锢</a>在：&quot;需要在哪里使用我们的函数&quot;；如果去掉参数，便会使我们更有创造力。</li>\n</ul>\n<h2>结论</h2>\n<p>Pointfree 风格也被成为 <a href=\"https://en.wikipedia.org/wiki/Tacit_programming\" target=\"_blank\" rel=\"noopener\">tacit 式编程</a>(隐含式编程)，可以使代码更清晰、更易于理解。通过代码重构将所有的转换组合成单一函数，我们最终会得到可以在更多地方使用的更小的构建块（函数）。</p>\n<h2>下一节</h2>\n<p>在当前示例中，我们尚未将所有代码都重构为 pointfree 的风格。还有一些代码是命令式的。大部分这种代码是处理对象和数组的。</p>\n<p>我们需要找到声明式的方式来处理对象和数组。Immutability (不变性) 怎么样？我们如何以 &quot;不变&quot; (immutable) 的方式来操作对象和数组呢？</p>\n<p>本系列的下一节，<a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">数据不变性和对象</a> 将讨论如何以函数式和 immutable 的方式来处理对象。紧随其后的章节：<a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">数据不变性和数组</a> 对数组也是相同的处理方式。</p>\n"},{"title":"Thinking in Ramda: 概要总结","date":"2017-06-18T02:17:35.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Wrap-Up](http://randycoulman.com/blog/2016/07/19/thinking-in-ramda-wrap-up/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的总结篇。\n\n在过去的八篇文章中，我们一直在讨论 [Ramda JavsScipt 库](http://ramda.cn/)，它提供了一系列以函数式、声明式和数据不变性方式工作的函数。\n\n在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：\n\n* 数据放在最后：几乎所有的函数都将数据参数作为最后一个参数。\n\n* 柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。\n\n这两个原则使我们能编写出非常清晰的函数式代码，可以将基本的构建模块组合成更强大的操作。\n\n## 总结\n\n作为参考，一下是本系列文章的简单概要。\n\n* [入门](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/)：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：`map`、`filter` 和 `reduce` 等。\n\n* [函数组合](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/)：演示了可以使用工具（如 `both`、`either`、`pipe` 和 `compose`）以多种方式组合函数。\n\n* [部分应用(Partial Application)](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/)：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 `partial` 和 `curry` 可以实现部分应用。我们还学习了 `flip` 和占位符（`__`）。\n\n* [声明式编程](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/)：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。\n\n* [无参数风格编程(Pointfree Style)](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/)：介绍了 pointfree 风格的思想，也被称为 \"tatic\" 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。\n\n* [数据不变性和对象](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/)：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。\n\n* [数据不变性和数组](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/)：继续上一节的主题，展示了数据不变性在数组中的应用。\n\n* [透镜(Lenses)](https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/)：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 `view`、`set` 和 `over` 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。\n\n## 后续\n\n该系列文章并未覆盖到 Ramda 所有部分。特别是，我们没有讨论处理字符串的函数，也没有讨论一些更高阶的概念，如 [transducers](http://ramda.cn/docs/#transduce)。\n\n要了解更多 Ramda 的作用，我建议仔细阅读 [官方文档](http://ramda.cn/docs/)，那里有大量的信息。所有的函数都按照它们处理数据的类型进行了分类，尽管有一些重叠。比如，有几个处理数组的函数可以用于处理字符串，`map` 可以作用于数组和对象两种类型。\n\n如果你对更高级的函数式主题感兴趣，可以参考一下资料：\n\n* Transducers：这里有一篇 [使用 transducers 解析日志](http://simplectic.com/blog/2015/ramda-transducers-logs/) 的介绍性文章。（译者也翻译了该系列两篇文章：[《Transducers Explained: Part 1 中文》](https://adispring.coding.me/2016/10/24/Transducers-Explained-Part-1/) 和 [《Transducers Explained: Pipelines 中文》](https://adispring.coding.me/2016/11/01/Transducers-Explained-Pipelines/)）。\n\n* 代数数据类型：如果你已经阅读了很多关于函数式编程的知识，应该听过代数类型和相关术语，如 \"Functor\"、\"Applicative\" 和 \"Monad\"。如果有兴趣深入了解这方面的思想，及其在 Ramda 中的实现和应用，可以查看 [ramda-fantasy](https://github.com/ramda/ramda-fantasy) 项目，该项目实现了符合 [Fantasy Land 规范](https://github.com/fantasyland/fantasy-land) （又称为 JavaScript 代数规范）的一些数据类型。\n","source":"_posts/Thinking-in-Ramda-Wrap-Up.md","raw":"---\ntitle: 'Thinking in Ramda: 概要总结'\ndate: 2017-06-18 10:17:35\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Wrap-Up](http://randycoulman.com/blog/2016/07/19/thinking-in-ramda-wrap-up/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的总结篇。\n\n在过去的八篇文章中，我们一直在讨论 [Ramda JavsScipt 库](http://ramda.cn/)，它提供了一系列以函数式、声明式和数据不变性方式工作的函数。\n\n在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：\n\n* 数据放在最后：几乎所有的函数都将数据参数作为最后一个参数。\n\n* 柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。\n\n这两个原则使我们能编写出非常清晰的函数式代码，可以将基本的构建模块组合成更强大的操作。\n\n## 总结\n\n作为参考，一下是本系列文章的简单概要。\n\n* [入门](https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/)：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：`map`、`filter` 和 `reduce` 等。\n\n* [函数组合](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/)：演示了可以使用工具（如 `both`、`either`、`pipe` 和 `compose`）以多种方式组合函数。\n\n* [部分应用(Partial Application)](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/)：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 `partial` 和 `curry` 可以实现部分应用。我们还学习了 `flip` 和占位符（`__`）。\n\n* [声明式编程](https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/)：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。\n\n* [无参数风格编程(Pointfree Style)](https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/)：介绍了 pointfree 风格的思想，也被称为 \"tatic\" 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。\n\n* [数据不变性和对象](https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/)：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。\n\n* [数据不变性和数组](https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/)：继续上一节的主题，展示了数据不变性在数组中的应用。\n\n* [透镜(Lenses)](https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/)：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 `view`、`set` 和 `over` 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。\n\n## 后续\n\n该系列文章并未覆盖到 Ramda 所有部分。特别是，我们没有讨论处理字符串的函数，也没有讨论一些更高阶的概念，如 [transducers](http://ramda.cn/docs/#transduce)。\n\n要了解更多 Ramda 的作用，我建议仔细阅读 [官方文档](http://ramda.cn/docs/)，那里有大量的信息。所有的函数都按照它们处理数据的类型进行了分类，尽管有一些重叠。比如，有几个处理数组的函数可以用于处理字符串，`map` 可以作用于数组和对象两种类型。\n\n如果你对更高级的函数式主题感兴趣，可以参考一下资料：\n\n* Transducers：这里有一篇 [使用 transducers 解析日志](http://simplectic.com/blog/2015/ramda-transducers-logs/) 的介绍性文章。（译者也翻译了该系列两篇文章：[《Transducers Explained: Part 1 中文》](https://adispring.coding.me/2016/10/24/Transducers-Explained-Part-1/) 和 [《Transducers Explained: Pipelines 中文》](https://adispring.coding.me/2016/11/01/Transducers-Explained-Pipelines/)）。\n\n* 代数数据类型：如果你已经阅读了很多关于函数式编程的知识，应该听过代数类型和相关术语，如 \"Functor\"、\"Applicative\" 和 \"Monad\"。如果有兴趣深入了解这方面的思想，及其在 Ramda 中的实现和应用，可以查看 [ramda-fantasy](https://github.com/ramda/ramda-fantasy) 项目，该项目实现了符合 [Fantasy Land 规范](https://github.com/fantasyland/fantasy-land) （又称为 JavaScript 代数规范）的一些数据类型。\n","slug":"Thinking-in-Ramda-Wrap-Up","published":1,"updated":"2020-06-06T14:44:04.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu30016f6mjygmycn00","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/07/19/thinking-in-ramda-wrap-up/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Wrap-Up</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的总结篇。</p>\n<p>在过去的八篇文章中，我们一直在讨论 <a href=\"http://ramda.cn/\" target=\"_blank\" rel=\"noopener\">Ramda JavsScipt 库</a>，它提供了一系列以函数式、声明式和数据不变性方式工作的函数。</p>\n<p>在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：</p>\n<ul>\n<li>\n<p>数据放在最后：几乎所有的函数都将数据参数作为最后一个参数。</p>\n</li>\n<li>\n<p>柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。</p>\n</li>\n</ul>\n<p>这两个原则使我们能编写出非常清晰的函数式代码，可以将基本的构建模块组合成更强大的操作。</p>\n<h2>总结</h2>\n<p>作为参考，一下是本系列文章的简单概要。</p>\n<ul>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">入门</a>：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：<code>map</code>、<code>filter</code> 和 <code>reduce</code> 等。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">函数组合</a>：演示了可以使用工具（如 <code>both</code>、<code>either</code>、<code>pipe</code> 和 <code>compose</code>）以多种方式组合函数。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">部分应用(Partial Application)</a>：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 <code>partial</code> 和 <code>curry</code> 可以实现部分应用。我们还学习了 <code>flip</code> 和占位符（<code>__</code>）。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">声明式编程</a>：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">无参数风格编程(Pointfree Style)</a>：介绍了 pointfree 风格的思想，也被称为 &quot;tatic&quot; 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">数据不变性和对象</a>：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">数据不变性和数组</a>：继续上一节的主题，展示了数据不变性在数组中的应用。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/\" target=\"_blank\" rel=\"noopener\">透镜(Lenses)</a>：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 <code>view</code>、<code>set</code> 和 <code>over</code> 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。</p>\n</li>\n</ul>\n<h2>后续</h2>\n<p>该系列文章并未覆盖到 Ramda 所有部分。特别是，我们没有讨论处理字符串的函数，也没有讨论一些更高阶的概念，如 <a href=\"http://ramda.cn/docs/#transduce\" target=\"_blank\" rel=\"noopener\">transducers</a>。</p>\n<p>要了解更多 Ramda 的作用，我建议仔细阅读 <a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a>，那里有大量的信息。所有的函数都按照它们处理数据的类型进行了分类，尽管有一些重叠。比如，有几个处理数组的函数可以用于处理字符串，<code>map</code> 可以作用于数组和对象两种类型。</p>\n<p>如果你对更高级的函数式主题感兴趣，可以参考一下资料：</p>\n<ul>\n<li>\n<p>Transducers：这里有一篇 <a href=\"http://simplectic.com/blog/2015/ramda-transducers-logs/\" target=\"_blank\" rel=\"noopener\">使用 transducers 解析日志</a> 的介绍性文章。（译者也翻译了该系列两篇文章：<a href=\"https://adispring.coding.me/2016/10/24/Transducers-Explained-Part-1/\" target=\"_blank\" rel=\"noopener\">《Transducers Explained: Part 1 中文》</a> 和 <a href=\"https://adispring.coding.me/2016/11/01/Transducers-Explained-Pipelines/\" target=\"_blank\" rel=\"noopener\">《Transducers Explained: Pipelines 中文》</a>）。</p>\n</li>\n<li>\n<p>代数数据类型：如果你已经阅读了很多关于函数式编程的知识，应该听过代数类型和相关术语，如 &quot;Functor&quot;、&quot;Applicative&quot; 和 &quot;Monad&quot;。如果有兴趣深入了解这方面的思想，及其在 Ramda 中的实现和应用，可以查看 <a href=\"https://github.com/ramda/ramda-fantasy\" target=\"_blank\" rel=\"noopener\">ramda-fantasy</a> 项目，该项目实现了符合 <a href=\"https://github.com/fantasyland/fantasy-land\" target=\"_blank\" rel=\"noopener\">Fantasy Land 规范</a> （又称为 JavaScript 代数规范）的一些数据类型。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/07/19/thinking-in-ramda-wrap-up/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Wrap-Up</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的总结篇。</p>\n<p>在过去的八篇文章中，我们一直在讨论 <a href=\"http://ramda.cn/\" target=\"_blank\" rel=\"noopener\">Ramda JavsScipt 库</a>，它提供了一系列以函数式、声明式和数据不变性方式工作的函数。</p>\n<p>在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：</p>\n<ul>\n<li>\n<p>数据放在最后：几乎所有的函数都将数据参数作为最后一个参数。</p>\n</li>\n<li>\n<p>柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。</p>\n</li>\n</ul>\n<p>这两个原则使我们能编写出非常清晰的函数式代码，可以将基本的构建模块组合成更强大的操作。</p>\n<h2>总结</h2>\n<p>作为参考，一下是本系列文章的简单概要。</p>\n<ul>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/\" target=\"_blank\" rel=\"noopener\">入门</a>：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：<code>map</code>、<code>filter</code> 和 <code>reduce</code> 等。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">函数组合</a>：演示了可以使用工具（如 <code>both</code>、<code>either</code>、<code>pipe</code> 和 <code>compose</code>）以多种方式组合函数。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/\" target=\"_blank\" rel=\"noopener\">部分应用(Partial Application)</a>：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 <code>partial</code> 和 <code>curry</code> 可以实现部分应用。我们还学习了 <code>flip</code> 和占位符（<code>__</code>）。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/\" target=\"_blank\" rel=\"noopener\">声明式编程</a>：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/\" target=\"_blank\" rel=\"noopener\">无参数风格编程(Pointfree Style)</a>：介绍了 pointfree 风格的思想，也被称为 &quot;tatic&quot; 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/\" target=\"_blank\" rel=\"noopener\">数据不变性和对象</a>：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/\" target=\"_blank\" rel=\"noopener\">数据不变性和数组</a>：继续上一节的主题，展示了数据不变性在数组中的应用。</p>\n</li>\n<li>\n<p><a href=\"https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/\" target=\"_blank\" rel=\"noopener\">透镜(Lenses)</a>：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 <code>view</code>、<code>set</code> 和 <code>over</code> 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。</p>\n</li>\n</ul>\n<h2>后续</h2>\n<p>该系列文章并未覆盖到 Ramda 所有部分。特别是，我们没有讨论处理字符串的函数，也没有讨论一些更高阶的概念，如 <a href=\"http://ramda.cn/docs/#transduce\" target=\"_blank\" rel=\"noopener\">transducers</a>。</p>\n<p>要了解更多 Ramda 的作用，我建议仔细阅读 <a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">官方文档</a>，那里有大量的信息。所有的函数都按照它们处理数据的类型进行了分类，尽管有一些重叠。比如，有几个处理数组的函数可以用于处理字符串，<code>map</code> 可以作用于数组和对象两种类型。</p>\n<p>如果你对更高级的函数式主题感兴趣，可以参考一下资料：</p>\n<ul>\n<li>\n<p>Transducers：这里有一篇 <a href=\"http://simplectic.com/blog/2015/ramda-transducers-logs/\" target=\"_blank\" rel=\"noopener\">使用 transducers 解析日志</a> 的介绍性文章。（译者也翻译了该系列两篇文章：<a href=\"https://adispring.coding.me/2016/10/24/Transducers-Explained-Part-1/\" target=\"_blank\" rel=\"noopener\">《Transducers Explained: Part 1 中文》</a> 和 <a href=\"https://adispring.coding.me/2016/11/01/Transducers-Explained-Pipelines/\" target=\"_blank\" rel=\"noopener\">《Transducers Explained: Pipelines 中文》</a>）。</p>\n</li>\n<li>\n<p>代数数据类型：如果你已经阅读了很多关于函数式编程的知识，应该听过代数类型和相关术语，如 &quot;Functor&quot;、&quot;Applicative&quot; 和 &quot;Monad&quot;。如果有兴趣深入了解这方面的思想，及其在 Ramda 中的实现和应用，可以查看 <a href=\"https://github.com/ramda/ramda-fantasy\" target=\"_blank\" rel=\"noopener\">ramda-fantasy</a> 项目，该项目实现了符合 <a href=\"https://github.com/fantasyland/fantasy-land\" target=\"_blank\" rel=\"noopener\">Fantasy Land 规范</a> （又称为 JavaScript 代数规范）的一些数据类型。</p>\n</li>\n</ul>\n"},{"title":"Thinking in Ramda: 入门","date":"2017-06-09T13:45:47.000Z","_content":"\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Getting Started](http://randycoulman.com/blog/2016/05/24/thinking-in-ramda-getting-started/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第一篇。\n\n本系列文章使用 [Ramda](http://ramda.cn) JavaScript 库进行演示。许多理论、方法同样适用于其他函数式 JavaScript 库，如 [Underscore](http://underscorejs.org/) 和 [Lodash](https://lodash.com/)。\n\n我将尽量用通俗、非学术性的语言演示函数式编程。一方面想让更多的人理解该系列文章；另一方面本人在函数式编程方面造诣尚浅。\n\n## Ramda\n\n我已经在博客中多次提到过 [Ramda](http://ramda.cn) JavaScript 库：\n\n* 在 [Using Ramda With Redux](http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/) 中，展示了在编写 [Redux](http://redux.js.org/) 应用程序时如何运用 Ramda 的例子。\n* 在 [Using Redux-api-middleware With Rails](http://randycoulman.com/blog/2016/04/19/using-redux-api-middleware-with-rails/) 中，我使用 Ramda 来转换请求和响应的数据。\n\n我发现 Ramda 是一个精心设计的库：包含许多 API ，来简洁、优雅进行 JavaScript 函数式编程。\n\n如果你想在阅读本系列文章时进行 Ramda 实验，Ramda 网站有一个 [repl 运行环境](http://ramda.cn/repl/) 。\n\n## 函数\n\n正如名字所示，函数式编程与函数有很大的关系。为了演示，我们定义一个函数为一段可重用的代码：接受 0 到多个参数，返回单个值。\n\n下面是一个简单的 JavaScript 函数：\n\n```js\nfunction double(x) {\n  return x * 2\n}\n```\n\n使用 ES6 箭头函数，可以以更简洁的方式实现相同的函数。现在就提一下，是因为在接下来会大量用到箭头函数：\n\n```js\nconst double = x => x * 2\n```\n\n几乎每种语言都会支持函数调用。\n\n有些语言更进一步，将函数视为一等公民：可以像使用普通类型的值的方式使用函数。例如：\n\n* 使用变量或常量引用函数\n* 将函数作为参数传递给其他函数\n* 将函数作为其他函数的返回值\n\nJavaScript 就是一种这样的语言，我们将利用它的这一优势进行编程。\n\n## 纯函数\n\n在进行函数式编程时，使用所谓的 \"纯\" 函数进行工作将变得非常重要。\n\n[纯函数](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html)是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 \"输出\"，不会对数据库进行读写，不会修改输入参数等。\n\n纯函数的基本思想是：相同的输入，永远会得到相同的输出。\n\n当然可以用非纯函数编程（而且这也是必须的，如果想让程序做任何有趣的事情），但在大多数情况下，需要保持大部分函数是纯函数。（译者注：并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生）\n\n## IMMUTABILITY\n\n函数式编程的另一个重要概念是 \"Immutability\"。什么意思呢？\"Immutability\" 是指 \"数据不变性\"。\n\n当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。\n\n如果想改变数组或对象中的元素时，需要返回一份带有更改值的新拷贝。后面文章将会对此做详细介绍。\n\nImmutability 和 纯函数息息相关。由于纯函数不允许有副作用，所以不允许更改函数体外部的数据结构。纯函数强制以 immutable 的方式处理数据。\n\n## 从哪里开始呢？\n\n开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。\n\n如果用过具备这些特性的其他语言（如 Ruby、Smalltalk），你可能已经熟悉了这些特性。\n\nMartin Fowler 有几篇关于 \"Collection PipeLines\" 非常好的文章，展示了[如何使用这些函数](https://martinfowler.com/articles/collection-pipeline/) 以及[如何将现有代码重构为 collection pipelines](https://martinfowler.com/articles/refactoring-pipelines.html)。\n\n注意，所有这些函数 `Array.prototype` 都有（除了 `reject`）。因此不需要 Ramda 也可以使用它们。但是，为了保持和本系列其他文章一致，本文将使用 Ramda 版本的函数。\n\n## foreach\n\n不必写显式的循环，而是用 `forEach` 函数代替循环。示例如下：\n\n```js\n// Replace this:\nfor (const value of myArray) {\n  console.log(value)\n}\n \n// with:\nforEach(value => console.log(value), myArray)\n```\n\n`forEach` 接受一个函数和一个数组，然后将函数作用于数组的每个元素。\n\n虽然 `forEach` 是这些函数中最简单的，但在函数式编程中它可能是最少用到的一个。`forEach` 没有返回值，所以只能用在有副作用的函数调用中。\n\n## map\n\n下一个要学习的最重要的函数是 `map`。类似于 `forEach`，`map` 也是将函数作用于数组的每个元素。但与 `forEach` 不同的是，`map` 将函数的每个返回值组成一个新数组，并将其返回。示例如下：\n\n```js\nmap(x => x * 2, [1, 2, 3]) //=> [2, 4, 6]\n```\n\n这里使用了匿名函数，但我们也可以在这里使用具名函数：\n\n```js\nconst double = x => x * 2\nmap(double, [1, 2, 3])\n```\n\n## filter/reject\n\n接下来，我们来看看 `filter` 和 `reject`。就像名字所示，`filter` 会根据断言函数的返回值从数组中选择元素，例如：\n\n```js\nconst isEven = x => x % 2 === 0\nfilter(isEven, [1, 2, 3, 4]) //=> [2, 4]\n```\n\n`filter` 将断言函数（本例中为 `isEven`）作用于数组中的每个元素。每当断言函数返回 \"真值\" 时，相应的元素将包含到结果中；反之当断言函数返回为 \"falsy\" 值时，相应的元素将从结果数组中排除掉（过滤掉）。\n\n`reject` 是 `filter` 的补操作。它保留使断言函数返回 \"falsy\" 的元素，排除使断言函数返回 \"truthy\" 的元素。\n\n```js\nreject(isEven, [1, 2, 3, 4]) //=> [1, 3]\n```\n\n## find\n\n`find` 将断言函数作用于数组中的每个元素，并返回第一个使断言函数返回真值的元素。\n\n```js\nfind(isEven, [1, 2, 3, 4]) //=> 2 \n```\n\n## reduce\n\n`reduce` 比之前遇到的其他函数要复杂一些。了解它是值得的，但如果刚开始不太好理解，不要被它挡住。你可以在理解它之前继续学习其他知识。\n\n`reduce` 接受一个二元函数(`reducing function`)、一个初始值和待处理的数组。\n\n归约函数的第一个参数称为 \"accumulator\" (累加值)，第二个参数取自数组中的元素；返回值为一个新的 \"accumulator\"。\n\n先来看一个示例，然后看看会发生什么。\n\n```js\nconst add = (accum, value) => accum + value\n\nreduce(add, 5, [1, 2, 3, 4]) //=> 15\n```\n\n1. `reduce` 首先将初始值 `5` 和 数组中的首个元素 `1` 传入归约函数 `add`，`add` 返回一个新的累加值：`5 + 1 = 6`。\n2. `reduce` 再次调用 `add`，这次使用新的累加值 `6` 和 数组中的下一个元素 `2` 作为参数，`add` 返回 `8`。\n3. `reduce` 再次使用 `8` 和 数组中的下个元素 `3` 来调用 `add`，输出 `11`。\n4. `reduce` 最后一次调用 `add`，使用 `11` 和 数组中的最后一个元素 `4` ，输出 `15`。\n5. `reduce` 将最终累加值 `15` 作为结果返回。\n\n## 结论\n\n从这些集合迭代函数开始，需要逐渐习惯将函数传入其他函数的编程方式。你可能在其他语言中用过，但没有意识到正在做函数式编程。\n\n## 下一节\n\n本系列的下一篇文章，[函数组合](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 将演示怎样以新的、有趣的方式对函数进行组合。\n","source":"_posts/Thinking-in-Ramda-入门.md","raw":"---\ntitle: 'Thinking in Ramda: 入门'\ndate: 2017-06-09 21:45:47\ncategories: 'Thinking in Ramda'\n---\n\n译者注：本文翻译自 Randy Coulman 的 《[Thinking in Ramda: Getting Started](http://randycoulman.com/blog/2016/05/24/thinking-in-ramda-getting-started/)》，转载请与[原作者](https://github.com/randycoulman)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n本文是函数式编程系列文章：[Thinking in Ramda](https://adispring.coding.me/categories/Thinking-in-Ramda/) 的第一篇。\n\n本系列文章使用 [Ramda](http://ramda.cn) JavaScript 库进行演示。许多理论、方法同样适用于其他函数式 JavaScript 库，如 [Underscore](http://underscorejs.org/) 和 [Lodash](https://lodash.com/)。\n\n我将尽量用通俗、非学术性的语言演示函数式编程。一方面想让更多的人理解该系列文章；另一方面本人在函数式编程方面造诣尚浅。\n\n## Ramda\n\n我已经在博客中多次提到过 [Ramda](http://ramda.cn) JavaScript 库：\n\n* 在 [Using Ramda With Redux](http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/) 中，展示了在编写 [Redux](http://redux.js.org/) 应用程序时如何运用 Ramda 的例子。\n* 在 [Using Redux-api-middleware With Rails](http://randycoulman.com/blog/2016/04/19/using-redux-api-middleware-with-rails/) 中，我使用 Ramda 来转换请求和响应的数据。\n\n我发现 Ramda 是一个精心设计的库：包含许多 API ，来简洁、优雅进行 JavaScript 函数式编程。\n\n如果你想在阅读本系列文章时进行 Ramda 实验，Ramda 网站有一个 [repl 运行环境](http://ramda.cn/repl/) 。\n\n## 函数\n\n正如名字所示，函数式编程与函数有很大的关系。为了演示，我们定义一个函数为一段可重用的代码：接受 0 到多个参数，返回单个值。\n\n下面是一个简单的 JavaScript 函数：\n\n```js\nfunction double(x) {\n  return x * 2\n}\n```\n\n使用 ES6 箭头函数，可以以更简洁的方式实现相同的函数。现在就提一下，是因为在接下来会大量用到箭头函数：\n\n```js\nconst double = x => x * 2\n```\n\n几乎每种语言都会支持函数调用。\n\n有些语言更进一步，将函数视为一等公民：可以像使用普通类型的值的方式使用函数。例如：\n\n* 使用变量或常量引用函数\n* 将函数作为参数传递给其他函数\n* 将函数作为其他函数的返回值\n\nJavaScript 就是一种这样的语言，我们将利用它的这一优势进行编程。\n\n## 纯函数\n\n在进行函数式编程时，使用所谓的 \"纯\" 函数进行工作将变得非常重要。\n\n[纯函数](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html)是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 \"输出\"，不会对数据库进行读写，不会修改输入参数等。\n\n纯函数的基本思想是：相同的输入，永远会得到相同的输出。\n\n当然可以用非纯函数编程（而且这也是必须的，如果想让程序做任何有趣的事情），但在大多数情况下，需要保持大部分函数是纯函数。（译者注：并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生）\n\n## IMMUTABILITY\n\n函数式编程的另一个重要概念是 \"Immutability\"。什么意思呢？\"Immutability\" 是指 \"数据不变性\"。\n\n当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。\n\n如果想改变数组或对象中的元素时，需要返回一份带有更改值的新拷贝。后面文章将会对此做详细介绍。\n\nImmutability 和 纯函数息息相关。由于纯函数不允许有副作用，所以不允许更改函数体外部的数据结构。纯函数强制以 immutable 的方式处理数据。\n\n## 从哪里开始呢？\n\n开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。\n\n如果用过具备这些特性的其他语言（如 Ruby、Smalltalk），你可能已经熟悉了这些特性。\n\nMartin Fowler 有几篇关于 \"Collection PipeLines\" 非常好的文章，展示了[如何使用这些函数](https://martinfowler.com/articles/collection-pipeline/) 以及[如何将现有代码重构为 collection pipelines](https://martinfowler.com/articles/refactoring-pipelines.html)。\n\n注意，所有这些函数 `Array.prototype` 都有（除了 `reject`）。因此不需要 Ramda 也可以使用它们。但是，为了保持和本系列其他文章一致，本文将使用 Ramda 版本的函数。\n\n## foreach\n\n不必写显式的循环，而是用 `forEach` 函数代替循环。示例如下：\n\n```js\n// Replace this:\nfor (const value of myArray) {\n  console.log(value)\n}\n \n// with:\nforEach(value => console.log(value), myArray)\n```\n\n`forEach` 接受一个函数和一个数组，然后将函数作用于数组的每个元素。\n\n虽然 `forEach` 是这些函数中最简单的，但在函数式编程中它可能是最少用到的一个。`forEach` 没有返回值，所以只能用在有副作用的函数调用中。\n\n## map\n\n下一个要学习的最重要的函数是 `map`。类似于 `forEach`，`map` 也是将函数作用于数组的每个元素。但与 `forEach` 不同的是，`map` 将函数的每个返回值组成一个新数组，并将其返回。示例如下：\n\n```js\nmap(x => x * 2, [1, 2, 3]) //=> [2, 4, 6]\n```\n\n这里使用了匿名函数，但我们也可以在这里使用具名函数：\n\n```js\nconst double = x => x * 2\nmap(double, [1, 2, 3])\n```\n\n## filter/reject\n\n接下来，我们来看看 `filter` 和 `reject`。就像名字所示，`filter` 会根据断言函数的返回值从数组中选择元素，例如：\n\n```js\nconst isEven = x => x % 2 === 0\nfilter(isEven, [1, 2, 3, 4]) //=> [2, 4]\n```\n\n`filter` 将断言函数（本例中为 `isEven`）作用于数组中的每个元素。每当断言函数返回 \"真值\" 时，相应的元素将包含到结果中；反之当断言函数返回为 \"falsy\" 值时，相应的元素将从结果数组中排除掉（过滤掉）。\n\n`reject` 是 `filter` 的补操作。它保留使断言函数返回 \"falsy\" 的元素，排除使断言函数返回 \"truthy\" 的元素。\n\n```js\nreject(isEven, [1, 2, 3, 4]) //=> [1, 3]\n```\n\n## find\n\n`find` 将断言函数作用于数组中的每个元素，并返回第一个使断言函数返回真值的元素。\n\n```js\nfind(isEven, [1, 2, 3, 4]) //=> 2 \n```\n\n## reduce\n\n`reduce` 比之前遇到的其他函数要复杂一些。了解它是值得的，但如果刚开始不太好理解，不要被它挡住。你可以在理解它之前继续学习其他知识。\n\n`reduce` 接受一个二元函数(`reducing function`)、一个初始值和待处理的数组。\n\n归约函数的第一个参数称为 \"accumulator\" (累加值)，第二个参数取自数组中的元素；返回值为一个新的 \"accumulator\"。\n\n先来看一个示例，然后看看会发生什么。\n\n```js\nconst add = (accum, value) => accum + value\n\nreduce(add, 5, [1, 2, 3, 4]) //=> 15\n```\n\n1. `reduce` 首先将初始值 `5` 和 数组中的首个元素 `1` 传入归约函数 `add`，`add` 返回一个新的累加值：`5 + 1 = 6`。\n2. `reduce` 再次调用 `add`，这次使用新的累加值 `6` 和 数组中的下一个元素 `2` 作为参数，`add` 返回 `8`。\n3. `reduce` 再次使用 `8` 和 数组中的下个元素 `3` 来调用 `add`，输出 `11`。\n4. `reduce` 最后一次调用 `add`，使用 `11` 和 数组中的最后一个元素 `4` ，输出 `15`。\n5. `reduce` 将最终累加值 `15` 作为结果返回。\n\n## 结论\n\n从这些集合迭代函数开始，需要逐渐习惯将函数传入其他函数的编程方式。你可能在其他语言中用过，但没有意识到正在做函数式编程。\n\n## 下一节\n\n本系列的下一篇文章，[函数组合](https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/) 将演示怎样以新的、有趣的方式对函数进行组合。\n","slug":"Thinking-in-Ramda-入门","published":1,"updated":"2020-06-06T14:44:04.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu40018f6mj6fm3lrg2","content":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/05/24/thinking-in-ramda-getting-started/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Getting Started</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第一篇。</p>\n<p>本系列文章使用 <a href=\"http://ramda.cn\" target=\"_blank\" rel=\"noopener\">Ramda</a> JavaScript 库进行演示。许多理论、方法同样适用于其他函数式 JavaScript 库，如 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a>。</p>\n<p>我将尽量用通俗、非学术性的语言演示函数式编程。一方面想让更多的人理解该系列文章；另一方面本人在函数式编程方面造诣尚浅。</p>\n<h2>Ramda</h2>\n<p>我已经在博客中多次提到过 <a href=\"http://ramda.cn\" target=\"_blank\" rel=\"noopener\">Ramda</a> JavaScript 库：</p>\n<ul>\n<li>在 <a href=\"http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/\" target=\"_blank\" rel=\"noopener\">Using Ramda With Redux</a> 中，展示了在编写 <a href=\"http://redux.js.org/\" target=\"_blank\" rel=\"noopener\">Redux</a> 应用程序时如何运用 Ramda 的例子。</li>\n<li>在 <a href=\"http://randycoulman.com/blog/2016/04/19/using-redux-api-middleware-with-rails/\" target=\"_blank\" rel=\"noopener\">Using Redux-api-middleware With Rails</a> 中，我使用 Ramda 来转换请求和响应的数据。</li>\n</ul>\n<p>我发现 Ramda 是一个精心设计的库：包含许多 API ，来简洁、优雅进行 JavaScript 函数式编程。</p>\n<p>如果你想在阅读本系列文章时进行 Ramda 实验，Ramda 网站有一个 <a href=\"http://ramda.cn/repl/\" target=\"_blank\" rel=\"noopener\">repl 运行环境</a> 。</p>\n<h2>函数</h2>\n<p>正如名字所示，函数式编程与函数有很大的关系。为了演示，我们定义一个函数为一段可重用的代码：接受 0 到多个参数，返回单个值。</p>\n<p>下面是一个简单的 JavaScript 函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 ES6 箭头函数，可以以更简洁的方式实现相同的函数。现在就提一下，是因为在接下来会大量用到箭头函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>几乎每种语言都会支持函数调用。</p>\n<p>有些语言更进一步，将函数视为一等公民：可以像使用普通类型的值的方式使用函数。例如：</p>\n<ul>\n<li>使用变量或常量引用函数</li>\n<li>将函数作为参数传递给其他函数</li>\n<li>将函数作为其他函数的返回值</li>\n</ul>\n<p>JavaScript 就是一种这样的语言，我们将利用它的这一优势进行编程。</p>\n<h2>纯函数</h2>\n<p>在进行函数式编程时，使用所谓的 &quot;纯&quot; 函数进行工作将变得非常重要。</p>\n<p><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html\" target=\"_blank\" rel=\"noopener\">纯函数</a>是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 &quot;输出&quot;，不会对数据库进行读写，不会修改输入参数等。</p>\n<p>纯函数的基本思想是：相同的输入，永远会得到相同的输出。</p>\n<p>当然可以用非纯函数编程（而且这也是必须的，如果想让程序做任何有趣的事情），但在大多数情况下，需要保持大部分函数是纯函数。（译者注：并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生）</p>\n<h2>IMMUTABILITY</h2>\n<p>函数式编程的另一个重要概念是 &quot;Immutability&quot;。什么意思呢？&quot;Immutability&quot; 是指 &quot;数据不变性&quot;。</p>\n<p>当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。</p>\n<p>如果想改变数组或对象中的元素时，需要返回一份带有更改值的新拷贝。后面文章将会对此做详细介绍。</p>\n<p>Immutability 和 纯函数息息相关。由于纯函数不允许有副作用，所以不允许更改函数体外部的数据结构。纯函数强制以 immutable 的方式处理数据。</p>\n<h2>从哪里开始呢？</h2>\n<p>开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。</p>\n<p>如果用过具备这些特性的其他语言（如 Ruby、Smalltalk），你可能已经熟悉了这些特性。</p>\n<p>Martin Fowler 有几篇关于 &quot;Collection PipeLines&quot; 非常好的文章，展示了<a href=\"https://martinfowler.com/articles/collection-pipeline/\" target=\"_blank\" rel=\"noopener\">如何使用这些函数</a> 以及<a href=\"https://martinfowler.com/articles/refactoring-pipelines.html\" target=\"_blank\" rel=\"noopener\">如何将现有代码重构为 collection pipelines</a>。</p>\n<p>注意，所有这些函数 <code>Array.prototype</code> 都有（除了 <code>reject</code>）。因此不需要 Ramda 也可以使用它们。但是，为了保持和本系列其他文章一致，本文将使用 Ramda 版本的函数。</p>\n<h2>foreach</h2>\n<p>不必写显式的循环，而是用 <code>forEach</code> 函数代替循环。示例如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Replace this:</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> myArray) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// with:</span></span><br><span class=\"line\">forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(value), myArray)</span><br></pre></td></tr></table></figure></p>\n<p><code>forEach</code> 接受一个函数和一个数组，然后将函数作用于数组的每个元素。</p>\n<p>虽然 <code>forEach</code> 是这些函数中最简单的，但在函数式编程中它可能是最少用到的一个。<code>forEach</code> 没有返回值，所以只能用在有副作用的函数调用中。</p>\n<h2>map</h2>\n<p>下一个要学习的最重要的函数是 <code>map</code>。类似于 <code>forEach</code>，<code>map</code> 也是将函数作用于数组的每个元素。但与 <code>forEach</code> 不同的是，<code>map</code> 将函数的每个返回值组成一个新数组，并将其返回。示例如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">//=&gt; [2, 4, 6]</span></span><br></pre></td></tr></table></figure></p>\n<p>这里使用了匿名函数，但我们也可以在这里使用具名函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span></span><br><span class=\"line\">map(double, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br></pre></td></tr></table></figure></p>\n<h2>filter/reject</h2>\n<p>接下来，我们来看看 <code>filter</code> 和 <code>reject</code>。就像名字所示，<code>filter</code> 会根据断言函数的返回值从数组中选择元素，例如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\">filter(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; [2, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p><code>filter</code> 将断言函数（本例中为 <code>isEven</code>）作用于数组中的每个元素。每当断言函数返回 &quot;真值&quot; 时，相应的元素将包含到结果中；反之当断言函数返回为 &quot;falsy&quot; 值时，相应的元素将从结果数组中排除掉（过滤掉）。</p>\n<p><code>reject</code> 是 <code>filter</code> 的补操作。它保留使断言函数返回 &quot;falsy&quot; 的元素，排除使断言函数返回 &quot;truthy&quot; 的元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reject(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; [1, 3]</span></span><br></pre></td></tr></table></figure></p>\n<h2>find</h2>\n<p><code>find</code> 将断言函数作用于数组中的每个元素，并返回第一个使断言函数返回真值的元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<h2>reduce</h2>\n<p><code>reduce</code> 比之前遇到的其他函数要复杂一些。了解它是值得的，但如果刚开始不太好理解，不要被它挡住。你可以在理解它之前继续学习其他知识。</p>\n<p><code>reduce</code> 接受一个二元函数(<code>reducing function</code>)、一个初始值和待处理的数组。</p>\n<p>归约函数的第一个参数称为 &quot;accumulator&quot; (累加值)，第二个参数取自数组中的元素；返回值为一个新的 &quot;accumulator&quot;。</p>\n<p>先来看一个示例，然后看看会发生什么。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">accum, value</span>) =&gt;</span> accum + value</span><br><span class=\"line\"></span><br><span class=\"line\">reduce(add, <span class=\"number\">5</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><code>reduce</code> 首先将初始值 <code>5</code> 和 数组中的首个元素 <code>1</code> 传入归约函数 <code>add</code>，<code>add</code> 返回一个新的累加值：<code>5 + 1 = 6</code>。</li>\n<li><code>reduce</code> 再次调用 <code>add</code>，这次使用新的累加值 <code>6</code> 和 数组中的下一个元素 <code>2</code> 作为参数，<code>add</code> 返回 <code>8</code>。</li>\n<li><code>reduce</code> 再次使用 <code>8</code> 和 数组中的下个元素 <code>3</code> 来调用 <code>add</code>，输出 <code>11</code>。</li>\n<li><code>reduce</code> 最后一次调用 <code>add</code>，使用 <code>11</code> 和 数组中的最后一个元素 <code>4</code> ，输出 <code>15</code>。</li>\n<li><code>reduce</code> 将最终累加值 <code>15</code> 作为结果返回。</li>\n</ol>\n<h2>结论</h2>\n<p>从这些集合迭代函数开始，需要逐渐习惯将函数传入其他函数的编程方式。你可能在其他语言中用过，但没有意识到正在做函数式编程。</p>\n<h2>下一节</h2>\n<p>本系列的下一篇文章，<a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">函数组合</a> 将演示怎样以新的、有趣的方式对函数进行组合。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Randy Coulman 的 《<a href=\"http://randycoulman.com/blog/2016/05/24/thinking-in-ramda-getting-started/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda: Getting Started</a>》，转载请与<a href=\"https://github.com/randycoulman\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>本文是函数式编程系列文章：<a href=\"https://adispring.coding.me/categories/Thinking-in-Ramda/\" target=\"_blank\" rel=\"noopener\">Thinking in Ramda</a> 的第一篇。</p>\n<p>本系列文章使用 <a href=\"http://ramda.cn\" target=\"_blank\" rel=\"noopener\">Ramda</a> JavaScript 库进行演示。许多理论、方法同样适用于其他函数式 JavaScript 库，如 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lodash</a>。</p>\n<p>我将尽量用通俗、非学术性的语言演示函数式编程。一方面想让更多的人理解该系列文章；另一方面本人在函数式编程方面造诣尚浅。</p>\n<h2>Ramda</h2>\n<p>我已经在博客中多次提到过 <a href=\"http://ramda.cn\" target=\"_blank\" rel=\"noopener\">Ramda</a> JavaScript 库：</p>\n<ul>\n<li>在 <a href=\"http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/\" target=\"_blank\" rel=\"noopener\">Using Ramda With Redux</a> 中，展示了在编写 <a href=\"http://redux.js.org/\" target=\"_blank\" rel=\"noopener\">Redux</a> 应用程序时如何运用 Ramda 的例子。</li>\n<li>在 <a href=\"http://randycoulman.com/blog/2016/04/19/using-redux-api-middleware-with-rails/\" target=\"_blank\" rel=\"noopener\">Using Redux-api-middleware With Rails</a> 中，我使用 Ramda 来转换请求和响应的数据。</li>\n</ul>\n<p>我发现 Ramda 是一个精心设计的库：包含许多 API ，来简洁、优雅进行 JavaScript 函数式编程。</p>\n<p>如果你想在阅读本系列文章时进行 Ramda 实验，Ramda 网站有一个 <a href=\"http://ramda.cn/repl/\" target=\"_blank\" rel=\"noopener\">repl 运行环境</a> 。</p>\n<h2>函数</h2>\n<p>正如名字所示，函数式编程与函数有很大的关系。为了演示，我们定义一个函数为一段可重用的代码：接受 0 到多个参数，返回单个值。</p>\n<p>下面是一个简单的 JavaScript 函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">double</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x * <span class=\"number\">2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>使用 ES6 箭头函数，可以以更简洁的方式实现相同的函数。现在就提一下，是因为在接下来会大量用到箭头函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>几乎每种语言都会支持函数调用。</p>\n<p>有些语言更进一步，将函数视为一等公民：可以像使用普通类型的值的方式使用函数。例如：</p>\n<ul>\n<li>使用变量或常量引用函数</li>\n<li>将函数作为参数传递给其他函数</li>\n<li>将函数作为其他函数的返回值</li>\n</ul>\n<p>JavaScript 就是一种这样的语言，我们将利用它的这一优势进行编程。</p>\n<h2>纯函数</h2>\n<p>在进行函数式编程时，使用所谓的 &quot;纯&quot; 函数进行工作将变得非常重要。</p>\n<p><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch3.html\" target=\"_blank\" rel=\"noopener\">纯函数</a>是没有副作用的函数。它不会给任何外部变量赋值，不会获取输入，不会产生 &quot;输出&quot;，不会对数据库进行读写，不会修改输入参数等。</p>\n<p>纯函数的基本思想是：相同的输入，永远会得到相同的输出。</p>\n<p>当然可以用非纯函数编程（而且这也是必须的，如果想让程序做任何有趣的事情），但在大多数情况下，需要保持大部分函数是纯函数。（译者注：并不是说，要禁止使用一切副作用，而是说，要让它们在可控的范围内发生）</p>\n<h2>IMMUTABILITY</h2>\n<p>函数式编程的另一个重要概念是 &quot;Immutability&quot;。什么意思呢？&quot;Immutability&quot; 是指 &quot;数据不变性&quot;。</p>\n<p>当以 immutable 方式工作时，一旦定义了某个值或对象，以后就再也不会改变它了。这意味着不能更改已有数组中的元素或对象中的属性。</p>\n<p>如果想改变数组或对象中的元素时，需要返回一份带有更改值的新拷贝。后面文章将会对此做详细介绍。</p>\n<p>Immutability 和 纯函数息息相关。由于纯函数不允许有副作用，所以不允许更改函数体外部的数据结构。纯函数强制以 immutable 的方式处理数据。</p>\n<h2>从哪里开始呢？</h2>\n<p>开始以函数式思维思考最简单的方式是，使用集合迭代函数代替循环。</p>\n<p>如果用过具备这些特性的其他语言（如 Ruby、Smalltalk），你可能已经熟悉了这些特性。</p>\n<p>Martin Fowler 有几篇关于 &quot;Collection PipeLines&quot; 非常好的文章，展示了<a href=\"https://martinfowler.com/articles/collection-pipeline/\" target=\"_blank\" rel=\"noopener\">如何使用这些函数</a> 以及<a href=\"https://martinfowler.com/articles/refactoring-pipelines.html\" target=\"_blank\" rel=\"noopener\">如何将现有代码重构为 collection pipelines</a>。</p>\n<p>注意，所有这些函数 <code>Array.prototype</code> 都有（除了 <code>reject</code>）。因此不需要 Ramda 也可以使用它们。但是，为了保持和本系列其他文章一致，本文将使用 Ramda 版本的函数。</p>\n<h2>foreach</h2>\n<p>不必写显式的循环，而是用 <code>forEach</code> 函数代替循环。示例如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Replace this:</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> value <span class=\"keyword\">of</span> myArray) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(value)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\">// with:</span></span><br><span class=\"line\">forEach(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> <span class=\"built_in\">console</span>.log(value), myArray)</span><br></pre></td></tr></table></figure></p>\n<p><code>forEach</code> 接受一个函数和一个数组，然后将函数作用于数组的每个元素。</p>\n<p>虽然 <code>forEach</code> 是这些函数中最简单的，但在函数式编程中它可能是最少用到的一个。<code>forEach</code> 没有返回值，所以只能用在有副作用的函数调用中。</p>\n<h2>map</h2>\n<p>下一个要学习的最重要的函数是 <code>map</code>。类似于 <code>forEach</code>，<code>map</code> 也是将函数作用于数组的每个元素。但与 <code>forEach</code> 不同的是，<code>map</code> 将函数的每个返回值组成一个新数组，并将其返回。示例如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map(<span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]) <span class=\"comment\">//=&gt; [2, 4, 6]</span></span><br></pre></td></tr></table></figure></p>\n<p>这里使用了匿名函数，但我们也可以在这里使用具名函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x * <span class=\"number\">2</span></span><br><span class=\"line\">map(double, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span><br></pre></td></tr></table></figure></p>\n<h2>filter/reject</h2>\n<p>接下来，我们来看看 <code>filter</code> 和 <code>reject</code>。就像名字所示，<code>filter</code> 会根据断言函数的返回值从数组中选择元素，例如：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isEven = <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x % <span class=\"number\">2</span> === <span class=\"number\">0</span></span><br><span class=\"line\">filter(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; [2, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p><code>filter</code> 将断言函数（本例中为 <code>isEven</code>）作用于数组中的每个元素。每当断言函数返回 &quot;真值&quot; 时，相应的元素将包含到结果中；反之当断言函数返回为 &quot;falsy&quot; 值时，相应的元素将从结果数组中排除掉（过滤掉）。</p>\n<p><code>reject</code> 是 <code>filter</code> 的补操作。它保留使断言函数返回 &quot;falsy&quot; 的元素，排除使断言函数返回 &quot;truthy&quot; 的元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reject(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; [1, 3]</span></span><br></pre></td></tr></table></figure></p>\n<h2>find</h2>\n<p><code>find</code> 将断言函数作用于数组中的每个元素，并返回第一个使断言函数返回真值的元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find(isEven, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; 2</span></span><br></pre></td></tr></table></figure></p>\n<h2>reduce</h2>\n<p><code>reduce</code> 比之前遇到的其他函数要复杂一些。了解它是值得的，但如果刚开始不太好理解，不要被它挡住。你可以在理解它之前继续学习其他知识。</p>\n<p><code>reduce</code> 接受一个二元函数(<code>reducing function</code>)、一个初始值和待处理的数组。</p>\n<p>归约函数的第一个参数称为 &quot;accumulator&quot; (累加值)，第二个参数取自数组中的元素；返回值为一个新的 &quot;accumulator&quot;。</p>\n<p>先来看一个示例，然后看看会发生什么。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"function\">(<span class=\"params\">accum, value</span>) =&gt;</span> accum + value</span><br><span class=\"line\"></span><br><span class=\"line\">reduce(add, <span class=\"number\">5</span>, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>]) <span class=\"comment\">//=&gt; 15</span></span><br></pre></td></tr></table></figure></p>\n<ol>\n<li><code>reduce</code> 首先将初始值 <code>5</code> 和 数组中的首个元素 <code>1</code> 传入归约函数 <code>add</code>，<code>add</code> 返回一个新的累加值：<code>5 + 1 = 6</code>。</li>\n<li><code>reduce</code> 再次调用 <code>add</code>，这次使用新的累加值 <code>6</code> 和 数组中的下一个元素 <code>2</code> 作为参数，<code>add</code> 返回 <code>8</code>。</li>\n<li><code>reduce</code> 再次使用 <code>8</code> 和 数组中的下个元素 <code>3</code> 来调用 <code>add</code>，输出 <code>11</code>。</li>\n<li><code>reduce</code> 最后一次调用 <code>add</code>，使用 <code>11</code> 和 数组中的最后一个元素 <code>4</code> ，输出 <code>15</code>。</li>\n<li><code>reduce</code> 将最终累加值 <code>15</code> 作为结果返回。</li>\n</ol>\n<h2>结论</h2>\n<p>从这些集合迭代函数开始，需要逐渐习惯将函数传入其他函数的编程方式。你可能在其他语言中用过，但没有意识到正在做函数式编程。</p>\n<h2>下一节</h2>\n<p>本系列的下一篇文章，<a href=\"https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/\" target=\"_blank\" rel=\"noopener\">函数组合</a> 将演示怎样以新的、有趣的方式对函数进行组合。</p>\n"},{"title":"Transducers Explained: Part 1 中文","date":"2016-10-24T02:10:20.000Z","_content":"\n译者注：本文翻译自 Kevin Beaty 的《[Transducers Explained: Part 1](http://simplectic.com/blog/2014/transducers-explained-1/)》, 转载请与[原作者](https://github.com/kevinbeaty)或[本人](https://github.com/adispring)联系。 \n对原文中出现的专业术语，在不妨碍理解的情况下采用原文单词。\n\nTransduce 相较于 Reduce 的改进，用一句话概括：在使用 Reduce 对每个元素归约之前，先对取出的每个元素进行转换。\n\nTransduce 的时间复杂度为 O(n), 传统 compose + reduce 的为O(mn)，m：compose 中包含 转变函数的个数，n：输入“数组”的长度。\n\n名词解释：\n\n* reduce：归约、折叠。\n* reducer：用来进行 reduce 的二元函数。\n* result：reducer 的首个参数，累积值。\n* item：reducer 的第二个参数，reduce 数组遍历过程中的当前元素。\n\n\n* transduce：transform + reduce。\n* transducer：传入一个transformer，返回一个新的transformer。\n* transformer：封装 *reducer*，返回一个控制 reduce 归约进程的对象 `{ init, step, result }`\n* xf：reduce 函数的首个参数，可以是 *reducer*，也可以是 transformer。\n* stepper：等同于 reducer。\n\n下面开始正文。\n\n---\n\n本文使用 JavaScript 对 transducers 原理进行剖析。首先介绍数组的 reducing(归约) 过程，并以此讲解在 reduce 中用于转换的 transformers；然后逐步引入 transducers，并将其用于 transduce 中。文末会有总结、展望、一些补充链接，以及当前涉及 transducer 的一些库。\n\n**Transducers...**\n\n\n## 什么是 Transducers ？\n\n[原文](http://clojure.org/reference/transducers)解释如下\n\n> Transducers 是可组合的算法变换。它们独立于输入和输出的上下文，并且作为一个独立的单元提供最基本的 transformation。由于 transducers 与输入和输出相解耦，所以它们可以用于许多不同的处理场景：collections, streams, channels, observables（集合、流、管道、观察者模式）等。Transducers 可以直接组合，与输入无关且不会产生额外的中间变量。\n\n**嗯...**\n\n## 还是不太理解\n\n让我们看看相关的代码。当使用 transducers 时，\"算法变换\"函数已经（至少部分）被定义了, 类似于传入 reduce 的 “reducer”。[Clojure 文档](http://clojure.org/reference/transducers) 将这些 \"算法变换\" 称为 *reducers*。这又是什么东西？好吧…… ，让我们从 `Array#reduce` 函数开始讲解。可以先看下 [MDN 的定义](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)。 \n\n## Reduce\n\n> reduce() 方法将一个二元函数作用于一个累积值和数组的每个元素（按从左到右的顺序）， 最终输出为与累积值类型相同的单个值。\n\n更多解释可以参考 [MDN 文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)（译者注：reduce 在某些语言中称为 foldl 左折叠，如 Haskell）。大家对 reduce 可能已经比较熟悉，在此将快速举些例子说明一下。\n\n```js\nconst sum = (result, item) => result + item;\n\nconst mult = (result, item) => result * item;\n\n// 10 (=1+2+3+4)\nconst summed = [2,3,4].reduce(sum, 1);\n\n// 24 (=1*2*3*4)\nconst multed = [2,3,4].reduce(mult, 1);\n```\n\n上述代码中的 *reducers* 是 `sum` 和 `mult`。*reducers* 连同初始值：1，一起传入 `reduce` 中。“输入源”是数组 [2, 3, 4]，“输出源”是通过 reduce 内部实现创建的新数组。\n\n关于 `reduce`， 需要记住的非常重要几点是：\n\n1. 归约（reduce）从输入的初始值开始。\n2. *reducer* 每次对一个元素进行操作，操作过程为：\n    * 初始值作为第一步的累积值\n    * 单步操作函数(*reducers* )的返回值作为下次迭代的累积值\n3. 将最后一次计算结果作为返回值。\n\n注意，在上述两例中，*reducer* 是一个二元函数。*reducer* 第一个参数是由 reduce 函数外部提供的, 其值为传入的初始值或者上次调用 *reducer* 的计算结果。第二个参数是由迭代过程中传入的单个元素。本例中， reduce 对数组中的每个元素进行迭代。我们稍后会看到其他的迭代方式。我们使用 *reducer* 函数来描述 “转换的本质”。\n\n## Transformer\n\n我们来正式实现 *transformer* 的归约过程：\n\n```js\nconst transformer = reducer => ({\n  // 1. 作为 reduce 开始的初始值\n  init: () => 1,\n\n  // 2. 每次输入一个元素，并将本次计算结果\n  //    传给下次迭代的 reducer\n  step: reducer,\n\n  // 3. 将最后一次的计算结果作为最终输出\n  result: result => result,\n});\n```\n\n我们创建一个对象来封装 reducer，并将其命名为名为 `step`；另外还提供了 `init` 函数用来初始化 transformer，`result` 函数来将最后一次计算结果转换为需要的最终输出。注意，在本文中，我们将只关注 `step` 函数，`init` 和 `result` 函数将在后续文章中做深入分析。现在，你可以把它们当作管理 transformation 生命周期的方法：`init` 用于初始化，`step` 用于迭代，`result` 用于输出整个归约结果。\n\n现在，我们来将刚定义的 transformer 运用到 reduce 中。\n\n```js\nconst input = [2,3,4];\n\nconst xf = transformer(sum);\nconst output = input.reduce(xf.step, xf.init());\n// output = 10 (=1+2+3+4)\n\nconst xf = transformer(mult);\nconst output = input.reduce(xf.step, xf.init());\n// output = 24 (=1*2*3*4)\n```\n\n我们的最终目标是将 transformation 与输入和输出解耦，所以现在我们将 `reduce` 定义为函数的形式。\n\n```js\nconst reduce = (xf, init, input) => {\n  let result = input.reduce(xf.step, init);\n  return xf.result(result);\n};\n```\n\n为了使用 reduce ，我们向其传入一个 transformer、初始值和输入源。上述实现结合了 transformer 的 `step` 函数和数组的 reduce 函数，并将 `step` 函数的结果作为输出。本次 reduce 的内部实现仍然假设输入类型为数组。 我们稍后将去掉这个假设。\n\n我们还接受一个 `init` 值作为 reduce 的参数，我们本可以使用 transformer 的 `init`，但是考虑到 reduce 函数的灵活性，需要能够自定义初始值。在实践中，transformer 的 `init` 函数仅在 reduce 未提供初始值的情况下使用。\n\n新 reduce 函数的使用类似于之前的 reduce 。\n\n```js\nconst input = [2,3,4];\nconst xf = transformer(sum);\nconst output = reduce(xf, xf.init(), input);\n// output = 10 (=1+2+3+4)\n\nconst input = [2,3,4];\nconst xf = transformer(mult);\nconst output = reduce(xf, xf.init(), input);\n// output = 24 (=1*2*3*4)\n```\n\n还可以给 reduce 传入初始值。\n\n```js\nconst input = [2,3,4];\nconst xf = transformer(sum);\nconst output = reduce(xf, 2, input);\n// output = 11 (=2+2+3+4)\n\nconst input = [2,3,4];\nconst xf = transformer(mult);\nconst output = reduce(xf, 2, input);\n// output = 48 (=2*2*3*4)\n```\nreduce 函数现在需要一个 transformer。由于 transformer的 `init` 函数未在 reduce 中用到，且 `result` 经常作为单位元(identity、恒等)函数使用：一个直接返回单参数（输入本身）的函数，我们将定义一个辅助函数，来将 *reduceing function* 转换为 transformer，并传入 reduce 使用。\n\n```js\nconst reduce = (xf, init, input) => {\n  if(typeof xf === 'function'){\n    // 确保 reduce 中含有 transformer \n    xf = wrap(xf);\n  }\n  const result = input.reduce(xf.step, init);\n  return xf.result(result);\n}\n\nconst wrap = xf => ({\n  // 1. 我们会显式的传入一个 reduce 的初始值，\n  //    所以这里不再需要内部的 init 函数\n  init: () => {\n    throw new Error('init not supported');\n  },\n\n  // 2. 每次输入一个元素，并将本次计算结果\n  //    传给下次迭代的 reducer\n  step: xf,\n\n  // 3. 将最后一次的计算结果作为输出\n  result: result => result,\n}\n```\n\n首先我们检查参数 `xf` 的类型是否为 function。若是，我们假定它是一个 step function, 并调用 wrap 函数将其转换为 transformer。然后像之前一样调用 reduce 。\n\n现在已经可以直接向 reduce 传递 reducer 了。\n\n```js\nconst input = [2,3,4];\nconst output = reduce(sum, 1, input);\n// output = 10 (=1+2+3+4)\n\nconst input = [2,3,4];\nconst output = reduce(mult, 2, input);\n// output = 48 (=2*2*3*4)\n```\n\n![reduce](./reduce.png)\n\n但我们仍然可以向 reduce 传 transformers。\n\n```js\nconst input = [2,3,4];\nconst xf = wrap(sum);\nconst output = reduce(xf, 2, input);\n// output = 11 (=2+2+3+4)\n\nconst input = [2,3,4];\nconst xf = wrap(mult);\nconst output = reduce(xf, 1, input);\n// output = 24 (=1*2*3*4)\n```\n\n请注意，我们现在可以在外部借助 wrap 直接封装已有的 *reducers* 来创建 transformer。这是使用 transducers 时经常用到的方法：将 transformations 定义为简单的函数，然后使用 transducers 库将其转换为transformer。\n\n## 不一样的数组拷贝\n\n目前，我们一直使用数字作为初始值和算术 *reducers* 的处理元素。其实不一定非要这样，`reduce` 也可以将数组作为处理元素。\n\n```js\nconst append = (result, item) => result.push(item);\n\nconst input = [2,3,4];\nconst output = reduce(append, [], input);\n// output = [2, 3, 4]\n```\n\n我们定义一个步进函数（stepper）`append`，用于将每个元素拷贝到新数组中，并返回该数组。借助 `append`， reduce 便可以创建一份数组的拷贝。\n\n上述操作是否够酷？或许算不上...。当你在将元素添加到输出数组之前先对它变换一下时，情况才变得有趣起来。\n\n## 最孤单的数字\n\n（注：One is the loneliest number，一句英文歌词，引出 `plus1` 转换）\n\n假设我们想要每个元素加1，定义一个加1函数。\n\n```js\nconst plus1 = item => item + 1;\n```\n\n现在创建一个 transformer ，它使用上面的函数在 step 中对每个独立元素进行转换。\n\n```js\nconst xfplus1 = {\n  init: () => { throw new Error('init not needed'); },\n\n  step: (result, item) => {\n    const plus1ed = plus1(item);\n    return append(result, plus1ed);\n  },\n  // step: (result, item) => append(result, plus1(item)),\n  \n  result: result => result,\n}\n```\n\n可以使用 transformer 逐步遍历并输出每步结果\n\n```js\nconst xf = xfplus1;\nconst init = [];\nlet result = xf.step(init, 2);\n// [3] (=append([], 2+1)))\n\nresult = xf.step(result, 3);\n// [3,4] (=append([3], 3+1)))\n\nresult = xf.step(result, 4);\n// [3,4,5] (=append([3,4], 4+1)))\n\nconst output = xf.result(result);\n// [3,4,5]\n```\n\n因此，我们使用一个 transformer 来遍历元素：将每个元素加1后添加到输出数组中。\n\n如果我们想要每个元素加1 后的总和，该怎么办呢？可以使用 reduce 。\n\n```js\nconst output = reduce(sum, 0, output);\n// 12 (=0+3+4+5)\n```\n\n上述方案虽然可行，但不幸的是，我们在获得最终答案的过程中，不得不创建一个中间数组。 有更好的方案吗？\n\n事实上是有的。回顾上面的 `xfplus1` ，如果我们将 `append` 调用换为 `sum` 调用，并且以 0 作为初始值，就可以定义一个不会产生中间数组，但直接对元素求和的 transformer。\n\n但是，有时我们想立即查看替换 *reducer* 后的结果，因为中间涉及的唯一变化就是将 `append` 替换为 `sum`。因此我们希望有一个能够创建 transformation 的函数，该函数不依赖于用于组合中间结果的 transformer。\n\n```js\nconst transducerPlus1 = (xf) => ({\n  init: () => xf.init(),\n  step: (result, item) => {\n    const plus1ed = plus1(item);\n    return xf.step(result, plus1ed);\n  },\n  result: result => result,\n});\n```\n\n该函数接受一个 transformer：`xf`，返回一个基于 `xf` 的新的 transformer。新 transformer 将经由 `plus1` 转换后的结果代理给 `xf`。由于我们可以使用 `step` 函数完全定义这个 transformation，新的 transformer 的 `xf` 只需 `init` 和 `result`。每次迭代时，先将每个元素进行 `plus1` 转换，然后调用封装过的 transformer 内部的 `step` 函数。\n\n## Transducer\n\n我们刚刚创建了第一个 transducer：一个接受现有 transformer，并返回新 transformer 的函数。新 transformer 会改变原有 transformation 的行为，transducer 会将一些额外的处理委托给新的封装过的 transformer。\n\n让我们实践一下，首先用刚才的 transducer 来重新实现前面的例子。\n\n```js\nconst stepper = wrap(append);\nconst init = [];\nconst transducer = transducerPlus1;\nconst xf = transducer(stepper);\nlet result = xf.step(init, 2);\n// [3] (=append([], 2+1)))\n\nresult = xf.step(result, 3);\n// [3,4] (=append([3], 3+1)))\n\nresult = xf.step(result, 4);\n// [3,4,5] (=append([3,4], 4+1)))\n\nconst output = xf.result(result);\n// [3,4,5]\n```\n\n运行过程和结果与之前相同，很好。唯一的区别是 transformer：`xf` 的创建。我们使用 `wrap` 将 `append` 转换成名为 `stepper` 的 transformer，然后使用 transducer 封装这个 stepper 并返回一个 `plus1` 转换。然后我们就可以像从前一样使用转换函数：xf 对每个元素逐步操作，并得到结果。\n\n## 中间辅助元素\n\n从现在开始，事情变得有趣起来：我们可以用相同的 transducer 来获得最终的累加和，不需要中间辅助数组，只需改变 stepper 和初始值。\n\n```js\nconst stepper = wrap(sum);\nconst init = 0;\nconst transducer = transducerPlus1;\nconst xf = transducer(stepper);\nlet result = xf.step(init, 2);\n// 3 (=sum(0, 2+1)))\n\nresult = xf.step(result, 3);\n// 7 (=sum(3, 3+1)))\n\nresult = xf.step(result, 4);\n// 12 (=sum(7, 4+1)))\n\nconst output = xf.result(result);\n// 12\n```\n\n不需要计算中间数组，一次迭代就可以得到结果。`sum` 与之前 `append` 例子只有两处不同：\n\n* 创建 stepper 时，用 sum 代替 append 进行封装。\n* 初始值使用 0 代替 []。\n\n仅此两处差异，其他完全一样。\n\n需要注意的是，只有 `stepper` 转换知道 `result` 的数据类型。当封装 `sum` 时，结果类型为数字，封装 `append` 时，结果是数组。初始值类型与 stepper 的 `result` 参数类型相同。被处理的单个元素的类型不限，因为 stepper 知道如何组合上次输出的结果和新的元素，并返回一个新的组合的结果，本次输出结果可能会用于下次迭代中的组合，如此迭代循环。\n\n这些特性允许我们定义独立于输出的 transformation 。\n\n## 可能会变糟\n\n(注：第二句歌词，Can be as bad as one，作者意思应该是，如果 `plus2` 还跟 `plus1` 一样从头重新实现一遍，就比较坑了)\n\n假如我们想要在归约之前 `plus2`，需要改变哪些地方呢？我们可以定义一个类似于 `transducerPlus1` 的新的 `transducerPlus2` 。回头看一下 `transducerPlus1` 是如何实现的，并决定哪些地方需要更改。但这样做违反了 DRY 原则。\n\n有更好的方案吗？\n\n实际上，除了将 step 的值用 `plus2` 替换掉 `plus1` 以外，其他都是一样的。\n\n让我们将 `plus1` 提取出来，并将其作为函数 `f` 进行传递。\n\n```js\nconst map = f => xf => ({\n  init: () => xf.init(),\n  step: (result, item) => {\n    const mapped = f(item);\n    return xf.step(result, mapped);\n  },\n  result: result => xf.result(result),\n});\n```\n\n我们定义了 mapping transducer，让我们使用它来逐步转换。\n\n```js\nconst plus2 = (input) => input + 2;\nconst transducer = map(plus2);\nconst stepper = wrap(append);\nconst xf = transducer(stepper);\nconst init = [];\nlet result = xf.step(init, 2);\n// [4] (=append([], 2+2)))\n\nresult = xf.step(result, 3);\n// [4,5] (=append([4], 3+2)))\n\nresult = xf.step(result, 4);\n// [4,5,6] (=append([4,5], 4+1)))\n\nconst output = xf.result(result);\n// [4,5,6]\n```\n\n本例相较于之前使用`plus1` 和 `append` 函数的例子，唯一的区别在于使用 `map` 创建 transducer。我们可以类似地使用 `map(plus1)` 来创建 `plus1` transducer。`transducerPlus1` 虽然只是短暂的出现便被 `map(plus1)` 代替，但它对我们理解 transduce 的内部原理帮助很大。\n\n## Transduce\n\n前面的示例讲解了使用 transducers 手动转换一系列的输入。让我们进一步优化。\n\n首先通过调用一个包含 stepper 转换的 transducer 来初始化 transformation，并定义 transduce 的初始值。\n\n```js\nconst transducer = map(plus1);\nconst stepper = wrap(append);\nconst xf = transducer(stepper);\nconst init = [];\n```\n\n然后使用 *reducer* `xf.step` 来遍历每个输入元素。将初始值作为 step 函数的第一个 `result` 参数（另一个是输入源中的元素），上一个 step 函数的返回值供所有后续元素迭代使用。\n\n```js\nlet result = xf.step(init, 2);\n// [3] (=append([], 2+1)))\n\nresult = xf.step(result, 3);\n// [3,4] (=append([3], 3+1)))\n\nresult = xf.step(result, 4);\n// [3,4,5] (=append([3,4], 4+1)))\n```\n\n我们使用 `xf.result` 输出最终结果。\n\n```js\nconst output = xf.result(result);\n// [3,4,5]\n```\n\n可能你已经注意到了，这与上面定义的 `reduce` 实现非常相似。 事实也是如此。 我们可以将这个过程封装成一个新的函数 `transduce`。\n\n```js\nconst transduce = (transducer, stepper, init, input) => {\n  if(typeof stepper === 'function'){\n    // 确保存在用于步进（迭代）的 transformer\n    stepper = wrap(stepper);\n  }\n\n  // 传入 stepper 来创建 transformer：xf\n  const xf = transducer(stepper);\n  // xf 现在成为一个 transformer\n  // 现在可以使用上面定义的 reduce 来迭代并\n  // （在迭代之前）变换输入元素\n  return reduce(xf, init, input);\n};\n```\n\n就像 reduce，我们需要确保 stepper 是一个 transformer。然后通过向 transducer 传入 stepper 来创建新的 transformer。 最后，我们使用包含新的 transformer 的 reduce 来进行迭代和转换结果。也就是说 transducer 的函数类型为：transformer -> transformer。\n\n我们来实践一下。\n\n```js\nconst transducer = map(plus1);\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [3,4,5]\n\nconst transducer = map(plus2);\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [4,5,6]\n```\n\n上述两例的唯一区别是传递给 map 的函数不同。\n\n我们来尝试一下不同的 step function 和初始值。\n\n```js\nconst transducer = map(plus1);\nconst stepper = sum;\nconst init = 0;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 12 (=3+4+5)\n\nconst transducer = map(plus2);\nconst stepper = sum;\nconst init = 0;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 15 (=4+5+6)\n\nconst transducer = map(plus1);\nconst stepper = mult;\nconst init = 1;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 60 (=3*4*5)\n\nconst transducer = map(plus2);\nconst stepper = mult;\nconst init = 1;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 120 (=4*5*6)\n```\n\n![transduce](./transduce.png)\n\n这里我们只是改变了 stepper 和初始值，便可以得到不同的结果。我们可以在不依赖中间变量的情况下，遍历一次便可求得累加和或乘积。\n\n## 组合\n\n如果我们想加3，改怎么办呢？我们可以定义 `plus3` 并且使用 `map`，但更好的方法是利用 transducers 的一个特性。\n\n事实上，我们可以通过其他两个函数：`plus1` 和 `plus2`，来定义 `plus3`。\n\n```js\nconst plus3 = item => puls2(plus1(item));\n```\n\n或许你已经看出来，其实这就是[函数组合](https://en.wikipedia.org/wiki/Function_composition_%28computer_science%29)。让我们通过函数组合来重新定义 `plus3`。\n\n```js\nconst compose2 = (fn1, fn2) => item => fn1(fn2(item));\n\nconst plus3 = compose2(plus1, plus2);\n\nconst output = [plus3(2), plus3(3), plus3(4)];\n// [5,6,7]\n```\n\n`compose2` 用于组合两个函数，调用顺序从右向左，看一下 `compose2` 的实现就可以知道为什么调用顺序是从右向左的了。最后一个 function 接受传入参数，返回结果作为下个 function 的输入。如此迭代，直到输出结果。\n\n让我们使用 `compose2` 来定义一个 transducer，该 transducer 由 `plus1` 和 `plus2` 组合而成，用于将每个迭代的元素加3。\n\n```js\nconst transducerPlus3 = map(compose2(plus1, plus2));\nconst transducer = transducerPlus3;\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [5,6,7]\n```\n\n我们使用“函数组合”来组合 `plus1` 和 `plus2` 而不是重新定义 `plus3`，来组合出传入 map 的加3操作。\n\n将上述这些的目的是什么呢？实际上，我们可以通过组合其他的 transducers 来创建新的 transducers。\n\n```js\nconst transducerPlus1 = map(plus1);\nconst transducerPlus2 = map(plus2);\nconst transducerPlus3 = compose2(transducerPlus1, transducerPlus2);\nconst transducer = transducerPlus3;\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [5,6,7]\n```\n\n新组合出来的 transducer 可以用于组合其他的 transducer 。\n\n```js\nconst transducerPlus1 = map(plus1);\nconst transducerPlus2 = map(plus2);\nconst transducerPlus3 = compose2(transducerPlus1, transducerPlus2);\nconst transducerPlus4 = compose2(transducerPlus3, transducerPlus1);\nconst transducer = transducerPlus4;\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n```\n![compose_transducers](./compose_transducers.png)\n\n再次注意，与本节前面的例子的唯一区别是 transducer 的创建。其它都没变。\n\n组合之所以能工作，是因为 transducers 的定义：接受一个 transformer 并返回一个新的 transformer。也即 transducer 的输入与返回值类型相同，且为单输入单输出。只要符合上述条件，便可以使用函数组合来创建与“输入函数”相同类型的“新函数”。\n\n由上可得，transducers 是一种 “可组合的算法变换”。这在实践中已经证明其强大之处：可以将新的变换定义为一系列较小变换的组合，然后将它们通过 `compose` 或 `pipe` 组合起来。我们将在后续章节中展示更多的例子。\n\n事实上，虽然函数组合调用顺序为由右向左，而 transformation 调用是自左向右的（译者注：这也是理解 transduce 的难点之一，理解了这个，也就基本理解了 transduce。可以通过单个 transducer 和 transformer 的组合，来理解 transformation 的调用顺序。transduce 本质上做的事情是 **在对每个元素进行归约之前先对其进行变换** ，将这句话重复五遍：），这也是 transduce 区别于 reduce 的“唯一”不同点）。\n\n在上面的 `transducersPlus4` 示例中，每个元素先进行 `plus3` 转换，然后进行 `plus1` 转换。\n\n虽然在本例中 transducers 的调用顺序对结果没有影响，但是**从左向右**的变换顺序还是需要牢记在心。这个变换调用顺序让你在阅读代码时更容易理解，因为它与你的阅读顺序是一至的（如果使用的是英文，或者中文）。\n\n## part 1 总结\n\nTransducers 将 “可组合的算法转换” 抽象出来，使其独立于输入、输出，甚至迭代的整个过程。\n\n本文演示了如何使用 transducers 来抽象算法转换，transducer 将一个 transformer 转换为另一个 transformer。transformer 可以用于 transduce 进行迭代和转换输入源。\n\n相较于 [Underscore.js](http://underscorejs.org/) 或 [Lo-Dash](https://lodash.com/)对数组和计算中间结果的对象进行操作，transducers 定义的 transformation 在函数方面类似于传递给 reduce 的 stepping function：将初始值作为首次迭代的“结果参数”，执行输入为一个“结果参数”和元素的函数，返回可能变换过的结果，并将其作为下次迭代的“结果参数”。一旦将 transformation 从数据中抽象出来，就可以将相同的 transformations 应用于以某初始值开始并遍历某个“累积结果”的不同处理过程。\n\n我们已经展示了相同的 transducers 可以操作不同的“输出源”，只需改变创建 transducer 时用到的初始值和 stepper。这种抽象的好处之一是：可以遍历一次得到结果，且没有中间数组产生。\n\n尽管没有明确说明，我们还是展示了 transducers 将 transducer 与 迭代过程及输入源解耦。在迭代过程中，我们使用相同的 transducer 对元素进行转换，并将转换结果传给 step function，我们使用数组的 reduce 从数组中获取数据。\n\n## 还想了解更多！\n\n[看这里](http://simplectic.com/blog/2014/transducers-explained-pipelines/) ,以后的文章中将会进一步讨论 transducers 并不会每步都输出元素；并且可能会提前终止迭代，并返回终止前已经归约的结果。本文只讨论了 step，未讨论 init 和 result，将来会有补充。\n\n我们将会了解到，输入源可以是任意产生一系列值的东西：惰性列表，不确定的序列生成器，CSP（通信顺序进程），[Node.js streams](https://github.com/transduce/transduce-stream)\nlazy lists, indefinite sequence generation, CSP[http://phuu.net/2014/08/31/csp-and-transducers.html), [push streams][12], [Node.js streams](https://github.com/transduce/transduce-stream), iterators, generators, immutable-js data structures, 等等。\n\n## 等不及了！\n\n在此期间，可以查看 [Clojure文档](http://clojure.org/transducers), 或者观看[视频](https://www.youtube.com/watch?v=6mTbuzafcII)或这篇[文章](http://phuu.net/2014/08/31/csp-and-transducers.html)，还有其他更多更好的介绍，可以自行 Google 。\n\n想要立刻实践一下？已经有三个库实现了相似的API：[transducers-js](https://github.com/cognitect-labs/transducers-js)、[transducers.js](https://github.com/jlongster/transducers.js)、[ramda](https://github.com/ramda/ramda/blob/v0.22.1/src/transduce.js)(译者注：ramda 中 transducer 部分也是本文作者写的）。本文介绍与 transducers-js 实现类似，但概念同样适用于 transducers.js。\n\n[Underscore.js](http://underscorejs.org/) 的粉丝？可以查看 [underarm](http://simplectic.com/projects/underarm/)，基于 [transduce](https://github.com/transduce/transduce) 库（译者注：本文作者写的库）写的。\n\n怎样将 transducer 应用到 [Node.js streams](https://github.com/transduce/transduce-stream) 中呢？我们还在探索。\n\n希望得到新文章的通知？可以在 Twitter 上关注 [simplectic](https://twitter.com/simplectic)。\n\n","source":"_posts/Transducers-Explained-Part-1.md","raw":"---\ntitle: 'Transducers Explained: Part 1 中文'\ndate: 2016-10-24 10:10:20\ntags:\n---\n\n译者注：本文翻译自 Kevin Beaty 的《[Transducers Explained: Part 1](http://simplectic.com/blog/2014/transducers-explained-1/)》, 转载请与[原作者](https://github.com/kevinbeaty)或[本人](https://github.com/adispring)联系。 \n对原文中出现的专业术语，在不妨碍理解的情况下采用原文单词。\n\nTransduce 相较于 Reduce 的改进，用一句话概括：在使用 Reduce 对每个元素归约之前，先对取出的每个元素进行转换。\n\nTransduce 的时间复杂度为 O(n), 传统 compose + reduce 的为O(mn)，m：compose 中包含 转变函数的个数，n：输入“数组”的长度。\n\n名词解释：\n\n* reduce：归约、折叠。\n* reducer：用来进行 reduce 的二元函数。\n* result：reducer 的首个参数，累积值。\n* item：reducer 的第二个参数，reduce 数组遍历过程中的当前元素。\n\n\n* transduce：transform + reduce。\n* transducer：传入一个transformer，返回一个新的transformer。\n* transformer：封装 *reducer*，返回一个控制 reduce 归约进程的对象 `{ init, step, result }`\n* xf：reduce 函数的首个参数，可以是 *reducer*，也可以是 transformer。\n* stepper：等同于 reducer。\n\n下面开始正文。\n\n---\n\n本文使用 JavaScript 对 transducers 原理进行剖析。首先介绍数组的 reducing(归约) 过程，并以此讲解在 reduce 中用于转换的 transformers；然后逐步引入 transducers，并将其用于 transduce 中。文末会有总结、展望、一些补充链接，以及当前涉及 transducer 的一些库。\n\n**Transducers...**\n\n\n## 什么是 Transducers ？\n\n[原文](http://clojure.org/reference/transducers)解释如下\n\n> Transducers 是可组合的算法变换。它们独立于输入和输出的上下文，并且作为一个独立的单元提供最基本的 transformation。由于 transducers 与输入和输出相解耦，所以它们可以用于许多不同的处理场景：collections, streams, channels, observables（集合、流、管道、观察者模式）等。Transducers 可以直接组合，与输入无关且不会产生额外的中间变量。\n\n**嗯...**\n\n## 还是不太理解\n\n让我们看看相关的代码。当使用 transducers 时，\"算法变换\"函数已经（至少部分）被定义了, 类似于传入 reduce 的 “reducer”。[Clojure 文档](http://clojure.org/reference/transducers) 将这些 \"算法变换\" 称为 *reducers*。这又是什么东西？好吧…… ，让我们从 `Array#reduce` 函数开始讲解。可以先看下 [MDN 的定义](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)。 \n\n## Reduce\n\n> reduce() 方法将一个二元函数作用于一个累积值和数组的每个元素（按从左到右的顺序）， 最终输出为与累积值类型相同的单个值。\n\n更多解释可以参考 [MDN 文档](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)（译者注：reduce 在某些语言中称为 foldl 左折叠，如 Haskell）。大家对 reduce 可能已经比较熟悉，在此将快速举些例子说明一下。\n\n```js\nconst sum = (result, item) => result + item;\n\nconst mult = (result, item) => result * item;\n\n// 10 (=1+2+3+4)\nconst summed = [2,3,4].reduce(sum, 1);\n\n// 24 (=1*2*3*4)\nconst multed = [2,3,4].reduce(mult, 1);\n```\n\n上述代码中的 *reducers* 是 `sum` 和 `mult`。*reducers* 连同初始值：1，一起传入 `reduce` 中。“输入源”是数组 [2, 3, 4]，“输出源”是通过 reduce 内部实现创建的新数组。\n\n关于 `reduce`， 需要记住的非常重要几点是：\n\n1. 归约（reduce）从输入的初始值开始。\n2. *reducer* 每次对一个元素进行操作，操作过程为：\n    * 初始值作为第一步的累积值\n    * 单步操作函数(*reducers* )的返回值作为下次迭代的累积值\n3. 将最后一次计算结果作为返回值。\n\n注意，在上述两例中，*reducer* 是一个二元函数。*reducer* 第一个参数是由 reduce 函数外部提供的, 其值为传入的初始值或者上次调用 *reducer* 的计算结果。第二个参数是由迭代过程中传入的单个元素。本例中， reduce 对数组中的每个元素进行迭代。我们稍后会看到其他的迭代方式。我们使用 *reducer* 函数来描述 “转换的本质”。\n\n## Transformer\n\n我们来正式实现 *transformer* 的归约过程：\n\n```js\nconst transformer = reducer => ({\n  // 1. 作为 reduce 开始的初始值\n  init: () => 1,\n\n  // 2. 每次输入一个元素，并将本次计算结果\n  //    传给下次迭代的 reducer\n  step: reducer,\n\n  // 3. 将最后一次的计算结果作为最终输出\n  result: result => result,\n});\n```\n\n我们创建一个对象来封装 reducer，并将其命名为名为 `step`；另外还提供了 `init` 函数用来初始化 transformer，`result` 函数来将最后一次计算结果转换为需要的最终输出。注意，在本文中，我们将只关注 `step` 函数，`init` 和 `result` 函数将在后续文章中做深入分析。现在，你可以把它们当作管理 transformation 生命周期的方法：`init` 用于初始化，`step` 用于迭代，`result` 用于输出整个归约结果。\n\n现在，我们来将刚定义的 transformer 运用到 reduce 中。\n\n```js\nconst input = [2,3,4];\n\nconst xf = transformer(sum);\nconst output = input.reduce(xf.step, xf.init());\n// output = 10 (=1+2+3+4)\n\nconst xf = transformer(mult);\nconst output = input.reduce(xf.step, xf.init());\n// output = 24 (=1*2*3*4)\n```\n\n我们的最终目标是将 transformation 与输入和输出解耦，所以现在我们将 `reduce` 定义为函数的形式。\n\n```js\nconst reduce = (xf, init, input) => {\n  let result = input.reduce(xf.step, init);\n  return xf.result(result);\n};\n```\n\n为了使用 reduce ，我们向其传入一个 transformer、初始值和输入源。上述实现结合了 transformer 的 `step` 函数和数组的 reduce 函数，并将 `step` 函数的结果作为输出。本次 reduce 的内部实现仍然假设输入类型为数组。 我们稍后将去掉这个假设。\n\n我们还接受一个 `init` 值作为 reduce 的参数，我们本可以使用 transformer 的 `init`，但是考虑到 reduce 函数的灵活性，需要能够自定义初始值。在实践中，transformer 的 `init` 函数仅在 reduce 未提供初始值的情况下使用。\n\n新 reduce 函数的使用类似于之前的 reduce 。\n\n```js\nconst input = [2,3,4];\nconst xf = transformer(sum);\nconst output = reduce(xf, xf.init(), input);\n// output = 10 (=1+2+3+4)\n\nconst input = [2,3,4];\nconst xf = transformer(mult);\nconst output = reduce(xf, xf.init(), input);\n// output = 24 (=1*2*3*4)\n```\n\n还可以给 reduce 传入初始值。\n\n```js\nconst input = [2,3,4];\nconst xf = transformer(sum);\nconst output = reduce(xf, 2, input);\n// output = 11 (=2+2+3+4)\n\nconst input = [2,3,4];\nconst xf = transformer(mult);\nconst output = reduce(xf, 2, input);\n// output = 48 (=2*2*3*4)\n```\nreduce 函数现在需要一个 transformer。由于 transformer的 `init` 函数未在 reduce 中用到，且 `result` 经常作为单位元(identity、恒等)函数使用：一个直接返回单参数（输入本身）的函数，我们将定义一个辅助函数，来将 *reduceing function* 转换为 transformer，并传入 reduce 使用。\n\n```js\nconst reduce = (xf, init, input) => {\n  if(typeof xf === 'function'){\n    // 确保 reduce 中含有 transformer \n    xf = wrap(xf);\n  }\n  const result = input.reduce(xf.step, init);\n  return xf.result(result);\n}\n\nconst wrap = xf => ({\n  // 1. 我们会显式的传入一个 reduce 的初始值，\n  //    所以这里不再需要内部的 init 函数\n  init: () => {\n    throw new Error('init not supported');\n  },\n\n  // 2. 每次输入一个元素，并将本次计算结果\n  //    传给下次迭代的 reducer\n  step: xf,\n\n  // 3. 将最后一次的计算结果作为输出\n  result: result => result,\n}\n```\n\n首先我们检查参数 `xf` 的类型是否为 function。若是，我们假定它是一个 step function, 并调用 wrap 函数将其转换为 transformer。然后像之前一样调用 reduce 。\n\n现在已经可以直接向 reduce 传递 reducer 了。\n\n```js\nconst input = [2,3,4];\nconst output = reduce(sum, 1, input);\n// output = 10 (=1+2+3+4)\n\nconst input = [2,3,4];\nconst output = reduce(mult, 2, input);\n// output = 48 (=2*2*3*4)\n```\n\n![reduce](./reduce.png)\n\n但我们仍然可以向 reduce 传 transformers。\n\n```js\nconst input = [2,3,4];\nconst xf = wrap(sum);\nconst output = reduce(xf, 2, input);\n// output = 11 (=2+2+3+4)\n\nconst input = [2,3,4];\nconst xf = wrap(mult);\nconst output = reduce(xf, 1, input);\n// output = 24 (=1*2*3*4)\n```\n\n请注意，我们现在可以在外部借助 wrap 直接封装已有的 *reducers* 来创建 transformer。这是使用 transducers 时经常用到的方法：将 transformations 定义为简单的函数，然后使用 transducers 库将其转换为transformer。\n\n## 不一样的数组拷贝\n\n目前，我们一直使用数字作为初始值和算术 *reducers* 的处理元素。其实不一定非要这样，`reduce` 也可以将数组作为处理元素。\n\n```js\nconst append = (result, item) => result.push(item);\n\nconst input = [2,3,4];\nconst output = reduce(append, [], input);\n// output = [2, 3, 4]\n```\n\n我们定义一个步进函数（stepper）`append`，用于将每个元素拷贝到新数组中，并返回该数组。借助 `append`， reduce 便可以创建一份数组的拷贝。\n\n上述操作是否够酷？或许算不上...。当你在将元素添加到输出数组之前先对它变换一下时，情况才变得有趣起来。\n\n## 最孤单的数字\n\n（注：One is the loneliest number，一句英文歌词，引出 `plus1` 转换）\n\n假设我们想要每个元素加1，定义一个加1函数。\n\n```js\nconst plus1 = item => item + 1;\n```\n\n现在创建一个 transformer ，它使用上面的函数在 step 中对每个独立元素进行转换。\n\n```js\nconst xfplus1 = {\n  init: () => { throw new Error('init not needed'); },\n\n  step: (result, item) => {\n    const plus1ed = plus1(item);\n    return append(result, plus1ed);\n  },\n  // step: (result, item) => append(result, plus1(item)),\n  \n  result: result => result,\n}\n```\n\n可以使用 transformer 逐步遍历并输出每步结果\n\n```js\nconst xf = xfplus1;\nconst init = [];\nlet result = xf.step(init, 2);\n// [3] (=append([], 2+1)))\n\nresult = xf.step(result, 3);\n// [3,4] (=append([3], 3+1)))\n\nresult = xf.step(result, 4);\n// [3,4,5] (=append([3,4], 4+1)))\n\nconst output = xf.result(result);\n// [3,4,5]\n```\n\n因此，我们使用一个 transformer 来遍历元素：将每个元素加1后添加到输出数组中。\n\n如果我们想要每个元素加1 后的总和，该怎么办呢？可以使用 reduce 。\n\n```js\nconst output = reduce(sum, 0, output);\n// 12 (=0+3+4+5)\n```\n\n上述方案虽然可行，但不幸的是，我们在获得最终答案的过程中，不得不创建一个中间数组。 有更好的方案吗？\n\n事实上是有的。回顾上面的 `xfplus1` ，如果我们将 `append` 调用换为 `sum` 调用，并且以 0 作为初始值，就可以定义一个不会产生中间数组，但直接对元素求和的 transformer。\n\n但是，有时我们想立即查看替换 *reducer* 后的结果，因为中间涉及的唯一变化就是将 `append` 替换为 `sum`。因此我们希望有一个能够创建 transformation 的函数，该函数不依赖于用于组合中间结果的 transformer。\n\n```js\nconst transducerPlus1 = (xf) => ({\n  init: () => xf.init(),\n  step: (result, item) => {\n    const plus1ed = plus1(item);\n    return xf.step(result, plus1ed);\n  },\n  result: result => result,\n});\n```\n\n该函数接受一个 transformer：`xf`，返回一个基于 `xf` 的新的 transformer。新 transformer 将经由 `plus1` 转换后的结果代理给 `xf`。由于我们可以使用 `step` 函数完全定义这个 transformation，新的 transformer 的 `xf` 只需 `init` 和 `result`。每次迭代时，先将每个元素进行 `plus1` 转换，然后调用封装过的 transformer 内部的 `step` 函数。\n\n## Transducer\n\n我们刚刚创建了第一个 transducer：一个接受现有 transformer，并返回新 transformer 的函数。新 transformer 会改变原有 transformation 的行为，transducer 会将一些额外的处理委托给新的封装过的 transformer。\n\n让我们实践一下，首先用刚才的 transducer 来重新实现前面的例子。\n\n```js\nconst stepper = wrap(append);\nconst init = [];\nconst transducer = transducerPlus1;\nconst xf = transducer(stepper);\nlet result = xf.step(init, 2);\n// [3] (=append([], 2+1)))\n\nresult = xf.step(result, 3);\n// [3,4] (=append([3], 3+1)))\n\nresult = xf.step(result, 4);\n// [3,4,5] (=append([3,4], 4+1)))\n\nconst output = xf.result(result);\n// [3,4,5]\n```\n\n运行过程和结果与之前相同，很好。唯一的区别是 transformer：`xf` 的创建。我们使用 `wrap` 将 `append` 转换成名为 `stepper` 的 transformer，然后使用 transducer 封装这个 stepper 并返回一个 `plus1` 转换。然后我们就可以像从前一样使用转换函数：xf 对每个元素逐步操作，并得到结果。\n\n## 中间辅助元素\n\n从现在开始，事情变得有趣起来：我们可以用相同的 transducer 来获得最终的累加和，不需要中间辅助数组，只需改变 stepper 和初始值。\n\n```js\nconst stepper = wrap(sum);\nconst init = 0;\nconst transducer = transducerPlus1;\nconst xf = transducer(stepper);\nlet result = xf.step(init, 2);\n// 3 (=sum(0, 2+1)))\n\nresult = xf.step(result, 3);\n// 7 (=sum(3, 3+1)))\n\nresult = xf.step(result, 4);\n// 12 (=sum(7, 4+1)))\n\nconst output = xf.result(result);\n// 12\n```\n\n不需要计算中间数组，一次迭代就可以得到结果。`sum` 与之前 `append` 例子只有两处不同：\n\n* 创建 stepper 时，用 sum 代替 append 进行封装。\n* 初始值使用 0 代替 []。\n\n仅此两处差异，其他完全一样。\n\n需要注意的是，只有 `stepper` 转换知道 `result` 的数据类型。当封装 `sum` 时，结果类型为数字，封装 `append` 时，结果是数组。初始值类型与 stepper 的 `result` 参数类型相同。被处理的单个元素的类型不限，因为 stepper 知道如何组合上次输出的结果和新的元素，并返回一个新的组合的结果，本次输出结果可能会用于下次迭代中的组合，如此迭代循环。\n\n这些特性允许我们定义独立于输出的 transformation 。\n\n## 可能会变糟\n\n(注：第二句歌词，Can be as bad as one，作者意思应该是，如果 `plus2` 还跟 `plus1` 一样从头重新实现一遍，就比较坑了)\n\n假如我们想要在归约之前 `plus2`，需要改变哪些地方呢？我们可以定义一个类似于 `transducerPlus1` 的新的 `transducerPlus2` 。回头看一下 `transducerPlus1` 是如何实现的，并决定哪些地方需要更改。但这样做违反了 DRY 原则。\n\n有更好的方案吗？\n\n实际上，除了将 step 的值用 `plus2` 替换掉 `plus1` 以外，其他都是一样的。\n\n让我们将 `plus1` 提取出来，并将其作为函数 `f` 进行传递。\n\n```js\nconst map = f => xf => ({\n  init: () => xf.init(),\n  step: (result, item) => {\n    const mapped = f(item);\n    return xf.step(result, mapped);\n  },\n  result: result => xf.result(result),\n});\n```\n\n我们定义了 mapping transducer，让我们使用它来逐步转换。\n\n```js\nconst plus2 = (input) => input + 2;\nconst transducer = map(plus2);\nconst stepper = wrap(append);\nconst xf = transducer(stepper);\nconst init = [];\nlet result = xf.step(init, 2);\n// [4] (=append([], 2+2)))\n\nresult = xf.step(result, 3);\n// [4,5] (=append([4], 3+2)))\n\nresult = xf.step(result, 4);\n// [4,5,6] (=append([4,5], 4+1)))\n\nconst output = xf.result(result);\n// [4,5,6]\n```\n\n本例相较于之前使用`plus1` 和 `append` 函数的例子，唯一的区别在于使用 `map` 创建 transducer。我们可以类似地使用 `map(plus1)` 来创建 `plus1` transducer。`transducerPlus1` 虽然只是短暂的出现便被 `map(plus1)` 代替，但它对我们理解 transduce 的内部原理帮助很大。\n\n## Transduce\n\n前面的示例讲解了使用 transducers 手动转换一系列的输入。让我们进一步优化。\n\n首先通过调用一个包含 stepper 转换的 transducer 来初始化 transformation，并定义 transduce 的初始值。\n\n```js\nconst transducer = map(plus1);\nconst stepper = wrap(append);\nconst xf = transducer(stepper);\nconst init = [];\n```\n\n然后使用 *reducer* `xf.step` 来遍历每个输入元素。将初始值作为 step 函数的第一个 `result` 参数（另一个是输入源中的元素），上一个 step 函数的返回值供所有后续元素迭代使用。\n\n```js\nlet result = xf.step(init, 2);\n// [3] (=append([], 2+1)))\n\nresult = xf.step(result, 3);\n// [3,4] (=append([3], 3+1)))\n\nresult = xf.step(result, 4);\n// [3,4,5] (=append([3,4], 4+1)))\n```\n\n我们使用 `xf.result` 输出最终结果。\n\n```js\nconst output = xf.result(result);\n// [3,4,5]\n```\n\n可能你已经注意到了，这与上面定义的 `reduce` 实现非常相似。 事实也是如此。 我们可以将这个过程封装成一个新的函数 `transduce`。\n\n```js\nconst transduce = (transducer, stepper, init, input) => {\n  if(typeof stepper === 'function'){\n    // 确保存在用于步进（迭代）的 transformer\n    stepper = wrap(stepper);\n  }\n\n  // 传入 stepper 来创建 transformer：xf\n  const xf = transducer(stepper);\n  // xf 现在成为一个 transformer\n  // 现在可以使用上面定义的 reduce 来迭代并\n  // （在迭代之前）变换输入元素\n  return reduce(xf, init, input);\n};\n```\n\n就像 reduce，我们需要确保 stepper 是一个 transformer。然后通过向 transducer 传入 stepper 来创建新的 transformer。 最后，我们使用包含新的 transformer 的 reduce 来进行迭代和转换结果。也就是说 transducer 的函数类型为：transformer -> transformer。\n\n我们来实践一下。\n\n```js\nconst transducer = map(plus1);\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [3,4,5]\n\nconst transducer = map(plus2);\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [4,5,6]\n```\n\n上述两例的唯一区别是传递给 map 的函数不同。\n\n我们来尝试一下不同的 step function 和初始值。\n\n```js\nconst transducer = map(plus1);\nconst stepper = sum;\nconst init = 0;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 12 (=3+4+5)\n\nconst transducer = map(plus2);\nconst stepper = sum;\nconst init = 0;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 15 (=4+5+6)\n\nconst transducer = map(plus1);\nconst stepper = mult;\nconst init = 1;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 60 (=3*4*5)\n\nconst transducer = map(plus2);\nconst stepper = mult;\nconst init = 1;\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// 120 (=4*5*6)\n```\n\n![transduce](./transduce.png)\n\n这里我们只是改变了 stepper 和初始值，便可以得到不同的结果。我们可以在不依赖中间变量的情况下，遍历一次便可求得累加和或乘积。\n\n## 组合\n\n如果我们想加3，改怎么办呢？我们可以定义 `plus3` 并且使用 `map`，但更好的方法是利用 transducers 的一个特性。\n\n事实上，我们可以通过其他两个函数：`plus1` 和 `plus2`，来定义 `plus3`。\n\n```js\nconst plus3 = item => puls2(plus1(item));\n```\n\n或许你已经看出来，其实这就是[函数组合](https://en.wikipedia.org/wiki/Function_composition_%28computer_science%29)。让我们通过函数组合来重新定义 `plus3`。\n\n```js\nconst compose2 = (fn1, fn2) => item => fn1(fn2(item));\n\nconst plus3 = compose2(plus1, plus2);\n\nconst output = [plus3(2), plus3(3), plus3(4)];\n// [5,6,7]\n```\n\n`compose2` 用于组合两个函数，调用顺序从右向左，看一下 `compose2` 的实现就可以知道为什么调用顺序是从右向左的了。最后一个 function 接受传入参数，返回结果作为下个 function 的输入。如此迭代，直到输出结果。\n\n让我们使用 `compose2` 来定义一个 transducer，该 transducer 由 `plus1` 和 `plus2` 组合而成，用于将每个迭代的元素加3。\n\n```js\nconst transducerPlus3 = map(compose2(plus1, plus2));\nconst transducer = transducerPlus3;\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [5,6,7]\n```\n\n我们使用“函数组合”来组合 `plus1` 和 `plus2` 而不是重新定义 `plus3`，来组合出传入 map 的加3操作。\n\n将上述这些的目的是什么呢？实际上，我们可以通过组合其他的 transducers 来创建新的 transducers。\n\n```js\nconst transducerPlus1 = map(plus1);\nconst transducerPlus2 = map(plus2);\nconst transducerPlus3 = compose2(transducerPlus1, transducerPlus2);\nconst transducer = transducerPlus3;\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [5,6,7]\n```\n\n新组合出来的 transducer 可以用于组合其他的 transducer 。\n\n```js\nconst transducerPlus1 = map(plus1);\nconst transducerPlus2 = map(plus2);\nconst transducerPlus3 = compose2(transducerPlus1, transducerPlus2);\nconst transducerPlus4 = compose2(transducerPlus3, transducerPlus1);\nconst transducer = transducerPlus4;\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n```\n![compose_transducers](./compose_transducers.png)\n\n再次注意，与本节前面的例子的唯一区别是 transducer 的创建。其它都没变。\n\n组合之所以能工作，是因为 transducers 的定义：接受一个 transformer 并返回一个新的 transformer。也即 transducer 的输入与返回值类型相同，且为单输入单输出。只要符合上述条件，便可以使用函数组合来创建与“输入函数”相同类型的“新函数”。\n\n由上可得，transducers 是一种 “可组合的算法变换”。这在实践中已经证明其强大之处：可以将新的变换定义为一系列较小变换的组合，然后将它们通过 `compose` 或 `pipe` 组合起来。我们将在后续章节中展示更多的例子。\n\n事实上，虽然函数组合调用顺序为由右向左，而 transformation 调用是自左向右的（译者注：这也是理解 transduce 的难点之一，理解了这个，也就基本理解了 transduce。可以通过单个 transducer 和 transformer 的组合，来理解 transformation 的调用顺序。transduce 本质上做的事情是 **在对每个元素进行归约之前先对其进行变换** ，将这句话重复五遍：），这也是 transduce 区别于 reduce 的“唯一”不同点）。\n\n在上面的 `transducersPlus4` 示例中，每个元素先进行 `plus3` 转换，然后进行 `plus1` 转换。\n\n虽然在本例中 transducers 的调用顺序对结果没有影响，但是**从左向右**的变换顺序还是需要牢记在心。这个变换调用顺序让你在阅读代码时更容易理解，因为它与你的阅读顺序是一至的（如果使用的是英文，或者中文）。\n\n## part 1 总结\n\nTransducers 将 “可组合的算法转换” 抽象出来，使其独立于输入、输出，甚至迭代的整个过程。\n\n本文演示了如何使用 transducers 来抽象算法转换，transducer 将一个 transformer 转换为另一个 transformer。transformer 可以用于 transduce 进行迭代和转换输入源。\n\n相较于 [Underscore.js](http://underscorejs.org/) 或 [Lo-Dash](https://lodash.com/)对数组和计算中间结果的对象进行操作，transducers 定义的 transformation 在函数方面类似于传递给 reduce 的 stepping function：将初始值作为首次迭代的“结果参数”，执行输入为一个“结果参数”和元素的函数，返回可能变换过的结果，并将其作为下次迭代的“结果参数”。一旦将 transformation 从数据中抽象出来，就可以将相同的 transformations 应用于以某初始值开始并遍历某个“累积结果”的不同处理过程。\n\n我们已经展示了相同的 transducers 可以操作不同的“输出源”，只需改变创建 transducer 时用到的初始值和 stepper。这种抽象的好处之一是：可以遍历一次得到结果，且没有中间数组产生。\n\n尽管没有明确说明，我们还是展示了 transducers 将 transducer 与 迭代过程及输入源解耦。在迭代过程中，我们使用相同的 transducer 对元素进行转换，并将转换结果传给 step function，我们使用数组的 reduce 从数组中获取数据。\n\n## 还想了解更多！\n\n[看这里](http://simplectic.com/blog/2014/transducers-explained-pipelines/) ,以后的文章中将会进一步讨论 transducers 并不会每步都输出元素；并且可能会提前终止迭代，并返回终止前已经归约的结果。本文只讨论了 step，未讨论 init 和 result，将来会有补充。\n\n我们将会了解到，输入源可以是任意产生一系列值的东西：惰性列表，不确定的序列生成器，CSP（通信顺序进程），[Node.js streams](https://github.com/transduce/transduce-stream)\nlazy lists, indefinite sequence generation, CSP[http://phuu.net/2014/08/31/csp-and-transducers.html), [push streams][12], [Node.js streams](https://github.com/transduce/transduce-stream), iterators, generators, immutable-js data structures, 等等。\n\n## 等不及了！\n\n在此期间，可以查看 [Clojure文档](http://clojure.org/transducers), 或者观看[视频](https://www.youtube.com/watch?v=6mTbuzafcII)或这篇[文章](http://phuu.net/2014/08/31/csp-and-transducers.html)，还有其他更多更好的介绍，可以自行 Google 。\n\n想要立刻实践一下？已经有三个库实现了相似的API：[transducers-js](https://github.com/cognitect-labs/transducers-js)、[transducers.js](https://github.com/jlongster/transducers.js)、[ramda](https://github.com/ramda/ramda/blob/v0.22.1/src/transduce.js)(译者注：ramda 中 transducer 部分也是本文作者写的）。本文介绍与 transducers-js 实现类似，但概念同样适用于 transducers.js。\n\n[Underscore.js](http://underscorejs.org/) 的粉丝？可以查看 [underarm](http://simplectic.com/projects/underarm/)，基于 [transduce](https://github.com/transduce/transduce) 库（译者注：本文作者写的库）写的。\n\n怎样将 transducer 应用到 [Node.js streams](https://github.com/transduce/transduce-stream) 中呢？我们还在探索。\n\n希望得到新文章的通知？可以在 Twitter 上关注 [simplectic](https://twitter.com/simplectic)。\n\n","slug":"Transducers-Explained-Part-1","published":1,"updated":"2020-06-06T14:44:04.092Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu5001af6mjgoo8vpw1","content":"<p>译者注：本文翻译自 Kevin Beaty 的《<a href=\"http://simplectic.com/blog/2014/transducers-explained-1/\" target=\"_blank\" rel=\"noopener\">Transducers Explained: Part 1</a>》, 转载请与<a href=\"https://github.com/kevinbeaty\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。\n对原文中出现的专业术语，在不妨碍理解的情况下采用原文单词。</p>\n<p>Transduce 相较于 Reduce 的改进，用一句话概括：在使用 Reduce 对每个元素归约之前，先对取出的每个元素进行转换。</p>\n<p>Transduce 的时间复杂度为 O(n), 传统 compose + reduce 的为O(mn)，m：compose 中包含 转变函数的个数，n：输入“数组”的长度。</p>\n<p>名词解释：</p>\n<ul>\n<li>reduce：归约、折叠。</li>\n<li>reducer：用来进行 reduce 的二元函数。</li>\n<li>result：reducer 的首个参数，累积值。</li>\n<li>item：reducer 的第二个参数，reduce 数组遍历过程中的当前元素。</li>\n</ul>\n<ul>\n<li>transduce：transform + reduce。</li>\n<li>transducer：传入一个transformer，返回一个新的transformer。</li>\n<li>transformer：封装 <em>reducer</em>，返回一个控制 reduce 归约进程的对象 <code>{ init, step, result }</code></li>\n<li>xf：reduce 函数的首个参数，可以是 <em>reducer</em>，也可以是 transformer。</li>\n<li>stepper：等同于 reducer。</li>\n</ul>\n<p>下面开始正文。</p>\n<hr>\n<p>本文使用 JavaScript 对 transducers 原理进行剖析。首先介绍数组的 reducing(归约) 过程，并以此讲解在 reduce 中用于转换的 transformers；然后逐步引入 transducers，并将其用于 transduce 中。文末会有总结、展望、一些补充链接，以及当前涉及 transducer 的一些库。</p>\n<p><strong>Transducers...</strong></p>\n<h2>什么是 Transducers ？</h2>\n<p><a href=\"http://clojure.org/reference/transducers\" target=\"_blank\" rel=\"noopener\">原文</a>解释如下</p>\n<blockquote>\n<p>Transducers 是可组合的算法变换。它们独立于输入和输出的上下文，并且作为一个独立的单元提供最基本的 transformation。由于 transducers 与输入和输出相解耦，所以它们可以用于许多不同的处理场景：collections, streams, channels, observables（集合、流、管道、观察者模式）等。Transducers 可以直接组合，与输入无关且不会产生额外的中间变量。</p>\n</blockquote>\n<p><strong>嗯...</strong></p>\n<h2>还是不太理解</h2>\n<p>让我们看看相关的代码。当使用 transducers 时，&quot;算法变换&quot;函数已经（至少部分）被定义了, 类似于传入 reduce 的 “reducer”。<a href=\"http://clojure.org/reference/transducers\" target=\"_blank\" rel=\"noopener\">Clojure 文档</a> 将这些 &quot;算法变换&quot; 称为 <em>reducers</em>。这又是什么东西？好吧…… ，让我们从 <code>Array#reduce</code> 函数开始讲解。可以先看下 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\" target=\"_blank\" rel=\"noopener\">MDN 的定义</a>。</p>\n<h2>Reduce</h2>\n<blockquote>\n<p>reduce() 方法将一个二元函数作用于一个累积值和数组的每个元素（按从左到右的顺序）， 最终输出为与累积值类型相同的单个值。</p>\n</blockquote>\n<p>更多解释可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\" target=\"_blank\" rel=\"noopener\">MDN 文档</a>（译者注：reduce 在某些语言中称为 foldl 左折叠，如 Haskell）。大家对 reduce 可能已经比较熟悉，在此将快速举些例子说明一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sum = <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> result + item;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mult = <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> result * item;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10 (=1+2+3+4)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> summed = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(sum, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 24 (=1*2*3*4)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> multed = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(mult, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中的 <em>reducers</em> 是 <code>sum</code> 和 <code>mult</code>。<em>reducers</em> 连同初始值：1，一起传入 <code>reduce</code> 中。“输入源”是数组 [2, 3, 4]，“输出源”是通过 reduce 内部实现创建的新数组。</p>\n<p>关于 <code>reduce</code>， 需要记住的非常重要几点是：</p>\n<ol>\n<li>归约（reduce）从输入的初始值开始。</li>\n<li><em>reducer</em> 每次对一个元素进行操作，操作过程为：\n<ul>\n<li>初始值作为第一步的累积值</li>\n<li>单步操作函数(<em>reducers</em> )的返回值作为下次迭代的累积值</li>\n</ul>\n</li>\n<li>将最后一次计算结果作为返回值。</li>\n</ol>\n<p>注意，在上述两例中，<em>reducer</em> 是一个二元函数。<em>reducer</em> 第一个参数是由 reduce 函数外部提供的, 其值为传入的初始值或者上次调用 <em>reducer</em> 的计算结果。第二个参数是由迭代过程中传入的单个元素。本例中， reduce 对数组中的每个元素进行迭代。我们稍后会看到其他的迭代方式。我们使用 <em>reducer</em> 函数来描述 “转换的本质”。</p>\n<h2>Transformer</h2>\n<p>我们来正式实现 <em>transformer</em> 的归约过程：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transformer = <span class=\"function\"><span class=\"params\">reducer</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 作为 reduce 开始的初始值</span></span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 每次输入一个元素，并将本次计算结果</span></span><br><span class=\"line\">  <span class=\"comment\">//    传给下次迭代的 reducer</span></span><br><span class=\"line\">  step: reducer,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将最后一次的计算结果作为最终输出</span></span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们创建一个对象来封装 reducer，并将其命名为名为 <code>step</code>；另外还提供了 <code>init</code> 函数用来初始化 transformer，<code>result</code> 函数来将最后一次计算结果转换为需要的最终输出。注意，在本文中，我们将只关注 <code>step</code> 函数，<code>init</code> 和 <code>result</code> 函数将在后续文章中做深入分析。现在，你可以把它们当作管理 transformation 生命周期的方法：<code>init</code> 用于初始化，<code>step</code> 用于迭代，<code>result</code> 用于输出整个归约结果。</p>\n<p>现在，我们来将刚定义的 transformer 运用到 reduce 中。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = input.reduce(xf.step, xf.init());</span><br><span class=\"line\"><span class=\"comment\">// output = 10 (=1+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = input.reduce(xf.step, xf.init());</span><br><span class=\"line\"><span class=\"comment\">// output = 24 (=1*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>我们的最终目标是将 transformation 与输入和输出解耦，所以现在我们将 <code>reduce</code> 定义为函数的形式。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">xf, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = input.reduce(xf.step, init);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(result);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>为了使用 reduce ，我们向其传入一个 transformer、初始值和输入源。上述实现结合了 transformer 的 <code>step</code> 函数和数组的 reduce 函数，并将 <code>step</code> 函数的结果作为输出。本次 reduce 的内部实现仍然假设输入类型为数组。 我们稍后将去掉这个假设。</p>\n<p>我们还接受一个 <code>init</code> 值作为 reduce 的参数，我们本可以使用 transformer 的 <code>init</code>，但是考虑到 reduce 函数的灵活性，需要能够自定义初始值。在实践中，transformer 的 <code>init</code> 函数仅在 reduce 未提供初始值的情况下使用。</p>\n<p>新 reduce 函数的使用类似于之前的 reduce 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, xf.init(), input);</span><br><span class=\"line\"><span class=\"comment\">// output = 10 (=1+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, xf.init(), input);</span><br><span class=\"line\"><span class=\"comment\">// output = 24 (=1*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>还可以给 reduce 传入初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 11 (=2+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 48 (=2*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>reduce 函数现在需要一个 transformer。由于 transformer的 <code>init</code> 函数未在 reduce 中用到，且 <code>result</code> 经常作为单位元(identity、恒等)函数使用：一个直接返回单参数（输入本身）的函数，我们将定义一个辅助函数，来将 <em>reduceing function</em> 转换为 transformer，并传入 reduce 使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">xf, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> xf === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 确保 reduce 中含有 transformer </span></span><br><span class=\"line\">    xf = wrap(xf);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = input.reduce(xf.step, init);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wrap = <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 我们会显式的传入一个 reduce 的初始值，</span></span><br><span class=\"line\">  <span class=\"comment\">//    所以这里不再需要内部的 init 函数</span></span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'init not supported'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 每次输入一个元素，并将本次计算结果</span></span><br><span class=\"line\">  <span class=\"comment\">//    传给下次迭代的 reducer</span></span><br><span class=\"line\">  step: xf,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将最后一次的计算结果作为输出</span></span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先我们检查参数 <code>xf</code> 的类型是否为 function。若是，我们假定它是一个 step function, 并调用 wrap 函数将其转换为 transformer。然后像之前一样调用 reduce 。</p>\n<p>现在已经可以直接向 reduce 传递 reducer 了。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(sum, <span class=\"number\">1</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 10 (=1+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(mult, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 48 (=2*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./reduce.png\" alt=\"reduce\"></p>\n<p>但我们仍然可以向 reduce 传 transformers。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = wrap(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 11 (=2+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = wrap(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">1</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 24 (=1*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>请注意，我们现在可以在外部借助 wrap 直接封装已有的 <em>reducers</em> 来创建 transformer。这是使用 transducers 时经常用到的方法：将 transformations 定义为简单的函数，然后使用 transducers 库将其转换为transformer。</p>\n<h2>不一样的数组拷贝</h2>\n<p>目前，我们一直使用数字作为初始值和算术 <em>reducers</em> 的处理元素。其实不一定非要这样，<code>reduce</code> 也可以将数组作为处理元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> append = <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> result.push(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(append, [], input);</span><br><span class=\"line\"><span class=\"comment\">// output = [2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们定义一个步进函数（stepper）<code>append</code>，用于将每个元素拷贝到新数组中，并返回该数组。借助 <code>append</code>， reduce 便可以创建一份数组的拷贝。</p>\n<p>上述操作是否够酷？或许算不上...。当你在将元素添加到输出数组之前先对它变换一下时，情况才变得有趣起来。</p>\n<h2>最孤单的数字</h2>\n<p>（注：One is the loneliest number，一句英文歌词，引出 <code>plus1</code> 转换）</p>\n<p>假设我们想要每个元素加1，定义一个加1函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<p>现在创建一个 transformer ，它使用上面的函数在 step 中对每个独立元素进行转换。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xfplus1 = &#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'init not needed'</span>); &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> plus1ed = plus1(item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> append(result, plus1ed);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// step: (result, item) =&gt; append(result, plus1(item)),</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以使用 transformer 逐步遍历并输出每步结果</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xf = xfplus1;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3] (=append([], 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4] (=append([3], 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5] (=append([3,4], 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>因此，我们使用一个 transformer 来遍历元素：将每个元素加1后添加到输出数组中。</p>\n<p>如果我们想要每个元素加1 后的总和，该怎么办呢？可以使用 reduce 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(sum, <span class=\"number\">0</span>, output);</span><br><span class=\"line\"><span class=\"comment\">// 12 (=0+3+4+5)</span></span><br></pre></td></tr></table></figure></p>\n<p>上述方案虽然可行，但不幸的是，我们在获得最终答案的过程中，不得不创建一个中间数组。 有更好的方案吗？</p>\n<p>事实上是有的。回顾上面的 <code>xfplus1</code> ，如果我们将 <code>append</code> 调用换为 <code>sum</code> 调用，并且以 0 作为初始值，就可以定义一个不会产生中间数组，但直接对元素求和的 transformer。</p>\n<p>但是，有时我们想立即查看替换 <em>reducer</em> 后的结果，因为中间涉及的唯一变化就是将 <code>append</code> 替换为 <code>sum</code>。因此我们希望有一个能够创建 transformation 的函数，该函数不依赖于用于组合中间结果的 transformer。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus1 = <span class=\"function\">(<span class=\"params\">xf</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> plus1ed = plus1(item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xf.step(result, plus1ed);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>该函数接受一个 transformer：<code>xf</code>，返回一个基于 <code>xf</code> 的新的 transformer。新 transformer 将经由 <code>plus1</code> 转换后的结果代理给 <code>xf</code>。由于我们可以使用 <code>step</code> 函数完全定义这个 transformation，新的 transformer 的 <code>xf</code> 只需 <code>init</code> 和 <code>result</code>。每次迭代时，先将每个元素进行 <code>plus1</code> 转换，然后调用封装过的 transformer 内部的 <code>step</code> 函数。</p>\n<h2>Transducer</h2>\n<p>我们刚刚创建了第一个 transducer：一个接受现有 transformer，并返回新 transformer 的函数。新 transformer 会改变原有 transformation 的行为，transducer 会将一些额外的处理委托给新的封装过的 transformer。</p>\n<p>让我们实践一下，首先用刚才的 transducer 来重新实现前面的例子。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(append);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus1;</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3] (=append([], 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4] (=append([3], 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5] (=append([3,4], 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>运行过程和结果与之前相同，很好。唯一的区别是 transformer：<code>xf</code> 的创建。我们使用 <code>wrap</code> 将 <code>append</code> 转换成名为 <code>stepper</code> 的 transformer，然后使用 transducer 封装这个 stepper 并返回一个 <code>plus1</code> 转换。然后我们就可以像从前一样使用转换函数：xf 对每个元素逐步操作，并得到结果。</p>\n<h2>中间辅助元素</h2>\n<p>从现在开始，事情变得有趣起来：我们可以用相同的 transducer 来获得最终的累加和，不需要中间辅助数组，只需改变 stepper 和初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus1;</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3 (=sum(0, 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 7 (=sum(3, 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// 12 (=sum(7, 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure></p>\n<p>不需要计算中间数组，一次迭代就可以得到结果。<code>sum</code> 与之前 <code>append</code> 例子只有两处不同：</p>\n<ul>\n<li>创建 stepper 时，用 sum 代替 append 进行封装。</li>\n<li>初始值使用 0 代替 []。</li>\n</ul>\n<p>仅此两处差异，其他完全一样。</p>\n<p>需要注意的是，只有 <code>stepper</code> 转换知道 <code>result</code> 的数据类型。当封装 <code>sum</code> 时，结果类型为数字，封装 <code>append</code> 时，结果是数组。初始值类型与 stepper 的 <code>result</code> 参数类型相同。被处理的单个元素的类型不限，因为 stepper 知道如何组合上次输出的结果和新的元素，并返回一个新的组合的结果，本次输出结果可能会用于下次迭代中的组合，如此迭代循环。</p>\n<p>这些特性允许我们定义独立于输出的 transformation 。</p>\n<h2>可能会变糟</h2>\n<p>(注：第二句歌词，Can be as bad as one，作者意思应该是，如果 <code>plus2</code> 还跟 <code>plus1</code> 一样从头重新实现一遍，就比较坑了)</p>\n<p>假如我们想要在归约之前 <code>plus2</code>，需要改变哪些地方呢？我们可以定义一个类似于 <code>transducerPlus1</code> 的新的 <code>transducerPlus2</code> 。回头看一下 <code>transducerPlus1</code> 是如何实现的，并决定哪些地方需要更改。但这样做违反了 DRY 原则。</p>\n<p>有更好的方案吗？</p>\n<p>实际上，除了将 step 的值用 <code>plus2</code> 替换掉 <code>plus1</code> 以外，其他都是一样的。</p>\n<p>让我们将 <code>plus1</code> 提取出来，并将其作为函数 <code>f</code> 进行传递。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> mapped = f(item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xf.step(result, mapped);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们定义了 mapping transducer，让我们使用它来逐步转换。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus2 = <span class=\"function\">(<span class=\"params\">input</span>) =&gt;</span> input + <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(append);</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [4] (=append([], 2+2)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [4,5] (=append([4], 3+2)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [4,5,6] (=append([4,5], 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [4,5,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>本例相较于之前使用<code>plus1</code> 和 <code>append</code> 函数的例子，唯一的区别在于使用 <code>map</code> 创建 transducer。我们可以类似地使用 <code>map(plus1)</code> 来创建 <code>plus1</code> transducer。<code>transducerPlus1</code> 虽然只是短暂的出现便被 <code>map(plus1)</code> 代替，但它对我们理解 transduce 的内部原理帮助很大。</p>\n<h2>Transduce</h2>\n<p>前面的示例讲解了使用 transducers 手动转换一系列的输入。让我们进一步优化。</p>\n<p>首先通过调用一个包含 stepper 转换的 transducer 来初始化 transformation，并定义 transduce 的初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(append);</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br></pre></td></tr></table></figure></p>\n<p>然后使用 <em>reducer</em> <code>xf.step</code> 来遍历每个输入元素。将初始值作为 step 函数的第一个 <code>result</code> 参数（另一个是输入源中的元素），上一个 step 函数的返回值供所有后续元素迭代使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3] (=append([], 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4] (=append([3], 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5] (=append([3,4], 4+1)))</span></span><br></pre></td></tr></table></figure></p>\n<p>我们使用 <code>xf.result</code> 输出最终结果。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>可能你已经注意到了，这与上面定义的 <code>reduce</code> 实现非常相似。 事实也是如此。 我们可以将这个过程封装成一个新的函数 <code>transduce</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transduce = <span class=\"function\">(<span class=\"params\">transducer, stepper, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> stepper === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 确保存在用于步进（迭代）的 transformer</span></span><br><span class=\"line\">    stepper = wrap(stepper);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 传入 stepper 来创建 transformer：xf</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\">  <span class=\"comment\">// xf 现在成为一个 transformer</span></span><br><span class=\"line\">  <span class=\"comment\">// 现在可以使用上面定义的 reduce 来迭代并</span></span><br><span class=\"line\">  <span class=\"comment\">// （在迭代之前）变换输入元素</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(xf, init, input);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>就像 reduce，我们需要确保 stepper 是一个 transformer。然后通过向 transducer 传入 stepper 来创建新的 transformer。 最后，我们使用包含新的 transformer 的 reduce 来进行迭代和转换结果。也就是说 transducer 的函数类型为：transformer -&gt; transformer。</p>\n<p>我们来实践一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [4,5,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>上述两例的唯一区别是传递给 map 的函数不同。</p>\n<p>我们来尝试一下不同的 step function 和初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = sum;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 12 (=3+4+5)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = sum;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 15 (=4+5+6)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = mult;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 60 (=3*4*5)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = mult;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 120 (=4*5*6)</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./transduce.png\" alt=\"transduce\"></p>\n<p>这里我们只是改变了 stepper 和初始值，便可以得到不同的结果。我们可以在不依赖中间变量的情况下，遍历一次便可求得累加和或乘积。</p>\n<h2>组合</h2>\n<p>如果我们想加3，改怎么办呢？我们可以定义 <code>plus3</code> 并且使用 <code>map</code>，但更好的方法是利用 transducers 的一个特性。</p>\n<p>事实上，我们可以通过其他两个函数：<code>plus1</code> 和 <code>plus2</code>，来定义 <code>plus3</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus3 = <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> puls2(plus1(item));</span><br></pre></td></tr></table></figure></p>\n<p>或许你已经看出来，其实这就是<a href=\"https://en.wikipedia.org/wiki/Function_composition_%28computer_science%29\" target=\"_blank\" rel=\"noopener\">函数组合</a>。让我们通过函数组合来重新定义 <code>plus3</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose2 = <span class=\"function\">(<span class=\"params\">fn1, fn2</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> fn1(fn2(item));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus3 = compose2(plus1, plus2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = [plus3(<span class=\"number\">2</span>), plus3(<span class=\"number\">3</span>), plus3(<span class=\"number\">4</span>)];</span><br><span class=\"line\"><span class=\"comment\">// [5,6,7]</span></span><br></pre></td></tr></table></figure></p>\n<p><code>compose2</code> 用于组合两个函数，调用顺序从右向左，看一下 <code>compose2</code> 的实现就可以知道为什么调用顺序是从右向左的了。最后一个 function 接受传入参数，返回结果作为下个 function 的输入。如此迭代，直到输出结果。</p>\n<p>让我们使用 <code>compose2</code> 来定义一个 transducer，该 transducer 由 <code>plus1</code> 和 <code>plus2</code> 组合而成，用于将每个迭代的元素加3。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus3 = map(compose2(plus1, plus2));</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus3;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [5,6,7]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们使用“函数组合”来组合 <code>plus1</code> 和 <code>plus2</code> 而不是重新定义 <code>plus3</code>，来组合出传入 map 的加3操作。</p>\n<p>将上述这些的目的是什么呢？实际上，我们可以通过组合其他的 transducers 来创建新的 transducers。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus1 = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus2 = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus3 = compose2(transducerPlus1, transducerPlus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus3;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [5,6,7]</span></span><br></pre></td></tr></table></figure></p>\n<p>新组合出来的 transducer 可以用于组合其他的 transducer 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus1 = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus2 = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus3 = compose2(transducerPlus1, transducerPlus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus4 = compose2(transducerPlus3, transducerPlus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus4;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./compose_transducers.png\" alt=\"compose_transducers\"></p>\n<p>再次注意，与本节前面的例子的唯一区别是 transducer 的创建。其它都没变。</p>\n<p>组合之所以能工作，是因为 transducers 的定义：接受一个 transformer 并返回一个新的 transformer。也即 transducer 的输入与返回值类型相同，且为单输入单输出。只要符合上述条件，便可以使用函数组合来创建与“输入函数”相同类型的“新函数”。</p>\n<p>由上可得，transducers 是一种 “可组合的算法变换”。这在实践中已经证明其强大之处：可以将新的变换定义为一系列较小变换的组合，然后将它们通过 <code>compose</code> 或 <code>pipe</code> 组合起来。我们将在后续章节中展示更多的例子。</p>\n<p>事实上，虽然函数组合调用顺序为由右向左，而 transformation 调用是自左向右的（译者注：这也是理解 transduce 的难点之一，理解了这个，也就基本理解了 transduce。可以通过单个 transducer 和 transformer 的组合，来理解 transformation 的调用顺序。transduce 本质上做的事情是 <strong>在对每个元素进行归约之前先对其进行变换</strong> ，将这句话重复五遍：），这也是 transduce 区别于 reduce 的“唯一”不同点）。</p>\n<p>在上面的 <code>transducersPlus4</code> 示例中，每个元素先进行 <code>plus3</code> 转换，然后进行 <code>plus1</code> 转换。</p>\n<p>虽然在本例中 transducers 的调用顺序对结果没有影响，但是<strong>从左向右</strong>的变换顺序还是需要牢记在心。这个变换调用顺序让你在阅读代码时更容易理解，因为它与你的阅读顺序是一至的（如果使用的是英文，或者中文）。</p>\n<h2>part 1 总结</h2>\n<p>Transducers 将 “可组合的算法转换” 抽象出来，使其独立于输入、输出，甚至迭代的整个过程。</p>\n<p>本文演示了如何使用 transducers 来抽象算法转换，transducer 将一个 transformer 转换为另一个 transformer。transformer 可以用于 transduce 进行迭代和转换输入源。</p>\n<p>相较于 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore.js</a> 或 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lo-Dash</a>对数组和计算中间结果的对象进行操作，transducers 定义的 transformation 在函数方面类似于传递给 reduce 的 stepping function：将初始值作为首次迭代的“结果参数”，执行输入为一个“结果参数”和元素的函数，返回可能变换过的结果，并将其作为下次迭代的“结果参数”。一旦将 transformation 从数据中抽象出来，就可以将相同的 transformations 应用于以某初始值开始并遍历某个“累积结果”的不同处理过程。</p>\n<p>我们已经展示了相同的 transducers 可以操作不同的“输出源”，只需改变创建 transducer 时用到的初始值和 stepper。这种抽象的好处之一是：可以遍历一次得到结果，且没有中间数组产生。</p>\n<p>尽管没有明确说明，我们还是展示了 transducers 将 transducer 与 迭代过程及输入源解耦。在迭代过程中，我们使用相同的 transducer 对元素进行转换，并将转换结果传给 step function，我们使用数组的 reduce 从数组中获取数据。</p>\n<h2>还想了解更多！</h2>\n<p><a href=\"http://simplectic.com/blog/2014/transducers-explained-pipelines/\" target=\"_blank\" rel=\"noopener\">看这里</a> ,以后的文章中将会进一步讨论 transducers 并不会每步都输出元素；并且可能会提前终止迭代，并返回终止前已经归约的结果。本文只讨论了 step，未讨论 init 和 result，将来会有补充。</p>\n<p>我们将会了解到，输入源可以是任意产生一系列值的东西：惰性列表，不确定的序列生成器，CSP（通信顺序进程），<a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a>\nlazy lists, indefinite sequence generation, CSP[http://phuu.net/2014/08/31/csp-and-transducers.html), [push streams][12], <a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a>, iterators, generators, immutable-js data structures, 等等。</p>\n<h2>等不及了！</h2>\n<p>在此期间，可以查看 <a href=\"http://clojure.org/transducers\" target=\"_blank\" rel=\"noopener\">Clojure文档</a>, 或者观看<a href=\"https://www.youtube.com/watch?v=6mTbuzafcII\" target=\"_blank\" rel=\"noopener\">视频</a>或这篇<a href=\"http://phuu.net/2014/08/31/csp-and-transducers.html\" target=\"_blank\" rel=\"noopener\">文章</a>，还有其他更多更好的介绍，可以自行 Google 。</p>\n<p>想要立刻实践一下？已经有三个库实现了相似的API：<a href=\"https://github.com/cognitect-labs/transducers-js\" target=\"_blank\" rel=\"noopener\">transducers-js</a>、<a href=\"https://github.com/jlongster/transducers.js\" target=\"_blank\" rel=\"noopener\">transducers.js</a>、<a href=\"https://github.com/ramda/ramda/blob/v0.22.1/src/transduce.js\" target=\"_blank\" rel=\"noopener\">ramda</a>(译者注：ramda 中 transducer 部分也是本文作者写的）。本文介绍与 transducers-js 实现类似，但概念同样适用于 transducers.js。</p>\n<p><a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore.js</a> 的粉丝？可以查看 <a href=\"http://simplectic.com/projects/underarm/\" target=\"_blank\" rel=\"noopener\">underarm</a>，基于 <a href=\"https://github.com/transduce/transduce\" target=\"_blank\" rel=\"noopener\">transduce</a> 库（译者注：本文作者写的库）写的。</p>\n<p>怎样将 transducer 应用到 <a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a> 中呢？我们还在探索。</p>\n<p>希望得到新文章的通知？可以在 Twitter 上关注 <a href=\"https://twitter.com/simplectic\" target=\"_blank\" rel=\"noopener\">simplectic</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 Kevin Beaty 的《<a href=\"http://simplectic.com/blog/2014/transducers-explained-1/\" target=\"_blank\" rel=\"noopener\">Transducers Explained: Part 1</a>》, 转载请与<a href=\"https://github.com/kevinbeaty\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。\n对原文中出现的专业术语，在不妨碍理解的情况下采用原文单词。</p>\n<p>Transduce 相较于 Reduce 的改进，用一句话概括：在使用 Reduce 对每个元素归约之前，先对取出的每个元素进行转换。</p>\n<p>Transduce 的时间复杂度为 O(n), 传统 compose + reduce 的为O(mn)，m：compose 中包含 转变函数的个数，n：输入“数组”的长度。</p>\n<p>名词解释：</p>\n<ul>\n<li>reduce：归约、折叠。</li>\n<li>reducer：用来进行 reduce 的二元函数。</li>\n<li>result：reducer 的首个参数，累积值。</li>\n<li>item：reducer 的第二个参数，reduce 数组遍历过程中的当前元素。</li>\n</ul>\n<ul>\n<li>transduce：transform + reduce。</li>\n<li>transducer：传入一个transformer，返回一个新的transformer。</li>\n<li>transformer：封装 <em>reducer</em>，返回一个控制 reduce 归约进程的对象 <code>{ init, step, result }</code></li>\n<li>xf：reduce 函数的首个参数，可以是 <em>reducer</em>，也可以是 transformer。</li>\n<li>stepper：等同于 reducer。</li>\n</ul>\n<p>下面开始正文。</p>\n<hr>\n<p>本文使用 JavaScript 对 transducers 原理进行剖析。首先介绍数组的 reducing(归约) 过程，并以此讲解在 reduce 中用于转换的 transformers；然后逐步引入 transducers，并将其用于 transduce 中。文末会有总结、展望、一些补充链接，以及当前涉及 transducer 的一些库。</p>\n<p><strong>Transducers...</strong></p>\n<h2>什么是 Transducers ？</h2>\n<p><a href=\"http://clojure.org/reference/transducers\" target=\"_blank\" rel=\"noopener\">原文</a>解释如下</p>\n<blockquote>\n<p>Transducers 是可组合的算法变换。它们独立于输入和输出的上下文，并且作为一个独立的单元提供最基本的 transformation。由于 transducers 与输入和输出相解耦，所以它们可以用于许多不同的处理场景：collections, streams, channels, observables（集合、流、管道、观察者模式）等。Transducers 可以直接组合，与输入无关且不会产生额外的中间变量。</p>\n</blockquote>\n<p><strong>嗯...</strong></p>\n<h2>还是不太理解</h2>\n<p>让我们看看相关的代码。当使用 transducers 时，&quot;算法变换&quot;函数已经（至少部分）被定义了, 类似于传入 reduce 的 “reducer”。<a href=\"http://clojure.org/reference/transducers\" target=\"_blank\" rel=\"noopener\">Clojure 文档</a> 将这些 &quot;算法变换&quot; 称为 <em>reducers</em>。这又是什么东西？好吧…… ，让我们从 <code>Array#reduce</code> 函数开始讲解。可以先看下 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\" target=\"_blank\" rel=\"noopener\">MDN 的定义</a>。</p>\n<h2>Reduce</h2>\n<blockquote>\n<p>reduce() 方法将一个二元函数作用于一个累积值和数组的每个元素（按从左到右的顺序）， 最终输出为与累积值类型相同的单个值。</p>\n</blockquote>\n<p>更多解释可以参考 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce\" target=\"_blank\" rel=\"noopener\">MDN 文档</a>（译者注：reduce 在某些语言中称为 foldl 左折叠，如 Haskell）。大家对 reduce 可能已经比较熟悉，在此将快速举些例子说明一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> sum = <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> result + item;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> mult = <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> result * item;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 10 (=1+2+3+4)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> summed = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(sum, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 24 (=1*2*3*4)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> multed = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>].reduce(mult, <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></p>\n<p>上述代码中的 <em>reducers</em> 是 <code>sum</code> 和 <code>mult</code>。<em>reducers</em> 连同初始值：1，一起传入 <code>reduce</code> 中。“输入源”是数组 [2, 3, 4]，“输出源”是通过 reduce 内部实现创建的新数组。</p>\n<p>关于 <code>reduce</code>， 需要记住的非常重要几点是：</p>\n<ol>\n<li>归约（reduce）从输入的初始值开始。</li>\n<li><em>reducer</em> 每次对一个元素进行操作，操作过程为：\n<ul>\n<li>初始值作为第一步的累积值</li>\n<li>单步操作函数(<em>reducers</em> )的返回值作为下次迭代的累积值</li>\n</ul>\n</li>\n<li>将最后一次计算结果作为返回值。</li>\n</ol>\n<p>注意，在上述两例中，<em>reducer</em> 是一个二元函数。<em>reducer</em> 第一个参数是由 reduce 函数外部提供的, 其值为传入的初始值或者上次调用 <em>reducer</em> 的计算结果。第二个参数是由迭代过程中传入的单个元素。本例中， reduce 对数组中的每个元素进行迭代。我们稍后会看到其他的迭代方式。我们使用 <em>reducer</em> 函数来描述 “转换的本质”。</p>\n<h2>Transformer</h2>\n<p>我们来正式实现 <em>transformer</em> 的归约过程：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transformer = <span class=\"function\"><span class=\"params\">reducer</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 作为 reduce 开始的初始值</span></span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"number\">1</span>,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 每次输入一个元素，并将本次计算结果</span></span><br><span class=\"line\">  <span class=\"comment\">//    传给下次迭代的 reducer</span></span><br><span class=\"line\">  step: reducer,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将最后一次的计算结果作为最终输出</span></span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们创建一个对象来封装 reducer，并将其命名为名为 <code>step</code>；另外还提供了 <code>init</code> 函数用来初始化 transformer，<code>result</code> 函数来将最后一次计算结果转换为需要的最终输出。注意，在本文中，我们将只关注 <code>step</code> 函数，<code>init</code> 和 <code>result</code> 函数将在后续文章中做深入分析。现在，你可以把它们当作管理 transformation 生命周期的方法：<code>init</code> 用于初始化，<code>step</code> 用于迭代，<code>result</code> 用于输出整个归约结果。</p>\n<p>现在，我们来将刚定义的 transformer 运用到 reduce 中。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = input.reduce(xf.step, xf.init());</span><br><span class=\"line\"><span class=\"comment\">// output = 10 (=1+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = input.reduce(xf.step, xf.init());</span><br><span class=\"line\"><span class=\"comment\">// output = 24 (=1*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>我们的最终目标是将 transformation 与输入和输出解耦，所以现在我们将 <code>reduce</code> 定义为函数的形式。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">xf, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = input.reduce(xf.step, init);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(result);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>为了使用 reduce ，我们向其传入一个 transformer、初始值和输入源。上述实现结合了 transformer 的 <code>step</code> 函数和数组的 reduce 函数，并将 <code>step</code> 函数的结果作为输出。本次 reduce 的内部实现仍然假设输入类型为数组。 我们稍后将去掉这个假设。</p>\n<p>我们还接受一个 <code>init</code> 值作为 reduce 的参数，我们本可以使用 transformer 的 <code>init</code>，但是考虑到 reduce 函数的灵活性，需要能够自定义初始值。在实践中，transformer 的 <code>init</code> 函数仅在 reduce 未提供初始值的情况下使用。</p>\n<p>新 reduce 函数的使用类似于之前的 reduce 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, xf.init(), input);</span><br><span class=\"line\"><span class=\"comment\">// output = 10 (=1+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, xf.init(), input);</span><br><span class=\"line\"><span class=\"comment\">// output = 24 (=1*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>还可以给 reduce 传入初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 11 (=2+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transformer(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 48 (=2*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>reduce 函数现在需要一个 transformer。由于 transformer的 <code>init</code> 函数未在 reduce 中用到，且 <code>result</code> 经常作为单位元(identity、恒等)函数使用：一个直接返回单参数（输入本身）的函数，我们将定义一个辅助函数，来将 <em>reduceing function</em> 转换为 transformer，并传入 reduce 使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">xf, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> xf === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 确保 reduce 中含有 transformer </span></span><br><span class=\"line\">    xf = wrap(xf);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> result = input.reduce(xf.step, init);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(result);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wrap = <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 1. 我们会显式的传入一个 reduce 的初始值，</span></span><br><span class=\"line\">  <span class=\"comment\">//    所以这里不再需要内部的 init 函数</span></span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'init not supported'</span>);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 2. 每次输入一个元素，并将本次计算结果</span></span><br><span class=\"line\">  <span class=\"comment\">//    传给下次迭代的 reducer</span></span><br><span class=\"line\">  step: xf,</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 3. 将最后一次的计算结果作为输出</span></span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先我们检查参数 <code>xf</code> 的类型是否为 function。若是，我们假定它是一个 step function, 并调用 wrap 函数将其转换为 transformer。然后像之前一样调用 reduce 。</p>\n<p>现在已经可以直接向 reduce 传递 reducer 了。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(sum, <span class=\"number\">1</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 10 (=1+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(mult, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 48 (=2*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./reduce.png\" alt=\"reduce\"></p>\n<p>但我们仍然可以向 reduce 传 transformers。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = wrap(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">2</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 11 (=2+2+3+4)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = wrap(mult);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(xf, <span class=\"number\">1</span>, input);</span><br><span class=\"line\"><span class=\"comment\">// output = 24 (=1*2*3*4)</span></span><br></pre></td></tr></table></figure></p>\n<p>请注意，我们现在可以在外部借助 wrap 直接封装已有的 <em>reducers</em> 来创建 transformer。这是使用 transducers 时经常用到的方法：将 transformations 定义为简单的函数，然后使用 transducers 库将其转换为transformer。</p>\n<h2>不一样的数组拷贝</h2>\n<p>目前，我们一直使用数字作为初始值和算术 <em>reducers</em> 的处理元素。其实不一定非要这样，<code>reduce</code> 也可以将数组作为处理元素。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> append = <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> result.push(item);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(append, [], input);</span><br><span class=\"line\"><span class=\"comment\">// output = [2, 3, 4]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们定义一个步进函数（stepper）<code>append</code>，用于将每个元素拷贝到新数组中，并返回该数组。借助 <code>append</code>， reduce 便可以创建一份数组的拷贝。</p>\n<p>上述操作是否够酷？或许算不上...。当你在将元素添加到输出数组之前先对它变换一下时，情况才变得有趣起来。</p>\n<h2>最孤单的数字</h2>\n<p>（注：One is the loneliest number，一句英文歌词，引出 <code>plus1</code> 转换）</p>\n<p>假设我们想要每个元素加1，定义一个加1函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<p>现在创建一个 transformer ，它使用上面的函数在 step 中对每个独立元素进行转换。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xfplus1 = &#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'init not needed'</span>); &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> plus1ed = plus1(item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> append(result, plus1ed);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"comment\">// step: (result, item) =&gt; append(result, plus1(item)),</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以使用 transformer 逐步遍历并输出每步结果</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> xf = xfplus1;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3] (=append([], 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4] (=append([3], 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5] (=append([3,4], 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>因此，我们使用一个 transformer 来遍历元素：将每个元素加1后添加到输出数组中。</p>\n<p>如果我们想要每个元素加1 后的总和，该怎么办呢？可以使用 reduce 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> output = reduce(sum, <span class=\"number\">0</span>, output);</span><br><span class=\"line\"><span class=\"comment\">// 12 (=0+3+4+5)</span></span><br></pre></td></tr></table></figure></p>\n<p>上述方案虽然可行，但不幸的是，我们在获得最终答案的过程中，不得不创建一个中间数组。 有更好的方案吗？</p>\n<p>事实上是有的。回顾上面的 <code>xfplus1</code> ，如果我们将 <code>append</code> 调用换为 <code>sum</code> 调用，并且以 0 作为初始值，就可以定义一个不会产生中间数组，但直接对元素求和的 transformer。</p>\n<p>但是，有时我们想立即查看替换 <em>reducer</em> 后的结果，因为中间涉及的唯一变化就是将 <code>append</code> 替换为 <code>sum</code>。因此我们希望有一个能够创建 transformation 的函数，该函数不依赖于用于组合中间结果的 transformer。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus1 = <span class=\"function\">(<span class=\"params\">xf</span>) =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> plus1ed = plus1(item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xf.step(result, plus1ed);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> result,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>该函数接受一个 transformer：<code>xf</code>，返回一个基于 <code>xf</code> 的新的 transformer。新 transformer 将经由 <code>plus1</code> 转换后的结果代理给 <code>xf</code>。由于我们可以使用 <code>step</code> 函数完全定义这个 transformation，新的 transformer 的 <code>xf</code> 只需 <code>init</code> 和 <code>result</code>。每次迭代时，先将每个元素进行 <code>plus1</code> 转换，然后调用封装过的 transformer 内部的 <code>step</code> 函数。</p>\n<h2>Transducer</h2>\n<p>我们刚刚创建了第一个 transducer：一个接受现有 transformer，并返回新 transformer 的函数。新 transformer 会改变原有 transformation 的行为，transducer 会将一些额外的处理委托给新的封装过的 transformer。</p>\n<p>让我们实践一下，首先用刚才的 transducer 来重新实现前面的例子。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(append);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus1;</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3] (=append([], 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4] (=append([3], 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5] (=append([3,4], 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>运行过程和结果与之前相同，很好。唯一的区别是 transformer：<code>xf</code> 的创建。我们使用 <code>wrap</code> 将 <code>append</code> 转换成名为 <code>stepper</code> 的 transformer，然后使用 transducer 封装这个 stepper 并返回一个 <code>plus1</code> 转换。然后我们就可以像从前一样使用转换函数：xf 对每个元素逐步操作，并得到结果。</p>\n<h2>中间辅助元素</h2>\n<p>从现在开始，事情变得有趣起来：我们可以用相同的 transducer 来获得最终的累加和，不需要中间辅助数组，只需改变 stepper 和初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(sum);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus1;</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// 3 (=sum(0, 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// 7 (=sum(3, 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// 12 (=sum(7, 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// 12</span></span><br></pre></td></tr></table></figure></p>\n<p>不需要计算中间数组，一次迭代就可以得到结果。<code>sum</code> 与之前 <code>append</code> 例子只有两处不同：</p>\n<ul>\n<li>创建 stepper 时，用 sum 代替 append 进行封装。</li>\n<li>初始值使用 0 代替 []。</li>\n</ul>\n<p>仅此两处差异，其他完全一样。</p>\n<p>需要注意的是，只有 <code>stepper</code> 转换知道 <code>result</code> 的数据类型。当封装 <code>sum</code> 时，结果类型为数字，封装 <code>append</code> 时，结果是数组。初始值类型与 stepper 的 <code>result</code> 参数类型相同。被处理的单个元素的类型不限，因为 stepper 知道如何组合上次输出的结果和新的元素，并返回一个新的组合的结果，本次输出结果可能会用于下次迭代中的组合，如此迭代循环。</p>\n<p>这些特性允许我们定义独立于输出的 transformation 。</p>\n<h2>可能会变糟</h2>\n<p>(注：第二句歌词，Can be as bad as one，作者意思应该是，如果 <code>plus2</code> 还跟 <code>plus1</code> 一样从头重新实现一遍，就比较坑了)</p>\n<p>假如我们想要在归约之前 <code>plus2</code>，需要改变哪些地方呢？我们可以定义一个类似于 <code>transducerPlus1</code> 的新的 <code>transducerPlus2</code> 。回头看一下 <code>transducerPlus1</code> 是如何实现的，并决定哪些地方需要更改。但这样做违反了 DRY 原则。</p>\n<p>有更好的方案吗？</p>\n<p>实际上，除了将 step 的值用 <code>plus2</code> 替换掉 <code>plus1</code> 以外，其他都是一样的。</p>\n<p>让我们将 <code>plus1</code> 提取出来，并将其作为函数 <code>f</code> 进行传递。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> mapped = f(item);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> xf.step(result, mapped);</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们定义了 mapping transducer，让我们使用它来逐步转换。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus2 = <span class=\"function\">(<span class=\"params\">input</span>) =&gt;</span> input + <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(append);</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [4] (=append([], 2+2)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [4,5] (=append([4], 3+2)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [4,5,6] (=append([4,5], 4+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [4,5,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>本例相较于之前使用<code>plus1</code> 和 <code>append</code> 函数的例子，唯一的区别在于使用 <code>map</code> 创建 transducer。我们可以类似地使用 <code>map(plus1)</code> 来创建 <code>plus1</code> transducer。<code>transducerPlus1</code> 虽然只是短暂的出现便被 <code>map(plus1)</code> 代替，但它对我们理解 transduce 的内部原理帮助很大。</p>\n<h2>Transduce</h2>\n<p>前面的示例讲解了使用 transducers 手动转换一系列的输入。让我们进一步优化。</p>\n<p>首先通过调用一个包含 stepper 转换的 transducer 来初始化 transformation，并定义 transduce 的初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = wrap(append);</span><br><span class=\"line\"><span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br></pre></td></tr></table></figure></p>\n<p>然后使用 <em>reducer</em> <code>xf.step</code> 来遍历每个输入元素。将初始值作为 step 函数的第一个 <code>result</code> 参数（另一个是输入源中的元素），上一个 step 函数的返回值供所有后续元素迭代使用。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result = xf.step(init, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3] (=append([], 2+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4] (=append([3], 3+1)))</span></span><br><span class=\"line\"></span><br><span class=\"line\">result = xf.step(result, <span class=\"number\">4</span>);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5] (=append([3,4], 4+1)))</span></span><br></pre></td></tr></table></figure></p>\n<p>我们使用 <code>xf.result</code> 输出最终结果。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> output = xf.result(result);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>可能你已经注意到了，这与上面定义的 <code>reduce</code> 实现非常相似。 事实也是如此。 我们可以将这个过程封装成一个新的函数 <code>transduce</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transduce = <span class=\"function\">(<span class=\"params\">transducer, stepper, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> stepper === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 确保存在用于步进（迭代）的 transformer</span></span><br><span class=\"line\">    stepper = wrap(stepper);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 传入 stepper 来创建 transformer：xf</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> xf = transducer(stepper);</span><br><span class=\"line\">  <span class=\"comment\">// xf 现在成为一个 transformer</span></span><br><span class=\"line\">  <span class=\"comment\">// 现在可以使用上面定义的 reduce 来迭代并</span></span><br><span class=\"line\">  <span class=\"comment\">// （在迭代之前）变换输入元素</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(xf, init, input);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>就像 reduce，我们需要确保 stepper 是一个 transformer。然后通过向 transducer 传入 stepper 来创建新的 transformer。 最后，我们使用包含新的 transformer 的 reduce 来进行迭代和转换结果。也就是说 transducer 的函数类型为：transformer -&gt; transformer。</p>\n<p>我们来实践一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [4,5,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>上述两例的唯一区别是传递给 map 的函数不同。</p>\n<p>我们来尝试一下不同的 step function 和初始值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = sum;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 12 (=3+4+5)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = sum;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 15 (=4+5+6)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = mult;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 60 (=3*4*5)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = mult;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// 120 (=4*5*6)</span></span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./transduce.png\" alt=\"transduce\"></p>\n<p>这里我们只是改变了 stepper 和初始值，便可以得到不同的结果。我们可以在不依赖中间变量的情况下，遍历一次便可求得累加和或乘积。</p>\n<h2>组合</h2>\n<p>如果我们想加3，改怎么办呢？我们可以定义 <code>plus3</code> 并且使用 <code>map</code>，但更好的方法是利用 transducers 的一个特性。</p>\n<p>事实上，我们可以通过其他两个函数：<code>plus1</code> 和 <code>plus2</code>，来定义 <code>plus3</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus3 = <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> puls2(plus1(item));</span><br></pre></td></tr></table></figure></p>\n<p>或许你已经看出来，其实这就是<a href=\"https://en.wikipedia.org/wiki/Function_composition_%28computer_science%29\" target=\"_blank\" rel=\"noopener\">函数组合</a>。让我们通过函数组合来重新定义 <code>plus3</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose2 = <span class=\"function\">(<span class=\"params\">fn1, fn2</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> fn1(fn2(item));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus3 = compose2(plus1, plus2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> output = [plus3(<span class=\"number\">2</span>), plus3(<span class=\"number\">3</span>), plus3(<span class=\"number\">4</span>)];</span><br><span class=\"line\"><span class=\"comment\">// [5,6,7]</span></span><br></pre></td></tr></table></figure></p>\n<p><code>compose2</code> 用于组合两个函数，调用顺序从右向左，看一下 <code>compose2</code> 的实现就可以知道为什么调用顺序是从右向左的了。最后一个 function 接受传入参数，返回结果作为下个 function 的输入。如此迭代，直到输出结果。</p>\n<p>让我们使用 <code>compose2</code> 来定义一个 transducer，该 transducer 由 <code>plus1</code> 和 <code>plus2</code> 组合而成，用于将每个迭代的元素加3。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus3 = map(compose2(plus1, plus2));</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus3;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [5,6,7]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们使用“函数组合”来组合 <code>plus1</code> 和 <code>plus2</code> 而不是重新定义 <code>plus3</code>，来组合出传入 map 的加3操作。</p>\n<p>将上述这些的目的是什么呢？实际上，我们可以通过组合其他的 transducers 来创建新的 transducers。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus1 = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus2 = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus3 = compose2(transducerPlus1, transducerPlus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus3;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [5,6,7]</span></span><br></pre></td></tr></table></figure></p>\n<p>新组合出来的 transducer 可以用于组合其他的 transducer 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus1 = map(plus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus2 = map(plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus3 = compose2(transducerPlus1, transducerPlus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducerPlus4 = compose2(transducerPlus3, transducerPlus1);</span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = transducerPlus4;</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br></pre></td></tr></table></figure></p>\n<p><img src=\"./compose_transducers.png\" alt=\"compose_transducers\"></p>\n<p>再次注意，与本节前面的例子的唯一区别是 transducer 的创建。其它都没变。</p>\n<p>组合之所以能工作，是因为 transducers 的定义：接受一个 transformer 并返回一个新的 transformer。也即 transducer 的输入与返回值类型相同，且为单输入单输出。只要符合上述条件，便可以使用函数组合来创建与“输入函数”相同类型的“新函数”。</p>\n<p>由上可得，transducers 是一种 “可组合的算法变换”。这在实践中已经证明其强大之处：可以将新的变换定义为一系列较小变换的组合，然后将它们通过 <code>compose</code> 或 <code>pipe</code> 组合起来。我们将在后续章节中展示更多的例子。</p>\n<p>事实上，虽然函数组合调用顺序为由右向左，而 transformation 调用是自左向右的（译者注：这也是理解 transduce 的难点之一，理解了这个，也就基本理解了 transduce。可以通过单个 transducer 和 transformer 的组合，来理解 transformation 的调用顺序。transduce 本质上做的事情是 <strong>在对每个元素进行归约之前先对其进行变换</strong> ，将这句话重复五遍：），这也是 transduce 区别于 reduce 的“唯一”不同点）。</p>\n<p>在上面的 <code>transducersPlus4</code> 示例中，每个元素先进行 <code>plus3</code> 转换，然后进行 <code>plus1</code> 转换。</p>\n<p>虽然在本例中 transducers 的调用顺序对结果没有影响，但是<strong>从左向右</strong>的变换顺序还是需要牢记在心。这个变换调用顺序让你在阅读代码时更容易理解，因为它与你的阅读顺序是一至的（如果使用的是英文，或者中文）。</p>\n<h2>part 1 总结</h2>\n<p>Transducers 将 “可组合的算法转换” 抽象出来，使其独立于输入、输出，甚至迭代的整个过程。</p>\n<p>本文演示了如何使用 transducers 来抽象算法转换，transducer 将一个 transformer 转换为另一个 transformer。transformer 可以用于 transduce 进行迭代和转换输入源。</p>\n<p>相较于 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore.js</a> 或 <a href=\"https://lodash.com/\" target=\"_blank\" rel=\"noopener\">Lo-Dash</a>对数组和计算中间结果的对象进行操作，transducers 定义的 transformation 在函数方面类似于传递给 reduce 的 stepping function：将初始值作为首次迭代的“结果参数”，执行输入为一个“结果参数”和元素的函数，返回可能变换过的结果，并将其作为下次迭代的“结果参数”。一旦将 transformation 从数据中抽象出来，就可以将相同的 transformations 应用于以某初始值开始并遍历某个“累积结果”的不同处理过程。</p>\n<p>我们已经展示了相同的 transducers 可以操作不同的“输出源”，只需改变创建 transducer 时用到的初始值和 stepper。这种抽象的好处之一是：可以遍历一次得到结果，且没有中间数组产生。</p>\n<p>尽管没有明确说明，我们还是展示了 transducers 将 transducer 与 迭代过程及输入源解耦。在迭代过程中，我们使用相同的 transducer 对元素进行转换，并将转换结果传给 step function，我们使用数组的 reduce 从数组中获取数据。</p>\n<h2>还想了解更多！</h2>\n<p><a href=\"http://simplectic.com/blog/2014/transducers-explained-pipelines/\" target=\"_blank\" rel=\"noopener\">看这里</a> ,以后的文章中将会进一步讨论 transducers 并不会每步都输出元素；并且可能会提前终止迭代，并返回终止前已经归约的结果。本文只讨论了 step，未讨论 init 和 result，将来会有补充。</p>\n<p>我们将会了解到，输入源可以是任意产生一系列值的东西：惰性列表，不确定的序列生成器，CSP（通信顺序进程），<a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a>\nlazy lists, indefinite sequence generation, CSP[http://phuu.net/2014/08/31/csp-and-transducers.html), [push streams][12], <a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a>, iterators, generators, immutable-js data structures, 等等。</p>\n<h2>等不及了！</h2>\n<p>在此期间，可以查看 <a href=\"http://clojure.org/transducers\" target=\"_blank\" rel=\"noopener\">Clojure文档</a>, 或者观看<a href=\"https://www.youtube.com/watch?v=6mTbuzafcII\" target=\"_blank\" rel=\"noopener\">视频</a>或这篇<a href=\"http://phuu.net/2014/08/31/csp-and-transducers.html\" target=\"_blank\" rel=\"noopener\">文章</a>，还有其他更多更好的介绍，可以自行 Google 。</p>\n<p>想要立刻实践一下？已经有三个库实现了相似的API：<a href=\"https://github.com/cognitect-labs/transducers-js\" target=\"_blank\" rel=\"noopener\">transducers-js</a>、<a href=\"https://github.com/jlongster/transducers.js\" target=\"_blank\" rel=\"noopener\">transducers.js</a>、<a href=\"https://github.com/ramda/ramda/blob/v0.22.1/src/transduce.js\" target=\"_blank\" rel=\"noopener\">ramda</a>(译者注：ramda 中 transducer 部分也是本文作者写的）。本文介绍与 transducers-js 实现类似，但概念同样适用于 transducers.js。</p>\n<p><a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">Underscore.js</a> 的粉丝？可以查看 <a href=\"http://simplectic.com/projects/underarm/\" target=\"_blank\" rel=\"noopener\">underarm</a>，基于 <a href=\"https://github.com/transduce/transduce\" target=\"_blank\" rel=\"noopener\">transduce</a> 库（译者注：本文作者写的库）写的。</p>\n<p>怎样将 transducer 应用到 <a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a> 中呢？我们还在探索。</p>\n<p>希望得到新文章的通知？可以在 Twitter 上关注 <a href=\"https://twitter.com/simplectic\" target=\"_blank\" rel=\"noopener\">simplectic</a>。</p>\n"},{"title":"Transducers Explained: Pipelines 中文","date":"2016-11-01T15:25:55.000Z","_content":"\n本文是 Transducer Explained 教程的第二篇。在[第一篇](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)中，讲解从 *reducing functions* 开始， 到 *transformers*， 再到使用 `map` *transducers* 的 `transduce` 。本文中，将介绍四个新的 *transducers*：`filter`、`remove`、`drop` 和 `take`。我们将展示如何将 *transducers* 组合成 *pipeline*，并讨论转换的顺序。我们还将改变 `reduce` 的实现，使其能够借助 `reduced` 值 提前终止遍历操作。\n\n那么，上次讲到哪了呢？\n\n## Transformer\n\n[第一篇](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)文章中，通过定义 *transformer* 协议规范了 `reduce` 的步骤。\n\n所有 transformers 都包含3个方法：\n\n1. 使用初始值初始化 transformation，`init`\n2. 使用 *reducing function* 来组合每个元素，`step`\n3. 将最后计算的结果转换为输出，`result`\n\n在第一篇文章中，我们使用 *reducing functions* ：`mult`、`add` 和 `append` 来转换输入值。\n\n```js\nconst append = (value, item) => value.push(item);\n```\n\n本文中，我们只会用到 `append`，将元素拼接到数组的尾部。\n\n## Reduce\n\n我们重新实现了 `reduce`，它接受以下参数：\n\n1. 一个 transformer 或者将被封装成 transformer 的 *reducing Function*\n2. 一个初始值（例如`[]`)。\n3. 一个输入源（例如传入 reduce 的数组）\n\n目前的实现使用 transformer 的 `step` 函数作为数组 *reducing function*，稍后将修改这一实现。\n\n在迭代过程中，使用两个参数来调用 `step` 函数：`value` 和 `item`。初始 value 由调用者提供，后续的每个 value 使用当前 `step` 函数的返回值。\n\n`item` 由一些迭代过程（如何翻译？）提供。在第一篇文章中展示了两个过程：归约数组的每个元素，并使用每个新的 `item` 手动调用 `step` 函数。（在后续文章中我们将看到更多例子）。\n\n## Transducer\n\n我们创建了 mapping *transducer*。\n\n```js\nconst map = f => xf => ({\n  init: () => xf.init(),\n  step: (result, item) => xf.step(result, f(item)),\n  result: result => xf.result(result),\n});\n```\n\n`map` transducer 接受一个 mapping 函数：`f`，并返回一个 transducer：\n\n1. 接受一个已有 transformer\n2. 返回一个新的 transformer，用来通过 `f` 转换 `items`\n3. 代理给封装的 transformer 额外的处理\n\n函数`f`可以是接受一个 item, 然后将其映射为一个新值的任意函数。\n\n```js\nconst plus1 = input => input + 1;\n\nconst plus2 = input => input + 2;\n```\n\n在本节的例子中将继续使用这两个简单的函数。\n\n## Transduce\n\n我们定义了一个新函数，`transduce`, 其接受：\n\n1. 一个 transducer: 定义transformation\n2. 一个 stepper 函数，或 transformer (如 `append`)\n3. 一个 stepper 函数 的初始值 (如 `[]`)\n4. 输入源 (如一个待转换的数组)\n\n向 transducer 传入 `stepper` 函数，来创建一个 transformer, 然后将该 transformer、初始值和输入源一同传入 `reduce`。\n\n我们已经展示过，使用相同的 transducer 可以产生不同的结果，只要改变传入 `transduce` 的初始值和 `stepper` 函数\n\n## Composition\n\n最后，我们展示了可以通过组合已有 transducers 来创建新的 transducers\n\n```js\nconst compose2 = (fn1, fn2) => item => fn1(fn2(item));\n\nconst transducer = compose2(\n      compose2(map(plus1), map(plus2)),\n      map(plus1));\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [6,7,8]\n```\n\n被组合的 transducer 从左向右对输入源进行转换。\n\n今天我们从这里开始讲起。如果对上例不熟悉，可以参考[第一篇文章](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)\n\n## Pipelines\n\n首先，定义一个新的函数，用它可以组合任意数量的函数。\n\n```js\nconst compose = (...fns) => xf => {\n  let i = fns.length - 1;\n  for(; i >=0; i--) { xf = fns[i](xf); }\n  return xf;\n};\n```\n\n这只是上面定义的 `compose2` 的扩展。函数组合从右向左：返回的函数接受用于调用右侧最后一个函数的初始参数。该调用的返回值(输出)用作左侧下一个函数的参数(输入)。对于所有传入 `ompose` 的函数，重复执行该过程。\n\n可以通过组合 `plus1` 和 `plus2` 来创建 `plus4`。\n\n```js\n// 手动调用 \nconst value = plus1(plus1(plus2(5)));\n// 9\n\n// 使用组合函数 (允许重复使用被组合的函数)\nconst plus4 = compose(plus1, plus1, plus2);\nconst value = plus4(5);\n// 9\n```\n\n我们通过组合 `map` transducers 来创建一个 `plus5` transducer。\n\n```js\nconst transducer = compose(\n      map(plus1),  // [3,4,5]\n      map(plus2),  // [5,6,7]\n      map(plus1),  // [6,7,8]\n      map(plus1)); // [7,8,9]\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [7,8,9]\n```\n\n每个 transducer 旁边的注释将每次转换通过数组展示出来，这样每次完成一个完整的转换，更容易追踪转换的过程。\n\n然而，需要清楚，整个转换过程中，transducers 每次只顺序转换一个 item，并且不会产生中间结果。注释仅仅表示 pipeline 的每步的转换结果。我们将在下面继续讨论这个问题。\n\n实际上，虽然组合是从右向左，转换的顺序实际上是从左向右的（在示例中是从上向下）。（需要将 transducers 的组合顺序 和 组合后 transducers 对输入源的转换顺序区分开)。在本例中顺序并不重要，但下一个例子中，便需要考虑调用顺序了。\n\n## Filter\n\n我们来定义 `filter` transducer\n\n```js\nconst filter = predicate => xf => ({\n  init: () => xf.init(),\n  step: (value, item) => {\n    const allow = predicate(item);\n    if(allow){\n      value = xf.step(value, item);\n    }\n    return value;\n  },\n  result: (value) => xf.result(value),\n};\n```\n\n注意到，只有在 predicate(断言) 返回 true 时，由 `filter` 返回的 transformer 才会代理给下一个(左侧) transformer。如果 predicate 返回 false，则会忽略该次 item，并返回上次的迭代结果。\n\n我们创建一个 transducer ，来过滤出所有奇数。\n\n```js\nconst isOdd = num => num % 2 === 1;\n\nconst transducer = filter(isOdd);\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [1,3,5]\n```\n\n我们创建了一个使用 `isOdd` predicate 来过滤元素的 transducer。然后使用 `transduce` 将其作用于一个整数数组，输出数组中只包含奇数。\n\n我们再创建一个函数，该函数返回一个检查与传入参数是否相等的 predicate。\n\n```js\n// another predicate \nconst isEqual = y => x => x === y;\n\nconst transducer = filter(isEqual(2));\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [2]\n```\n\n可以看到，创建的 predicate `isEqual(2) 只允许数字 2 输出。\n\n再来一个辅助函数，接受一个 predicate，将其结果取反。\n\n```js\nconst not = predicate => x => !predicate(x);\n\nconst transducer = filter(not(isEqual(2)));\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [1,3,4,5]\n```\n\n我们修改了前面的例子：对 predicate `isEqual(2)` 取反，由此创建了一个移除输入源中所有数字 2 的 transducer。\n\n现在在我们的 pipeline 库中有了另一件武器，一起来把玩一下吧。\n\n## Pipeline 顺序\n\n我们来对每个元素加 1，然后过滤出奇数。\n\n```js\nconst transducer = compose(\n      map(plus1),         // [2,3,4,5,6]\n      filter(isOdd));     // [3,5]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [3,5]\n```\n\n首先调用 `map(plus1)` transducer 对每个元素加 1，然后调用下一步转换：过滤出所有奇数。\n\n我们改变一下 transducers 的顺序，看看会发生什么。\n\n```js\nconst transducer = compose(\n      filter(isOdd),      // [1,3,5]\n      map(plus1));        // [2,4,6]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [2,4,6]\n```\n\n我们首先过滤出所有奇数。filter(`isOdd`) transformer 只将奇数传给下一个 transformer。所有传到下一步的元素(奇数)都会加1。\n\n上述表明了 *组合 transducers* 的两个重要性质：\n\n1. 虽然组合是从右向左，但转换是从左向右。\n2. 使用 transducers 越早减少 pipeline 中元素的数量，效率可能会越高。\n \n注意到，在最后一个例子中，`map(plus1)` 仅仅使用所有元素的子集调用。同样的，并未创建中间数组，仅仅作为注释便于理解而已。\n\n## Remove\n\n开始讲另一个 transducer 了哈。\n\n```js\nconst remove = predicate => filter(not(predicate));\n```\n\n很简单吧。实际上，我们可以通过对 predicate 取反 和 重用 `filter` 来创建 `remove`。\n\n我们来实践一下。\n\n```js\nconst transducer = compose(\n      filter(isOdd),        // [1,3,5]\n      map(plus1),           // [2,4,6] \n      remove(isEqual(4)));  // [2,6]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [2,6]\n```\n\n首先过滤出奇数，然后对每项加1，然后删除 `4`。\n\n## Drop \n\n如果我们想在迭代开始时跳过 `n` 个元素，该做么做呢？这正是 `drop` transducer 的本职。\n\n```js\nconst drop = n => xf => {\n  var left = n;\n  return {\n    init: () => xf.init(),\n    step: function(value, item){\n      if(left > 0){\n        left--;\n      } else {\n        value = xf.step(value, item);\n      }\n      return value;\n    },\n    result: result => xf.result(result),\n  }\n}\n```\n\n你可以这样使用：\n\n```js\nvar transducer = drop(2);\nvar stepper = append;\nvar init = [];\nvar input = [1,2,3,4,5];\nvar output = transduce(transducer, stepper, init, input);\n// [3,4,5]\n```\n\nDrop 接受从列表开始待丢弃元素的个数。这是我们第一个用来创建有状态变换的 transducer 的示例。每次调用 `drop` transducer 来创建一个 transformation 时，便会创建一个变量 `left`，指示在当次 transformation时，还剩多少个需要被丢弃的元素。`left` 被初始化为 `n`。\n\n注意，我们使用一个无状态的 transducer 创建了一个有状态的 transformer。这是一个重要的区别。这意味着我们可以重用 `drop(2)` transducer 任意多次，而不必担心任何状态。状态是在 transformer 中创建的，而不是 transducer 中。\n\n假如我们不想丢弃，而是获取前 `n` 个元素并丢弃剩余元素，该怎么办呢？为方便实现，假设 `n > 0`。\n\n我们来尝试一下。\n\n```js\nconst take = n => xf => {\n  var left = n;\n  return {\n    init: () => xf.init(),\n    step: function(value, item){\n      value = xf.step(value, item);\n      if(--left <= 0){\n        // 如何停止???\n      }\n      return value;\n    },\n    result: result => xf.result(result),\n  }\n};\n```\n\n哦噢，麻烦来了。我们知道如何逐步处理每个元素，并且通过 transformer 的状态来保持剩余元素的计数。但是，如何停止对剩余元素的迭代呢？\n\n为什么我们需要表明我们已经完成，不再接受任何额外元素呢？不仅因为继续接受元素是一种浪费，还因为无法保证迭代能够完成。有可能迭代是无限的。如果可以，我们当然想终止无限迭代。\n\n那么如何表示提前终止呢？我们需要在看一下迭代的源代码：`transduce`。\n\n## Reduce redux (终极 Reduce)\n\n下面是当前 `transduce` 和 `reduce` 的定义，取自[第一篇文章](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)：\n\n```js\nconst transduce = (transducer, stepper, init, input) => {\n  if(typeof stepper === 'function'){\n    stepper = wrap(stepper);\n  }\n\n  var xf = transducer(stepper);\n  return reduce(xf, init, input);\n};\n\nconst reduce(xf, init, input) => {\n  if(typeof xf === 'function'){\n    xf = wrap(xf);\n  }\n  // how do we stop?? \n  var value = input.reduce(xf.step, init); \n  return xf.result(value);\n};\n\nconst wrap = stepper => ({\n  init: () => throw new Error('init not supported'),\n  step: stepper,\n  result: value => value,\n};\n```\n\n看一下上面的实现，便会发现，我们正在使用原生数组 `reduce` 方法进行迭代，`reduce` 的 reducing function 来自 transformer。后续文章中，我们将删除输入源是数组的假设，但现在还需继续使用改假设。我们来定义自己的 `arrayReduce` 实现。\n\n```js\nconst reduce = (xf, init, input) => {\n  if(typeof xf === 'function'){\n    xf = wrap(xf);\n  }\n\n  return arrayReduce(xf, init, input);\n};\n\nconst arrayReduce(xf, init, array) => {\n  var value = init;\n  var idx = 0;\n  var length = array.length;\n  for(; idx < length; idx++){\n    value = xf.step(value, array[idx]);\n    // We need to break here, but how do we know?\n  }\n  return xf.result(value);\n};\n```\n\n`arrayReduce` 的实现接受一个 transformer 、初始值和输入数组。然后使用 `for` 循环遍历每个元素，并使用累加值 value 和数组元素来调用 transformer `step` 函数。\n\n我们需要一个方法来打破这个循环，打破循环需要依赖某些标记值。幸运的是，我们可以采用已有的 [transducer 协议](https://github.com/cognitect-labs/transducers-js#reduced)。\n\n为了在调用 transformer 中的 `step` 之后发出提前终止信号，我们可以将 *reduced* 值封装在包含两个属性的对象中：\n\n1. `value`: 存储实际要封装的值。\n2. `__transducers_reduced__`: bool 类型值，为`true`时，表示该对象是 reduced 的，迭代需要被终止。\n\n实现如下：\n\n```js\nconst reduced = value => ({\n  value: value,\n  __transducers_reduced__: true,\n});\n```\n\n我们还将添加一个 predicate 来确定值是否是 reduced 。\n\n```js\nconst iReduced = value => value && value.__transducers_reduced__;\n```\n\n此外，我还需要一个方法来提取，或 `deref`(解引用) reduced 的值。\n\n现在我们可以优化 `arrayReduce` 来处理因 reduced values 提前终止的情况。\n\n```js\nconst arrayReduce => (xf, init, array) => {\n  var value = init;\n  var idx = 0;\n  var length = array.length;\n  for(; idx < length; idx++){\n    value = xf.step(value, array[idx]);\n    if(isReduced(value)){\n      value = deref(value);\n      break;\n    }\n  }\n  return xf.result(value);\n}\n```\n\n我们像以前一样对每个元素进行迭代，但每次调用 `step` 之后，我们检查是否得到一个 reduced value。如果是，我们提取值并终止迭代(中断循环)。我们仍然对最终值调用 `result` 方法，不管它来自 reduced value 还是完整的迭代。\n\n## Take 2\n\n现在可以完成 `take` 的实现了：\n\n```js\nconst take = n => xf => {\n  var left = n;\n  return {\n    init: () => xf.init(),\n    step: function(value, item){\n      value = xf.step(value, item);\n      if(--left <= 0){\n        // we are done, so signal reduced\n        value = reduced(value);\n      }\n      return value;\n    },\n    result: value => xf.result(value),\n  }\n};\n```\n\n我们之前唯一缺失的是：当检测到转换完成后使用 `reduced` 对值进行封装。(现在已经补上了)\n\n让我们看看它是否能工作：\n\n```js\nconst transducer = take(3);\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [1,2,3]\n```\n\n工作正常！\n\n就像任何其他的 transducer，你可以将 `drop` 和 `take` 组合成一个 pipeline\n\n```js\nconst transducer = compose(\n    drop(1),    // [2,3,4,5]\n    take(3),    // [2,3,4]\n    drop(1));   // [3,4]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [3,4]\n```\n\n第一个 `drop` 跳过第一个元素，然后将剩余元素通过 step 传给下一个 transformer。`take`  transformer 逐一遍历从第一个 `drop` 传过来的数组的前三个元素，然后停止迭代。最后一个 `drop` 删除从 `take` 传过来的数组的首个元素，并且在终止之前逐一发送剩余的两个元素。\n\n## 第二部分总结\n\n我们首先总结了在第一篇文章中学到的内容。我们增加了4个新的 transducers：`filter`、`remove`、`take`、`drop`。我们通过组合 transducers 来创建 transformer pipelines，并看到变换的顺序是从左到右。\n\n我们看到，除了在转换期间改变元素，一个 transformer 可以决定跳过任意元素，通过不调用下一个 transformer 的 `step` 来实现。每一个 transformer 的实现决定了什么会传递到下个 transformer。有些情况下， transformer 可能会发送多个值，例如 `cat` 或 [`transduce-string`](https://github.com/transduce/transduce-string)。\n\n我们还看到了可以创建有状态变换的 transducer 的一些例子。状态由 transformer 管理，而不是 transducer。这允许无状态 transducer 的重用，即时它们创建的 transformers 管理状态。\n\n当实现 `take` 时，我们意识到需要添加一个用于提前终止迭代的方法。我们改变了 `reduce` 的实现来处理和解包 reduced 的值，并且实现 `take` 用于在取完数据时终止迭代。\n\n## 还有别的吗？\n\n在入门教程的最后一篇文章中还有一些需要解释的相关问题。我们仍未解释 transformer 的 `init` 和 `reduce` 的作用。我们将添加 `into` 并一般化 `reduce` 的实现来支持迭代器。\n\n我们还看到输入元素可以是产生 sequence 值的任意东西：惰性列表、无限序列生成器、[CSP](http://phuu.net/2014/08/31/csp-and-transducers.html)、[Node.js streams](https://github.com/transduce/transduce-stream)、迭代器、生成器、immutable-js 数据结构等。\n\n想要获取新文章的通知吗？可以关注 获取 [simplectic](https://twitter.com/simplectic) 的 Twitter。\n\n## 我现在已经准备好了！\n\n已经准备使用 transducers 了吗？你应该已经具备良好的知识体系，如果通读了这篇文章：查看 [transducers-js](https://github.com/cognitect-labs/transducers-js) 和 [transducers.js](https://github.com/jlongster/transducers.js)。我们主要参考 transducers-js 的实现，但概念同样适用于 transducers.js。\n\n如果你喜欢 [Underscore.js](http://simplectic.com/projects/underarm)，可以查看 [underarm](http://underscorejs.org/)。它基于 [transduce](https://github.com/transduce/transduce) 库，允许针对 transducers.js 和 transducer-js 支持的公共协议定义 API。\n\n","source":"_posts/Transducers-Explained-Pipelines.md","raw":"---\ntitle: 'Transducers Explained: Pipelines 中文'\ndate: 2016-11-01 23:25:55\ntags:\n---\n\n本文是 Transducer Explained 教程的第二篇。在[第一篇](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)中，讲解从 *reducing functions* 开始， 到 *transformers*， 再到使用 `map` *transducers* 的 `transduce` 。本文中，将介绍四个新的 *transducers*：`filter`、`remove`、`drop` 和 `take`。我们将展示如何将 *transducers* 组合成 *pipeline*，并讨论转换的顺序。我们还将改变 `reduce` 的实现，使其能够借助 `reduced` 值 提前终止遍历操作。\n\n那么，上次讲到哪了呢？\n\n## Transformer\n\n[第一篇](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)文章中，通过定义 *transformer* 协议规范了 `reduce` 的步骤。\n\n所有 transformers 都包含3个方法：\n\n1. 使用初始值初始化 transformation，`init`\n2. 使用 *reducing function* 来组合每个元素，`step`\n3. 将最后计算的结果转换为输出，`result`\n\n在第一篇文章中，我们使用 *reducing functions* ：`mult`、`add` 和 `append` 来转换输入值。\n\n```js\nconst append = (value, item) => value.push(item);\n```\n\n本文中，我们只会用到 `append`，将元素拼接到数组的尾部。\n\n## Reduce\n\n我们重新实现了 `reduce`，它接受以下参数：\n\n1. 一个 transformer 或者将被封装成 transformer 的 *reducing Function*\n2. 一个初始值（例如`[]`)。\n3. 一个输入源（例如传入 reduce 的数组）\n\n目前的实现使用 transformer 的 `step` 函数作为数组 *reducing function*，稍后将修改这一实现。\n\n在迭代过程中，使用两个参数来调用 `step` 函数：`value` 和 `item`。初始 value 由调用者提供，后续的每个 value 使用当前 `step` 函数的返回值。\n\n`item` 由一些迭代过程（如何翻译？）提供。在第一篇文章中展示了两个过程：归约数组的每个元素，并使用每个新的 `item` 手动调用 `step` 函数。（在后续文章中我们将看到更多例子）。\n\n## Transducer\n\n我们创建了 mapping *transducer*。\n\n```js\nconst map = f => xf => ({\n  init: () => xf.init(),\n  step: (result, item) => xf.step(result, f(item)),\n  result: result => xf.result(result),\n});\n```\n\n`map` transducer 接受一个 mapping 函数：`f`，并返回一个 transducer：\n\n1. 接受一个已有 transformer\n2. 返回一个新的 transformer，用来通过 `f` 转换 `items`\n3. 代理给封装的 transformer 额外的处理\n\n函数`f`可以是接受一个 item, 然后将其映射为一个新值的任意函数。\n\n```js\nconst plus1 = input => input + 1;\n\nconst plus2 = input => input + 2;\n```\n\n在本节的例子中将继续使用这两个简单的函数。\n\n## Transduce\n\n我们定义了一个新函数，`transduce`, 其接受：\n\n1. 一个 transducer: 定义transformation\n2. 一个 stepper 函数，或 transformer (如 `append`)\n3. 一个 stepper 函数 的初始值 (如 `[]`)\n4. 输入源 (如一个待转换的数组)\n\n向 transducer 传入 `stepper` 函数，来创建一个 transformer, 然后将该 transformer、初始值和输入源一同传入 `reduce`。\n\n我们已经展示过，使用相同的 transducer 可以产生不同的结果，只要改变传入 `transduce` 的初始值和 `stepper` 函数\n\n## Composition\n\n最后，我们展示了可以通过组合已有 transducers 来创建新的 transducers\n\n```js\nconst compose2 = (fn1, fn2) => item => fn1(fn2(item));\n\nconst transducer = compose2(\n      compose2(map(plus1), map(plus2)),\n      map(plus1));\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [6,7,8]\n```\n\n被组合的 transducer 从左向右对输入源进行转换。\n\n今天我们从这里开始讲起。如果对上例不熟悉，可以参考[第一篇文章](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)\n\n## Pipelines\n\n首先，定义一个新的函数，用它可以组合任意数量的函数。\n\n```js\nconst compose = (...fns) => xf => {\n  let i = fns.length - 1;\n  for(; i >=0; i--) { xf = fns[i](xf); }\n  return xf;\n};\n```\n\n这只是上面定义的 `compose2` 的扩展。函数组合从右向左：返回的函数接受用于调用右侧最后一个函数的初始参数。该调用的返回值(输出)用作左侧下一个函数的参数(输入)。对于所有传入 `ompose` 的函数，重复执行该过程。\n\n可以通过组合 `plus1` 和 `plus2` 来创建 `plus4`。\n\n```js\n// 手动调用 \nconst value = plus1(plus1(plus2(5)));\n// 9\n\n// 使用组合函数 (允许重复使用被组合的函数)\nconst plus4 = compose(plus1, plus1, plus2);\nconst value = plus4(5);\n// 9\n```\n\n我们通过组合 `map` transducers 来创建一个 `plus5` transducer。\n\n```js\nconst transducer = compose(\n      map(plus1),  // [3,4,5]\n      map(plus2),  // [5,6,7]\n      map(plus1),  // [6,7,8]\n      map(plus1)); // [7,8,9]\nconst stepper = append;\nconst init = [];\nconst input = [2,3,4];\nconst output = transduce(transducer, stepper, init, input);\n// [7,8,9]\n```\n\n每个 transducer 旁边的注释将每次转换通过数组展示出来，这样每次完成一个完整的转换，更容易追踪转换的过程。\n\n然而，需要清楚，整个转换过程中，transducers 每次只顺序转换一个 item，并且不会产生中间结果。注释仅仅表示 pipeline 的每步的转换结果。我们将在下面继续讨论这个问题。\n\n实际上，虽然组合是从右向左，转换的顺序实际上是从左向右的（在示例中是从上向下）。（需要将 transducers 的组合顺序 和 组合后 transducers 对输入源的转换顺序区分开)。在本例中顺序并不重要，但下一个例子中，便需要考虑调用顺序了。\n\n## Filter\n\n我们来定义 `filter` transducer\n\n```js\nconst filter = predicate => xf => ({\n  init: () => xf.init(),\n  step: (value, item) => {\n    const allow = predicate(item);\n    if(allow){\n      value = xf.step(value, item);\n    }\n    return value;\n  },\n  result: (value) => xf.result(value),\n};\n```\n\n注意到，只有在 predicate(断言) 返回 true 时，由 `filter` 返回的 transformer 才会代理给下一个(左侧) transformer。如果 predicate 返回 false，则会忽略该次 item，并返回上次的迭代结果。\n\n我们创建一个 transducer ，来过滤出所有奇数。\n\n```js\nconst isOdd = num => num % 2 === 1;\n\nconst transducer = filter(isOdd);\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [1,3,5]\n```\n\n我们创建了一个使用 `isOdd` predicate 来过滤元素的 transducer。然后使用 `transduce` 将其作用于一个整数数组，输出数组中只包含奇数。\n\n我们再创建一个函数，该函数返回一个检查与传入参数是否相等的 predicate。\n\n```js\n// another predicate \nconst isEqual = y => x => x === y;\n\nconst transducer = filter(isEqual(2));\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [2]\n```\n\n可以看到，创建的 predicate `isEqual(2) 只允许数字 2 输出。\n\n再来一个辅助函数，接受一个 predicate，将其结果取反。\n\n```js\nconst not = predicate => x => !predicate(x);\n\nconst transducer = filter(not(isEqual(2)));\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [1,3,4,5]\n```\n\n我们修改了前面的例子：对 predicate `isEqual(2)` 取反，由此创建了一个移除输入源中所有数字 2 的 transducer。\n\n现在在我们的 pipeline 库中有了另一件武器，一起来把玩一下吧。\n\n## Pipeline 顺序\n\n我们来对每个元素加 1，然后过滤出奇数。\n\n```js\nconst transducer = compose(\n      map(plus1),         // [2,3,4,5,6]\n      filter(isOdd));     // [3,5]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [3,5]\n```\n\n首先调用 `map(plus1)` transducer 对每个元素加 1，然后调用下一步转换：过滤出所有奇数。\n\n我们改变一下 transducers 的顺序，看看会发生什么。\n\n```js\nconst transducer = compose(\n      filter(isOdd),      // [1,3,5]\n      map(plus1));        // [2,4,6]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [2,4,6]\n```\n\n我们首先过滤出所有奇数。filter(`isOdd`) transformer 只将奇数传给下一个 transformer。所有传到下一步的元素(奇数)都会加1。\n\n上述表明了 *组合 transducers* 的两个重要性质：\n\n1. 虽然组合是从右向左，但转换是从左向右。\n2. 使用 transducers 越早减少 pipeline 中元素的数量，效率可能会越高。\n \n注意到，在最后一个例子中，`map(plus1)` 仅仅使用所有元素的子集调用。同样的，并未创建中间数组，仅仅作为注释便于理解而已。\n\n## Remove\n\n开始讲另一个 transducer 了哈。\n\n```js\nconst remove = predicate => filter(not(predicate));\n```\n\n很简单吧。实际上，我们可以通过对 predicate 取反 和 重用 `filter` 来创建 `remove`。\n\n我们来实践一下。\n\n```js\nconst transducer = compose(\n      filter(isOdd),        // [1,3,5]\n      map(plus1),           // [2,4,6] \n      remove(isEqual(4)));  // [2,6]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [2,6]\n```\n\n首先过滤出奇数，然后对每项加1，然后删除 `4`。\n\n## Drop \n\n如果我们想在迭代开始时跳过 `n` 个元素，该做么做呢？这正是 `drop` transducer 的本职。\n\n```js\nconst drop = n => xf => {\n  var left = n;\n  return {\n    init: () => xf.init(),\n    step: function(value, item){\n      if(left > 0){\n        left--;\n      } else {\n        value = xf.step(value, item);\n      }\n      return value;\n    },\n    result: result => xf.result(result),\n  }\n}\n```\n\n你可以这样使用：\n\n```js\nvar transducer = drop(2);\nvar stepper = append;\nvar init = [];\nvar input = [1,2,3,4,5];\nvar output = transduce(transducer, stepper, init, input);\n// [3,4,5]\n```\n\nDrop 接受从列表开始待丢弃元素的个数。这是我们第一个用来创建有状态变换的 transducer 的示例。每次调用 `drop` transducer 来创建一个 transformation 时，便会创建一个变量 `left`，指示在当次 transformation时，还剩多少个需要被丢弃的元素。`left` 被初始化为 `n`。\n\n注意，我们使用一个无状态的 transducer 创建了一个有状态的 transformer。这是一个重要的区别。这意味着我们可以重用 `drop(2)` transducer 任意多次，而不必担心任何状态。状态是在 transformer 中创建的，而不是 transducer 中。\n\n假如我们不想丢弃，而是获取前 `n` 个元素并丢弃剩余元素，该怎么办呢？为方便实现，假设 `n > 0`。\n\n我们来尝试一下。\n\n```js\nconst take = n => xf => {\n  var left = n;\n  return {\n    init: () => xf.init(),\n    step: function(value, item){\n      value = xf.step(value, item);\n      if(--left <= 0){\n        // 如何停止???\n      }\n      return value;\n    },\n    result: result => xf.result(result),\n  }\n};\n```\n\n哦噢，麻烦来了。我们知道如何逐步处理每个元素，并且通过 transformer 的状态来保持剩余元素的计数。但是，如何停止对剩余元素的迭代呢？\n\n为什么我们需要表明我们已经完成，不再接受任何额外元素呢？不仅因为继续接受元素是一种浪费，还因为无法保证迭代能够完成。有可能迭代是无限的。如果可以，我们当然想终止无限迭代。\n\n那么如何表示提前终止呢？我们需要在看一下迭代的源代码：`transduce`。\n\n## Reduce redux (终极 Reduce)\n\n下面是当前 `transduce` 和 `reduce` 的定义，取自[第一篇文章](https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/)：\n\n```js\nconst transduce = (transducer, stepper, init, input) => {\n  if(typeof stepper === 'function'){\n    stepper = wrap(stepper);\n  }\n\n  var xf = transducer(stepper);\n  return reduce(xf, init, input);\n};\n\nconst reduce(xf, init, input) => {\n  if(typeof xf === 'function'){\n    xf = wrap(xf);\n  }\n  // how do we stop?? \n  var value = input.reduce(xf.step, init); \n  return xf.result(value);\n};\n\nconst wrap = stepper => ({\n  init: () => throw new Error('init not supported'),\n  step: stepper,\n  result: value => value,\n};\n```\n\n看一下上面的实现，便会发现，我们正在使用原生数组 `reduce` 方法进行迭代，`reduce` 的 reducing function 来自 transformer。后续文章中，我们将删除输入源是数组的假设，但现在还需继续使用改假设。我们来定义自己的 `arrayReduce` 实现。\n\n```js\nconst reduce = (xf, init, input) => {\n  if(typeof xf === 'function'){\n    xf = wrap(xf);\n  }\n\n  return arrayReduce(xf, init, input);\n};\n\nconst arrayReduce(xf, init, array) => {\n  var value = init;\n  var idx = 0;\n  var length = array.length;\n  for(; idx < length; idx++){\n    value = xf.step(value, array[idx]);\n    // We need to break here, but how do we know?\n  }\n  return xf.result(value);\n};\n```\n\n`arrayReduce` 的实现接受一个 transformer 、初始值和输入数组。然后使用 `for` 循环遍历每个元素，并使用累加值 value 和数组元素来调用 transformer `step` 函数。\n\n我们需要一个方法来打破这个循环，打破循环需要依赖某些标记值。幸运的是，我们可以采用已有的 [transducer 协议](https://github.com/cognitect-labs/transducers-js#reduced)。\n\n为了在调用 transformer 中的 `step` 之后发出提前终止信号，我们可以将 *reduced* 值封装在包含两个属性的对象中：\n\n1. `value`: 存储实际要封装的值。\n2. `__transducers_reduced__`: bool 类型值，为`true`时，表示该对象是 reduced 的，迭代需要被终止。\n\n实现如下：\n\n```js\nconst reduced = value => ({\n  value: value,\n  __transducers_reduced__: true,\n});\n```\n\n我们还将添加一个 predicate 来确定值是否是 reduced 。\n\n```js\nconst iReduced = value => value && value.__transducers_reduced__;\n```\n\n此外，我还需要一个方法来提取，或 `deref`(解引用) reduced 的值。\n\n现在我们可以优化 `arrayReduce` 来处理因 reduced values 提前终止的情况。\n\n```js\nconst arrayReduce => (xf, init, array) => {\n  var value = init;\n  var idx = 0;\n  var length = array.length;\n  for(; idx < length; idx++){\n    value = xf.step(value, array[idx]);\n    if(isReduced(value)){\n      value = deref(value);\n      break;\n    }\n  }\n  return xf.result(value);\n}\n```\n\n我们像以前一样对每个元素进行迭代，但每次调用 `step` 之后，我们检查是否得到一个 reduced value。如果是，我们提取值并终止迭代(中断循环)。我们仍然对最终值调用 `result` 方法，不管它来自 reduced value 还是完整的迭代。\n\n## Take 2\n\n现在可以完成 `take` 的实现了：\n\n```js\nconst take = n => xf => {\n  var left = n;\n  return {\n    init: () => xf.init(),\n    step: function(value, item){\n      value = xf.step(value, item);\n      if(--left <= 0){\n        // we are done, so signal reduced\n        value = reduced(value);\n      }\n      return value;\n    },\n    result: value => xf.result(value),\n  }\n};\n```\n\n我们之前唯一缺失的是：当检测到转换完成后使用 `reduced` 对值进行封装。(现在已经补上了)\n\n让我们看看它是否能工作：\n\n```js\nconst transducer = take(3);\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [1,2,3]\n```\n\n工作正常！\n\n就像任何其他的 transducer，你可以将 `drop` 和 `take` 组合成一个 pipeline\n\n```js\nconst transducer = compose(\n    drop(1),    // [2,3,4,5]\n    take(3),    // [2,3,4]\n    drop(1));   // [3,4]\nconst stepper = append;\nconst init = [];\nconst input = [1,2,3,4,5];\nconst output = transduce(transducer, stepper, init, input);\n// [3,4]\n```\n\n第一个 `drop` 跳过第一个元素，然后将剩余元素通过 step 传给下一个 transformer。`take`  transformer 逐一遍历从第一个 `drop` 传过来的数组的前三个元素，然后停止迭代。最后一个 `drop` 删除从 `take` 传过来的数组的首个元素，并且在终止之前逐一发送剩余的两个元素。\n\n## 第二部分总结\n\n我们首先总结了在第一篇文章中学到的内容。我们增加了4个新的 transducers：`filter`、`remove`、`take`、`drop`。我们通过组合 transducers 来创建 transformer pipelines，并看到变换的顺序是从左到右。\n\n我们看到，除了在转换期间改变元素，一个 transformer 可以决定跳过任意元素，通过不调用下一个 transformer 的 `step` 来实现。每一个 transformer 的实现决定了什么会传递到下个 transformer。有些情况下， transformer 可能会发送多个值，例如 `cat` 或 [`transduce-string`](https://github.com/transduce/transduce-string)。\n\n我们还看到了可以创建有状态变换的 transducer 的一些例子。状态由 transformer 管理，而不是 transducer。这允许无状态 transducer 的重用，即时它们创建的 transformers 管理状态。\n\n当实现 `take` 时，我们意识到需要添加一个用于提前终止迭代的方法。我们改变了 `reduce` 的实现来处理和解包 reduced 的值，并且实现 `take` 用于在取完数据时终止迭代。\n\n## 还有别的吗？\n\n在入门教程的最后一篇文章中还有一些需要解释的相关问题。我们仍未解释 transformer 的 `init` 和 `reduce` 的作用。我们将添加 `into` 并一般化 `reduce` 的实现来支持迭代器。\n\n我们还看到输入元素可以是产生 sequence 值的任意东西：惰性列表、无限序列生成器、[CSP](http://phuu.net/2014/08/31/csp-and-transducers.html)、[Node.js streams](https://github.com/transduce/transduce-stream)、迭代器、生成器、immutable-js 数据结构等。\n\n想要获取新文章的通知吗？可以关注 获取 [simplectic](https://twitter.com/simplectic) 的 Twitter。\n\n## 我现在已经准备好了！\n\n已经准备使用 transducers 了吗？你应该已经具备良好的知识体系，如果通读了这篇文章：查看 [transducers-js](https://github.com/cognitect-labs/transducers-js) 和 [transducers.js](https://github.com/jlongster/transducers.js)。我们主要参考 transducers-js 的实现，但概念同样适用于 transducers.js。\n\n如果你喜欢 [Underscore.js](http://simplectic.com/projects/underarm)，可以查看 [underarm](http://underscorejs.org/)。它基于 [transduce](https://github.com/transduce/transduce) 库，允许针对 transducers.js 和 transducer-js 支持的公共协议定义 API。\n\n","slug":"Transducers-Explained-Pipelines","published":1,"updated":"2020-06-06T14:44:04.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu6001cf6mjetqom159","content":"<p>本文是 Transducer Explained 教程的第二篇。在<a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇</a>中，讲解从 <em>reducing functions</em> 开始， 到 <em>transformers</em>， 再到使用 <code>map</code> <em>transducers</em> 的 <code>transduce</code> 。本文中，将介绍四个新的 <em>transducers</em>：<code>filter</code>、<code>remove</code>、<code>drop</code> 和 <code>take</code>。我们将展示如何将 <em>transducers</em> 组合成 <em>pipeline</em>，并讨论转换的顺序。我们还将改变 <code>reduce</code> 的实现，使其能够借助 <code>reduced</code> 值 提前终止遍历操作。</p>\n<p>那么，上次讲到哪了呢？</p>\n<h2>Transformer</h2>\n<p><a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇</a>文章中，通过定义 <em>transformer</em> 协议规范了 <code>reduce</code> 的步骤。</p>\n<p>所有 transformers 都包含3个方法：</p>\n<ol>\n<li>使用初始值初始化 transformation，<code>init</code></li>\n<li>使用 <em>reducing function</em> 来组合每个元素，<code>step</code></li>\n<li>将最后计算的结果转换为输出，<code>result</code></li>\n</ol>\n<p>在第一篇文章中，我们使用 <em>reducing functions</em> ：<code>mult</code>、<code>add</code> 和 <code>append</code> 来转换输入值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> append = <span class=\"function\">(<span class=\"params\">value, item</span>) =&gt;</span> value.push(item);</span><br></pre></td></tr></table></figure></p>\n<p>本文中，我们只会用到 <code>append</code>，将元素拼接到数组的尾部。</p>\n<h2>Reduce</h2>\n<p>我们重新实现了 <code>reduce</code>，它接受以下参数：</p>\n<ol>\n<li>一个 transformer 或者将被封装成 transformer 的 <em>reducing Function</em></li>\n<li>一个初始值（例如<code>[]</code>)。</li>\n<li>一个输入源（例如传入 reduce 的数组）</li>\n</ol>\n<p>目前的实现使用 transformer 的 <code>step</code> 函数作为数组 <em>reducing function</em>，稍后将修改这一实现。</p>\n<p>在迭代过程中，使用两个参数来调用 <code>step</code> 函数：<code>value</code> 和 <code>item</code>。初始 value 由调用者提供，后续的每个 value 使用当前 <code>step</code> 函数的返回值。</p>\n<p><code>item</code> 由一些迭代过程（如何翻译？）提供。在第一篇文章中展示了两个过程：归约数组的每个元素，并使用每个新的 <code>item</code> 手动调用 <code>step</code> 函数。（在后续文章中我们将看到更多例子）。</p>\n<h2>Transducer</h2>\n<p>我们创建了 mapping <em>transducer</em>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> xf.step(result, f(item)),</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> transducer 接受一个 mapping 函数：<code>f</code>，并返回一个 transducer：</p>\n<ol>\n<li>接受一个已有 transformer</li>\n<li>返回一个新的 transformer，用来通过 <code>f</code> 转换 <code>items</code></li>\n<li>代理给封装的 transformer 额外的处理</li>\n</ol>\n<p>函数<code>f</code>可以是接受一个 item, 然后将其映射为一个新值的任意函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">input</span> =&gt;</span> input + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus2 = <span class=\"function\"><span class=\"params\">input</span> =&gt;</span> input + <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<p>在本节的例子中将继续使用这两个简单的函数。</p>\n<h2>Transduce</h2>\n<p>我们定义了一个新函数，<code>transduce</code>, 其接受：</p>\n<ol>\n<li>一个 transducer: 定义transformation</li>\n<li>一个 stepper 函数，或 transformer (如 <code>append</code>)</li>\n<li>一个 stepper 函数 的初始值 (如 <code>[]</code>)</li>\n<li>输入源 (如一个待转换的数组)</li>\n</ol>\n<p>向 transducer 传入 <code>stepper</code> 函数，来创建一个 transformer, 然后将该 transformer、初始值和输入源一同传入 <code>reduce</code>。</p>\n<p>我们已经展示过，使用相同的 transducer 可以产生不同的结果，只要改变传入 <code>transduce</code> 的初始值和 <code>stepper</code> 函数</p>\n<h2>Composition</h2>\n<p>最后，我们展示了可以通过组合已有 transducers 来创建新的 transducers</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose2 = <span class=\"function\">(<span class=\"params\">fn1, fn2</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> fn1(fn2(item));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose2(</span><br><span class=\"line\">      compose2(map(plus1), map(plus2)),</span><br><span class=\"line\">      map(plus1));</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [6,7,8]</span></span><br></pre></td></tr></table></figure></p>\n<p>被组合的 transducer 从左向右对输入源进行转换。</p>\n<p>今天我们从这里开始讲起。如果对上例不熟悉，可以参考<a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇文章</a></p>\n<h2>Pipelines</h2>\n<p>首先，定义一个新的函数，用它可以组合任意数量的函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = fns.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &gt;=<span class=\"number\">0</span>; i--) &#123; xf = fns[i](xf); &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这只是上面定义的 <code>compose2</code> 的扩展。函数组合从右向左：返回的函数接受用于调用右侧最后一个函数的初始参数。该调用的返回值(输出)用作左侧下一个函数的参数(输入)。对于所有传入 <code>ompose</code> 的函数，重复执行该过程。</p>\n<p>可以通过组合 <code>plus1</code> 和 <code>plus2</code> 来创建 <code>plus4</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动调用 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> value = plus1(plus1(plus2(<span class=\"number\">5</span>)));</span><br><span class=\"line\"><span class=\"comment\">// 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用组合函数 (允许重复使用被组合的函数)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus4 = compose(plus1, plus1, plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> value = plus4(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 9</span></span><br></pre></td></tr></table></figure></p>\n<p>我们通过组合 <code>map</code> transducers 来创建一个 <code>plus5</code> transducer。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      map(plus1),  <span class=\"comment\">// [3,4,5]</span></span><br><span class=\"line\">      map(plus2),  <span class=\"comment\">// [5,6,7]</span></span><br><span class=\"line\">      map(plus1),  <span class=\"comment\">// [6,7,8]</span></span><br><span class=\"line\">      map(plus1)); <span class=\"comment\">// [7,8,9]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [7,8,9]</span></span><br></pre></td></tr></table></figure></p>\n<p>每个 transducer 旁边的注释将每次转换通过数组展示出来，这样每次完成一个完整的转换，更容易追踪转换的过程。</p>\n<p>然而，需要清楚，整个转换过程中，transducers 每次只顺序转换一个 item，并且不会产生中间结果。注释仅仅表示 pipeline 的每步的转换结果。我们将在下面继续讨论这个问题。</p>\n<p>实际上，虽然组合是从右向左，转换的顺序实际上是从左向右的（在示例中是从上向下）。（需要将 transducers 的组合顺序 和 组合后 transducers 对输入源的转换顺序区分开)。在本例中顺序并不重要，但下一个例子中，便需要考虑调用顺序了。</p>\n<h2>Filter</h2>\n<p>我们来定义 <code>filter</code> transducer</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filter = <span class=\"function\"><span class=\"params\">predicate</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">value, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> allow = predicate(item);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(allow)&#123;</span><br><span class=\"line\">      value = xf.step(value, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  result: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> xf.result(value),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意到，只有在 predicate(断言) 返回 true 时，由 <code>filter</code> 返回的 transformer 才会代理给下一个(左侧) transformer。如果 predicate 返回 false，则会忽略该次 item，并返回上次的迭代结果。</p>\n<p>我们创建一个 transducer ，来过滤出所有奇数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isOdd = <span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num % <span class=\"number\">2</span> === <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = filter(isOdd);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [1,3,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们创建了一个使用 <code>isOdd</code> predicate 来过滤元素的 transducer。然后使用 <code>transduce</code> 将其作用于一个整数数组，输出数组中只包含奇数。</p>\n<p>我们再创建一个函数，该函数返回一个检查与传入参数是否相等的 predicate。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// another predicate </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isEqual = <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x === y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = filter(isEqual(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [2]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，创建的 predicate `isEqual(2) 只允许数字 2 输出。</p>\n<p>再来一个辅助函数，接受一个 predicate，将其结果取反。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> not = <span class=\"function\"><span class=\"params\">predicate</span> =&gt;</span> <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !predicate(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = filter(not(isEqual(<span class=\"number\">2</span>)));</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [1,3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们修改了前面的例子：对 predicate <code>isEqual(2)</code> 取反，由此创建了一个移除输入源中所有数字 2 的 transducer。</p>\n<p>现在在我们的 pipeline 库中有了另一件武器，一起来把玩一下吧。</p>\n<h2>Pipeline 顺序</h2>\n<p>我们来对每个元素加 1，然后过滤出奇数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      map(plus1),         <span class=\"comment\">// [2,3,4,5,6]</span></span><br><span class=\"line\">      filter(isOdd));     <span class=\"comment\">// [3,5]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>首先调用 <code>map(plus1)</code> transducer 对每个元素加 1，然后调用下一步转换：过滤出所有奇数。</p>\n<p>我们改变一下 transducers 的顺序，看看会发生什么。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      filter(isOdd),      <span class=\"comment\">// [1,3,5]</span></span><br><span class=\"line\">      map(plus1));        <span class=\"comment\">// [2,4,6]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [2,4,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们首先过滤出所有奇数。filter(<code>isOdd</code>) transformer 只将奇数传给下一个 transformer。所有传到下一步的元素(奇数)都会加1。</p>\n<p>上述表明了 <em>组合 transducers</em> 的两个重要性质：</p>\n<ol>\n<li>虽然组合是从右向左，但转换是从左向右。</li>\n<li>使用 transducers 越早减少 pipeline 中元素的数量，效率可能会越高。</li>\n</ol>\n<p>注意到，在最后一个例子中，<code>map(plus1)</code> 仅仅使用所有元素的子集调用。同样的，并未创建中间数组，仅仅作为注释便于理解而已。</p>\n<h2>Remove</h2>\n<p>开始讲另一个 transducer 了哈。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> remove = <span class=\"function\"><span class=\"params\">predicate</span> =&gt;</span> filter(not(predicate));</span><br></pre></td></tr></table></figure></p>\n<p>很简单吧。实际上，我们可以通过对 predicate 取反 和 重用 <code>filter</code> 来创建 <code>remove</code>。</p>\n<p>我们来实践一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      filter(isOdd),        <span class=\"comment\">// [1,3,5]</span></span><br><span class=\"line\">      map(plus1),           <span class=\"comment\">// [2,4,6] </span></span><br><span class=\"line\">      remove(isEqual(<span class=\"number\">4</span>)));  <span class=\"comment\">// [2,6]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [2,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>首先过滤出奇数，然后对每项加1，然后删除 <code>4</code>。</p>\n<h2>Drop</h2>\n<p>如果我们想在迭代开始时跳过 <code>n</code> 个元素，该做么做呢？这正是 <code>drop</code> transducer 的本职。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> drop = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = n;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">    step: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, item</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(left &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        left--;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        value = xf.step(value, item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你可以这样使用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> transducer = drop(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">var</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>Drop 接受从列表开始待丢弃元素的个数。这是我们第一个用来创建有状态变换的 transducer 的示例。每次调用 <code>drop</code> transducer 来创建一个 transformation 时，便会创建一个变量 <code>left</code>，指示在当次 transformation时，还剩多少个需要被丢弃的元素。<code>left</code> 被初始化为 <code>n</code>。</p>\n<p>注意，我们使用一个无状态的 transducer 创建了一个有状态的 transformer。这是一个重要的区别。这意味着我们可以重用 <code>drop(2)</code> transducer 任意多次，而不必担心任何状态。状态是在 transformer 中创建的，而不是 transducer 中。</p>\n<p>假如我们不想丢弃，而是获取前 <code>n</code> 个元素并丢弃剩余元素，该怎么办呢？为方便实现，假设 <code>n &gt; 0</code>。</p>\n<p>我们来尝试一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> take = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = n;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">    step: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, item</span>)</span>&#123;</span><br><span class=\"line\">      value = xf.step(value, item);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(--left &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如何停止???</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>哦噢，麻烦来了。我们知道如何逐步处理每个元素，并且通过 transformer 的状态来保持剩余元素的计数。但是，如何停止对剩余元素的迭代呢？</p>\n<p>为什么我们需要表明我们已经完成，不再接受任何额外元素呢？不仅因为继续接受元素是一种浪费，还因为无法保证迭代能够完成。有可能迭代是无限的。如果可以，我们当然想终止无限迭代。</p>\n<p>那么如何表示提前终止呢？我们需要在看一下迭代的源代码：<code>transduce</code>。</p>\n<h2>Reduce redux (终极 Reduce)</h2>\n<p>下面是当前 <code>transduce</code> 和 <code>reduce</code> 的定义，取自<a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇文章</a>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transduce = <span class=\"function\">(<span class=\"params\">transducer, stepper, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> stepper === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    stepper = wrap(stepper);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xf = transducer(stepper);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(xf, init, input);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reduce(xf, init, input) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> xf === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    xf = wrap(xf);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// how do we stop?? </span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = input.reduce(xf.step, init); </span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wrap = <span class=\"function\"><span class=\"params\">stepper</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'init not supported'</span>),</span><br><span class=\"line\">  step: stepper,</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>看一下上面的实现，便会发现，我们正在使用原生数组 <code>reduce</code> 方法进行迭代，<code>reduce</code> 的 reducing function 来自 transformer。后续文章中，我们将删除输入源是数组的假设，但现在还需继续使用改假设。我们来定义自己的 <code>arrayReduce</code> 实现。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">xf, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> xf === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    xf = wrap(xf);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arrayReduce(xf, init, input);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayReduce(xf, init, array) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = init;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; idx &lt; length; idx++)&#123;</span><br><span class=\"line\">    value = xf.step(value, array[idx]);</span><br><span class=\"line\">    <span class=\"comment\">// We need to break here, but how do we know?</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>arrayReduce</code> 的实现接受一个 transformer 、初始值和输入数组。然后使用 <code>for</code> 循环遍历每个元素，并使用累加值 value 和数组元素来调用 transformer <code>step</code> 函数。</p>\n<p>我们需要一个方法来打破这个循环，打破循环需要依赖某些标记值。幸运的是，我们可以采用已有的 <a href=\"https://github.com/cognitect-labs/transducers-js#reduced\" target=\"_blank\" rel=\"noopener\">transducer 协议</a>。</p>\n<p>为了在调用 transformer 中的 <code>step</code> 之后发出提前终止信号，我们可以将 <em>reduced</em> 值封装在包含两个属性的对象中：</p>\n<ol>\n<li><code>value</code>: 存储实际要封装的值。</li>\n<li><code>__transducers_reduced__</code>: bool 类型值，为<code>true</code>时，表示该对象是 reduced 的，迭代需要被终止。</li>\n</ol>\n<p>实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduced = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  value: value,</span><br><span class=\"line\">  __transducers_reduced__: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们还将添加一个 predicate 来确定值是否是 reduced 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iReduced = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &amp;&amp; value.__transducers_reduced__;</span><br></pre></td></tr></table></figure></p>\n<p>此外，我还需要一个方法来提取，或 <code>deref</code>(解引用) reduced 的值。</p>\n<p>现在我们可以优化 <code>arrayReduce</code> 来处理因 reduced values 提前终止的情况。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayReduce =&gt; <span class=\"function\">(<span class=\"params\">xf, init, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = init;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; idx &lt; length; idx++)&#123;</span><br><span class=\"line\">    value = xf.step(value, array[idx]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isReduced(value))&#123;</span><br><span class=\"line\">      value = deref(value);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们像以前一样对每个元素进行迭代，但每次调用 <code>step</code> 之后，我们检查是否得到一个 reduced value。如果是，我们提取值并终止迭代(中断循环)。我们仍然对最终值调用 <code>result</code> 方法，不管它来自 reduced value 还是完整的迭代。</p>\n<h2>Take 2</h2>\n<p>现在可以完成 <code>take</code> 的实现了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> take = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = n;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">    step: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, item</span>)</span>&#123;</span><br><span class=\"line\">      value = xf.step(value, item);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(--left &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// we are done, so signal reduced</span></span><br><span class=\"line\">        value = reduced(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    result: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> xf.result(value),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们之前唯一缺失的是：当检测到转换完成后使用 <code>reduced</code> 对值进行封装。(现在已经补上了)</p>\n<p>让我们看看它是否能工作：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = take(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>工作正常！</p>\n<p>就像任何其他的 transducer，你可以将 <code>drop</code> 和 <code>take</code> 组合成一个 pipeline</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">    drop(<span class=\"number\">1</span>),    <span class=\"comment\">// [2,3,4,5]</span></span><br><span class=\"line\">    take(<span class=\"number\">3</span>),    <span class=\"comment\">// [2,3,4]</span></span><br><span class=\"line\">    drop(<span class=\"number\">1</span>));   <span class=\"comment\">// [3,4]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,4]</span></span><br></pre></td></tr></table></figure></p>\n<p>第一个 <code>drop</code> 跳过第一个元素，然后将剩余元素通过 step 传给下一个 transformer。<code>take</code>  transformer 逐一遍历从第一个 <code>drop</code> 传过来的数组的前三个元素，然后停止迭代。最后一个 <code>drop</code> 删除从 <code>take</code> 传过来的数组的首个元素，并且在终止之前逐一发送剩余的两个元素。</p>\n<h2>第二部分总结</h2>\n<p>我们首先总结了在第一篇文章中学到的内容。我们增加了4个新的 transducers：<code>filter</code>、<code>remove</code>、<code>take</code>、<code>drop</code>。我们通过组合 transducers 来创建 transformer pipelines，并看到变换的顺序是从左到右。</p>\n<p>我们看到，除了在转换期间改变元素，一个 transformer 可以决定跳过任意元素，通过不调用下一个 transformer 的 <code>step</code> 来实现。每一个 transformer 的实现决定了什么会传递到下个 transformer。有些情况下， transformer 可能会发送多个值，例如 <code>cat</code> 或 <a href=\"https://github.com/transduce/transduce-string\" target=\"_blank\" rel=\"noopener\"><code>transduce-string</code></a>。</p>\n<p>我们还看到了可以创建有状态变换的 transducer 的一些例子。状态由 transformer 管理，而不是 transducer。这允许无状态 transducer 的重用，即时它们创建的 transformers 管理状态。</p>\n<p>当实现 <code>take</code> 时，我们意识到需要添加一个用于提前终止迭代的方法。我们改变了 <code>reduce</code> 的实现来处理和解包 reduced 的值，并且实现 <code>take</code> 用于在取完数据时终止迭代。</p>\n<h2>还有别的吗？</h2>\n<p>在入门教程的最后一篇文章中还有一些需要解释的相关问题。我们仍未解释 transformer 的 <code>init</code> 和 <code>reduce</code> 的作用。我们将添加 <code>into</code> 并一般化 <code>reduce</code> 的实现来支持迭代器。</p>\n<p>我们还看到输入元素可以是产生 sequence 值的任意东西：惰性列表、无限序列生成器、<a href=\"http://phuu.net/2014/08/31/csp-and-transducers.html\" target=\"_blank\" rel=\"noopener\">CSP</a>、<a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a>、迭代器、生成器、immutable-js 数据结构等。</p>\n<p>想要获取新文章的通知吗？可以关注 获取 <a href=\"https://twitter.com/simplectic\" target=\"_blank\" rel=\"noopener\">simplectic</a> 的 Twitter。</p>\n<h2>我现在已经准备好了！</h2>\n<p>已经准备使用 transducers 了吗？你应该已经具备良好的知识体系，如果通读了这篇文章：查看 <a href=\"https://github.com/cognitect-labs/transducers-js\" target=\"_blank\" rel=\"noopener\">transducers-js</a> 和 <a href=\"https://github.com/jlongster/transducers.js\" target=\"_blank\" rel=\"noopener\">transducers.js</a>。我们主要参考 transducers-js 的实现，但概念同样适用于 transducers.js。</p>\n<p>如果你喜欢 <a href=\"http://simplectic.com/projects/underarm\" target=\"_blank\" rel=\"noopener\">Underscore.js</a>，可以查看 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">underarm</a>。它基于 <a href=\"https://github.com/transduce/transduce\" target=\"_blank\" rel=\"noopener\">transduce</a> 库，允许针对 transducers.js 和 transducer-js 支持的公共协议定义 API。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文是 Transducer Explained 教程的第二篇。在<a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇</a>中，讲解从 <em>reducing functions</em> 开始， 到 <em>transformers</em>， 再到使用 <code>map</code> <em>transducers</em> 的 <code>transduce</code> 。本文中，将介绍四个新的 <em>transducers</em>：<code>filter</code>、<code>remove</code>、<code>drop</code> 和 <code>take</code>。我们将展示如何将 <em>transducers</em> 组合成 <em>pipeline</em>，并讨论转换的顺序。我们还将改变 <code>reduce</code> 的实现，使其能够借助 <code>reduced</code> 值 提前终止遍历操作。</p>\n<p>那么，上次讲到哪了呢？</p>\n<h2>Transformer</h2>\n<p><a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇</a>文章中，通过定义 <em>transformer</em> 协议规范了 <code>reduce</code> 的步骤。</p>\n<p>所有 transformers 都包含3个方法：</p>\n<ol>\n<li>使用初始值初始化 transformation，<code>init</code></li>\n<li>使用 <em>reducing function</em> 来组合每个元素，<code>step</code></li>\n<li>将最后计算的结果转换为输出，<code>result</code></li>\n</ol>\n<p>在第一篇文章中，我们使用 <em>reducing functions</em> ：<code>mult</code>、<code>add</code> 和 <code>append</code> 来转换输入值。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> append = <span class=\"function\">(<span class=\"params\">value, item</span>) =&gt;</span> value.push(item);</span><br></pre></td></tr></table></figure></p>\n<p>本文中，我们只会用到 <code>append</code>，将元素拼接到数组的尾部。</p>\n<h2>Reduce</h2>\n<p>我们重新实现了 <code>reduce</code>，它接受以下参数：</p>\n<ol>\n<li>一个 transformer 或者将被封装成 transformer 的 <em>reducing Function</em></li>\n<li>一个初始值（例如<code>[]</code>)。</li>\n<li>一个输入源（例如传入 reduce 的数组）</li>\n</ol>\n<p>目前的实现使用 transformer 的 <code>step</code> 函数作为数组 <em>reducing function</em>，稍后将修改这一实现。</p>\n<p>在迭代过程中，使用两个参数来调用 <code>step</code> 函数：<code>value</code> 和 <code>item</code>。初始 value 由调用者提供，后续的每个 value 使用当前 <code>step</code> 函数的返回值。</p>\n<p><code>item</code> 由一些迭代过程（如何翻译？）提供。在第一篇文章中展示了两个过程：归约数组的每个元素，并使用每个新的 <code>item</code> 手动调用 <code>step</code> 函数。（在后续文章中我们将看到更多例子）。</p>\n<h2>Transducer</h2>\n<p>我们创建了 mapping <em>transducer</em>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> map = <span class=\"function\"><span class=\"params\">f</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">result, item</span>) =&gt;</span> xf.step(result, f(item)),</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p><code>map</code> transducer 接受一个 mapping 函数：<code>f</code>，并返回一个 transducer：</p>\n<ol>\n<li>接受一个已有 transformer</li>\n<li>返回一个新的 transformer，用来通过 <code>f</code> 转换 <code>items</code></li>\n<li>代理给封装的 transformer 额外的处理</li>\n</ol>\n<p>函数<code>f</code>可以是接受一个 item, 然后将其映射为一个新值的任意函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> plus1 = <span class=\"function\"><span class=\"params\">input</span> =&gt;</span> input + <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus2 = <span class=\"function\"><span class=\"params\">input</span> =&gt;</span> input + <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure></p>\n<p>在本节的例子中将继续使用这两个简单的函数。</p>\n<h2>Transduce</h2>\n<p>我们定义了一个新函数，<code>transduce</code>, 其接受：</p>\n<ol>\n<li>一个 transducer: 定义transformation</li>\n<li>一个 stepper 函数，或 transformer (如 <code>append</code>)</li>\n<li>一个 stepper 函数 的初始值 (如 <code>[]</code>)</li>\n<li>输入源 (如一个待转换的数组)</li>\n</ol>\n<p>向 transducer 传入 <code>stepper</code> 函数，来创建一个 transformer, 然后将该 transformer、初始值和输入源一同传入 <code>reduce</code>。</p>\n<p>我们已经展示过，使用相同的 transducer 可以产生不同的结果，只要改变传入 <code>transduce</code> 的初始值和 <code>stepper</code> 函数</p>\n<h2>Composition</h2>\n<p>最后，我们展示了可以通过组合已有 transducers 来创建新的 transducers</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose2 = <span class=\"function\">(<span class=\"params\">fn1, fn2</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">item</span> =&gt;</span> fn1(fn2(item));</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose2(</span><br><span class=\"line\">      compose2(map(plus1), map(plus2)),</span><br><span class=\"line\">      map(plus1));</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [6,7,8]</span></span><br></pre></td></tr></table></figure></p>\n<p>被组合的 transducer 从左向右对输入源进行转换。</p>\n<p>今天我们从这里开始讲起。如果对上例不熟悉，可以参考<a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇文章</a></p>\n<h2>Pipelines</h2>\n<p>首先，定义一个新的函数，用它可以组合任意数量的函数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> compose = <span class=\"function\">(<span class=\"params\">...fns</span>) =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> i = fns.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; i &gt;=<span class=\"number\">0</span>; i--) &#123; xf = fns[i](xf); &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这只是上面定义的 <code>compose2</code> 的扩展。函数组合从右向左：返回的函数接受用于调用右侧最后一个函数的初始参数。该调用的返回值(输出)用作左侧下一个函数的参数(输入)。对于所有传入 <code>ompose</code> 的函数，重复执行该过程。</p>\n<p>可以通过组合 <code>plus1</code> 和 <code>plus2</code> 来创建 <code>plus4</code>。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 手动调用 </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> value = plus1(plus1(plus2(<span class=\"number\">5</span>)));</span><br><span class=\"line\"><span class=\"comment\">// 9</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用组合函数 (允许重复使用被组合的函数)</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> plus4 = compose(plus1, plus1, plus2);</span><br><span class=\"line\"><span class=\"keyword\">const</span> value = plus4(<span class=\"number\">5</span>);</span><br><span class=\"line\"><span class=\"comment\">// 9</span></span><br></pre></td></tr></table></figure></p>\n<p>我们通过组合 <code>map</code> transducers 来创建一个 <code>plus5</code> transducer。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      map(plus1),  <span class=\"comment\">// [3,4,5]</span></span><br><span class=\"line\">      map(plus2),  <span class=\"comment\">// [5,6,7]</span></span><br><span class=\"line\">      map(plus1),  <span class=\"comment\">// [6,7,8]</span></span><br><span class=\"line\">      map(plus1)); <span class=\"comment\">// [7,8,9]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [7,8,9]</span></span><br></pre></td></tr></table></figure></p>\n<p>每个 transducer 旁边的注释将每次转换通过数组展示出来，这样每次完成一个完整的转换，更容易追踪转换的过程。</p>\n<p>然而，需要清楚，整个转换过程中，transducers 每次只顺序转换一个 item，并且不会产生中间结果。注释仅仅表示 pipeline 的每步的转换结果。我们将在下面继续讨论这个问题。</p>\n<p>实际上，虽然组合是从右向左，转换的顺序实际上是从左向右的（在示例中是从上向下）。（需要将 transducers 的组合顺序 和 组合后 transducers 对输入源的转换顺序区分开)。在本例中顺序并不重要，但下一个例子中，便需要考虑调用顺序了。</p>\n<h2>Filter</h2>\n<p>我们来定义 <code>filter</code> transducer</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> filter = <span class=\"function\"><span class=\"params\">predicate</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">  step: <span class=\"function\">(<span class=\"params\">value, item</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> allow = predicate(item);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(allow)&#123;</span><br><span class=\"line\">      value = xf.step(value, item);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  result: <span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> xf.result(value),</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>注意到，只有在 predicate(断言) 返回 true 时，由 <code>filter</code> 返回的 transformer 才会代理给下一个(左侧) transformer。如果 predicate 返回 false，则会忽略该次 item，并返回上次的迭代结果。</p>\n<p>我们创建一个 transducer ，来过滤出所有奇数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> isOdd = <span class=\"function\"><span class=\"params\">num</span> =&gt;</span> num % <span class=\"number\">2</span> === <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = filter(isOdd);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [1,3,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们创建了一个使用 <code>isOdd</code> predicate 来过滤元素的 transducer。然后使用 <code>transduce</code> 将其作用于一个整数数组，输出数组中只包含奇数。</p>\n<p>我们再创建一个函数，该函数返回一个检查与传入参数是否相等的 predicate。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// another predicate </span></span><br><span class=\"line\"><span class=\"keyword\">const</span> isEqual = <span class=\"function\"><span class=\"params\">y</span> =&gt;</span> <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> x === y;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = filter(isEqual(<span class=\"number\">2</span>));</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [2]</span></span><br></pre></td></tr></table></figure></p>\n<p>可以看到，创建的 predicate `isEqual(2) 只允许数字 2 输出。</p>\n<p>再来一个辅助函数，接受一个 predicate，将其结果取反。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> not = <span class=\"function\"><span class=\"params\">predicate</span> =&gt;</span> <span class=\"function\"><span class=\"params\">x</span> =&gt;</span> !predicate(x);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> transducer = filter(not(isEqual(<span class=\"number\">2</span>)));</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [1,3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们修改了前面的例子：对 predicate <code>isEqual(2)</code> 取反，由此创建了一个移除输入源中所有数字 2 的 transducer。</p>\n<p>现在在我们的 pipeline 库中有了另一件武器，一起来把玩一下吧。</p>\n<h2>Pipeline 顺序</h2>\n<p>我们来对每个元素加 1，然后过滤出奇数。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      map(plus1),         <span class=\"comment\">// [2,3,4,5,6]</span></span><br><span class=\"line\">      filter(isOdd));     <span class=\"comment\">// [3,5]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>首先调用 <code>map(plus1)</code> transducer 对每个元素加 1，然后调用下一步转换：过滤出所有奇数。</p>\n<p>我们改变一下 transducers 的顺序，看看会发生什么。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      filter(isOdd),      <span class=\"comment\">// [1,3,5]</span></span><br><span class=\"line\">      map(plus1));        <span class=\"comment\">// [2,4,6]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [2,4,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>我们首先过滤出所有奇数。filter(<code>isOdd</code>) transformer 只将奇数传给下一个 transformer。所有传到下一步的元素(奇数)都会加1。</p>\n<p>上述表明了 <em>组合 transducers</em> 的两个重要性质：</p>\n<ol>\n<li>虽然组合是从右向左，但转换是从左向右。</li>\n<li>使用 transducers 越早减少 pipeline 中元素的数量，效率可能会越高。</li>\n</ol>\n<p>注意到，在最后一个例子中，<code>map(plus1)</code> 仅仅使用所有元素的子集调用。同样的，并未创建中间数组，仅仅作为注释便于理解而已。</p>\n<h2>Remove</h2>\n<p>开始讲另一个 transducer 了哈。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> remove = <span class=\"function\"><span class=\"params\">predicate</span> =&gt;</span> filter(not(predicate));</span><br></pre></td></tr></table></figure></p>\n<p>很简单吧。实际上，我们可以通过对 predicate 取反 和 重用 <code>filter</code> 来创建 <code>remove</code>。</p>\n<p>我们来实践一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">      filter(isOdd),        <span class=\"comment\">// [1,3,5]</span></span><br><span class=\"line\">      map(plus1),           <span class=\"comment\">// [2,4,6] </span></span><br><span class=\"line\">      remove(isEqual(<span class=\"number\">4</span>)));  <span class=\"comment\">// [2,6]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [2,6]</span></span><br></pre></td></tr></table></figure></p>\n<p>首先过滤出奇数，然后对每项加1，然后删除 <code>4</code>。</p>\n<h2>Drop</h2>\n<p>如果我们想在迭代开始时跳过 <code>n</code> 个元素，该做么做呢？这正是 <code>drop</code> transducer 的本职。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> drop = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = n;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">    step: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, item</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(left &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        left--;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        value = xf.step(value, item);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你可以这样使用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> transducer = drop(<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">var</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">var</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">var</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,4,5]</span></span><br></pre></td></tr></table></figure></p>\n<p>Drop 接受从列表开始待丢弃元素的个数。这是我们第一个用来创建有状态变换的 transducer 的示例。每次调用 <code>drop</code> transducer 来创建一个 transformation 时，便会创建一个变量 <code>left</code>，指示在当次 transformation时，还剩多少个需要被丢弃的元素。<code>left</code> 被初始化为 <code>n</code>。</p>\n<p>注意，我们使用一个无状态的 transducer 创建了一个有状态的 transformer。这是一个重要的区别。这意味着我们可以重用 <code>drop(2)</code> transducer 任意多次，而不必担心任何状态。状态是在 transformer 中创建的，而不是 transducer 中。</p>\n<p>假如我们不想丢弃，而是获取前 <code>n</code> 个元素并丢弃剩余元素，该怎么办呢？为方便实现，假设 <code>n &gt; 0</code>。</p>\n<p>我们来尝试一下。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> take = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = n;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">    step: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, item</span>)</span>&#123;</span><br><span class=\"line\">      value = xf.step(value, item);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(--left &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 如何停止???</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    result: <span class=\"function\"><span class=\"params\">result</span> =&gt;</span> xf.result(result),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>哦噢，麻烦来了。我们知道如何逐步处理每个元素，并且通过 transformer 的状态来保持剩余元素的计数。但是，如何停止对剩余元素的迭代呢？</p>\n<p>为什么我们需要表明我们已经完成，不再接受任何额外元素呢？不仅因为继续接受元素是一种浪费，还因为无法保证迭代能够完成。有可能迭代是无限的。如果可以，我们当然想终止无限迭代。</p>\n<p>那么如何表示提前终止呢？我们需要在看一下迭代的源代码：<code>transduce</code>。</p>\n<h2>Reduce redux (终极 Reduce)</h2>\n<p>下面是当前 <code>transduce</code> 和 <code>reduce</code> 的定义，取自<a href=\"https://adispring.github.io/2016/10/24/Transducers-Explained-Part-1/\">第一篇文章</a>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transduce = <span class=\"function\">(<span class=\"params\">transducer, stepper, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> stepper === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    stepper = wrap(stepper);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> xf = transducer(stepper);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> reduce(xf, init, input);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> reduce(xf, init, input) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> xf === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    xf = wrap(xf);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// how do we stop?? </span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = input.reduce(xf.step, init); </span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(value);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> wrap = <span class=\"function\"><span class=\"params\">stepper</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">'init not supported'</span>),</span><br><span class=\"line\">  step: stepper,</span><br><span class=\"line\">  result: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>看一下上面的实现，便会发现，我们正在使用原生数组 <code>reduce</code> 方法进行迭代，<code>reduce</code> 的 reducing function 来自 transformer。后续文章中，我们将删除输入源是数组的假设，但现在还需继续使用改假设。我们来定义自己的 <code>arrayReduce</code> 实现。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduce = <span class=\"function\">(<span class=\"params\">xf, init, input</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">typeof</span> xf === <span class=\"string\">'function'</span>)&#123;</span><br><span class=\"line\">    xf = wrap(xf);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> arrayReduce(xf, init, input);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrayReduce(xf, init, array) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = init;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; idx &lt; length; idx++)&#123;</span><br><span class=\"line\">    value = xf.step(value, array[idx]);</span><br><span class=\"line\">    <span class=\"comment\">// We need to break here, but how do we know?</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(value);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p><code>arrayReduce</code> 的实现接受一个 transformer 、初始值和输入数组。然后使用 <code>for</code> 循环遍历每个元素，并使用累加值 value 和数组元素来调用 transformer <code>step</code> 函数。</p>\n<p>我们需要一个方法来打破这个循环，打破循环需要依赖某些标记值。幸运的是，我们可以采用已有的 <a href=\"https://github.com/cognitect-labs/transducers-js#reduced\" target=\"_blank\" rel=\"noopener\">transducer 协议</a>。</p>\n<p>为了在调用 transformer 中的 <code>step</code> 之后发出提前终止信号，我们可以将 <em>reduced</em> 值封装在包含两个属性的对象中：</p>\n<ol>\n<li><code>value</code>: 存储实际要封装的值。</li>\n<li><code>__transducers_reduced__</code>: bool 类型值，为<code>true</code>时，表示该对象是 reduced 的，迭代需要被终止。</li>\n</ol>\n<p>实现如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> reduced = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> (&#123;</span><br><span class=\"line\">  value: value,</span><br><span class=\"line\">  __transducers_reduced__: <span class=\"literal\">true</span>,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>我们还将添加一个 predicate 来确定值是否是 reduced 。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> iReduced = <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> value &amp;&amp; value.__transducers_reduced__;</span><br></pre></td></tr></table></figure></p>\n<p>此外，我还需要一个方法来提取，或 <code>deref</code>(解引用) reduced 的值。</p>\n<p>现在我们可以优化 <code>arrayReduce</code> 来处理因 reduced values 提前终止的情况。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayReduce =&gt; <span class=\"function\">(<span class=\"params\">xf, init, array</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> value = init;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> idx = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> length = array.length;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(; idx &lt; length; idx++)&#123;</span><br><span class=\"line\">    value = xf.step(value, array[idx]);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isReduced(value))&#123;</span><br><span class=\"line\">      value = deref(value);</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> xf.result(value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们像以前一样对每个元素进行迭代，但每次调用 <code>step</code> 之后，我们检查是否得到一个 reduced value。如果是，我们提取值并终止迭代(中断循环)。我们仍然对最终值调用 <code>result</code> 方法，不管它来自 reduced value 还是完整的迭代。</p>\n<h2>Take 2</h2>\n<p>现在可以完成 <code>take</code> 的实现了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> take = <span class=\"function\"><span class=\"params\">n</span> =&gt;</span> <span class=\"function\"><span class=\"params\">xf</span> =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> left = n;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    init: <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> xf.init(),</span><br><span class=\"line\">    step: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value, item</span>)</span>&#123;</span><br><span class=\"line\">      value = xf.step(value, item);</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(--left &lt;= <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// we are done, so signal reduced</span></span><br><span class=\"line\">        value = reduced(value);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    result: <span class=\"function\"><span class=\"params\">value</span> =&gt;</span> xf.result(value),</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>我们之前唯一缺失的是：当检测到转换完成后使用 <code>reduced</code> 对值进行封装。(现在已经补上了)</p>\n<p>让我们看看它是否能工作：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = take(<span class=\"number\">3</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [1,2,3]</span></span><br></pre></td></tr></table></figure></p>\n<p>工作正常！</p>\n<p>就像任何其他的 transducer，你可以将 <code>drop</code> 和 <code>take</code> 组合成一个 pipeline</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> transducer = compose(</span><br><span class=\"line\">    drop(<span class=\"number\">1</span>),    <span class=\"comment\">// [2,3,4,5]</span></span><br><span class=\"line\">    take(<span class=\"number\">3</span>),    <span class=\"comment\">// [2,3,4]</span></span><br><span class=\"line\">    drop(<span class=\"number\">1</span>));   <span class=\"comment\">// [3,4]</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> stepper = append;</span><br><span class=\"line\"><span class=\"keyword\">const</span> init = [];</span><br><span class=\"line\"><span class=\"keyword\">const</span> input = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = transduce(transducer, stepper, init, input);</span><br><span class=\"line\"><span class=\"comment\">// [3,4]</span></span><br></pre></td></tr></table></figure></p>\n<p>第一个 <code>drop</code> 跳过第一个元素，然后将剩余元素通过 step 传给下一个 transformer。<code>take</code>  transformer 逐一遍历从第一个 <code>drop</code> 传过来的数组的前三个元素，然后停止迭代。最后一个 <code>drop</code> 删除从 <code>take</code> 传过来的数组的首个元素，并且在终止之前逐一发送剩余的两个元素。</p>\n<h2>第二部分总结</h2>\n<p>我们首先总结了在第一篇文章中学到的内容。我们增加了4个新的 transducers：<code>filter</code>、<code>remove</code>、<code>take</code>、<code>drop</code>。我们通过组合 transducers 来创建 transformer pipelines，并看到变换的顺序是从左到右。</p>\n<p>我们看到，除了在转换期间改变元素，一个 transformer 可以决定跳过任意元素，通过不调用下一个 transformer 的 <code>step</code> 来实现。每一个 transformer 的实现决定了什么会传递到下个 transformer。有些情况下， transformer 可能会发送多个值，例如 <code>cat</code> 或 <a href=\"https://github.com/transduce/transduce-string\" target=\"_blank\" rel=\"noopener\"><code>transduce-string</code></a>。</p>\n<p>我们还看到了可以创建有状态变换的 transducer 的一些例子。状态由 transformer 管理，而不是 transducer。这允许无状态 transducer 的重用，即时它们创建的 transformers 管理状态。</p>\n<p>当实现 <code>take</code> 时，我们意识到需要添加一个用于提前终止迭代的方法。我们改变了 <code>reduce</code> 的实现来处理和解包 reduced 的值，并且实现 <code>take</code> 用于在取完数据时终止迭代。</p>\n<h2>还有别的吗？</h2>\n<p>在入门教程的最后一篇文章中还有一些需要解释的相关问题。我们仍未解释 transformer 的 <code>init</code> 和 <code>reduce</code> 的作用。我们将添加 <code>into</code> 并一般化 <code>reduce</code> 的实现来支持迭代器。</p>\n<p>我们还看到输入元素可以是产生 sequence 值的任意东西：惰性列表、无限序列生成器、<a href=\"http://phuu.net/2014/08/31/csp-and-transducers.html\" target=\"_blank\" rel=\"noopener\">CSP</a>、<a href=\"https://github.com/transduce/transduce-stream\" target=\"_blank\" rel=\"noopener\">Node.js streams</a>、迭代器、生成器、immutable-js 数据结构等。</p>\n<p>想要获取新文章的通知吗？可以关注 获取 <a href=\"https://twitter.com/simplectic\" target=\"_blank\" rel=\"noopener\">simplectic</a> 的 Twitter。</p>\n<h2>我现在已经准备好了！</h2>\n<p>已经准备使用 transducers 了吗？你应该已经具备良好的知识体系，如果通读了这篇文章：查看 <a href=\"https://github.com/cognitect-labs/transducers-js\" target=\"_blank\" rel=\"noopener\">transducers-js</a> 和 <a href=\"https://github.com/jlongster/transducers.js\" target=\"_blank\" rel=\"noopener\">transducers.js</a>。我们主要参考 transducers-js 的实现，但概念同样适用于 transducers.js。</p>\n<p>如果你喜欢 <a href=\"http://simplectic.com/projects/underarm\" target=\"_blank\" rel=\"noopener\">Underscore.js</a>，可以查看 <a href=\"http://underscorejs.org/\" target=\"_blank\" rel=\"noopener\">underarm</a>。它基于 <a href=\"https://github.com/transduce/transduce\" target=\"_blank\" rel=\"noopener\">transduce</a> 库，允许针对 transducers.js 和 transducer-js 支持的公共协议定义 API。</p>\n"},{"title":"Ramda 函数简介","date":"2017-10-20T23:25:36.000Z","_content":"\nRamda API 已经快到 300 个了，对每个 API 按类型分别进行简介，当作 Ramda 的一份 CheatSheet 。\n\n# 列表\n\n| Action                                                  | Function                                                                 |\n| :-----                                                  | :-------                                                                 |\n| 列表转换                                                | [map](http://ramda.cn/docs/#map)                                         |\n| 列表过滤：过滤出符合条件的元素                          | [filter](http://ramda.cn/docs/#filter)                                   |\n| 列表过滤：过滤掉符合条件的元素                          | [reject](http://ramda.cn/docs/#reject)                                   |\n| 列表折叠：从左向右对所有元素依次归约（折叠）            | [reduce](http://ramda.cn/docs/#reduce)                                   |\n| 列表折叠：从右向左对所有元素依次归约（折叠）            | [reduceRight](http://ramda.cn/docs/#reduceRight)                         |\n| 列表折叠(增强版)                                        | [transduce](http://ramda.cn/docs/#transduce)                             |\n| 列表去重                                                | [uniq](http://ramda.cn/docs/#uniq)                                       |\n| 列表去重：对处理后的元素做相等性判断                    | [uniqBy](http://ramda.cn/docs/#uniqBy)                                   |\n| 列表去重：通过断言函数（predicate）判断                 | [uniqWith](http://ramda.cn/docs/#uniqWith)                               |\n| 列表排序                                                | [sort](http://ramda.cn/docs/#sort)                                       |\n| 列表翻转                                                | [reverse](http://ramda.cn/docs/#reverse)                                 |\n| 列表拼接                                                | [concat](http://ramda.cn/docs/#concat)                                   |\n| 列表长度                                                | [length](http://ramda.cn/docs/#length)                                   |\n| 列表表头拼接元素                                        | [prepend](http://ramda.cn/docs/#prepend)                                 |\n| 列表表尾拼接元素                                        | [append](http://ramda.cn/docs/#append)                                   |\n| 更新指定索引处的值                                      | [adjust](http://ramda.cn/docs/#adjust)                                   |\n| 替换指定索引处的值                                      | [update](http://ramda.cn/docs/#update)                                   |\n| 将列表元素转换为其指定的属性值，等价于 R.map(R.prop)    | [pluck](http://ramda.cn/docs/#pluck)                                     |\n| 为列表迭代函数添加两个参数：索引和整个列表              | [addIndex](http://ramda.cn/docs/#addIndex)                               |\n| 取出特定索引范围内的元素                                | [slice](http://ramda.cn/docs/#slice)                                     |\n| 将列表通过分隔符拼接成字符串                            | [join](http://ramda.cn/docs/#join)                                       |\n| 取出第 N 个元素                                         | [nth](http://ramda.cn/docs/#nth)                                         |\n| 取出前 N 个元素                                         | [take](http://ramda.cn/docs/#take)                                       |\n| 取出后 N 个元素                                         | [takeLast](http://ramda.cn/docs/#takeLast)                               |\n| 从前往后取出满足条件的元素，直至不满足条件的首个元素止  | [takeWhile](http://ramda.cn/docs/#takeWhile)                             |\n| 从后向前取出满足条件的元素，直至不满足条件的首个元素止  | [takeLastWhile](http://ramda.cn/docs/#takeLastWhile)                     |\n| 删除前 N 个元素                                         | [drop](http://ramda.cn/docs/#drop)                                       |\n| 删除后 N 个元素                                         | [dropLast](http://ramda.cn/docs/#dropLast)                               |\n| 从前往后删除满足条件的元素，直至不满足条件的首个元素止  | [dropWhile](http://ramda.cn/docs/#dropWhile)                             |\n| 从后向前删除满足条件的元素，直至不满足条件的首个元素止  | [dropLastWhile](http://ramda.cn/docs/#dropLastWhile)                     |\n| 取出首个元素                                            | [head](http://ramda.cn/docs/#head)                                       |\n| 取出末尾元素                                            | [last](http://ramda.cn/docs/#taillast)                                   |\n| 取出前 length - 1 个元素（删除末尾元素）                | [init](http://ramda.cn/docs/#init)                                       |\n| 取出后 length - 1 个元素（删除首个元素）                | [tail](http://ramda.cn/docs/#tail)                                       |\n| 求差集：{a∣a∈xs ∩ a∉ys}                                 | [difference](http://ramda.cn/docs/#difference)                           |\n| 求差集：{a∣a∉xs ∩ a∈ys}                                 | [without](http://ramda.cn/docs/#without)                                 |\n| 求差集：根据条件计算第一个列表与第二个列表的差集        | [differenceWith](http://ramda.cn/docs/#differenceWith)                   |\n| 求对称差集：{(xs ∪ ys) - (xs ∩ ys)}                     | [symmetricDifference](http://ramda.cn/docs/#symmetricDifference)         |\n| 求对称差集：根据条件计算所有不属于两个列表交集的元素    | [symmetricDifferenceWith](http://ramda.cn/docs/#symmetricDifferenceWith) |\n| 求交集：{xs ∩ ys}                                       | [intersection](http://ramda.cn/docs/#intersection)                       |\n| 求交集：从 xs 中挑选出在 ys 中符合条件的元素            | [innerJoin](http://ramda.cn/docs/#innerJoin)                             |\n| 求并集：{xs ∪ ys}                                       | [union](http://ramda.cn/docs/#union)                                     |\n| 求并集：根据条件判断两元素是否重复                      | [unionWith](http://ramda.cn/docs/#unionWith)                             |\n| 查找列表中首个满足条件的元素                            | [find](http://ramda.cn/docs/#find)                                       |\n| 查找列表中首个满足条件的元素的索引                      | [findIndex](http://ramda.cn/docs/#findIndex)                             |\n| 查找列表中最后一个满足条件的元素                        | [findLast](http://ramda.cn/docs/#findLast)                               |\n| 查找列表中最后一个满足条件的元素的索引                  | [findLastIndex](http://ramda.cn/docs/#findLastIndex)                     |\n| 查找给定元素在列表中首次出现时的索引                    | [indexOf](http://ramda.cn/docs/#indexOf)                                 |\n| 查找给定元素在列表中末次出现时的索引                    | [lastIndexOf](http://ramda.cn/docs/#lastIndexOf)                         |\n| 列表判断：判断元素是否包含在列表中                      | [contains](http://ramda.cn/docs/#contains)                               |\n| 列表判断：判断是否列表中所有元素都满足条件              | [all](http://ramda.cn/docs/#all)                                         |\n| 列表判断：判断是否列表中所有元素都不满足条件            | [none](http://ramda.cn/docs/#none)                                       |\n| 列表判断：判断是否列表中存在满足条件的元素              | [any](http://ramda.cn/docs/#any)                                         |\n| 列表判断：判断列表是否以给定的值开头                    | [startsWith](http://ramda.cn/docs/#startsWith)                           |\n| 列表判断：判断列表是否以给定的值结尾                    | [endsWith](http://ramda.cn/docs/#endsWith)                               |\n| 列表分组：按是否符合条件，将元素分为两组                | [partition](http://ramda.cn/docs/#partition)                             |\n| 列表分组：对列表中元素按指定规则分组                    | [groupBy](http://ramda.cn/docs/#groupBy)                                 |\n| 列表分段：对列表中元素按指定规则分段                    | [groupWith](http://ramda.cn/docs/#groupWith)                             |\n| 列表分组：对列表中元素按指定规则分组折叠                | [reduceBy](http://ramda.cn/docs/#reduceBy)                               |\n| 列表分割：在指定索引处                                  | [splitAt](http://ramda.cn/docs/#splitAt)                                 |\n| 列表分割：每隔 N 个元素                                 | [splitEvery](http://ramda.cn/docs/#splitEvery)                           |\n| 列表分割：按条件分割                                    | [splitWhen](http://ramda.cn/docs/#splitWhen)                             |\n| 对两个列表相同位置的元素进行组合                        | [zip](http://ramda.cn/docs/#zip)                                         |\n| 对两个列表相同位置的元素进行键值对组合，fromPairs ∘ zip | [zipObj](http://ramda.cn/docs/#zipObj)                                   |\n| 对两个列表相同位置的元素按规则进行组合                  | [zipWith](http://ramda.cn/docs/#zipWith)                                 |\n| 由一系列键值对列表创建对象                              | [fromPairs](http://ramda.cn/docs/#fromPairs)                             |\n| 列表彻底扁平化                                          | [flatten](http://ramda.cn/docs/#flatten)                                 |\n| 列表单层扁平化                                          | [unnest](http://ramda.cn/docs/#unnest)                                   |\n| 先对列表内元素做 Kleisli 映射，再做扁平化，flatMap，>>= | [chain](http://ramda.cn/docs/#chain)                                     |\n| 函子间的自然变化？                                      | [sequence](http://ramda.cn/docs/#sequence)                               |\n| 列表插入                                                | [insert](http://ramda.cn/docs/#insert)                                   |\n| 将子列表插入列表                                        | [insertAll](http://ramda.cn/docs/#insertAll)                             |\n| 在列表元素之间插入分割元素                              | [intersperse](http://ramda.cn/docs/#intersperse)                         |\n| 列表转换 + 折叠？                                       | [into](http://ramda.cn/docs/#into)                                       |\n| 将 reduce 的迭代过程记录下来                            | [mapAccum](http://ramda.cn/docs/#mapAccum)                               |\n| 将 reduceRight 的迭代过程记录下来                       | [mapAccumRight](http://ramda.cn/docs/#mapAccumRight)                     |\n| 合并多个对象                                            | [mergeAll](http://ramda.cn/docs/#mergeAll)                               |\n| 由两个参数组成列表                                      | [pair](http://ramda.cn/docs/#pair)                                       |\n| 从 reduce 或 transduce 中提前退出迭代时的值             | [reduced](http://ramda.cn/docs/#reduced)                                 |\n| 可以提前退出的 reduce 迭代                              | [reduceWhile](http://ramda.cn/docs/#reduceWhile)                         |\n| 列表生成：生成左闭右开的升序数字列表                    | [range](http://ramda.cn/docs/#range)                                     |\n| 列表生成：生成含有 N 个同一元素的列表                   | [repeat](http://ramda.cn/docs/#repeat)                                   |\n| 列表生成：函数执行 N 次，生成 N 元列表                  | [times](http://ramda.cn/docs/#times)                                     |\n| 列表生成：通过迭代函数生成列表                          | [unfold](http://ramda.cn/docs/#unfold)                                   |\n| 二维列表行列式转换                                      | [transpose](http://ramda.cn/docs/#transpose)                             |\n| 二维列表生成                                            | [xprod](http://ramda.cn/docs/#xprod)                                     |\n\n\n# 函数\n\n| Action                                                       | Function                                           |\n| :-----                                                       | :-------                                           |\n| 函数组合：纵向，从右往左                                     | [compose](http://ramda.cn/docs/#compose)           |\n| 函数组合：纵向，从左往右                                     | [pipe](http://ramda.cn/docs/#pipe)                 |\n| 函数组合：纵向                                               | [o](http://ramda.cn/docs/#o)                       |\n| 函数组合：横向                                               | [converge](http://ramda.cn/docs/#converge)         |\n| 函数组合：横向                                               | [useWith](http://ramda.cn/docs/#useWith)           |\n| Kleisili 函数组合                                            | [composeK](http://ramda.cn/docs/#composeK)         |\n| Kleisili 函数组合                                            | [pipeK](http://ramda.cn/docs/#pipeK)               |\n| Promise 函数组合                                             | [composeP](http://ramda.cn/docs/#composeP)         |\n| Promise 函数组合                                             | [pipeP](http://ramda.cn/docs/#pipeP)               |\n| 单位函数：输出等于输入                                       | [identity](http://ramda.cn/docs/#identity)         |\n| 函数柯里化                                                   | [curry](http://ramda.cn/docs/#curry)               |\n| N 元函数柯里化                                               | [curryN](http://ramda.cn/docs/#curryN)             |\n| 将柯里化函数 转为 N 元函数                                   | [uncurryN](http://ramda.cn/docs/#uncurryN)         |\n| 柯里化函数的参数占位符                                       | [__](http://ramda.cn/docs/#__)                     |\n| 参数部分调用：从左往右                                       | [partial](http://ramda.cn/docs/#partial)           |\n| 参数部分调用：从右往左                                       | [partialRight](http://ramda.cn/docs/#partialRight) |\n| 函数缓存                                                     | [memoize](http://ramda.cn/docs/#memoize)           |\n| 函数缓存：可以自定义缓存键值                                 | [memoizeWith](http://ramda.cn/docs/#memoizeWith)   |\n| 只执行一次的函数                                             | [once](http://ramda.cn/docs/#once)                 |\n| 创建返回恒定值的函数                                         | [always](http://ramda.cn/docs/#always)             |\n| 恒定返回 `true` 的函数                                       | [T](http://ramda.cn/docs/#T)                       |\n| 恒定返回 `false`  的函数                                     | [F](http://ramda.cn/docs/#F)                       |\n| Applicative Functor 的 ap 方法，<*>                          | [ap](http://ramda.cn/docs/#ap)                     |\n| 将函数作用于参数列表                                         | [apply](http://ramda.cn/docs/#apply)               |\n| 将接受 __单列表参数__ 的函数转为接受 __普通参数列表__ 的函数 | [unapply](http://ramda.cn/docs/#unapply)           |\n| 将首个参数（函数）作用于其余参数                             | [call](http://ramda.cn/docs/#call)                 |\n| 绑定函数上下文                                               | [bind](http://ramda.cn/docs/#bind)                 |\n| 利用属性值为函数的对象生成同构对象                           | [applySpec](http://ramda.cn/docs/#applySpec)       |\n| 将函数列表作用于参数列表                                     | [juxt](http://ramda.cn/docs/#juxt)                 |\n| 将给定值传给给定函数，CPS: flip($)                           | [applyTo](http://ramda.cn/docs/#applyTo)           |\n| 比较函数，一般用于排序                                       | [comparator](http://ramda.cn/docs/#comparator)     |\n| 升序比较函数                                                 | [ascend](http://ramda.cn/docs/#ascend)             |\n| 降序比较函数                                                 | [descend](http://ramda.cn/docs/#descend)           |\n| 将函数封装为 N 元函数                                        | [nArg](http://ramda.cn/docs/#nArg)                 |\n| 将函数封装为一元函数                                         | [unary](http://ramda.cn/docs/#unary)               |\n| 将函数封装为二元函数                                         | [binary](http://ramda.cn/docs/#binary)             |\n| 提取第 N 个参数                                              | [nthArg](http://ramda.cn/docs/#nthArg)             |\n| 将构造函数封装为普通函数，创建实例时，不需要 new 操作符      | [construct](http://ramda.cn/docs/#construct)       |\n| 将构造函数封装为 N 元普通函数，创建实例时，不需要 new 操作符 | [constructN](http://ramda.cn/docs/#constructN)     |\n| 通过函数名调用函数                                           | [invoker](http://ramda.cn/docs/#invoker)           |\n| 创建相应类型的空值                                           | [empty](http://ramda.cn/docs/#empty)               |\n| 判断是否为空值                                               | [isEmpty](http://ramda.cn/docs/#isEmpty)           |\n| 交换函数前两个参数的位置                                     | [flip](http://ramda.cn/docs/#flip)                 |\n| 函数提升                                                     | [lift](http://ramda.cn/docs/#lift)                 |\n| N 元函数提升                                                 | [liftN](http://ramda.cn/docs/#liftN)               |\n| 生成单元素列表                                               | [of](http://ramda.cn/docs/#of)                     |\n| 输出等于输入，但产生副作用的函数，一般用于调试               | [tap](http://ramda.cn/docs/#tap)                   |\n| 异常捕获                                                     | [tryCatch](http://ramda.cn/docs/#tryCatch)         |\n\n\n# 对象\n\n| Action                                                    | Function                                                   |\n| :-----                                                    | :-------                                                   |\n| 属性设置                                                  | [assoc](http://ramda.cn/docs/#assoc)                       |\n| 属性按路径设置                                            | [assocPath](http://ramda.cn/docs/#assocPath)               |\n| 属性删除                                                  | [dissoc](http://ramda.cn/docs/#dissoc)                     |\n| 属性按路径删除                                            | [disscoPath](http://ramda.cn/docs/#disscoPath)             |\n| 获取属性值                                                | [prop](http://ramda.cn/docs/#prop)                         |\n| 获取属性值，带有默认值                                    | [propOr](http://ramda.cn/docs/#propOr)                     |\n| 获取路径上的属性值                                        | [path](http://ramda.cn/docs/#path)                         |\n| 获取路径上的属性值，带有默认值                            | [pathOr](http://ramda.cn/docs/#pathOr)                     |\n| 判断属性是否满足给定的条件                                | [propSatisfies](http://ramda.cn/docs/#propSatisfies)       |\n| 判断属性是否与给定值相等                                  | [propEq](http://ramda.cn/docs/#propEq)                     |\n| 判断两个对象指定的属性值是否相等                          | [eqProps](http://ramda.cn/docs/#eqProps)                   |\n| 判断路径上的属性值是否满足给定的条件                      | [pathSatisfies](http://ramda.cn/docs/#pathSatisfies)       |\n| 判断路径上的属性值是否与给定值相等                        | [pathEq](http://ramda.cn/docs/#pathEq)                     |\n| 获取属性值组成的列表                                      | [props](http://ramda.cn/docs/#props)                       |\n| 判断属性是否为给定类型                                    | [propIs](http://ramda.cn/docs/#propIs)                     |\n| 判断多个属性是否同时满足给定的条件                        | [where](http://ramda.cn/docs/#where)                       |\n| 判断多个属性是否等于给定对应属性值                        | [whereEq](http://ramda.cn/docs/#whereEq)                   |\n| 删除多个属性                                              | [omit](http://ramda.cn/docs/#omit)                         |\n| 提取多个属性                                              | [pick](http://ramda.cn/docs/#pick)                         |\n| 提取多个属性                                              | [pickAll](http://ramda.cn/docs/#pickAll)                   |\n| 对列表中元素提取多个属性，模拟 SQL 的 `select`            | [project](http://ramda.cn/docs/#project)                   |\n| 提取键值满足条件的属性                                    | [pickBy](http://ramda.cn/docs/#pickBy)                     |\n| 对特定属性进行特定变换                                    | [evolve](http://ramda.cn/docs/#evolve)                     |\n| 是否包含指定的键                                          | [has](http://ramda.cn/docs/#has)                           |\n| 是否包含指定的键：包括原型链上的键                        | [hasIn](http://ramda.cn/docs/#hasIn)                       |\n| 键值对换位                                                | [invertObj](http://ramda.cn/docs/#invertObj)               |\n| 键值对换位：将值放入数组中                                | [invert](http://ramda.cn/docs/#invert)                     |\n| 取出所有的键                                              | [keys](http://ramda.cn/docs/#keys)                         |\n| 取出所有的键：包括原型链上的键                            | [keysIn](http://ramda.cn/docs/#keysIn)                     |\n| 取出所有的值                                              | [values](http://ramda.cn/docs/#values)                     |\n| 取出所有的值：包括原型链上的值                            | [valuesIn](http://ramda.cn/docs/#valuesIn)                 |\n| 透镜：包括属性的 getter 和 setter                         | [lens](http://ramda.cn/docs/#lens)                         |\n| 透镜：指定索引的透镜                                      | [lensIndex](http://ramda.cn/docs/#lensIndex)               |\n| 透镜：指定路径的透镜                                      | [lensPath](http://ramda.cn/docs/#lensPath)                 |\n| 透镜：指定属性的透镜                                      | [lensProp](http://ramda.cn/docs/#lensProp)                 |\n| 透镜：对被 `lens` 聚焦的属性做变换                        | [over](http://ramda.cn/docs/#over)                         |\n| 透镜：对被 `lens` 聚焦的属性进行设置                      | [set](http://ramda.cn/docs/#set)                           |\n| 透镜：读取被 `lens` 聚焦的属性值                          | [view](http://ramda.cn/docs/#view)                         |\n| `Object` 版 `map`，转换函数参数：(value, key, obj)        | [mapObjIndexed](http://ramda.cn/docs/#mapObjIndexed)       |\n| 对象合并                                                  | [merge](http://ramda.cn/docs/#merge)                       |\n| 对象合并：对重复的属性值按给定规则合并                    | [mergeWith](http://ramda.cn/docs/#mergeWith)               |\n| 对象合并：对重复的属性值按给定规则合并                    | [mergeWithKey](http://ramda.cn/docs/#mergeWithKey)         |\n| 对象深递归合并：以左侧对象属性为主                        | [mergeDeepLeft](http://ramda.cn/docs/#mergeDeepLeft)       |\n| 对象深递归合并：以右侧对象属性为主                        | [mergeDeepRight](http://ramda.cn/docs/#mergeDeepRight)     |\n| 对象深递归合并：对重复的非对象类型的值按给定规则合并      | [mergeDeepWith](http://ramda.cn/docs/#mergeDeepWith)       |\n| 对象深递归合并：对重复的非对象类型的值按给定规则合并      | [mergeDeepWithKey](http://ramda.cn/docs/#mergeDeepWithKey) |\n| 创建包含单个键值对的对象                                  | [objOf](http://ramda.cn/docs/#objOf)                       |\n| 将对象键值对转换为元素为键值二元组的列表                  | [toPairs](http://ramda.cn/docs/#toPairs)                   |\n| 将对象键值对转换为元素为键值二元组的列表:包括原型链上的键 | [toPairsIn](http://ramda.cn/docs/#toPairsIn)               |\n| 将二元组的列表转换为对象                                  | [fromPairs](http://ramda.cn/docs/#fromPairs)               |\n\n# 逻辑运算\n\n| Action                                                          | Function                                             |\n| :-----                                                          | :-------                                             |\n| 判断是否满足所有条件                                            | [allPass](http://ramda.cn/docs/#allPass)             |\n| 判断是否满足任一条件                                            | [anyPass](http://ramda.cn/docs/#anyPass)             |\n| 判断是否同时满足两个条件                                        | [both](http://ramda.cn/docs/#both)                   |\n| 判断是否满足两个条件中的任意一个                                | [either](http://ramda.cn/docs/#either)               |\n| 逻辑与操作                                                      | [and](http://ramda.cn/docs/#and)                     |\n| 逻辑或操作                                                      | [or](http://ramda.cn/docs/#or)                       |\n| 模式匹配，相当于多个 `if/else`                                  | [cond](http://ramda.cn/docs/#cond)                   |\n| 单个 `if/else`，`cond` 的特例                                   | [ifElse](http://ramda.cn/docs/#ifElse)               |\n| 满足条件，则执行处理函数，否则原样返回输入值，`ifElse` 的特例   | [when](http://ramda.cn/docs/#when)                   |\n| 不满足条件时，执行处理函数，否则原样返回输入值，`ifElse` 的特例 | [unless](http://ramda.cn/docs/#unless)               |\n| 逻辑非操作，参数为布尔值                                        | [not](http://ramda.cn/docs/#not)                     |\n| 对函数返回值取反                                                | [complement](http://ramda.cn/docs/#complement)       |\n| 添加默认值                                                      | [defaultTo](http://ramda.cn/docs/#defaultTo)         |\n| 一直计算，直到满足给定条件                                      | [until](http://ramda.cn/docs/#until)                 |\n| 判断给定值是否为该类型的空值                                    | [isEmpty](http://ramda.cn/docs/#isEmpty)             |\n| 判断给定值是否为 `null` 或 `undefined`                          | [isNil](http://ramda.cn/docs/#isNil)                 |\n| 返回给定值所属类型的空值                                        | [empty](http://ramda.cn/docs/#empty)                 |\n\n\n# 关系运算\n\n| Action                                               | Function                                                                 |\n| :-----                                               | :-------                                                                 |\n| 等于                                                 | [equals](http://ramda.cn/docs/#equals)                                   |\n| 完全相等                                             | [identical](http://ramda.cn/docs/#identical)                             |\n| 通过规则判断是否相等                                 | [eqBy](http://ramda.cn/docs/#eqBy)                                       |\n| 大于                                                 | [gt](http://ramda.cn/docs/#gt)                                           |\n| 大于等于                                             | [gte](http://ramda.cn/docs/#gte)                                         |\n| 小于                                                 | [lt](http://ramda.cn/docs/#lt)                                           |\n| 小于等于                                             | [lte](http://ramda.cn/docs/#lte)                                         |\n| 限定有序数据类型的范围                               | [clamp](http://ramda.cn/docs/#clamp)                                     |\n| 求两个数的较大值                                     | [max](http://ramda.cn/docs/#max)                                         |\n| 按规则求两个数的较大值                               | [maxBy](http://ramda.cn/docs/#maxBy)                                     |\n| 求两个数的较小值                                     | [min](http://ramda.cn/docs/#min)                                         |\n| 按规则求两个数的较小值                               | [minBy](http://ramda.cn/docs/#minBy)                                     |\n| 求差集：{a∣a∈xs ∩ a∉ys}                              | [difference](http://ramda.cn/docs/#difference)                           |\n| 求差集：{a∣a∉xs ∩ a∈ys}                              | [without](http://ramda.cn/docs/#without)                                 |\n| 求差集：根据条件计算第一个列表与第二个列表的差集     | [differenceWith](http://ramda.cn/docs/#differenceWith)                   |\n| 求对称差集：{(xs ∪ ys) - (xs ∩ ys)}                  | [symmetricDifference](http://ramda.cn/docs/#symmetricDifference)         |\n| 求对称差集：根据条件计算所有不属于两个列表交集的元素 | [symmetricDifferenceWith](http://ramda.cn/docs/#symmetricDifferenceWith) |\n| 求交集：{xs ∩ ys}                                    | [intersection](http://ramda.cn/docs/#intersection)                       |\n| 求交集：从 xs 中挑选出在 ys 中符合条件的元素         | [innerJoin](http://ramda.cn/docs/#innerJoin)                             |\n| 求并集：{xs ∪ ys}                                    | [union](http://ramda.cn/docs/#union)                                     |\n| 求并集：根据条件判断两元素是否重复                   | [unionWith](http://ramda.cn/docs/#unionWith)                             |\n\n\n# 数学运算\n\n| Action     | Function                                   |\n| :-----     | :-------                                   |\n| 加         | [add](http://ramda.cn/docs/#add)           |\n| 减         | [subtract](http://ramda.cn/docs/#subtract) |\n| 乘         | [multiply](http://ramda.cn/docs/#multiply) |\n| 除         | [divide](http://ramda.cn/docs/#divide)     |\n| 加1        | [inc](http://ramda.cn/docs/#inc)           |\n| 减1        | [dec](http://ramda.cn/docs/#dec)           |\n| 取反       | [negate](http://ramda.cn/docs/#negate)     |\n| 列表累加和 | [sum](http://ramda.cn/docs/#sum)           |\n| 列表累乘积 | [product](http://ramda.cn/docs/#product)   |\n| 列表平均值 | [mean](http://ramda.cn/docs/#mean)         |\n| 列表中位数 | [median](http://ramda.cn/docs/#median)     |\n| 取模：算术 | [mathMod](http://ramda.cn/docs/#mathMod)   |\n| 取模：JS   | [modulo](http://ramda.cn/docs/#modulo)     |\n\n\n# 类型操作\n\n| Action                           | Function                               |\n| :-----                           | :-------                               |\n| 类型判断                         | [is](http://ramda.cn/docs/#is)         |\n| 类型描述                         | [type](http://ramda.cn/docs/#type)     |\n| 属性类型判断                     | [propIs](http://ramda.cn/docs/#propIs) |\n| 判断是否为 `null` 或 `undefined` | [isNil](http://ramda.cn/docs/#isNil)   |\n\n\n# 参考资料\n\n关于 `Applicative Functor`，及其操作符 [R.ap]([ap](http://ramda.cn/docs/#ap)) (haskell 中的 `<*>`) 和 [lift](http://ramda.cn/docs/#lift) (haskell 中的 `<$>`) 的论述可参考下列资料：\n\n1. 《Learn You A Haskell For Great Good》的 [Applicative 章节](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors)，函数 `(->) r` 也是 Applicative，需要深入理解。\n\n```haskell\nFunction :: ((->) r)\nFunction a = ((->) r) a \n           = r -> a\n\n;; Functor、Applicative、Monad 的类定义\n\nclass Functor f where  \n    fmap :: (a -> b) -> f a -> f b  \n\nclass (Functor f) => Applicative f where  \n    pure :: a -> f a  \n    (<*>) :: f (a -> b) -> f a -> f b  \n\nclass Monad m where  \n    return :: a -> m a  \n  \n    (>>=) :: m a -> (a -> m b) -> m b  \n  \n    (>>) :: m a -> m b -> m b  \n    x >> y = x >>= \\_ -> y  \n  \n    fail :: String -> m a  \n    fail msg = error msg  \n\n;; 作为Functor、Applicative、Monad 的实例的 Function 的定义，可以对比上面的类定义查看\ninstance Functor ((->) r) where\n    fmap = (.)\n\nfmap :: (a -> b) -> (c -> a) -> (c -> b)\n\nf :: a -> b\n\ng :: c -> a\nh :: c -> b\n\nconst h = fmap(f, g) = map(f, g) = compose(f, g)\n\ninstance Applicative ((->) r) where\n    pure x = (\\_ -> x)\n    f <*> g = \\x -> f x (g x)\n\nf <*> g = (r->(a->b)) -> (r->a) -> (r->b)\n        = (r->a->b) -> (r->a) -> r -> b\n\ninstance Monad ((->) r) where\n    return x = \\_ -> x\n    h >>= f = \\w -> f (h w) w\n```\n\n2. [《JS 函数式编程指南》](https://github.com/MostlyAdequate/mostly-adequate-guide)：\n    1. [第 10 章: Applicative Functor](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html)\n    2. [第 10 章: Applicative Functor lift](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#lift)\n\n3. stackoverflow: function as Functor/Applicative Functor/Monad：\n    1. [confused about function as instance of Functor in haskell](https://stackoverflow.com/questions/10294272/confused-about-function-as-instance-of-functor-in-haskell)\n    2. [functions as applicative functors (Haskell / LYAH)](https://stackoverflow.com/questions/11810889/functions-as-applicative-functors-haskell-lyah)\n    3. [Function as an Instance of Monad](https://stackoverflow.com/questions/13080014/function-as-an-instance-of-monad)\n\n4. [Functions as Functors](http://www.tomharding.me/2017/04/15/functions-as-functors/)\n\n","source":"_posts/What-Function-Should-I-Use.md","raw":"---\ntitle: Ramda 函数简介\ndate: 2017-10-21 07:25:36\ncategories: 'Ramda'\n---\n\nRamda API 已经快到 300 个了，对每个 API 按类型分别进行简介，当作 Ramda 的一份 CheatSheet 。\n\n# 列表\n\n| Action                                                  | Function                                                                 |\n| :-----                                                  | :-------                                                                 |\n| 列表转换                                                | [map](http://ramda.cn/docs/#map)                                         |\n| 列表过滤：过滤出符合条件的元素                          | [filter](http://ramda.cn/docs/#filter)                                   |\n| 列表过滤：过滤掉符合条件的元素                          | [reject](http://ramda.cn/docs/#reject)                                   |\n| 列表折叠：从左向右对所有元素依次归约（折叠）            | [reduce](http://ramda.cn/docs/#reduce)                                   |\n| 列表折叠：从右向左对所有元素依次归约（折叠）            | [reduceRight](http://ramda.cn/docs/#reduceRight)                         |\n| 列表折叠(增强版)                                        | [transduce](http://ramda.cn/docs/#transduce)                             |\n| 列表去重                                                | [uniq](http://ramda.cn/docs/#uniq)                                       |\n| 列表去重：对处理后的元素做相等性判断                    | [uniqBy](http://ramda.cn/docs/#uniqBy)                                   |\n| 列表去重：通过断言函数（predicate）判断                 | [uniqWith](http://ramda.cn/docs/#uniqWith)                               |\n| 列表排序                                                | [sort](http://ramda.cn/docs/#sort)                                       |\n| 列表翻转                                                | [reverse](http://ramda.cn/docs/#reverse)                                 |\n| 列表拼接                                                | [concat](http://ramda.cn/docs/#concat)                                   |\n| 列表长度                                                | [length](http://ramda.cn/docs/#length)                                   |\n| 列表表头拼接元素                                        | [prepend](http://ramda.cn/docs/#prepend)                                 |\n| 列表表尾拼接元素                                        | [append](http://ramda.cn/docs/#append)                                   |\n| 更新指定索引处的值                                      | [adjust](http://ramda.cn/docs/#adjust)                                   |\n| 替换指定索引处的值                                      | [update](http://ramda.cn/docs/#update)                                   |\n| 将列表元素转换为其指定的属性值，等价于 R.map(R.prop)    | [pluck](http://ramda.cn/docs/#pluck)                                     |\n| 为列表迭代函数添加两个参数：索引和整个列表              | [addIndex](http://ramda.cn/docs/#addIndex)                               |\n| 取出特定索引范围内的元素                                | [slice](http://ramda.cn/docs/#slice)                                     |\n| 将列表通过分隔符拼接成字符串                            | [join](http://ramda.cn/docs/#join)                                       |\n| 取出第 N 个元素                                         | [nth](http://ramda.cn/docs/#nth)                                         |\n| 取出前 N 个元素                                         | [take](http://ramda.cn/docs/#take)                                       |\n| 取出后 N 个元素                                         | [takeLast](http://ramda.cn/docs/#takeLast)                               |\n| 从前往后取出满足条件的元素，直至不满足条件的首个元素止  | [takeWhile](http://ramda.cn/docs/#takeWhile)                             |\n| 从后向前取出满足条件的元素，直至不满足条件的首个元素止  | [takeLastWhile](http://ramda.cn/docs/#takeLastWhile)                     |\n| 删除前 N 个元素                                         | [drop](http://ramda.cn/docs/#drop)                                       |\n| 删除后 N 个元素                                         | [dropLast](http://ramda.cn/docs/#dropLast)                               |\n| 从前往后删除满足条件的元素，直至不满足条件的首个元素止  | [dropWhile](http://ramda.cn/docs/#dropWhile)                             |\n| 从后向前删除满足条件的元素，直至不满足条件的首个元素止  | [dropLastWhile](http://ramda.cn/docs/#dropLastWhile)                     |\n| 取出首个元素                                            | [head](http://ramda.cn/docs/#head)                                       |\n| 取出末尾元素                                            | [last](http://ramda.cn/docs/#taillast)                                   |\n| 取出前 length - 1 个元素（删除末尾元素）                | [init](http://ramda.cn/docs/#init)                                       |\n| 取出后 length - 1 个元素（删除首个元素）                | [tail](http://ramda.cn/docs/#tail)                                       |\n| 求差集：{a∣a∈xs ∩ a∉ys}                                 | [difference](http://ramda.cn/docs/#difference)                           |\n| 求差集：{a∣a∉xs ∩ a∈ys}                                 | [without](http://ramda.cn/docs/#without)                                 |\n| 求差集：根据条件计算第一个列表与第二个列表的差集        | [differenceWith](http://ramda.cn/docs/#differenceWith)                   |\n| 求对称差集：{(xs ∪ ys) - (xs ∩ ys)}                     | [symmetricDifference](http://ramda.cn/docs/#symmetricDifference)         |\n| 求对称差集：根据条件计算所有不属于两个列表交集的元素    | [symmetricDifferenceWith](http://ramda.cn/docs/#symmetricDifferenceWith) |\n| 求交集：{xs ∩ ys}                                       | [intersection](http://ramda.cn/docs/#intersection)                       |\n| 求交集：从 xs 中挑选出在 ys 中符合条件的元素            | [innerJoin](http://ramda.cn/docs/#innerJoin)                             |\n| 求并集：{xs ∪ ys}                                       | [union](http://ramda.cn/docs/#union)                                     |\n| 求并集：根据条件判断两元素是否重复                      | [unionWith](http://ramda.cn/docs/#unionWith)                             |\n| 查找列表中首个满足条件的元素                            | [find](http://ramda.cn/docs/#find)                                       |\n| 查找列表中首个满足条件的元素的索引                      | [findIndex](http://ramda.cn/docs/#findIndex)                             |\n| 查找列表中最后一个满足条件的元素                        | [findLast](http://ramda.cn/docs/#findLast)                               |\n| 查找列表中最后一个满足条件的元素的索引                  | [findLastIndex](http://ramda.cn/docs/#findLastIndex)                     |\n| 查找给定元素在列表中首次出现时的索引                    | [indexOf](http://ramda.cn/docs/#indexOf)                                 |\n| 查找给定元素在列表中末次出现时的索引                    | [lastIndexOf](http://ramda.cn/docs/#lastIndexOf)                         |\n| 列表判断：判断元素是否包含在列表中                      | [contains](http://ramda.cn/docs/#contains)                               |\n| 列表判断：判断是否列表中所有元素都满足条件              | [all](http://ramda.cn/docs/#all)                                         |\n| 列表判断：判断是否列表中所有元素都不满足条件            | [none](http://ramda.cn/docs/#none)                                       |\n| 列表判断：判断是否列表中存在满足条件的元素              | [any](http://ramda.cn/docs/#any)                                         |\n| 列表判断：判断列表是否以给定的值开头                    | [startsWith](http://ramda.cn/docs/#startsWith)                           |\n| 列表判断：判断列表是否以给定的值结尾                    | [endsWith](http://ramda.cn/docs/#endsWith)                               |\n| 列表分组：按是否符合条件，将元素分为两组                | [partition](http://ramda.cn/docs/#partition)                             |\n| 列表分组：对列表中元素按指定规则分组                    | [groupBy](http://ramda.cn/docs/#groupBy)                                 |\n| 列表分段：对列表中元素按指定规则分段                    | [groupWith](http://ramda.cn/docs/#groupWith)                             |\n| 列表分组：对列表中元素按指定规则分组折叠                | [reduceBy](http://ramda.cn/docs/#reduceBy)                               |\n| 列表分割：在指定索引处                                  | [splitAt](http://ramda.cn/docs/#splitAt)                                 |\n| 列表分割：每隔 N 个元素                                 | [splitEvery](http://ramda.cn/docs/#splitEvery)                           |\n| 列表分割：按条件分割                                    | [splitWhen](http://ramda.cn/docs/#splitWhen)                             |\n| 对两个列表相同位置的元素进行组合                        | [zip](http://ramda.cn/docs/#zip)                                         |\n| 对两个列表相同位置的元素进行键值对组合，fromPairs ∘ zip | [zipObj](http://ramda.cn/docs/#zipObj)                                   |\n| 对两个列表相同位置的元素按规则进行组合                  | [zipWith](http://ramda.cn/docs/#zipWith)                                 |\n| 由一系列键值对列表创建对象                              | [fromPairs](http://ramda.cn/docs/#fromPairs)                             |\n| 列表彻底扁平化                                          | [flatten](http://ramda.cn/docs/#flatten)                                 |\n| 列表单层扁平化                                          | [unnest](http://ramda.cn/docs/#unnest)                                   |\n| 先对列表内元素做 Kleisli 映射，再做扁平化，flatMap，>>= | [chain](http://ramda.cn/docs/#chain)                                     |\n| 函子间的自然变化？                                      | [sequence](http://ramda.cn/docs/#sequence)                               |\n| 列表插入                                                | [insert](http://ramda.cn/docs/#insert)                                   |\n| 将子列表插入列表                                        | [insertAll](http://ramda.cn/docs/#insertAll)                             |\n| 在列表元素之间插入分割元素                              | [intersperse](http://ramda.cn/docs/#intersperse)                         |\n| 列表转换 + 折叠？                                       | [into](http://ramda.cn/docs/#into)                                       |\n| 将 reduce 的迭代过程记录下来                            | [mapAccum](http://ramda.cn/docs/#mapAccum)                               |\n| 将 reduceRight 的迭代过程记录下来                       | [mapAccumRight](http://ramda.cn/docs/#mapAccumRight)                     |\n| 合并多个对象                                            | [mergeAll](http://ramda.cn/docs/#mergeAll)                               |\n| 由两个参数组成列表                                      | [pair](http://ramda.cn/docs/#pair)                                       |\n| 从 reduce 或 transduce 中提前退出迭代时的值             | [reduced](http://ramda.cn/docs/#reduced)                                 |\n| 可以提前退出的 reduce 迭代                              | [reduceWhile](http://ramda.cn/docs/#reduceWhile)                         |\n| 列表生成：生成左闭右开的升序数字列表                    | [range](http://ramda.cn/docs/#range)                                     |\n| 列表生成：生成含有 N 个同一元素的列表                   | [repeat](http://ramda.cn/docs/#repeat)                                   |\n| 列表生成：函数执行 N 次，生成 N 元列表                  | [times](http://ramda.cn/docs/#times)                                     |\n| 列表生成：通过迭代函数生成列表                          | [unfold](http://ramda.cn/docs/#unfold)                                   |\n| 二维列表行列式转换                                      | [transpose](http://ramda.cn/docs/#transpose)                             |\n| 二维列表生成                                            | [xprod](http://ramda.cn/docs/#xprod)                                     |\n\n\n# 函数\n\n| Action                                                       | Function                                           |\n| :-----                                                       | :-------                                           |\n| 函数组合：纵向，从右往左                                     | [compose](http://ramda.cn/docs/#compose)           |\n| 函数组合：纵向，从左往右                                     | [pipe](http://ramda.cn/docs/#pipe)                 |\n| 函数组合：纵向                                               | [o](http://ramda.cn/docs/#o)                       |\n| 函数组合：横向                                               | [converge](http://ramda.cn/docs/#converge)         |\n| 函数组合：横向                                               | [useWith](http://ramda.cn/docs/#useWith)           |\n| Kleisili 函数组合                                            | [composeK](http://ramda.cn/docs/#composeK)         |\n| Kleisili 函数组合                                            | [pipeK](http://ramda.cn/docs/#pipeK)               |\n| Promise 函数组合                                             | [composeP](http://ramda.cn/docs/#composeP)         |\n| Promise 函数组合                                             | [pipeP](http://ramda.cn/docs/#pipeP)               |\n| 单位函数：输出等于输入                                       | [identity](http://ramda.cn/docs/#identity)         |\n| 函数柯里化                                                   | [curry](http://ramda.cn/docs/#curry)               |\n| N 元函数柯里化                                               | [curryN](http://ramda.cn/docs/#curryN)             |\n| 将柯里化函数 转为 N 元函数                                   | [uncurryN](http://ramda.cn/docs/#uncurryN)         |\n| 柯里化函数的参数占位符                                       | [__](http://ramda.cn/docs/#__)                     |\n| 参数部分调用：从左往右                                       | [partial](http://ramda.cn/docs/#partial)           |\n| 参数部分调用：从右往左                                       | [partialRight](http://ramda.cn/docs/#partialRight) |\n| 函数缓存                                                     | [memoize](http://ramda.cn/docs/#memoize)           |\n| 函数缓存：可以自定义缓存键值                                 | [memoizeWith](http://ramda.cn/docs/#memoizeWith)   |\n| 只执行一次的函数                                             | [once](http://ramda.cn/docs/#once)                 |\n| 创建返回恒定值的函数                                         | [always](http://ramda.cn/docs/#always)             |\n| 恒定返回 `true` 的函数                                       | [T](http://ramda.cn/docs/#T)                       |\n| 恒定返回 `false`  的函数                                     | [F](http://ramda.cn/docs/#F)                       |\n| Applicative Functor 的 ap 方法，<*>                          | [ap](http://ramda.cn/docs/#ap)                     |\n| 将函数作用于参数列表                                         | [apply](http://ramda.cn/docs/#apply)               |\n| 将接受 __单列表参数__ 的函数转为接受 __普通参数列表__ 的函数 | [unapply](http://ramda.cn/docs/#unapply)           |\n| 将首个参数（函数）作用于其余参数                             | [call](http://ramda.cn/docs/#call)                 |\n| 绑定函数上下文                                               | [bind](http://ramda.cn/docs/#bind)                 |\n| 利用属性值为函数的对象生成同构对象                           | [applySpec](http://ramda.cn/docs/#applySpec)       |\n| 将函数列表作用于参数列表                                     | [juxt](http://ramda.cn/docs/#juxt)                 |\n| 将给定值传给给定函数，CPS: flip($)                           | [applyTo](http://ramda.cn/docs/#applyTo)           |\n| 比较函数，一般用于排序                                       | [comparator](http://ramda.cn/docs/#comparator)     |\n| 升序比较函数                                                 | [ascend](http://ramda.cn/docs/#ascend)             |\n| 降序比较函数                                                 | [descend](http://ramda.cn/docs/#descend)           |\n| 将函数封装为 N 元函数                                        | [nArg](http://ramda.cn/docs/#nArg)                 |\n| 将函数封装为一元函数                                         | [unary](http://ramda.cn/docs/#unary)               |\n| 将函数封装为二元函数                                         | [binary](http://ramda.cn/docs/#binary)             |\n| 提取第 N 个参数                                              | [nthArg](http://ramda.cn/docs/#nthArg)             |\n| 将构造函数封装为普通函数，创建实例时，不需要 new 操作符      | [construct](http://ramda.cn/docs/#construct)       |\n| 将构造函数封装为 N 元普通函数，创建实例时，不需要 new 操作符 | [constructN](http://ramda.cn/docs/#constructN)     |\n| 通过函数名调用函数                                           | [invoker](http://ramda.cn/docs/#invoker)           |\n| 创建相应类型的空值                                           | [empty](http://ramda.cn/docs/#empty)               |\n| 判断是否为空值                                               | [isEmpty](http://ramda.cn/docs/#isEmpty)           |\n| 交换函数前两个参数的位置                                     | [flip](http://ramda.cn/docs/#flip)                 |\n| 函数提升                                                     | [lift](http://ramda.cn/docs/#lift)                 |\n| N 元函数提升                                                 | [liftN](http://ramda.cn/docs/#liftN)               |\n| 生成单元素列表                                               | [of](http://ramda.cn/docs/#of)                     |\n| 输出等于输入，但产生副作用的函数，一般用于调试               | [tap](http://ramda.cn/docs/#tap)                   |\n| 异常捕获                                                     | [tryCatch](http://ramda.cn/docs/#tryCatch)         |\n\n\n# 对象\n\n| Action                                                    | Function                                                   |\n| :-----                                                    | :-------                                                   |\n| 属性设置                                                  | [assoc](http://ramda.cn/docs/#assoc)                       |\n| 属性按路径设置                                            | [assocPath](http://ramda.cn/docs/#assocPath)               |\n| 属性删除                                                  | [dissoc](http://ramda.cn/docs/#dissoc)                     |\n| 属性按路径删除                                            | [disscoPath](http://ramda.cn/docs/#disscoPath)             |\n| 获取属性值                                                | [prop](http://ramda.cn/docs/#prop)                         |\n| 获取属性值，带有默认值                                    | [propOr](http://ramda.cn/docs/#propOr)                     |\n| 获取路径上的属性值                                        | [path](http://ramda.cn/docs/#path)                         |\n| 获取路径上的属性值，带有默认值                            | [pathOr](http://ramda.cn/docs/#pathOr)                     |\n| 判断属性是否满足给定的条件                                | [propSatisfies](http://ramda.cn/docs/#propSatisfies)       |\n| 判断属性是否与给定值相等                                  | [propEq](http://ramda.cn/docs/#propEq)                     |\n| 判断两个对象指定的属性值是否相等                          | [eqProps](http://ramda.cn/docs/#eqProps)                   |\n| 判断路径上的属性值是否满足给定的条件                      | [pathSatisfies](http://ramda.cn/docs/#pathSatisfies)       |\n| 判断路径上的属性值是否与给定值相等                        | [pathEq](http://ramda.cn/docs/#pathEq)                     |\n| 获取属性值组成的列表                                      | [props](http://ramda.cn/docs/#props)                       |\n| 判断属性是否为给定类型                                    | [propIs](http://ramda.cn/docs/#propIs)                     |\n| 判断多个属性是否同时满足给定的条件                        | [where](http://ramda.cn/docs/#where)                       |\n| 判断多个属性是否等于给定对应属性值                        | [whereEq](http://ramda.cn/docs/#whereEq)                   |\n| 删除多个属性                                              | [omit](http://ramda.cn/docs/#omit)                         |\n| 提取多个属性                                              | [pick](http://ramda.cn/docs/#pick)                         |\n| 提取多个属性                                              | [pickAll](http://ramda.cn/docs/#pickAll)                   |\n| 对列表中元素提取多个属性，模拟 SQL 的 `select`            | [project](http://ramda.cn/docs/#project)                   |\n| 提取键值满足条件的属性                                    | [pickBy](http://ramda.cn/docs/#pickBy)                     |\n| 对特定属性进行特定变换                                    | [evolve](http://ramda.cn/docs/#evolve)                     |\n| 是否包含指定的键                                          | [has](http://ramda.cn/docs/#has)                           |\n| 是否包含指定的键：包括原型链上的键                        | [hasIn](http://ramda.cn/docs/#hasIn)                       |\n| 键值对换位                                                | [invertObj](http://ramda.cn/docs/#invertObj)               |\n| 键值对换位：将值放入数组中                                | [invert](http://ramda.cn/docs/#invert)                     |\n| 取出所有的键                                              | [keys](http://ramda.cn/docs/#keys)                         |\n| 取出所有的键：包括原型链上的键                            | [keysIn](http://ramda.cn/docs/#keysIn)                     |\n| 取出所有的值                                              | [values](http://ramda.cn/docs/#values)                     |\n| 取出所有的值：包括原型链上的值                            | [valuesIn](http://ramda.cn/docs/#valuesIn)                 |\n| 透镜：包括属性的 getter 和 setter                         | [lens](http://ramda.cn/docs/#lens)                         |\n| 透镜：指定索引的透镜                                      | [lensIndex](http://ramda.cn/docs/#lensIndex)               |\n| 透镜：指定路径的透镜                                      | [lensPath](http://ramda.cn/docs/#lensPath)                 |\n| 透镜：指定属性的透镜                                      | [lensProp](http://ramda.cn/docs/#lensProp)                 |\n| 透镜：对被 `lens` 聚焦的属性做变换                        | [over](http://ramda.cn/docs/#over)                         |\n| 透镜：对被 `lens` 聚焦的属性进行设置                      | [set](http://ramda.cn/docs/#set)                           |\n| 透镜：读取被 `lens` 聚焦的属性值                          | [view](http://ramda.cn/docs/#view)                         |\n| `Object` 版 `map`，转换函数参数：(value, key, obj)        | [mapObjIndexed](http://ramda.cn/docs/#mapObjIndexed)       |\n| 对象合并                                                  | [merge](http://ramda.cn/docs/#merge)                       |\n| 对象合并：对重复的属性值按给定规则合并                    | [mergeWith](http://ramda.cn/docs/#mergeWith)               |\n| 对象合并：对重复的属性值按给定规则合并                    | [mergeWithKey](http://ramda.cn/docs/#mergeWithKey)         |\n| 对象深递归合并：以左侧对象属性为主                        | [mergeDeepLeft](http://ramda.cn/docs/#mergeDeepLeft)       |\n| 对象深递归合并：以右侧对象属性为主                        | [mergeDeepRight](http://ramda.cn/docs/#mergeDeepRight)     |\n| 对象深递归合并：对重复的非对象类型的值按给定规则合并      | [mergeDeepWith](http://ramda.cn/docs/#mergeDeepWith)       |\n| 对象深递归合并：对重复的非对象类型的值按给定规则合并      | [mergeDeepWithKey](http://ramda.cn/docs/#mergeDeepWithKey) |\n| 创建包含单个键值对的对象                                  | [objOf](http://ramda.cn/docs/#objOf)                       |\n| 将对象键值对转换为元素为键值二元组的列表                  | [toPairs](http://ramda.cn/docs/#toPairs)                   |\n| 将对象键值对转换为元素为键值二元组的列表:包括原型链上的键 | [toPairsIn](http://ramda.cn/docs/#toPairsIn)               |\n| 将二元组的列表转换为对象                                  | [fromPairs](http://ramda.cn/docs/#fromPairs)               |\n\n# 逻辑运算\n\n| Action                                                          | Function                                             |\n| :-----                                                          | :-------                                             |\n| 判断是否满足所有条件                                            | [allPass](http://ramda.cn/docs/#allPass)             |\n| 判断是否满足任一条件                                            | [anyPass](http://ramda.cn/docs/#anyPass)             |\n| 判断是否同时满足两个条件                                        | [both](http://ramda.cn/docs/#both)                   |\n| 判断是否满足两个条件中的任意一个                                | [either](http://ramda.cn/docs/#either)               |\n| 逻辑与操作                                                      | [and](http://ramda.cn/docs/#and)                     |\n| 逻辑或操作                                                      | [or](http://ramda.cn/docs/#or)                       |\n| 模式匹配，相当于多个 `if/else`                                  | [cond](http://ramda.cn/docs/#cond)                   |\n| 单个 `if/else`，`cond` 的特例                                   | [ifElse](http://ramda.cn/docs/#ifElse)               |\n| 满足条件，则执行处理函数，否则原样返回输入值，`ifElse` 的特例   | [when](http://ramda.cn/docs/#when)                   |\n| 不满足条件时，执行处理函数，否则原样返回输入值，`ifElse` 的特例 | [unless](http://ramda.cn/docs/#unless)               |\n| 逻辑非操作，参数为布尔值                                        | [not](http://ramda.cn/docs/#not)                     |\n| 对函数返回值取反                                                | [complement](http://ramda.cn/docs/#complement)       |\n| 添加默认值                                                      | [defaultTo](http://ramda.cn/docs/#defaultTo)         |\n| 一直计算，直到满足给定条件                                      | [until](http://ramda.cn/docs/#until)                 |\n| 判断给定值是否为该类型的空值                                    | [isEmpty](http://ramda.cn/docs/#isEmpty)             |\n| 判断给定值是否为 `null` 或 `undefined`                          | [isNil](http://ramda.cn/docs/#isNil)                 |\n| 返回给定值所属类型的空值                                        | [empty](http://ramda.cn/docs/#empty)                 |\n\n\n# 关系运算\n\n| Action                                               | Function                                                                 |\n| :-----                                               | :-------                                                                 |\n| 等于                                                 | [equals](http://ramda.cn/docs/#equals)                                   |\n| 完全相等                                             | [identical](http://ramda.cn/docs/#identical)                             |\n| 通过规则判断是否相等                                 | [eqBy](http://ramda.cn/docs/#eqBy)                                       |\n| 大于                                                 | [gt](http://ramda.cn/docs/#gt)                                           |\n| 大于等于                                             | [gte](http://ramda.cn/docs/#gte)                                         |\n| 小于                                                 | [lt](http://ramda.cn/docs/#lt)                                           |\n| 小于等于                                             | [lte](http://ramda.cn/docs/#lte)                                         |\n| 限定有序数据类型的范围                               | [clamp](http://ramda.cn/docs/#clamp)                                     |\n| 求两个数的较大值                                     | [max](http://ramda.cn/docs/#max)                                         |\n| 按规则求两个数的较大值                               | [maxBy](http://ramda.cn/docs/#maxBy)                                     |\n| 求两个数的较小值                                     | [min](http://ramda.cn/docs/#min)                                         |\n| 按规则求两个数的较小值                               | [minBy](http://ramda.cn/docs/#minBy)                                     |\n| 求差集：{a∣a∈xs ∩ a∉ys}                              | [difference](http://ramda.cn/docs/#difference)                           |\n| 求差集：{a∣a∉xs ∩ a∈ys}                              | [without](http://ramda.cn/docs/#without)                                 |\n| 求差集：根据条件计算第一个列表与第二个列表的差集     | [differenceWith](http://ramda.cn/docs/#differenceWith)                   |\n| 求对称差集：{(xs ∪ ys) - (xs ∩ ys)}                  | [symmetricDifference](http://ramda.cn/docs/#symmetricDifference)         |\n| 求对称差集：根据条件计算所有不属于两个列表交集的元素 | [symmetricDifferenceWith](http://ramda.cn/docs/#symmetricDifferenceWith) |\n| 求交集：{xs ∩ ys}                                    | [intersection](http://ramda.cn/docs/#intersection)                       |\n| 求交集：从 xs 中挑选出在 ys 中符合条件的元素         | [innerJoin](http://ramda.cn/docs/#innerJoin)                             |\n| 求并集：{xs ∪ ys}                                    | [union](http://ramda.cn/docs/#union)                                     |\n| 求并集：根据条件判断两元素是否重复                   | [unionWith](http://ramda.cn/docs/#unionWith)                             |\n\n\n# 数学运算\n\n| Action     | Function                                   |\n| :-----     | :-------                                   |\n| 加         | [add](http://ramda.cn/docs/#add)           |\n| 减         | [subtract](http://ramda.cn/docs/#subtract) |\n| 乘         | [multiply](http://ramda.cn/docs/#multiply) |\n| 除         | [divide](http://ramda.cn/docs/#divide)     |\n| 加1        | [inc](http://ramda.cn/docs/#inc)           |\n| 减1        | [dec](http://ramda.cn/docs/#dec)           |\n| 取反       | [negate](http://ramda.cn/docs/#negate)     |\n| 列表累加和 | [sum](http://ramda.cn/docs/#sum)           |\n| 列表累乘积 | [product](http://ramda.cn/docs/#product)   |\n| 列表平均值 | [mean](http://ramda.cn/docs/#mean)         |\n| 列表中位数 | [median](http://ramda.cn/docs/#median)     |\n| 取模：算术 | [mathMod](http://ramda.cn/docs/#mathMod)   |\n| 取模：JS   | [modulo](http://ramda.cn/docs/#modulo)     |\n\n\n# 类型操作\n\n| Action                           | Function                               |\n| :-----                           | :-------                               |\n| 类型判断                         | [is](http://ramda.cn/docs/#is)         |\n| 类型描述                         | [type](http://ramda.cn/docs/#type)     |\n| 属性类型判断                     | [propIs](http://ramda.cn/docs/#propIs) |\n| 判断是否为 `null` 或 `undefined` | [isNil](http://ramda.cn/docs/#isNil)   |\n\n\n# 参考资料\n\n关于 `Applicative Functor`，及其操作符 [R.ap]([ap](http://ramda.cn/docs/#ap)) (haskell 中的 `<*>`) 和 [lift](http://ramda.cn/docs/#lift) (haskell 中的 `<$>`) 的论述可参考下列资料：\n\n1. 《Learn You A Haskell For Great Good》的 [Applicative 章节](http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors)，函数 `(->) r` 也是 Applicative，需要深入理解。\n\n```haskell\nFunction :: ((->) r)\nFunction a = ((->) r) a \n           = r -> a\n\n;; Functor、Applicative、Monad 的类定义\n\nclass Functor f where  \n    fmap :: (a -> b) -> f a -> f b  \n\nclass (Functor f) => Applicative f where  \n    pure :: a -> f a  \n    (<*>) :: f (a -> b) -> f a -> f b  \n\nclass Monad m where  \n    return :: a -> m a  \n  \n    (>>=) :: m a -> (a -> m b) -> m b  \n  \n    (>>) :: m a -> m b -> m b  \n    x >> y = x >>= \\_ -> y  \n  \n    fail :: String -> m a  \n    fail msg = error msg  \n\n;; 作为Functor、Applicative、Monad 的实例的 Function 的定义，可以对比上面的类定义查看\ninstance Functor ((->) r) where\n    fmap = (.)\n\nfmap :: (a -> b) -> (c -> a) -> (c -> b)\n\nf :: a -> b\n\ng :: c -> a\nh :: c -> b\n\nconst h = fmap(f, g) = map(f, g) = compose(f, g)\n\ninstance Applicative ((->) r) where\n    pure x = (\\_ -> x)\n    f <*> g = \\x -> f x (g x)\n\nf <*> g = (r->(a->b)) -> (r->a) -> (r->b)\n        = (r->a->b) -> (r->a) -> r -> b\n\ninstance Monad ((->) r) where\n    return x = \\_ -> x\n    h >>= f = \\w -> f (h w) w\n```\n\n2. [《JS 函数式编程指南》](https://github.com/MostlyAdequate/mostly-adequate-guide)：\n    1. [第 10 章: Applicative Functor](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html)\n    2. [第 10 章: Applicative Functor lift](https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#lift)\n\n3. stackoverflow: function as Functor/Applicative Functor/Monad：\n    1. [confused about function as instance of Functor in haskell](https://stackoverflow.com/questions/10294272/confused-about-function-as-instance-of-functor-in-haskell)\n    2. [functions as applicative functors (Haskell / LYAH)](https://stackoverflow.com/questions/11810889/functions-as-applicative-functors-haskell-lyah)\n    3. [Function as an Instance of Monad](https://stackoverflow.com/questions/13080014/function-as-an-instance-of-monad)\n\n4. [Functions as Functors](http://www.tomharding.me/2017/04/15/functions-as-functors/)\n\n","slug":"What-Function-Should-I-Use","published":1,"updated":"2020-06-06T14:44:04.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu7001ef6mj1dwsf4gc","content":"<p>Ramda API 已经快到 300 个了，对每个 API 按类型分别进行简介，当作 Ramda 的一份 CheatSheet 。</p>\n<h1>列表</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">列表转换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表过滤：过滤出符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表过滤：过滤掉符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reject\" target=\"_blank\" rel=\"noopener\">reject</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表折叠：从左向右对所有元素依次归约（折叠）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表折叠：从右向左对所有元素依次归约（折叠）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduceRight\" target=\"_blank\" rel=\"noopener\">reduceRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表折叠(增强版)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#transduce\" target=\"_blank\" rel=\"noopener\">transduce</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表去重</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uniq\" target=\"_blank\" rel=\"noopener\">uniq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表去重：对处理后的元素做相等性判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uniqBy\" target=\"_blank\" rel=\"noopener\">uniqBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表去重：通过断言函数（predicate）判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uniqWith\" target=\"_blank\" rel=\"noopener\">uniqWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表排序</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#sort\" target=\"_blank\" rel=\"noopener\">sort</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表翻转</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reverse\" target=\"_blank\" rel=\"noopener\">reverse</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表拼接</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#concat\" target=\"_blank\" rel=\"noopener\">concat</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表长度</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#length\" target=\"_blank\" rel=\"noopener\">length</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表表头拼接元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#prepend\" target=\"_blank\" rel=\"noopener\">prepend</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表表尾拼接元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#append\" target=\"_blank\" rel=\"noopener\">append</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新指定索引处的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#adjust\" target=\"_blank\" rel=\"noopener\">adjust</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">替换指定索引处的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#update\" target=\"_blank\" rel=\"noopener\">update</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将列表元素转换为其指定的属性值，等价于 R.map(R.prop)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pluck\" target=\"_blank\" rel=\"noopener\">pluck</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">为列表迭代函数添加两个参数：索引和整个列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#addIndex\" target=\"_blank\" rel=\"noopener\">addIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出特定索引范围内的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#slice\" target=\"_blank\" rel=\"noopener\">slice</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将列表通过分隔符拼接成字符串</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#join\" target=\"_blank\" rel=\"noopener\">join</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出第 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#nth\" target=\"_blank\" rel=\"noopener\">nth</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出前 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#take\" target=\"_blank\" rel=\"noopener\">take</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出后 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#takeLast\" target=\"_blank\" rel=\"noopener\">takeLast</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从前往后取出满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#takeWhile\" target=\"_blank\" rel=\"noopener\">takeWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从后向前取出满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#takeLastWhile\" target=\"_blank\" rel=\"noopener\">takeLastWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">删除前 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#drop\" target=\"_blank\" rel=\"noopener\">drop</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">删除后 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dropLast\" target=\"_blank\" rel=\"noopener\">dropLast</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从前往后删除满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dropWhile\" target=\"_blank\" rel=\"noopener\">dropWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从后向前删除满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dropLastWhile\" target=\"_blank\" rel=\"noopener\">dropLastWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出首个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#head\" target=\"_blank\" rel=\"noopener\">head</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出末尾元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#taillast\" target=\"_blank\" rel=\"noopener\">last</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出前 length - 1 个元素（删除末尾元素）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#init\" target=\"_blank\" rel=\"noopener\">init</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出后 length - 1 个元素（删除首个元素）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#tail\" target=\"_blank\" rel=\"noopener\">tail</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∈xs ∩ a∉ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∉xs ∩ a∈ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#without\" target=\"_blank\" rel=\"noopener\">without</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：根据条件计算第一个列表与第二个列表的差集</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifference\" target=\"_blank\" rel=\"noopener\">symmetricDifference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifferenceWith\" target=\"_blank\" rel=\"noopener\">symmetricDifferenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：{xs ∩ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#intersection\" target=\"_blank\" rel=\"noopener\">intersection</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#innerJoin\" target=\"_blank\" rel=\"noopener\">innerJoin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：{xs ∪ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#union\" target=\"_blank\" rel=\"noopener\">union</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：根据条件判断两元素是否重复</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unionWith\" target=\"_blank\" rel=\"noopener\">unionWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中首个满足条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#find\" target=\"_blank\" rel=\"noopener\">find</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中首个满足条件的元素的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#findIndex\" target=\"_blank\" rel=\"noopener\">findIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中最后一个满足条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#findLast\" target=\"_blank\" rel=\"noopener\">findLast</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中最后一个满足条件的元素的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#findLastIndex\" target=\"_blank\" rel=\"noopener\">findLastIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找给定元素在列表中首次出现时的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#indexOf\" target=\"_blank\" rel=\"noopener\">indexOf</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找给定元素在列表中末次出现时的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lastIndexOf\" target=\"_blank\" rel=\"noopener\">lastIndexOf</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断元素是否包含在列表中</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#contains\" target=\"_blank\" rel=\"noopener\">contains</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断是否列表中所有元素都满足条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#all\" target=\"_blank\" rel=\"noopener\">all</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断是否列表中所有元素都不满足条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#none\" target=\"_blank\" rel=\"noopener\">none</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断是否列表中存在满足条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#any\" target=\"_blank\" rel=\"noopener\">any</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断列表是否以给定的值开头</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#startsWith\" target=\"_blank\" rel=\"noopener\">startsWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断列表是否以给定的值结尾</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#endsWith\" target=\"_blank\" rel=\"noopener\">endsWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分组：按是否符合条件，将元素分为两组</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#partition\" target=\"_blank\" rel=\"noopener\">partition</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分组：对列表中元素按指定规则分组</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#groupBy\" target=\"_blank\" rel=\"noopener\">groupBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分段：对列表中元素按指定规则分段</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#groupWith\" target=\"_blank\" rel=\"noopener\">groupWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分组：对列表中元素按指定规则分组折叠</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduceBy\" target=\"_blank\" rel=\"noopener\">reduceBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分割：在指定索引处</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#splitAt\" target=\"_blank\" rel=\"noopener\">splitAt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分割：每隔 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#splitEvery\" target=\"_blank\" rel=\"noopener\">splitEvery</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分割：按条件分割</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#splitWhen\" target=\"_blank\" rel=\"noopener\">splitWhen</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对两个列表相同位置的元素进行组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#zip\" target=\"_blank\" rel=\"noopener\">zip</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对两个列表相同位置的元素进行键值对组合，fromPairs ∘ zip</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#zipObj\" target=\"_blank\" rel=\"noopener\">zipObj</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对两个列表相同位置的元素按规则进行组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#zipWith\" target=\"_blank\" rel=\"noopener\">zipWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">由一系列键值对列表创建对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#fromPairs\" target=\"_blank\" rel=\"noopener\">fromPairs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表彻底扁平化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#flatten\" target=\"_blank\" rel=\"noopener\">flatten</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表单层扁平化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unnest\" target=\"_blank\" rel=\"noopener\">unnest</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">先对列表内元素做 Kleisli 映射，再做扁平化，flatMap，&gt;&gt;=</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#chain\" target=\"_blank\" rel=\"noopener\">chain</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函子间的自然变化？</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#sequence\" target=\"_blank\" rel=\"noopener\">sequence</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表插入</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#insert\" target=\"_blank\" rel=\"noopener\">insert</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将子列表插入列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#insertAll\" target=\"_blank\" rel=\"noopener\">insertAll</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">在列表元素之间插入分割元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#intersperse\" target=\"_blank\" rel=\"noopener\">intersperse</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表转换 + 折叠？</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#into\" target=\"_blank\" rel=\"noopener\">into</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将 reduce 的迭代过程记录下来</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mapAccum\" target=\"_blank\" rel=\"noopener\">mapAccum</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将 reduceRight 的迭代过程记录下来</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mapAccumRight\" target=\"_blank\" rel=\"noopener\">mapAccumRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">合并多个对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeAll\" target=\"_blank\" rel=\"noopener\">mergeAll</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">由两个参数组成列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pair\" target=\"_blank\" rel=\"noopener\">pair</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从 reduce 或 transduce 中提前退出迭代时的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduced\" target=\"_blank\" rel=\"noopener\">reduced</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可以提前退出的 reduce 迭代</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduceWhile\" target=\"_blank\" rel=\"noopener\">reduceWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：生成左闭右开的升序数字列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#range\" target=\"_blank\" rel=\"noopener\">range</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：生成含有 N 个同一元素的列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#repeat\" target=\"_blank\" rel=\"noopener\">repeat</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：函数执行 N 次，生成 N 元列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#times\" target=\"_blank\" rel=\"noopener\">times</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：通过迭代函数生成列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unfold\" target=\"_blank\" rel=\"noopener\">unfold</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">二维列表行列式转换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#transpose\" target=\"_blank\" rel=\"noopener\">transpose</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">二维列表生成</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#xprod\" target=\"_blank\" rel=\"noopener\">xprod</a></td>\n</tr>\n</tbody>\n</table>\n<h1>函数</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">函数组合：纵向，从右往左</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#compose\" target=\"_blank\" rel=\"noopener\">compose</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：纵向，从左往右</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pipe\" target=\"_blank\" rel=\"noopener\">pipe</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：纵向</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#o\" target=\"_blank\" rel=\"noopener\">o</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：横向</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#converge\" target=\"_blank\" rel=\"noopener\">converge</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：横向</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#useWith\" target=\"_blank\" rel=\"noopener\">useWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Kleisili 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#composeK\" target=\"_blank\" rel=\"noopener\">composeK</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Kleisili 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pipeK\" target=\"_blank\" rel=\"noopener\">pipeK</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Promise 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#composeP\" target=\"_blank\" rel=\"noopener\">composeP</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Promise 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pipeP\" target=\"_blank\" rel=\"noopener\">pipeP</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">单位函数：输出等于输入</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#identity\" target=\"_blank\" rel=\"noopener\">identity</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数柯里化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#curry\" target=\"_blank\" rel=\"noopener\">curry</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">N 元函数柯里化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#curryN\" target=\"_blank\" rel=\"noopener\">curryN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将柯里化函数 转为 N 元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uncurryN\" target=\"_blank\" rel=\"noopener\">uncurryN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">柯里化函数的参数占位符</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#__\" target=\"_blank\" rel=\"noopener\">__</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数部分调用：从左往右</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#partial\" target=\"_blank\" rel=\"noopener\">partial</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数部分调用：从右往左</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#partialRight\" target=\"_blank\" rel=\"noopener\">partialRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数缓存</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#memoize\" target=\"_blank\" rel=\"noopener\">memoize</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数缓存：可以自定义缓存键值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#memoizeWith\" target=\"_blank\" rel=\"noopener\">memoizeWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">只执行一次的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#once\" target=\"_blank\" rel=\"noopener\">once</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">创建返回恒定值的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#always\" target=\"_blank\" rel=\"noopener\">always</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">恒定返回 <code>true</code> 的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#T\" target=\"_blank\" rel=\"noopener\">T</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">恒定返回 <code>false</code>  的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#F\" target=\"_blank\" rel=\"noopener\">F</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Applicative Functor 的 ap 方法，&lt;*&gt;</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#ap\" target=\"_blank\" rel=\"noopener\">ap</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数作用于参数列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#apply\" target=\"_blank\" rel=\"noopener\">apply</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将接受 <strong>单列表参数</strong> 的函数转为接受 <strong>普通参数列表</strong> 的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unapply\" target=\"_blank\" rel=\"noopener\">unapply</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将首个参数（函数）作用于其余参数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#call\" target=\"_blank\" rel=\"noopener\">call</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">绑定函数上下文</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#bind\" target=\"_blank\" rel=\"noopener\">bind</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">利用属性值为函数的对象生成同构对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#applySpec\" target=\"_blank\" rel=\"noopener\">applySpec</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数列表作用于参数列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#juxt\" target=\"_blank\" rel=\"noopener\">juxt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将给定值传给给定函数，CPS: flip($)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#applyTo\" target=\"_blank\" rel=\"noopener\">applyTo</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">比较函数，一般用于排序</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#comparator\" target=\"_blank\" rel=\"noopener\">comparator</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升序比较函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#ascend\" target=\"_blank\" rel=\"noopener\">ascend</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">降序比较函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#descend\" target=\"_blank\" rel=\"noopener\">descend</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数封装为 N 元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#nArg\" target=\"_blank\" rel=\"noopener\">nArg</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数封装为一元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unary\" target=\"_blank\" rel=\"noopener\">unary</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数封装为二元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#binary\" target=\"_blank\" rel=\"noopener\">binary</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取第 N 个参数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#nthArg\" target=\"_blank\" rel=\"noopener\">nthArg</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将构造函数封装为普通函数，创建实例时，不需要 new 操作符</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#construct\" target=\"_blank\" rel=\"noopener\">construct</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将构造函数封装为 N 元普通函数，创建实例时，不需要 new 操作符</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#constructN\" target=\"_blank\" rel=\"noopener\">constructN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过函数名调用函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#invoker\" target=\"_blank\" rel=\"noopener\">invoker</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">创建相应类型的空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#empty\" target=\"_blank\" rel=\"noopener\">empty</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否为空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isEmpty\" target=\"_blank\" rel=\"noopener\">isEmpty</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">交换函数前两个参数的位置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#flip\" target=\"_blank\" rel=\"noopener\">flip</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数提升</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lift\" target=\"_blank\" rel=\"noopener\">lift</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">N 元函数提升</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#liftN\" target=\"_blank\" rel=\"noopener\">liftN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">生成单元素列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#of\" target=\"_blank\" rel=\"noopener\">of</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">输出等于输入，但产生副作用的函数，一般用于调试</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#tap\" target=\"_blank\" rel=\"noopener\">tap</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">异常捕获</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#tryCatch\" target=\"_blank\" rel=\"noopener\">tryCatch</a></td>\n</tr>\n</tbody>\n</table>\n<h1>对象</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">属性设置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#assoc\" target=\"_blank\" rel=\"noopener\">assoc</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性按路径设置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#assocPath\" target=\"_blank\" rel=\"noopener\">assocPath</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性删除</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dissoc\" target=\"_blank\" rel=\"noopener\">dissoc</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性按路径删除</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#disscoPath\" target=\"_blank\" rel=\"noopener\">disscoPath</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#prop\" target=\"_blank\" rel=\"noopener\">prop</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取属性值，带有默认值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propOr\" target=\"_blank\" rel=\"noopener\">propOr</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取路径上的属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#path\" target=\"_blank\" rel=\"noopener\">path</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取路径上的属性值，带有默认值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pathOr\" target=\"_blank\" rel=\"noopener\">pathOr</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断属性是否满足给定的条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propSatisfies\" target=\"_blank\" rel=\"noopener\">propSatisfies</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断属性是否与给定值相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propEq\" target=\"_blank\" rel=\"noopener\">propEq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断两个对象指定的属性值是否相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#eqProps\" target=\"_blank\" rel=\"noopener\">eqProps</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断路径上的属性值是否满足给定的条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pathSatisfies\" target=\"_blank\" rel=\"noopener\">pathSatisfies</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断路径上的属性值是否与给定值相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pathEq\" target=\"_blank\" rel=\"noopener\">pathEq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取属性值组成的列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#props\" target=\"_blank\" rel=\"noopener\">props</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断属性是否为给定类型</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propIs\" target=\"_blank\" rel=\"noopener\">propIs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断多个属性是否同时满足给定的条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#where\" target=\"_blank\" rel=\"noopener\">where</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断多个属性是否等于给定对应属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#whereEq\" target=\"_blank\" rel=\"noopener\">whereEq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">删除多个属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#omit\" target=\"_blank\" rel=\"noopener\">omit</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取多个属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pick\" target=\"_blank\" rel=\"noopener\">pick</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取多个属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pickAll\" target=\"_blank\" rel=\"noopener\">pickAll</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对列表中元素提取多个属性，模拟 SQL 的 <code>select</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#project\" target=\"_blank\" rel=\"noopener\">project</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取键值满足条件的属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pickBy\" target=\"_blank\" rel=\"noopener\">pickBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对特定属性进行特定变换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#evolve\" target=\"_blank\" rel=\"noopener\">evolve</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否包含指定的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#has\" target=\"_blank\" rel=\"noopener\">has</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否包含指定的键：包括原型链上的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#hasIn\" target=\"_blank\" rel=\"noopener\">hasIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键值对换位</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#invertObj\" target=\"_blank\" rel=\"noopener\">invertObj</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键值对换位：将值放入数组中</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#invert\" target=\"_blank\" rel=\"noopener\">invert</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#keys\" target=\"_blank\" rel=\"noopener\">keys</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的键：包括原型链上的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#keysIn\" target=\"_blank\" rel=\"noopener\">keysIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#values\" target=\"_blank\" rel=\"noopener\">values</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的值：包括原型链上的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#valuesIn\" target=\"_blank\" rel=\"noopener\">valuesIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：包括属性的 getter 和 setter</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lens\" target=\"_blank\" rel=\"noopener\">lens</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：指定索引的透镜</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lensIndex\" target=\"_blank\" rel=\"noopener\">lensIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：指定路径的透镜</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lensPath\" target=\"_blank\" rel=\"noopener\">lensPath</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：指定属性的透镜</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lensProp\" target=\"_blank\" rel=\"noopener\">lensProp</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：对被 <code>lens</code> 聚焦的属性做变换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#over\" target=\"_blank\" rel=\"noopener\">over</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：对被 <code>lens</code> 聚焦的属性进行设置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#set\" target=\"_blank\" rel=\"noopener\">set</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：读取被 <code>lens</code> 聚焦的属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#view\" target=\"_blank\" rel=\"noopener\">view</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>Object</code> 版 <code>map</code>，转换函数参数：(value, key, obj)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mapObjIndexed\" target=\"_blank\" rel=\"noopener\">mapObjIndexed</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#merge\" target=\"_blank\" rel=\"noopener\">merge</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象合并：对重复的属性值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeWith\" target=\"_blank\" rel=\"noopener\">mergeWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象合并：对重复的属性值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeWithKey\" target=\"_blank\" rel=\"noopener\">mergeWithKey</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：以左侧对象属性为主</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepLeft\" target=\"_blank\" rel=\"noopener\">mergeDeepLeft</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：以右侧对象属性为主</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepRight\" target=\"_blank\" rel=\"noopener\">mergeDeepRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepWith\" target=\"_blank\" rel=\"noopener\">mergeDeepWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepWithKey\" target=\"_blank\" rel=\"noopener\">mergeDeepWithKey</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">创建包含单个键值对的对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#objOf\" target=\"_blank\" rel=\"noopener\">objOf</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将对象键值对转换为元素为键值二元组的列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#toPairs\" target=\"_blank\" rel=\"noopener\">toPairs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将对象键值对转换为元素为键值二元组的列表:包括原型链上的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#toPairsIn\" target=\"_blank\" rel=\"noopener\">toPairsIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将二元组的列表转换为对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#fromPairs\" target=\"_blank\" rel=\"noopener\">fromPairs</a></td>\n</tr>\n</tbody>\n</table>\n<h1>逻辑运算</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">判断是否满足所有条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#allPass\" target=\"_blank\" rel=\"noopener\">allPass</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否满足任一条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#anyPass\" target=\"_blank\" rel=\"noopener\">anyPass</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否同时满足两个条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#both\" target=\"_blank\" rel=\"noopener\">both</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否满足两个条件中的任意一个</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#either\" target=\"_blank\" rel=\"noopener\">either</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑与操作</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#and\" target=\"_blank\" rel=\"noopener\">and</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑或操作</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#or\" target=\"_blank\" rel=\"noopener\">or</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">模式匹配，相当于多个 <code>if/else</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">cond</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">单个 <code>if/else</code>，<code>cond</code> 的特例</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#ifElse\" target=\"_blank\" rel=\"noopener\">ifElse</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">满足条件，则执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#when\" target=\"_blank\" rel=\"noopener\">when</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不满足条件时，执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">unless</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑非操作，参数为布尔值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#not\" target=\"_blank\" rel=\"noopener\">not</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对函数返回值取反</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#complement\" target=\"_blank\" rel=\"noopener\">complement</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">添加默认值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#defaultTo\" target=\"_blank\" rel=\"noopener\">defaultTo</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一直计算，直到满足给定条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#until\" target=\"_blank\" rel=\"noopener\">until</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断给定值是否为该类型的空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isEmpty\" target=\"_blank\" rel=\"noopener\">isEmpty</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断给定值是否为 <code>null</code> 或 <code>undefined</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isNil\" target=\"_blank\" rel=\"noopener\">isNil</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">返回给定值所属类型的空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#empty\" target=\"_blank\" rel=\"noopener\">empty</a></td>\n</tr>\n</tbody>\n</table>\n<h1>关系运算</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">等于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#equals\" target=\"_blank\" rel=\"noopener\">equals</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">完全相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#identical\" target=\"_blank\" rel=\"noopener\">identical</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过规则判断是否相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#eqBy\" target=\"_blank\" rel=\"noopener\">eqBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">大于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#gt\" target=\"_blank\" rel=\"noopener\">gt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">大于等于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#gte\" target=\"_blank\" rel=\"noopener\">gte</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">小于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lt\" target=\"_blank\" rel=\"noopener\">lt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">小于等于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lte\" target=\"_blank\" rel=\"noopener\">lte</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">限定有序数据类型的范围</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#clamp\" target=\"_blank\" rel=\"noopener\">clamp</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求两个数的较大值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#max\" target=\"_blank\" rel=\"noopener\">max</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按规则求两个数的较大值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#maxBy\" target=\"_blank\" rel=\"noopener\">maxBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求两个数的较小值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#min\" target=\"_blank\" rel=\"noopener\">min</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按规则求两个数的较小值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#minBy\" target=\"_blank\" rel=\"noopener\">minBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∈xs ∩ a∉ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∉xs ∩ a∈ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#without\" target=\"_blank\" rel=\"noopener\">without</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：根据条件计算第一个列表与第二个列表的差集</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifference\" target=\"_blank\" rel=\"noopener\">symmetricDifference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifferenceWith\" target=\"_blank\" rel=\"noopener\">symmetricDifferenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：{xs ∩ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#intersection\" target=\"_blank\" rel=\"noopener\">intersection</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#innerJoin\" target=\"_blank\" rel=\"noopener\">innerJoin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：{xs ∪ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#union\" target=\"_blank\" rel=\"noopener\">union</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：根据条件判断两元素是否重复</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unionWith\" target=\"_blank\" rel=\"noopener\">unionWith</a></td>\n</tr>\n</tbody>\n</table>\n<h1>数学运算</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">加</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#add\" target=\"_blank\" rel=\"noopener\">add</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">减</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#subtract\" target=\"_blank\" rel=\"noopener\">subtract</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">乘</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#multiply\" target=\"_blank\" rel=\"noopener\">multiply</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">除</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#divide\" target=\"_blank\" rel=\"noopener\">divide</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">加1</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#inc\" target=\"_blank\" rel=\"noopener\">inc</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">减1</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dec\" target=\"_blank\" rel=\"noopener\">dec</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取反</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#negate\" target=\"_blank\" rel=\"noopener\">negate</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表累加和</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#sum\" target=\"_blank\" rel=\"noopener\">sum</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表累乘积</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#product\" target=\"_blank\" rel=\"noopener\">product</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表平均值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mean\" target=\"_blank\" rel=\"noopener\">mean</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表中位数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#median\" target=\"_blank\" rel=\"noopener\">median</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取模：算术</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mathMod\" target=\"_blank\" rel=\"noopener\">mathMod</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取模：JS</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#modulo\" target=\"_blank\" rel=\"noopener\">modulo</a></td>\n</tr>\n</tbody>\n</table>\n<h1>类型操作</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">类型判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#is\" target=\"_blank\" rel=\"noopener\">is</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类型描述</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#type\" target=\"_blank\" rel=\"noopener\">type</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性类型判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propIs\" target=\"_blank\" rel=\"noopener\">propIs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否为 <code>null</code> 或 <code>undefined</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isNil\" target=\"_blank\" rel=\"noopener\">isNil</a></td>\n</tr>\n</tbody>\n</table>\n<h1>参考资料</h1>\n<p>关于 <code>Applicative Functor</code>，及其操作符 <a href=\"%5Bap%5D(http://ramda.cn/docs/#ap)\">R.ap</a> (haskell 中的 <code>&lt;*&gt;</code>) 和 <a href=\"http://ramda.cn/docs/#lift\" target=\"_blank\" rel=\"noopener\">lift</a> (haskell 中的 <code>&lt;$&gt;</code>) 的论述可参考下列资料：</p>\n<ol>\n<li>《Learn You A Haskell For Great Good》的 <a href=\"http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors\" target=\"_blank\" rel=\"noopener\">Applicative 章节</a>，函数 <code>(-&gt;) r</code> 也是 Applicative，需要深入理解。</li>\n</ol>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Function</span> :: ((-&gt;) r)</span><br><span class=\"line\"><span class=\"type\">Function</span> a = ((-&gt;) r) a </span><br><span class=\"line\">           = r -&gt; a</span><br><span class=\"line\"></span><br><span class=\"line\">;; <span class=\"type\">Functor</span>、<span class=\"type\">Applicative</span>、<span class=\"type\">Monad</span> 的类定义</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">Functor</span> f <span class=\"keyword\">where</span></span>  </span><br><span class=\"line\">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> (<span class=\"type\">Functor</span> <span class=\"title\">f</span>) =&gt; <span class=\"type\">Applicative</span> f <span class=\"keyword\">where</span></span>  </span><br><span class=\"line\">    pure :: a -&gt; f a  </span><br><span class=\"line\">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">Monad</span> m <span class=\"keyword\">where</span></span>  </span><br><span class=\"line\">    return :: a -&gt; m a  </span><br><span class=\"line\">  </span><br><span class=\"line\">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  </span><br><span class=\"line\">  </span><br><span class=\"line\">    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  </span><br><span class=\"line\">    x &gt;&gt; y = x &gt;&gt;= \\_ -&gt; y  </span><br><span class=\"line\">  </span><br><span class=\"line\">    fail :: <span class=\"type\">String</span> -&gt; m a  </span><br><span class=\"line\">    fail msg = error msg  </span><br><span class=\"line\"></span><br><span class=\"line\">;; 作为<span class=\"type\">Functor</span>、<span class=\"type\">Applicative</span>、<span class=\"type\">Monad</span> 的实例的 <span class=\"type\">Function</span> 的定义，可以对比上面的类定义查看</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Functor</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    fmap = (.)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">fmap</span> :: (a -&gt; b) -&gt; (c -&gt; a) -&gt; (c -&gt; b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">f</span> :: a -&gt; b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">g</span> :: c -&gt; a</span><br><span class=\"line\"><span class=\"title\">h</span> :: c -&gt; b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">const</span> h = fmap(f, g) = map(f, g) = compose(f, g)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    pure x = (\\_ -&gt; x)</span><br><span class=\"line\">    f &lt;*&gt; g = \\x -&gt; f x (g x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">f</span> &lt;*&gt; g = (r-&gt;(a-&gt;b)) -&gt; (r-&gt;a) -&gt; (r-&gt;b)</span><br><span class=\"line\">        = (r-&gt;a-&gt;b) -&gt; (r-&gt;a) -&gt; r -&gt; b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Monad</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    return x = \\_ -&gt; x</span><br><span class=\"line\">    h &gt;&gt;= f = \\w -&gt; f (h w) w</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>\n<p><a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide\" target=\"_blank\" rel=\"noopener\">《JS 函数式编程指南》</a>：</p>\n<ol>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html\" target=\"_blank\" rel=\"noopener\">第 10 章: Applicative Functor</a></li>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#lift\" target=\"_blank\" rel=\"noopener\">第 10 章: Applicative Functor lift</a></li>\n</ol>\n</li>\n<li>\n<p>stackoverflow: function as Functor/Applicative Functor/Monad：</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/10294272/confused-about-function-as-instance-of-functor-in-haskell\" target=\"_blank\" rel=\"noopener\">confused about function as instance of Functor in haskell</a></li>\n<li><a href=\"https://stackoverflow.com/questions/11810889/functions-as-applicative-functors-haskell-lyah\" target=\"_blank\" rel=\"noopener\">functions as applicative functors (Haskell / LYAH)</a></li>\n<li><a href=\"https://stackoverflow.com/questions/13080014/function-as-an-instance-of-monad\" target=\"_blank\" rel=\"noopener\">Function as an Instance of Monad</a></li>\n</ol>\n</li>\n<li>\n<p><a href=\"http://www.tomharding.me/2017/04/15/functions-as-functors/\" target=\"_blank\" rel=\"noopener\">Functions as Functors</a></p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>Ramda API 已经快到 300 个了，对每个 API 按类型分别进行简介，当作 Ramda 的一份 CheatSheet 。</p>\n<h1>列表</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">列表转换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#map\" target=\"_blank\" rel=\"noopener\">map</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表过滤：过滤出符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#filter\" target=\"_blank\" rel=\"noopener\">filter</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表过滤：过滤掉符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reject\" target=\"_blank\" rel=\"noopener\">reject</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表折叠：从左向右对所有元素依次归约（折叠）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduce\" target=\"_blank\" rel=\"noopener\">reduce</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表折叠：从右向左对所有元素依次归约（折叠）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduceRight\" target=\"_blank\" rel=\"noopener\">reduceRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表折叠(增强版)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#transduce\" target=\"_blank\" rel=\"noopener\">transduce</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表去重</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uniq\" target=\"_blank\" rel=\"noopener\">uniq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表去重：对处理后的元素做相等性判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uniqBy\" target=\"_blank\" rel=\"noopener\">uniqBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表去重：通过断言函数（predicate）判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uniqWith\" target=\"_blank\" rel=\"noopener\">uniqWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表排序</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#sort\" target=\"_blank\" rel=\"noopener\">sort</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表翻转</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reverse\" target=\"_blank\" rel=\"noopener\">reverse</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表拼接</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#concat\" target=\"_blank\" rel=\"noopener\">concat</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表长度</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#length\" target=\"_blank\" rel=\"noopener\">length</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表表头拼接元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#prepend\" target=\"_blank\" rel=\"noopener\">prepend</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表表尾拼接元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#append\" target=\"_blank\" rel=\"noopener\">append</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">更新指定索引处的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#adjust\" target=\"_blank\" rel=\"noopener\">adjust</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">替换指定索引处的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#update\" target=\"_blank\" rel=\"noopener\">update</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将列表元素转换为其指定的属性值，等价于 R.map(R.prop)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pluck\" target=\"_blank\" rel=\"noopener\">pluck</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">为列表迭代函数添加两个参数：索引和整个列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#addIndex\" target=\"_blank\" rel=\"noopener\">addIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出特定索引范围内的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#slice\" target=\"_blank\" rel=\"noopener\">slice</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将列表通过分隔符拼接成字符串</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#join\" target=\"_blank\" rel=\"noopener\">join</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出第 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#nth\" target=\"_blank\" rel=\"noopener\">nth</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出前 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#take\" target=\"_blank\" rel=\"noopener\">take</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出后 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#takeLast\" target=\"_blank\" rel=\"noopener\">takeLast</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从前往后取出满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#takeWhile\" target=\"_blank\" rel=\"noopener\">takeWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从后向前取出满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#takeLastWhile\" target=\"_blank\" rel=\"noopener\">takeLastWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">删除前 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#drop\" target=\"_blank\" rel=\"noopener\">drop</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">删除后 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dropLast\" target=\"_blank\" rel=\"noopener\">dropLast</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从前往后删除满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dropWhile\" target=\"_blank\" rel=\"noopener\">dropWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从后向前删除满足条件的元素，直至不满足条件的首个元素止</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dropLastWhile\" target=\"_blank\" rel=\"noopener\">dropLastWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出首个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#head\" target=\"_blank\" rel=\"noopener\">head</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出末尾元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#taillast\" target=\"_blank\" rel=\"noopener\">last</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出前 length - 1 个元素（删除末尾元素）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#init\" target=\"_blank\" rel=\"noopener\">init</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出后 length - 1 个元素（删除首个元素）</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#tail\" target=\"_blank\" rel=\"noopener\">tail</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∈xs ∩ a∉ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∉xs ∩ a∈ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#without\" target=\"_blank\" rel=\"noopener\">without</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：根据条件计算第一个列表与第二个列表的差集</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifference\" target=\"_blank\" rel=\"noopener\">symmetricDifference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifferenceWith\" target=\"_blank\" rel=\"noopener\">symmetricDifferenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：{xs ∩ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#intersection\" target=\"_blank\" rel=\"noopener\">intersection</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#innerJoin\" target=\"_blank\" rel=\"noopener\">innerJoin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：{xs ∪ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#union\" target=\"_blank\" rel=\"noopener\">union</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：根据条件判断两元素是否重复</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unionWith\" target=\"_blank\" rel=\"noopener\">unionWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中首个满足条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#find\" target=\"_blank\" rel=\"noopener\">find</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中首个满足条件的元素的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#findIndex\" target=\"_blank\" rel=\"noopener\">findIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中最后一个满足条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#findLast\" target=\"_blank\" rel=\"noopener\">findLast</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找列表中最后一个满足条件的元素的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#findLastIndex\" target=\"_blank\" rel=\"noopener\">findLastIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找给定元素在列表中首次出现时的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#indexOf\" target=\"_blank\" rel=\"noopener\">indexOf</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">查找给定元素在列表中末次出现时的索引</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lastIndexOf\" target=\"_blank\" rel=\"noopener\">lastIndexOf</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断元素是否包含在列表中</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#contains\" target=\"_blank\" rel=\"noopener\">contains</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断是否列表中所有元素都满足条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#all\" target=\"_blank\" rel=\"noopener\">all</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断是否列表中所有元素都不满足条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#none\" target=\"_blank\" rel=\"noopener\">none</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断是否列表中存在满足条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#any\" target=\"_blank\" rel=\"noopener\">any</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断列表是否以给定的值开头</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#startsWith\" target=\"_blank\" rel=\"noopener\">startsWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表判断：判断列表是否以给定的值结尾</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#endsWith\" target=\"_blank\" rel=\"noopener\">endsWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分组：按是否符合条件，将元素分为两组</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#partition\" target=\"_blank\" rel=\"noopener\">partition</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分组：对列表中元素按指定规则分组</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#groupBy\" target=\"_blank\" rel=\"noopener\">groupBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分段：对列表中元素按指定规则分段</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#groupWith\" target=\"_blank\" rel=\"noopener\">groupWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分组：对列表中元素按指定规则分组折叠</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduceBy\" target=\"_blank\" rel=\"noopener\">reduceBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分割：在指定索引处</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#splitAt\" target=\"_blank\" rel=\"noopener\">splitAt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分割：每隔 N 个元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#splitEvery\" target=\"_blank\" rel=\"noopener\">splitEvery</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表分割：按条件分割</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#splitWhen\" target=\"_blank\" rel=\"noopener\">splitWhen</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对两个列表相同位置的元素进行组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#zip\" target=\"_blank\" rel=\"noopener\">zip</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对两个列表相同位置的元素进行键值对组合，fromPairs ∘ zip</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#zipObj\" target=\"_blank\" rel=\"noopener\">zipObj</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对两个列表相同位置的元素按规则进行组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#zipWith\" target=\"_blank\" rel=\"noopener\">zipWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">由一系列键值对列表创建对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#fromPairs\" target=\"_blank\" rel=\"noopener\">fromPairs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表彻底扁平化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#flatten\" target=\"_blank\" rel=\"noopener\">flatten</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表单层扁平化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unnest\" target=\"_blank\" rel=\"noopener\">unnest</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">先对列表内元素做 Kleisli 映射，再做扁平化，flatMap，&gt;&gt;=</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#chain\" target=\"_blank\" rel=\"noopener\">chain</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函子间的自然变化？</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#sequence\" target=\"_blank\" rel=\"noopener\">sequence</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表插入</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#insert\" target=\"_blank\" rel=\"noopener\">insert</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将子列表插入列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#insertAll\" target=\"_blank\" rel=\"noopener\">insertAll</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">在列表元素之间插入分割元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#intersperse\" target=\"_blank\" rel=\"noopener\">intersperse</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表转换 + 折叠？</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#into\" target=\"_blank\" rel=\"noopener\">into</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将 reduce 的迭代过程记录下来</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mapAccum\" target=\"_blank\" rel=\"noopener\">mapAccum</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将 reduceRight 的迭代过程记录下来</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mapAccumRight\" target=\"_blank\" rel=\"noopener\">mapAccumRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">合并多个对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeAll\" target=\"_blank\" rel=\"noopener\">mergeAll</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">由两个参数组成列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pair\" target=\"_blank\" rel=\"noopener\">pair</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">从 reduce 或 transduce 中提前退出迭代时的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduced\" target=\"_blank\" rel=\"noopener\">reduced</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">可以提前退出的 reduce 迭代</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#reduceWhile\" target=\"_blank\" rel=\"noopener\">reduceWhile</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：生成左闭右开的升序数字列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#range\" target=\"_blank\" rel=\"noopener\">range</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：生成含有 N 个同一元素的列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#repeat\" target=\"_blank\" rel=\"noopener\">repeat</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：函数执行 N 次，生成 N 元列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#times\" target=\"_blank\" rel=\"noopener\">times</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表生成：通过迭代函数生成列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unfold\" target=\"_blank\" rel=\"noopener\">unfold</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">二维列表行列式转换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#transpose\" target=\"_blank\" rel=\"noopener\">transpose</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">二维列表生成</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#xprod\" target=\"_blank\" rel=\"noopener\">xprod</a></td>\n</tr>\n</tbody>\n</table>\n<h1>函数</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">函数组合：纵向，从右往左</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#compose\" target=\"_blank\" rel=\"noopener\">compose</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：纵向，从左往右</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pipe\" target=\"_blank\" rel=\"noopener\">pipe</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：纵向</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#o\" target=\"_blank\" rel=\"noopener\">o</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：横向</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#converge\" target=\"_blank\" rel=\"noopener\">converge</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数组合：横向</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#useWith\" target=\"_blank\" rel=\"noopener\">useWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Kleisili 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#composeK\" target=\"_blank\" rel=\"noopener\">composeK</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Kleisili 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pipeK\" target=\"_blank\" rel=\"noopener\">pipeK</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Promise 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#composeP\" target=\"_blank\" rel=\"noopener\">composeP</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Promise 函数组合</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pipeP\" target=\"_blank\" rel=\"noopener\">pipeP</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">单位函数：输出等于输入</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#identity\" target=\"_blank\" rel=\"noopener\">identity</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数柯里化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#curry\" target=\"_blank\" rel=\"noopener\">curry</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">N 元函数柯里化</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#curryN\" target=\"_blank\" rel=\"noopener\">curryN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将柯里化函数 转为 N 元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#uncurryN\" target=\"_blank\" rel=\"noopener\">uncurryN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">柯里化函数的参数占位符</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#__\" target=\"_blank\" rel=\"noopener\">__</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数部分调用：从左往右</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#partial\" target=\"_blank\" rel=\"noopener\">partial</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">参数部分调用：从右往左</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#partialRight\" target=\"_blank\" rel=\"noopener\">partialRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数缓存</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#memoize\" target=\"_blank\" rel=\"noopener\">memoize</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数缓存：可以自定义缓存键值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#memoizeWith\" target=\"_blank\" rel=\"noopener\">memoizeWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">只执行一次的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#once\" target=\"_blank\" rel=\"noopener\">once</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">创建返回恒定值的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#always\" target=\"_blank\" rel=\"noopener\">always</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">恒定返回 <code>true</code> 的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#T\" target=\"_blank\" rel=\"noopener\">T</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">恒定返回 <code>false</code>  的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#F\" target=\"_blank\" rel=\"noopener\">F</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">Applicative Functor 的 ap 方法，&lt;*&gt;</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#ap\" target=\"_blank\" rel=\"noopener\">ap</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数作用于参数列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#apply\" target=\"_blank\" rel=\"noopener\">apply</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将接受 <strong>单列表参数</strong> 的函数转为接受 <strong>普通参数列表</strong> 的函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unapply\" target=\"_blank\" rel=\"noopener\">unapply</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将首个参数（函数）作用于其余参数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#call\" target=\"_blank\" rel=\"noopener\">call</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">绑定函数上下文</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#bind\" target=\"_blank\" rel=\"noopener\">bind</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">利用属性值为函数的对象生成同构对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#applySpec\" target=\"_blank\" rel=\"noopener\">applySpec</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数列表作用于参数列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#juxt\" target=\"_blank\" rel=\"noopener\">juxt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将给定值传给给定函数，CPS: flip($)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#applyTo\" target=\"_blank\" rel=\"noopener\">applyTo</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">比较函数，一般用于排序</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#comparator\" target=\"_blank\" rel=\"noopener\">comparator</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">升序比较函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#ascend\" target=\"_blank\" rel=\"noopener\">ascend</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">降序比较函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#descend\" target=\"_blank\" rel=\"noopener\">descend</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数封装为 N 元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#nArg\" target=\"_blank\" rel=\"noopener\">nArg</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数封装为一元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unary\" target=\"_blank\" rel=\"noopener\">unary</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将函数封装为二元函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#binary\" target=\"_blank\" rel=\"noopener\">binary</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取第 N 个参数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#nthArg\" target=\"_blank\" rel=\"noopener\">nthArg</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将构造函数封装为普通函数，创建实例时，不需要 new 操作符</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#construct\" target=\"_blank\" rel=\"noopener\">construct</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将构造函数封装为 N 元普通函数，创建实例时，不需要 new 操作符</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#constructN\" target=\"_blank\" rel=\"noopener\">constructN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过函数名调用函数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#invoker\" target=\"_blank\" rel=\"noopener\">invoker</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">创建相应类型的空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#empty\" target=\"_blank\" rel=\"noopener\">empty</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否为空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isEmpty\" target=\"_blank\" rel=\"noopener\">isEmpty</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">交换函数前两个参数的位置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#flip\" target=\"_blank\" rel=\"noopener\">flip</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">函数提升</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lift\" target=\"_blank\" rel=\"noopener\">lift</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">N 元函数提升</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#liftN\" target=\"_blank\" rel=\"noopener\">liftN</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">生成单元素列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#of\" target=\"_blank\" rel=\"noopener\">of</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">输出等于输入，但产生副作用的函数，一般用于调试</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#tap\" target=\"_blank\" rel=\"noopener\">tap</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">异常捕获</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#tryCatch\" target=\"_blank\" rel=\"noopener\">tryCatch</a></td>\n</tr>\n</tbody>\n</table>\n<h1>对象</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">属性设置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#assoc\" target=\"_blank\" rel=\"noopener\">assoc</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性按路径设置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#assocPath\" target=\"_blank\" rel=\"noopener\">assocPath</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性删除</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dissoc\" target=\"_blank\" rel=\"noopener\">dissoc</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性按路径删除</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#disscoPath\" target=\"_blank\" rel=\"noopener\">disscoPath</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#prop\" target=\"_blank\" rel=\"noopener\">prop</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取属性值，带有默认值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propOr\" target=\"_blank\" rel=\"noopener\">propOr</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取路径上的属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#path\" target=\"_blank\" rel=\"noopener\">path</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取路径上的属性值，带有默认值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pathOr\" target=\"_blank\" rel=\"noopener\">pathOr</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断属性是否满足给定的条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propSatisfies\" target=\"_blank\" rel=\"noopener\">propSatisfies</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断属性是否与给定值相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propEq\" target=\"_blank\" rel=\"noopener\">propEq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断两个对象指定的属性值是否相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#eqProps\" target=\"_blank\" rel=\"noopener\">eqProps</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断路径上的属性值是否满足给定的条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pathSatisfies\" target=\"_blank\" rel=\"noopener\">pathSatisfies</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断路径上的属性值是否与给定值相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pathEq\" target=\"_blank\" rel=\"noopener\">pathEq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">获取属性值组成的列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#props\" target=\"_blank\" rel=\"noopener\">props</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断属性是否为给定类型</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propIs\" target=\"_blank\" rel=\"noopener\">propIs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断多个属性是否同时满足给定的条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#where\" target=\"_blank\" rel=\"noopener\">where</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断多个属性是否等于给定对应属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#whereEq\" target=\"_blank\" rel=\"noopener\">whereEq</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">删除多个属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#omit\" target=\"_blank\" rel=\"noopener\">omit</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取多个属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pick\" target=\"_blank\" rel=\"noopener\">pick</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取多个属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pickAll\" target=\"_blank\" rel=\"noopener\">pickAll</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对列表中元素提取多个属性，模拟 SQL 的 <code>select</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#project\" target=\"_blank\" rel=\"noopener\">project</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">提取键值满足条件的属性</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#pickBy\" target=\"_blank\" rel=\"noopener\">pickBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对特定属性进行特定变换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#evolve\" target=\"_blank\" rel=\"noopener\">evolve</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否包含指定的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#has\" target=\"_blank\" rel=\"noopener\">has</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">是否包含指定的键：包括原型链上的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#hasIn\" target=\"_blank\" rel=\"noopener\">hasIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键值对换位</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#invertObj\" target=\"_blank\" rel=\"noopener\">invertObj</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">键值对换位：将值放入数组中</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#invert\" target=\"_blank\" rel=\"noopener\">invert</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#keys\" target=\"_blank\" rel=\"noopener\">keys</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的键：包括原型链上的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#keysIn\" target=\"_blank\" rel=\"noopener\">keysIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#values\" target=\"_blank\" rel=\"noopener\">values</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取出所有的值：包括原型链上的值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#valuesIn\" target=\"_blank\" rel=\"noopener\">valuesIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：包括属性的 getter 和 setter</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lens\" target=\"_blank\" rel=\"noopener\">lens</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：指定索引的透镜</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lensIndex\" target=\"_blank\" rel=\"noopener\">lensIndex</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：指定路径的透镜</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lensPath\" target=\"_blank\" rel=\"noopener\">lensPath</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：指定属性的透镜</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lensProp\" target=\"_blank\" rel=\"noopener\">lensProp</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：对被 <code>lens</code> 聚焦的属性做变换</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#over\" target=\"_blank\" rel=\"noopener\">over</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：对被 <code>lens</code> 聚焦的属性进行设置</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#set\" target=\"_blank\" rel=\"noopener\">set</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">透镜：读取被 <code>lens</code> 聚焦的属性值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#view\" target=\"_blank\" rel=\"noopener\">view</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><code>Object</code> 版 <code>map</code>，转换函数参数：(value, key, obj)</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mapObjIndexed\" target=\"_blank\" rel=\"noopener\">mapObjIndexed</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#merge\" target=\"_blank\" rel=\"noopener\">merge</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象合并：对重复的属性值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeWith\" target=\"_blank\" rel=\"noopener\">mergeWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象合并：对重复的属性值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeWithKey\" target=\"_blank\" rel=\"noopener\">mergeWithKey</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：以左侧对象属性为主</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepLeft\" target=\"_blank\" rel=\"noopener\">mergeDeepLeft</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：以右侧对象属性为主</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepRight\" target=\"_blank\" rel=\"noopener\">mergeDeepRight</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepWith\" target=\"_blank\" rel=\"noopener\">mergeDeepWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mergeDeepWithKey\" target=\"_blank\" rel=\"noopener\">mergeDeepWithKey</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">创建包含单个键值对的对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#objOf\" target=\"_blank\" rel=\"noopener\">objOf</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将对象键值对转换为元素为键值二元组的列表</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#toPairs\" target=\"_blank\" rel=\"noopener\">toPairs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将对象键值对转换为元素为键值二元组的列表:包括原型链上的键</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#toPairsIn\" target=\"_blank\" rel=\"noopener\">toPairsIn</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">将二元组的列表转换为对象</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#fromPairs\" target=\"_blank\" rel=\"noopener\">fromPairs</a></td>\n</tr>\n</tbody>\n</table>\n<h1>逻辑运算</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">判断是否满足所有条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#allPass\" target=\"_blank\" rel=\"noopener\">allPass</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否满足任一条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#anyPass\" target=\"_blank\" rel=\"noopener\">anyPass</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否同时满足两个条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#both\" target=\"_blank\" rel=\"noopener\">both</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否满足两个条件中的任意一个</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#either\" target=\"_blank\" rel=\"noopener\">either</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑与操作</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#and\" target=\"_blank\" rel=\"noopener\">and</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑或操作</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#or\" target=\"_blank\" rel=\"noopener\">or</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">模式匹配，相当于多个 <code>if/else</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#cond\" target=\"_blank\" rel=\"noopener\">cond</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">单个 <code>if/else</code>，<code>cond</code> 的特例</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#ifElse\" target=\"_blank\" rel=\"noopener\">ifElse</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">满足条件，则执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#when\" target=\"_blank\" rel=\"noopener\">when</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">不满足条件时，执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unless\" target=\"_blank\" rel=\"noopener\">unless</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">逻辑非操作，参数为布尔值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#not\" target=\"_blank\" rel=\"noopener\">not</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">对函数返回值取反</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#complement\" target=\"_blank\" rel=\"noopener\">complement</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">添加默认值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#defaultTo\" target=\"_blank\" rel=\"noopener\">defaultTo</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">一直计算，直到满足给定条件</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#until\" target=\"_blank\" rel=\"noopener\">until</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断给定值是否为该类型的空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isEmpty\" target=\"_blank\" rel=\"noopener\">isEmpty</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断给定值是否为 <code>null</code> 或 <code>undefined</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isNil\" target=\"_blank\" rel=\"noopener\">isNil</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">返回给定值所属类型的空值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#empty\" target=\"_blank\" rel=\"noopener\">empty</a></td>\n</tr>\n</tbody>\n</table>\n<h1>关系运算</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">等于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#equals\" target=\"_blank\" rel=\"noopener\">equals</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">完全相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#identical\" target=\"_blank\" rel=\"noopener\">identical</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">通过规则判断是否相等</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#eqBy\" target=\"_blank\" rel=\"noopener\">eqBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">大于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#gt\" target=\"_blank\" rel=\"noopener\">gt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">大于等于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#gte\" target=\"_blank\" rel=\"noopener\">gte</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">小于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lt\" target=\"_blank\" rel=\"noopener\">lt</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">小于等于</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#lte\" target=\"_blank\" rel=\"noopener\">lte</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">限定有序数据类型的范围</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#clamp\" target=\"_blank\" rel=\"noopener\">clamp</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求两个数的较大值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#max\" target=\"_blank\" rel=\"noopener\">max</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按规则求两个数的较大值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#maxBy\" target=\"_blank\" rel=\"noopener\">maxBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求两个数的较小值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#min\" target=\"_blank\" rel=\"noopener\">min</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">按规则求两个数的较小值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#minBy\" target=\"_blank\" rel=\"noopener\">minBy</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∈xs ∩ a∉ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#difference\" target=\"_blank\" rel=\"noopener\">difference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：{a∣a∉xs ∩ a∈ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#without\" target=\"_blank\" rel=\"noopener\">without</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求差集：根据条件计算第一个列表与第二个列表的差集</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#differenceWith\" target=\"_blank\" rel=\"noopener\">differenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifference\" target=\"_blank\" rel=\"noopener\">symmetricDifference</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#symmetricDifferenceWith\" target=\"_blank\" rel=\"noopener\">symmetricDifferenceWith</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：{xs ∩ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#intersection\" target=\"_blank\" rel=\"noopener\">intersection</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#innerJoin\" target=\"_blank\" rel=\"noopener\">innerJoin</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：{xs ∪ ys}</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#union\" target=\"_blank\" rel=\"noopener\">union</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">求并集：根据条件判断两元素是否重复</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#unionWith\" target=\"_blank\" rel=\"noopener\">unionWith</a></td>\n</tr>\n</tbody>\n</table>\n<h1>数学运算</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">加</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#add\" target=\"_blank\" rel=\"noopener\">add</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">减</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#subtract\" target=\"_blank\" rel=\"noopener\">subtract</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">乘</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#multiply\" target=\"_blank\" rel=\"noopener\">multiply</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">除</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#divide\" target=\"_blank\" rel=\"noopener\">divide</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">加1</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#inc\" target=\"_blank\" rel=\"noopener\">inc</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">减1</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#dec\" target=\"_blank\" rel=\"noopener\">dec</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取反</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#negate\" target=\"_blank\" rel=\"noopener\">negate</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表累加和</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#sum\" target=\"_blank\" rel=\"noopener\">sum</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表累乘积</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#product\" target=\"_blank\" rel=\"noopener\">product</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表平均值</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mean\" target=\"_blank\" rel=\"noopener\">mean</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">列表中位数</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#median\" target=\"_blank\" rel=\"noopener\">median</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取模：算术</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#mathMod\" target=\"_blank\" rel=\"noopener\">mathMod</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">取模：JS</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#modulo\" target=\"_blank\" rel=\"noopener\">modulo</a></td>\n</tr>\n</tbody>\n</table>\n<h1>类型操作</h1>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">Action</th>\n<th style=\"text-align:left\">Function</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">类型判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#is\" target=\"_blank\" rel=\"noopener\">is</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类型描述</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#type\" target=\"_blank\" rel=\"noopener\">type</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">属性类型判断</td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#propIs\" target=\"_blank\" rel=\"noopener\">propIs</a></td>\n</tr>\n<tr>\n<td style=\"text-align:left\">判断是否为 <code>null</code> 或 <code>undefined</code></td>\n<td style=\"text-align:left\"><a href=\"http://ramda.cn/docs/#isNil\" target=\"_blank\" rel=\"noopener\">isNil</a></td>\n</tr>\n</tbody>\n</table>\n<h1>参考资料</h1>\n<p>关于 <code>Applicative Functor</code>，及其操作符 <a href=\"%5Bap%5D(http://ramda.cn/docs/#ap)\">R.ap</a> (haskell 中的 <code>&lt;*&gt;</code>) 和 <a href=\"http://ramda.cn/docs/#lift\" target=\"_blank\" rel=\"noopener\">lift</a> (haskell 中的 <code>&lt;$&gt;</code>) 的论述可参考下列资料：</p>\n<ol>\n<li>《Learn You A Haskell For Great Good》的 <a href=\"http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors\" target=\"_blank\" rel=\"noopener\">Applicative 章节</a>，函数 <code>(-&gt;) r</code> 也是 Applicative，需要深入理解。</li>\n</ol>\n<p><figure class=\"highlight haskell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Function</span> :: ((-&gt;) r)</span><br><span class=\"line\"><span class=\"type\">Function</span> a = ((-&gt;) r) a </span><br><span class=\"line\">           = r -&gt; a</span><br><span class=\"line\"></span><br><span class=\"line\">;; <span class=\"type\">Functor</span>、<span class=\"type\">Applicative</span>、<span class=\"type\">Monad</span> 的类定义</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">Functor</span> f <span class=\"keyword\">where</span></span>  </span><br><span class=\"line\">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> (<span class=\"type\">Functor</span> <span class=\"title\">f</span>) =&gt; <span class=\"type\">Applicative</span> f <span class=\"keyword\">where</span></span>  </span><br><span class=\"line\">    pure :: a -&gt; f a  </span><br><span class=\"line\">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"type\">Monad</span> m <span class=\"keyword\">where</span></span>  </span><br><span class=\"line\">    return :: a -&gt; m a  </span><br><span class=\"line\">  </span><br><span class=\"line\">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  </span><br><span class=\"line\">  </span><br><span class=\"line\">    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  </span><br><span class=\"line\">    x &gt;&gt; y = x &gt;&gt;= \\_ -&gt; y  </span><br><span class=\"line\">  </span><br><span class=\"line\">    fail :: <span class=\"type\">String</span> -&gt; m a  </span><br><span class=\"line\">    fail msg = error msg  </span><br><span class=\"line\"></span><br><span class=\"line\">;; 作为<span class=\"type\">Functor</span>、<span class=\"type\">Applicative</span>、<span class=\"type\">Monad</span> 的实例的 <span class=\"type\">Function</span> 的定义，可以对比上面的类定义查看</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Functor</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    fmap = (.)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">fmap</span> :: (a -&gt; b) -&gt; (c -&gt; a) -&gt; (c -&gt; b)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">f</span> :: a -&gt; b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">g</span> :: c -&gt; a</span><br><span class=\"line\"><span class=\"title\">h</span> :: c -&gt; b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">const</span> h = fmap(f, g) = map(f, g) = compose(f, g)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Applicative</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    pure x = (\\_ -&gt; x)</span><br><span class=\"line\">    f &lt;*&gt; g = \\x -&gt; f x (g x)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title\">f</span> &lt;*&gt; g = (r-&gt;(a-&gt;b)) -&gt; (r-&gt;a) -&gt; (r-&gt;b)</span><br><span class=\"line\">        = (r-&gt;a-&gt;b) -&gt; (r-&gt;a) -&gt; r -&gt; b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">instance</span> <span class=\"type\">Monad</span> ((-&gt;) r) <span class=\"keyword\">where</span></span></span><br><span class=\"line\">    return x = \\_ -&gt; x</span><br><span class=\"line\">    h &gt;&gt;= f = \\w -&gt; f (h w) w</span><br></pre></td></tr></table></figure></p>\n<ol start=\"2\">\n<li>\n<p><a href=\"https://github.com/MostlyAdequate/mostly-adequate-guide\" target=\"_blank\" rel=\"noopener\">《JS 函数式编程指南》</a>：</p>\n<ol>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html\" target=\"_blank\" rel=\"noopener\">第 10 章: Applicative Functor</a></li>\n<li><a href=\"https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#lift\" target=\"_blank\" rel=\"noopener\">第 10 章: Applicative Functor lift</a></li>\n</ol>\n</li>\n<li>\n<p>stackoverflow: function as Functor/Applicative Functor/Monad：</p>\n<ol>\n<li><a href=\"https://stackoverflow.com/questions/10294272/confused-about-function-as-instance-of-functor-in-haskell\" target=\"_blank\" rel=\"noopener\">confused about function as instance of Functor in haskell</a></li>\n<li><a href=\"https://stackoverflow.com/questions/11810889/functions-as-applicative-functors-haskell-lyah\" target=\"_blank\" rel=\"noopener\">functions as applicative functors (Haskell / LYAH)</a></li>\n<li><a href=\"https://stackoverflow.com/questions/13080014/function-as-an-instance-of-monad\" target=\"_blank\" rel=\"noopener\">Function as an Instance of Monad</a></li>\n</ol>\n</li>\n<li>\n<p><a href=\"http://www.tomharding.me/2017/04/15/functions-as-functors/\" target=\"_blank\" rel=\"noopener\">Functions as Functors</a></p>\n</li>\n</ol>\n"},{"title":"为什么柯里化有帮助","date":"2017-06-28T15:26:34.000Z","_content":"\n译者注：本文翻译自 [Hugh FD Jackson](https://hughfdjackson.com/) 的 《[Why Curry Helps](https://hughfdjackson.com/javascript/why-curry-helps/)》，转载请与[原作者](https://hughfdjackson.com/)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n程序员的梦想是编写代码，并能够非常容易地对其进行复用。还要有强表达力，因为你书写的方式就是在表达你想要的东西，并且它应该被复用，因为... 好吧，你正在复用。你还想要什么呢？\n\n[curry](https://npmjs.org/package/curry) 可以帮忙。\n\n## 什么是柯里化，为什么它如此的美味？\n\nJavaScript 中正常的函数调用如下：\n\n```js\nvar add = function(a, b){ return a + b }\nadd(1, 2) //= 3\n```\n\n一个函数接受多个参数，并返回一个值。我可以使用少于指定数量的参数调用它（可能得到奇怪的结果），或者多于指定的数量（超出的部分一般会被忽略）。\n\n```js\nadd(1, 2, 'IGNORE ME') //= 3\nadd(1) //= NaN\n```\n\n一个柯里化的函数需要借用一系列单参数函数来处理它的多个参数。例如，柯里化的加法会是这样：\n\n```js\nvar curry = require('curry')\nvar add = curry(function(a, b){ return a + b })\nvar add100 = add(100)\nadd100(1) //= 101\n```\n\n接受多个参数的柯里化函数将被写成如下形式：\n\n```js\nvar sum3 = curry(function(a, b, c){ return a + b + c })\nsum3(1)(2)(3) //= 6\n```\n\n由于这在 JavaScript 语法中很丑，[curry](https://npmjs.org/package/curry) 允许你一次调用多个参数：\n\n```js\nvar sum3 = curry(function(a, b, c){ return a + b + c })\nsum3(1, 2, 3) //= 6\nsum3(1)(2, 3) //= 6\nsum3(1, 2)(3) //= 6\n```\n\n## 所以呢？\n\n如果你还未习惯这样一门语言：柯里化函数是其日常工作一部分（如 [Haskell](http://learnyouahaskell.com/)），那么它给我们带来的好处可能不太明显。在我看来，有两点非常重要：\n\n* 小的模块可以轻松地配置和复用，不杂乱。\n* 从头至尾都使用函数。\n\n### 小模块\n\n我们来看一个明显的例子；映射一个集合来获取它的成员的 ids：\n\n```js\nvar objects = [{ id: 1 }, { id: 2 }, { id: 3 }]\nobjects.map(function(o){ return o.id })\n```\n\n如果你正想搞清楚第二行的真正逻辑，我来跟你解释一下吧：\n\n> MAP over OBJECTS to get IDS (对Objects进行映射，来获得对应的ID)\n\n有很多种实现这种操作的方式；可以函数定义的形式实现。我们来理一理：\n\n```js\nvar get = curry(function(property, object){ return object[property] })\nobjects.map(get('id')) //= [1, 2, 3]\n```\n\n现在我们正在探讨这个操作的真正逻辑 - 映射这些对象，获取它们的 ids 。BAM。我们在 `get` 函数中真正创建的是一个 **可以部分配置的函数**。\n\n如果想复用 '从对象列表中获取ids' 这个功能，该怎么办呢？我们先用一种笨的方法实现：\n\n```js\nvar getIDs = function(objects){\n    return objects.map(get('id'))\n}\ngetIDs(objects) //= [1, 2, 3]\n```\n\nHrm，我们似乎从高雅和简洁的方式回到了混乱的方式。可以做些什么呢？Ah，如果 `map` 可以先部分配置一个函数，而不同时调用集合，会怎样呢？\n\n```js\nvar map = curry(function(fn, value){ return value.map(fn) })\nvar getIDs = map(get('id'))\n\ngetIDs(objects) //= [1, 2, 3]\n```\n\n我们开始看到，如果基本的构建块是柯里化函数，我们可以轻松地从中创建新的功能。更令人兴奋的是，代码读起来也很像你所工作领域（语言、环境）的逻辑。\n\n## 全是函数\n\n这种方法的另一个优点是它鼓励创建函数，而不是方法。虽然方法很好 - 允许多态，可读性也不错 - 但它们并不总是能拿来干活的工具，比如大量的异步代码。\n\n在这个示例中，我们从服务器获取一些数据，并对其进行处理。数据看起来像是这样：\n\n```js\n{\n    \"user\": \"hughfdjackson\",\n    \"posts\": [\n        { \"title\": \"why curry?\", \"contents\": \"...\" },\n        { \"title\": \"prototypes: the short(est possible) story\", \"contents\": \"...\" }\n    ]\n}\n```\n\n你的任务是提取每个用户的帖子的标签。赶紧来试一下：\n\n```js\nfetchFromServer()\n    .then(JSON.parse)\n    .then(function(data){ return data.posts })\n    .then(function(posts){\n        return posts.map(function(post){ return post.title })\n    })\n```\n\n好吧，这不公平，你在催我。（另外，我代表你写了这段代码 - 可能你会更有优雅地解决它，但我好像离题了...）。\n\n由于 Promises 链（或者，如果你喜欢，也可以用回调）需要与函数一起 *工作*，你不能轻易地映射从服务器获取的值，而无需首先显式地将其包裹在代码块中。（需要显式的写出参数）\n\n再来一次，这次使用已经定义好的工具：\n\n```js\nfetchFromServer()\n    .then(JSON.parse)\n    .then(get('posts'))\n    .then(map(get('title')))\n```\n\n这具有很强的逻辑性、表达力；如果不使用柯里化函数，我们几乎不可能轻易的将其实现。\n\n## 总结（tl;dr）\n\n[curry](https://npmjs.org/package/curry) 赋予你一种强大的表达能力。\n\n我建议你下载下来，玩一会儿。如果你已经熟悉了这个概念，我觉得你可以直接找到合适的 API。如果没有的话，建议你和你的同事一起研究一下吧。\n\n","source":"_posts/Why-Curry-Helps.md","raw":"---\ntitle: 为什么柯里化有帮助\ndate: 2017-06-28 23:26:34\ncategories: 'Ramda'\n---\n\n译者注：本文翻译自 [Hugh FD Jackson](https://hughfdjackson.com/) 的 《[Why Curry Helps](https://hughfdjackson.com/javascript/why-curry-helps/)》，转载请与[原作者](https://hughfdjackson.com/)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n程序员的梦想是编写代码，并能够非常容易地对其进行复用。还要有强表达力，因为你书写的方式就是在表达你想要的东西，并且它应该被复用，因为... 好吧，你正在复用。你还想要什么呢？\n\n[curry](https://npmjs.org/package/curry) 可以帮忙。\n\n## 什么是柯里化，为什么它如此的美味？\n\nJavaScript 中正常的函数调用如下：\n\n```js\nvar add = function(a, b){ return a + b }\nadd(1, 2) //= 3\n```\n\n一个函数接受多个参数，并返回一个值。我可以使用少于指定数量的参数调用它（可能得到奇怪的结果），或者多于指定的数量（超出的部分一般会被忽略）。\n\n```js\nadd(1, 2, 'IGNORE ME') //= 3\nadd(1) //= NaN\n```\n\n一个柯里化的函数需要借用一系列单参数函数来处理它的多个参数。例如，柯里化的加法会是这样：\n\n```js\nvar curry = require('curry')\nvar add = curry(function(a, b){ return a + b })\nvar add100 = add(100)\nadd100(1) //= 101\n```\n\n接受多个参数的柯里化函数将被写成如下形式：\n\n```js\nvar sum3 = curry(function(a, b, c){ return a + b + c })\nsum3(1)(2)(3) //= 6\n```\n\n由于这在 JavaScript 语法中很丑，[curry](https://npmjs.org/package/curry) 允许你一次调用多个参数：\n\n```js\nvar sum3 = curry(function(a, b, c){ return a + b + c })\nsum3(1, 2, 3) //= 6\nsum3(1)(2, 3) //= 6\nsum3(1, 2)(3) //= 6\n```\n\n## 所以呢？\n\n如果你还未习惯这样一门语言：柯里化函数是其日常工作一部分（如 [Haskell](http://learnyouahaskell.com/)），那么它给我们带来的好处可能不太明显。在我看来，有两点非常重要：\n\n* 小的模块可以轻松地配置和复用，不杂乱。\n* 从头至尾都使用函数。\n\n### 小模块\n\n我们来看一个明显的例子；映射一个集合来获取它的成员的 ids：\n\n```js\nvar objects = [{ id: 1 }, { id: 2 }, { id: 3 }]\nobjects.map(function(o){ return o.id })\n```\n\n如果你正想搞清楚第二行的真正逻辑，我来跟你解释一下吧：\n\n> MAP over OBJECTS to get IDS (对Objects进行映射，来获得对应的ID)\n\n有很多种实现这种操作的方式；可以函数定义的形式实现。我们来理一理：\n\n```js\nvar get = curry(function(property, object){ return object[property] })\nobjects.map(get('id')) //= [1, 2, 3]\n```\n\n现在我们正在探讨这个操作的真正逻辑 - 映射这些对象，获取它们的 ids 。BAM。我们在 `get` 函数中真正创建的是一个 **可以部分配置的函数**。\n\n如果想复用 '从对象列表中获取ids' 这个功能，该怎么办呢？我们先用一种笨的方法实现：\n\n```js\nvar getIDs = function(objects){\n    return objects.map(get('id'))\n}\ngetIDs(objects) //= [1, 2, 3]\n```\n\nHrm，我们似乎从高雅和简洁的方式回到了混乱的方式。可以做些什么呢？Ah，如果 `map` 可以先部分配置一个函数，而不同时调用集合，会怎样呢？\n\n```js\nvar map = curry(function(fn, value){ return value.map(fn) })\nvar getIDs = map(get('id'))\n\ngetIDs(objects) //= [1, 2, 3]\n```\n\n我们开始看到，如果基本的构建块是柯里化函数，我们可以轻松地从中创建新的功能。更令人兴奋的是，代码读起来也很像你所工作领域（语言、环境）的逻辑。\n\n## 全是函数\n\n这种方法的另一个优点是它鼓励创建函数，而不是方法。虽然方法很好 - 允许多态，可读性也不错 - 但它们并不总是能拿来干活的工具，比如大量的异步代码。\n\n在这个示例中，我们从服务器获取一些数据，并对其进行处理。数据看起来像是这样：\n\n```js\n{\n    \"user\": \"hughfdjackson\",\n    \"posts\": [\n        { \"title\": \"why curry?\", \"contents\": \"...\" },\n        { \"title\": \"prototypes: the short(est possible) story\", \"contents\": \"...\" }\n    ]\n}\n```\n\n你的任务是提取每个用户的帖子的标签。赶紧来试一下：\n\n```js\nfetchFromServer()\n    .then(JSON.parse)\n    .then(function(data){ return data.posts })\n    .then(function(posts){\n        return posts.map(function(post){ return post.title })\n    })\n```\n\n好吧，这不公平，你在催我。（另外，我代表你写了这段代码 - 可能你会更有优雅地解决它，但我好像离题了...）。\n\n由于 Promises 链（或者，如果你喜欢，也可以用回调）需要与函数一起 *工作*，你不能轻易地映射从服务器获取的值，而无需首先显式地将其包裹在代码块中。（需要显式的写出参数）\n\n再来一次，这次使用已经定义好的工具：\n\n```js\nfetchFromServer()\n    .then(JSON.parse)\n    .then(get('posts'))\n    .then(map(get('title')))\n```\n\n这具有很强的逻辑性、表达力；如果不使用柯里化函数，我们几乎不可能轻易的将其实现。\n\n## 总结（tl;dr）\n\n[curry](https://npmjs.org/package/curry) 赋予你一种强大的表达能力。\n\n我建议你下载下来，玩一会儿。如果你已经熟悉了这个概念，我觉得你可以直接找到合适的 API。如果没有的话，建议你和你的同事一起研究一下吧。\n\n","slug":"Why-Curry-Helps","published":1,"updated":"2020-06-06T14:44:04.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu7001gf6mjl0ac1rc6","content":"<p>译者注：本文翻译自 <a href=\"https://hughfdjackson.com/\" target=\"_blank\" rel=\"noopener\">Hugh FD Jackson</a> 的 《<a href=\"https://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">Why Curry Helps</a>》，转载请与<a href=\"https://hughfdjackson.com/\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>程序员的梦想是编写代码，并能够非常容易地对其进行复用。还要有强表达力，因为你书写的方式就是在表达你想要的东西，并且它应该被复用，因为... 好吧，你正在复用。你还想要什么呢？</p>\n<p><a href=\"https://npmjs.org/package/curry\" target=\"_blank\" rel=\"noopener\">curry</a> 可以帮忙。</p>\n<h2>什么是柯里化，为什么它如此的美味？</h2>\n<p>JavaScript 中正常的函数调用如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123; <span class=\"keyword\">return</span> a + b &#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">//= 3</span></span><br></pre></td></tr></table></figure></p>\n<p>一个函数接受多个参数，并返回一个值。我可以使用少于指定数量的参数调用它（可能得到奇怪的结果），或者多于指定的数量（超出的部分一般会被忽略）。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'IGNORE ME'</span>) <span class=\"comment\">//= 3</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>) <span class=\"comment\">//= NaN</span></span><br></pre></td></tr></table></figure></p>\n<p>一个柯里化的函数需要借用一系列单参数函数来处理它的多个参数。例如，柯里化的加法会是这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> curry = <span class=\"built_in\">require</span>(<span class=\"string\">'curry'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123; <span class=\"keyword\">return</span> a + b &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> add100 = add(<span class=\"number\">100</span>)</span><br><span class=\"line\">add100(<span class=\"number\">1</span>) <span class=\"comment\">//= 101</span></span><br></pre></td></tr></table></figure></p>\n<p>接受多个参数的柯里化函数将被写成如下形式：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum3 = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123; <span class=\"keyword\">return</span> a + b + c &#125;)</span><br><span class=\"line\">sum3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br></pre></td></tr></table></figure></p>\n<p>由于这在 JavaScript 语法中很丑，<a href=\"https://npmjs.org/package/curry\" target=\"_blank\" rel=\"noopener\">curry</a> 允许你一次调用多个参数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum3 = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123; <span class=\"keyword\">return</span> a + b + c &#125;)</span><br><span class=\"line\">sum3(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br><span class=\"line\">sum3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br><span class=\"line\">sum3(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br></pre></td></tr></table></figure></p>\n<h2>所以呢？</h2>\n<p>如果你还未习惯这样一门语言：柯里化函数是其日常工作一部分（如 <a href=\"http://learnyouahaskell.com/\" target=\"_blank\" rel=\"noopener\">Haskell</a>），那么它给我们带来的好处可能不太明显。在我看来，有两点非常重要：</p>\n<ul>\n<li>小的模块可以轻松地配置和复用，不杂乱。</li>\n<li>从头至尾都使用函数。</li>\n</ul>\n<h3>小模块</h3>\n<p>我们来看一个明显的例子；映射一个集合来获取它的成员的 ids：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objects = [&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span> &#125;, &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span> &#125;]</span><br><span class=\"line\">objects.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123; <span class=\"keyword\">return</span> o.id &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如果你正想搞清楚第二行的真正逻辑，我来跟你解释一下吧：</p>\n<blockquote>\n<p>MAP over OBJECTS to get IDS (对Objects进行映射，来获得对应的ID)</p>\n</blockquote>\n<p>有很多种实现这种操作的方式；可以函数定义的形式实现。我们来理一理：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">get</span> = curry(function(property, object)&#123; <span class=\"keyword\">return</span> object[property] &#125;)</span><br><span class=\"line\">objects.map(<span class=\"keyword\">get</span>('id')) //= [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>现在我们正在探讨这个操作的真正逻辑 - 映射这些对象，获取它们的 ids 。BAM。我们在 <code>get</code> 函数中真正创建的是一个 <strong>可以部分配置的函数</strong>。</p>\n<p>如果想复用 '从对象列表中获取ids' 这个功能，该怎么办呢？我们先用一种笨的方法实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIDs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">objects</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objects.map(<span class=\"keyword\">get</span>('id'))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getIDs(objects) //= [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>Hrm，我们似乎从高雅和简洁的方式回到了混乱的方式。可以做些什么呢？Ah，如果 <code>map</code> 可以先部分配置一个函数，而不同时调用集合，会怎样呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, value</span>)</span>&#123; <span class=\"keyword\">return</span> value.map(fn) &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> getIDs = map(<span class=\"keyword\">get</span>('id'))</span><br><span class=\"line\"></span><br><span class=\"line\">getIDs(objects) //= [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>我们开始看到，如果基本的构建块是柯里化函数，我们可以轻松地从中创建新的功能。更令人兴奋的是，代码读起来也很像你所工作领域（语言、环境）的逻辑。</p>\n<h2>全是函数</h2>\n<p>这种方法的另一个优点是它鼓励创建函数，而不是方法。虽然方法很好 - 允许多态，可读性也不错 - 但它们并不总是能拿来干活的工具，比如大量的异步代码。</p>\n<p>在这个示例中，我们从服务器获取一些数据，并对其进行处理。数据看起来像是这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span>: <span class=\"string\">\"hughfdjackson\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"posts\"</span>: [</span><br><span class=\"line\">        &#123; <span class=\"string\">\"title\"</span>: <span class=\"string\">\"why curry?\"</span>, <span class=\"string\">\"contents\"</span>: <span class=\"string\">\"...\"</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"string\">\"title\"</span>: <span class=\"string\">\"prototypes: the short(est possible) story\"</span>, <span class=\"string\">\"contents\"</span>: <span class=\"string\">\"...\"</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你的任务是提取每个用户的帖子的标签。赶紧来试一下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetchFromServer()</span><br><span class=\"line\">    .then(<span class=\"built_in\">JSON</span>.parse)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123; <span class=\"keyword\">return</span> data.posts &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> posts.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>)</span>&#123; <span class=\"keyword\">return</span> post.title &#125;)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>好吧，这不公平，你在催我。（另外，我代表你写了这段代码 - 可能你会更有优雅地解决它，但我好像离题了...）。</p>\n<p>由于 Promises 链（或者，如果你喜欢，也可以用回调）需要与函数一起 <em>工作</em>，你不能轻易地映射从服务器获取的值，而无需首先显式地将其包裹在代码块中。（需要显式的写出参数）</p>\n<p>再来一次，这次使用已经定义好的工具：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetchFromServer()</span><br><span class=\"line\">    .then(<span class=\"built_in\">JSON</span>.parse)</span><br><span class=\"line\">    .then(<span class=\"keyword\">get</span>('posts'))</span><br><span class=\"line\">    .then(map(<span class=\"keyword\">get</span>('title')))</span><br></pre></td></tr></table></figure></p>\n<p>这具有很强的逻辑性、表达力；如果不使用柯里化函数，我们几乎不可能轻易的将其实现。</p>\n<h2>总结（tl;dr）</h2>\n<p><a href=\"https://npmjs.org/package/curry\" target=\"_blank\" rel=\"noopener\">curry</a> 赋予你一种强大的表达能力。</p>\n<p>我建议你下载下来，玩一会儿。如果你已经熟悉了这个概念，我觉得你可以直接找到合适的 API。如果没有的话，建议你和你的同事一起研究一下吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 <a href=\"https://hughfdjackson.com/\" target=\"_blank\" rel=\"noopener\">Hugh FD Jackson</a> 的 《<a href=\"https://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">Why Curry Helps</a>》，转载请与<a href=\"https://hughfdjackson.com/\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>程序员的梦想是编写代码，并能够非常容易地对其进行复用。还要有强表达力，因为你书写的方式就是在表达你想要的东西，并且它应该被复用，因为... 好吧，你正在复用。你还想要什么呢？</p>\n<p><a href=\"https://npmjs.org/package/curry\" target=\"_blank\" rel=\"noopener\">curry</a> 可以帮忙。</p>\n<h2>什么是柯里化，为什么它如此的美味？</h2>\n<p>JavaScript 中正常的函数调用如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123; <span class=\"keyword\">return</span> a + b &#125;</span><br><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>) <span class=\"comment\">//= 3</span></span><br></pre></td></tr></table></figure></p>\n<p>一个函数接受多个参数，并返回一个值。我可以使用少于指定数量的参数调用它（可能得到奇怪的结果），或者多于指定的数量（超出的部分一般会被忽略）。</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">'IGNORE ME'</span>) <span class=\"comment\">//= 3</span></span><br><span class=\"line\">add(<span class=\"number\">1</span>) <span class=\"comment\">//= NaN</span></span><br></pre></td></tr></table></figure></p>\n<p>一个柯里化的函数需要借用一系列单参数函数来处理它的多个参数。例如，柯里化的加法会是这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> curry = <span class=\"built_in\">require</span>(<span class=\"string\">'curry'</span>)</span><br><span class=\"line\"><span class=\"keyword\">var</span> add = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>)</span>&#123; <span class=\"keyword\">return</span> a + b &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> add100 = add(<span class=\"number\">100</span>)</span><br><span class=\"line\">add100(<span class=\"number\">1</span>) <span class=\"comment\">//= 101</span></span><br></pre></td></tr></table></figure></p>\n<p>接受多个参数的柯里化函数将被写成如下形式：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum3 = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123; <span class=\"keyword\">return</span> a + b + c &#125;)</span><br><span class=\"line\">sum3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br></pre></td></tr></table></figure></p>\n<p>由于这在 JavaScript 语法中很丑，<a href=\"https://npmjs.org/package/curry\" target=\"_blank\" rel=\"noopener\">curry</a> 允许你一次调用多个参数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sum3 = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b, c</span>)</span>&#123; <span class=\"keyword\">return</span> a + b + c &#125;)</span><br><span class=\"line\">sum3(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br><span class=\"line\">sum3(<span class=\"number\">1</span>)(<span class=\"number\">2</span>, <span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br><span class=\"line\">sum3(<span class=\"number\">1</span>, <span class=\"number\">2</span>)(<span class=\"number\">3</span>) <span class=\"comment\">//= 6</span></span><br></pre></td></tr></table></figure></p>\n<h2>所以呢？</h2>\n<p>如果你还未习惯这样一门语言：柯里化函数是其日常工作一部分（如 <a href=\"http://learnyouahaskell.com/\" target=\"_blank\" rel=\"noopener\">Haskell</a>），那么它给我们带来的好处可能不太明显。在我看来，有两点非常重要：</p>\n<ul>\n<li>小的模块可以轻松地配置和复用，不杂乱。</li>\n<li>从头至尾都使用函数。</li>\n</ul>\n<h3>小模块</h3>\n<p>我们来看一个明显的例子；映射一个集合来获取它的成员的 ids：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> objects = [&#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span> &#125;, &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span> &#125;, &#123; <span class=\"attr\">id</span>: <span class=\"number\">3</span> &#125;]</span><br><span class=\"line\">objects.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">o</span>)</span>&#123; <span class=\"keyword\">return</span> o.id &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>如果你正想搞清楚第二行的真正逻辑，我来跟你解释一下吧：</p>\n<blockquote>\n<p>MAP over OBJECTS to get IDS (对Objects进行映射，来获得对应的ID)</p>\n</blockquote>\n<p>有很多种实现这种操作的方式；可以函数定义的形式实现。我们来理一理：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">get</span> = curry(function(property, object)&#123; <span class=\"keyword\">return</span> object[property] &#125;)</span><br><span class=\"line\">objects.map(<span class=\"keyword\">get</span>('id')) //= [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>现在我们正在探讨这个操作的真正逻辑 - 映射这些对象，获取它们的 ids 。BAM。我们在 <code>get</code> 函数中真正创建的是一个 <strong>可以部分配置的函数</strong>。</p>\n<p>如果想复用 '从对象列表中获取ids' 这个功能，该怎么办呢？我们先用一种笨的方法实现：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> getIDs = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">objects</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> objects.map(<span class=\"keyword\">get</span>('id'))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">getIDs(objects) //= [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>Hrm，我们似乎从高雅和简洁的方式回到了混乱的方式。可以做些什么呢？Ah，如果 <code>map</code> 可以先部分配置一个函数，而不同时调用集合，会怎样呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> map = curry(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">fn, value</span>)</span>&#123; <span class=\"keyword\">return</span> value.map(fn) &#125;)</span><br><span class=\"line\"><span class=\"keyword\">var</span> getIDs = map(<span class=\"keyword\">get</span>('id'))</span><br><span class=\"line\"></span><br><span class=\"line\">getIDs(objects) //= [1, 2, 3]</span><br></pre></td></tr></table></figure></p>\n<p>我们开始看到，如果基本的构建块是柯里化函数，我们可以轻松地从中创建新的功能。更令人兴奋的是，代码读起来也很像你所工作领域（语言、环境）的逻辑。</p>\n<h2>全是函数</h2>\n<p>这种方法的另一个优点是它鼓励创建函数，而不是方法。虽然方法很好 - 允许多态，可读性也不错 - 但它们并不总是能拿来干活的工具，比如大量的异步代码。</p>\n<p>在这个示例中，我们从服务器获取一些数据，并对其进行处理。数据看起来像是这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"user\"</span>: <span class=\"string\">\"hughfdjackson\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"posts\"</span>: [</span><br><span class=\"line\">        &#123; <span class=\"string\">\"title\"</span>: <span class=\"string\">\"why curry?\"</span>, <span class=\"string\">\"contents\"</span>: <span class=\"string\">\"...\"</span> &#125;,</span><br><span class=\"line\">        &#123; <span class=\"string\">\"title\"</span>: <span class=\"string\">\"prototypes: the short(est possible) story\"</span>, <span class=\"string\">\"contents\"</span>: <span class=\"string\">\"...\"</span> &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>你的任务是提取每个用户的帖子的标签。赶紧来试一下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetchFromServer()</span><br><span class=\"line\">    .then(<span class=\"built_in\">JSON</span>.parse)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">data</span>)</span>&#123; <span class=\"keyword\">return</span> data.posts &#125;)</span><br><span class=\"line\">    .then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">posts</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> posts.map(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">post</span>)</span>&#123; <span class=\"keyword\">return</span> post.title &#125;)</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure></p>\n<p>好吧，这不公平，你在催我。（另外，我代表你写了这段代码 - 可能你会更有优雅地解决它，但我好像离题了...）。</p>\n<p>由于 Promises 链（或者，如果你喜欢，也可以用回调）需要与函数一起 <em>工作</em>，你不能轻易地映射从服务器获取的值，而无需首先显式地将其包裹在代码块中。（需要显式的写出参数）</p>\n<p>再来一次，这次使用已经定义好的工具：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fetchFromServer()</span><br><span class=\"line\">    .then(<span class=\"built_in\">JSON</span>.parse)</span><br><span class=\"line\">    .then(<span class=\"keyword\">get</span>('posts'))</span><br><span class=\"line\">    .then(map(<span class=\"keyword\">get</span>('title')))</span><br></pre></td></tr></table></figure></p>\n<p>这具有很强的逻辑性、表达力；如果不使用柯里化函数，我们几乎不可能轻易的将其实现。</p>\n<h2>总结（tl;dr）</h2>\n<p><a href=\"https://npmjs.org/package/curry\" target=\"_blank\" rel=\"noopener\">curry</a> 赋予你一种强大的表达能力。</p>\n<p>我建议你下载下来，玩一会儿。如果你已经熟悉了这个概念，我觉得你可以直接找到合适的 API。如果没有的话，建议你和你的同事一起研究一下吧。</p>\n"},{"title":"Why Ramda","date":"2017-06-25T08:26:35.000Z","_content":"\n译者注：本文翻译自 [Scott Sauyet](https://github.com/CrossEye) 的 《[Why Ramda](http://fr.umio.us/why-ramda/)》，转载请与[原作者](https://github.com/CrossEye)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n当 [buzzdecafe](http://buzzdecafe.github.io/) 最近将 [Ramda](https://github.com/ramda/ramda) [介绍给](http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/) 大家时，出现了两种截然相反的反应。那些熟悉函数式技术（在 JavaScript 或其他语言中）的人大部分的反应是：\"Cool\"。他们可能对此非常兴奋，也可能觉得只是另一个有潜力的工具而已，但他们都知道它的作用和目的。\n\n另一部分人的反应是：\"Huh?\"\n\n![other-group-reponse](./rbudiharso_tweet-2.png)\n\n对于那些不熟悉函数式编程的人来说，Ramda 似乎没有什么帮助。Ramda 中的大部分功能在类似于 [Underscore](https://github.com/jashkenas/underscore) 和 [Lodash](https://github.com/lodash/lodash) 库中都已经有了。\n\n这些人是对的。如果你希望一直使用之前一直在用的命令式和面向对象的方式进行编程，那么 Ramda 可能没有太多价值。\n\n然而，它提供了一种不同的编码风格，这种编程风格天然适合于函数式编程语言：Ramda 可以让 \"通过函数式组合构建复杂的逻辑\" 变得更简单。注意，任何包含 `compose` 函数的库都可以进行函数式组合；这样做真正的意义是：*\"make it simple(让编程变得简单)\"*。\n\n来看看 Ramda 是如何工作的。\n\n\"TODO lists\" (待办事项列表) 似乎是用于比较 Web 框架的 \"标准样例\"，所以我们也借用它来进行演示。假设需要一个能够删除所有已完成项的 \"TODO list\"。\n\n使用内置的 Array 原型方法，我们可能会这样写：\n\n```js\n// Plain JS\nvar incompleteTasks = tasks.filter(function(task) {\n    return !task.complete;\n});\n```\n\n使用 LoDash，似乎变得简单一些：\n\n```js\n// Lo-Dash\nvar incompleteTasks = _.filter(tasks, {complete: false});\n```\n\n通过上述任一方法，我们都可以得到一个过滤的任务列表。\n\n在 Ramda 中，我们可以这样做：\n\n```js\nvar incomplete = R.filter(R.where({complete: false});\n```\n\n(更新：`where` 函数被[拆分成两部分](https://github.com/ramda/ramda/pull/1036)：[`where`](http://ramdajs.com/docs/#where) 和 [`whereEq`](http://ramdajs.com/docs/#whereEq)，该段代码可能不会像现在这样工作了)。\n\n注意到有什么不同了吗？这里没有提到任务列表。Ramda 代码只给我们函数（没有给数据参数）。\n\n这就是重点所在。\n\n现在我们有了一个函数，可以很容易与其他函数组合，来处理任意我们选择的数据。假设现在有一个函数：`groupByUser`，可以通过用户对待办事项进行分类。我们可以简单地创建一个新函数：\n\n```js\nvar activeByUser = R.compose(groupByUser, incomplete);\n```\n\n用来选择未完成的任务，并对其按用户分类。\n\n如果给它提供数据，这就是一个函数调用。如果不借助 `compose` 手写出来，可能看起来会像这样：\n\n```js\n// (if created by hand)\nvar activeByUser = function(tasks) {\n    return groupByUser(incomplete(tasks));\n};\n```\n\n\"不必手动一步一步地去做\" 是组合的关键所在。并且组合是函数式编程的一项关键技术。让我们看看，如果再进一步的话会发生什么。如果需要使用到期日期来对这些用户的待办事项进行排序，该怎么办呢？\n\n```js\nvar sortUserTasks = R.compose(R.map(R.sortBy(R.prop(\"dueDate\"))), activeByUser);\n```\n\n## 一步到位？\n\n善于观察的读者可能已经注意到了，我们可以组合上述所有需求。由于 `compose` 函数可以接受多个参数，为什么不一次完成上面所有的功能呢？\n\n```js\nvar sortUserTasks = R.compose(\n    R.mapObj(R.sortBy(R.prop('dueDate'))),\n    groupByUser,\n    R.filter(R.where({complete: false})\n);\n```\n\n我的答案是：如果中间函数 `activeByUser` 和 `incomplete` 没有其他的调用，上述方案可能更合理一些。但是这可能会使调试变得更麻烦，而且对代码的可读性也并没有什么帮助。\n\n事实上，可以换个思路。我们在内部使用可重用的复杂模块，这样做可能会更好些：\n\n```js\nvar sortByDate = R.sortBy(R.prop('dueDate'));\nvar sortUserTasks = R.compose(R.mapObj(sortByDate), activeByUser);\n```\n\n现在可以用 `sortByDate` 对任何任务列表，通过到期日期进行排序。（事实上，可以更灵活，它可以对任何符合下面条件的数组进行排序：数组元素为包含可排序的 \"dueDate\" 属性的对象。\n\n但是，等等，如果想要按日期降序排列呢？\n\n```js\nvar sortByDateDescend = R.compose(R.reverse, sortByDate);\nvar sortUserTasks = R.compose(R.mapObj(sortByDateDescend), activeByUser);\n```\n\n如果确定只需要按日期降序排列，可以将所有这些操作都在 `sortByDateDescend` 中进行组合。如果不确定会升序还是降序排列，我个人会将升序和降序方法都保留。\n\n## 数据在哪里？\n\n我们 **仍然** 没有任何数据。这是怎么回事？没有数据的 \"数据处理\" 是...什么呢？是 \"处理\"。接下来恐怕需要你多一些耐心了。当进行函数式编程时，所有能获得只是组成 pipeline （管道）的函数。一个函数将数据提供给下一个，下一个函数将数据提供给下下个，依次类推，直到所需的结果从 pipeline 末端输出。\n\n到目前为止，我们已经创建的函数如下：\n\n```js\nincomplete: [Task] -> [Task]\nsortByDate: [Task] -> [Task]\nsortByDateDescend: [Task] -> [Task]\nactiveByUser: [Task] -> {String: [Task]}\nsortUserTasks: {String: [Task]} -> {String: [Task]}\n```\n\n虽然我们使用了之前的函数来构建 `sortUserTasks` ，但它们单独可能都是有用的。我们可能掩盖了一些东西。我只是让你想象有一个构建 `activeByUser` 的函数 `byUser`，但并没有真正看到过它。那么我们如何构建这个函数呢？\n\n下面是一种方法：\n\n```js\nvar groupByUser = R.partition(R.prop('username'));\n```\n\n`partition` 使用了 Ramda 中的 `reduce`（与 Array.prototype.reduce [类似](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)）。它也被叫做 `foldl`，一个在许多其他函数式语言中使用的名称。我们不会在这里做过多讨论。你可以在 [网上](https://www.google.com/?q=reduce+function+javascript) 获得所有关于 `reduce` 的信息。`partition` 只是使用 `reduce` 将一个列表分成具有相同键值的子列表，子列表通过函数来确定，本例中为 `prop('username')`，它只是简单地从每个数组元素中取出 \"username\" 属性。\n\n（所以，我是否使用 \"闪亮\" 的新函数来分散了你的注意力？我在这里仍然没有提到数据！对不住了，看！一大波 \"闪亮\" 的新函数又来了！）\n\n## 但等等，还有更多（函数）\n\n如果我们愿意，可以继续这样下去。如果想从列表中选出前 5 个元素，可以使用 Ramda 的 `take` 函数。所以想要获取每个用户前 5 个任务，可以这样做：\n\n```js\nvar topFiveUserTasks = R.compose(R.mapObj(R.take(5)), sortUserTasks);\n```\n\n(会有人在这里想到 [Brubeck 和 Desmond](http://en.wikipedia.org/wiki/Take_Five) 吗)？\n\n然后，可以将返回的对象压缩为属性的子集。比如标题和到期日期。用户名在这个数据结构里显然是多余的，我们也可能不想将过多不需要的属性传递给其他系统。\n\n可以使用 Ramda 的 `project` 函数来模拟 SQL 的 `select`：\n\n```js\nvar importantFields = R.project(['title', 'dueDate']);\nvar topDataAllUsers = R.compose(R.mapObj(importantFields), topFiveUserTasks);\n```\n\n我们一路创建的一些函数，看起来可以在 TODO 应用的其他地方复用。其他的一些函数或许只是创建出来放在那里，以供将来组合使用。所以，如果现在回顾一下，我们可能会组合出下面的代码：\n\n```js\nvar incomplete = R.filter(R.where({complete: false}));\nvar sortByDate = R.sortBy(R.prop('dueDate'));\nvar sortByDateDescend = R.compose(R.reverse, sortByDate);\nvar importantFields = R.project(['title', 'dueDate']);\nvar groupByUser = R.partition(R.prop('username'));\nvar activeByUser = R.compose(groupByUser, incomplete);\nvar topDataAllUsers = R.compose(R.mapObj(R.compose(importantFields, \n    R.take(5), sortByDateDescend)), activeByUser);\n```\n\n## 好吧，够了！我可以看一些数据吗？\n\n好的，马上就可以了。\n\n现在是时候将数据传给我们的函数了。但关键是，这些函数都接受相同类型的数据，一个包含 TODO 元素的数组。我们还没有具体描述这些元素的数据结构，但我们知道它至少必须包含下列属性：\n\n* complete: Boolean\n* dueDate: String, formatted YYYY-MM-DD\n* title: String\n* userName: String\n\n所以，如果我们有一个任务数组，该如何使用呢？很简单：\n\n```js\nvar results = topDataAllUsers(tasks);\n```\n\n就这些吗？\n\n所有已经编写的程序，就只有这些？\n\n恐怕是这样。输出会是一个像下面这样的对象：\n\n```js\n{\n    Michael: [\n        {dueDate: '2014-06-22', title: 'Integrate types with main code'},\n        {dueDate: '2014-06-15', title: 'Finish algebraic types'},\n        {dueDate: '2014-06-06', title: 'Types infrastucture'},\n        {dueDate: '2014-05-24', title: 'Separating generators'},\n        {dueDate: '2014-05-17', title: 'Add modulo function'}\n    ],\n    Richard: [\n        {dueDate: '2014-06-22', title: 'API documentation'},\n        {dueDate: '2014-06-15', title: 'Overview documentation'}\n    ],\n    Scott: [\n        {dueDate: '2014-06-22', title: 'Complete build system'},\n        {dueDate: '2014-06-15', title: 'Determine versioning scheme'},\n        {dueDate: '2014-06-09', title: 'Add `mapObj`'},\n        {dueDate: '2014-06-05', title: 'Fix `and`/`or`/`not`'},\n        {dueDate: '2014-06-01', title: 'Fold algebra branch back in'}\n    ]\n}\n```\n\n但这里有件有趣的事情。你可以将相同的任务初始列表传给 `incomplete` ，然后得到一个过滤过的列表：\n\n```js\nvar incompleteTasks = incomplete(tasks);\n```\n\n返回的内容可能是下面这样子：\n\n```js\n[\n    {\n        username: 'Scott',\n        title: 'Add `mapObj`',\n        dueDate: '2014-06-09',\n        complete: false,\n        effort: 'low',\n        priority: 'medium'\n    }, {\n        username: 'Michael',\n        title: 'Finish algebraic types',\n        dueDate: '2014-06-15',\n        complete: true,\n        effort: 'high',\n        priority: 'high'\n    } /*, ... */\n]\n```\n\n当然，你也可以将任务列表传给 `sortByDate`、`sortByDateDescend`、`importantFields`、`byUser` 或者 `activeByUser`。因为它们都处理相似的数据类型：一系列任务的列表。我们可以通过简单的组合创建出大量的工具。\n\n## 新需求\n\n在游戏的最后，你刚刚被告知需要添加一个新特性。你需要过滤出仅属于特定用户的任务，然后对该用户进行与之前相同的过滤、排序和提取子集操作。\n\n这个逻辑当前嵌入到 `topDataAllUser` 里了...，或许我们组合的函数侵入太深。但也很容易重构。通常情况下，最难的是起一个好的名字。\"gloss\" 可能不太好，但已经是深夜了，这是我能想到最好的了：\n\n```js\nvar gloss = R.compose(importantFields, R.take(5), sortByDateDescend);\nvar topData = R.compose(gloss, incomplete);\nvar topDataAllUsers = R.compose(R.mapObj(gloss), activeByUser);\nvar byUser = R.use(R.filter).over(R.propEq(\"username\"));\n```\n\n如果想使用它，可以像下面这样：\n\n```js\nvar results = topData(byUser('Scott', tasks));\n```\n\n## 拜托，我只是想要我的数据！\n\n\"好的\"，你说，\"也许这很酷，但现在我真的只是想要我的数据，我不想要不知猴年马月才能返回给我数据的函数。我还能用 Ramda 吗？\"\n\n当然可以。\n\n让我们回到第一个函数：\n\n```js\nvar incomplete = R.filter(R.where({complete: false}));\n```\n\n如何才能变成会返回数据的东西呢？非常简单：\n\n```js\nvar incompleteTasks = R.filter(R.where({complete: false}), tasks);\n```\n\n所有其他主要的函数也是这样：只需要在调用的最后面添加一个 `tasks` 参数，即可返回数据。\n\n## 刚刚发生了什么？\n\n这是 Ramda 的另一个重要特性。Ramda 所有主要的函数都是自动柯里化的。这意味着，如果你不提供给函数需要的所有参数，不想立即调用函数，我们会返会一个接受剩余参数的新函数。所以，`filter` 的定义既包含数组，也包含了过滤数组元素的 \"predicate\" 函数（判断函数）。在初始版本中，我们没有提供数组值，所以 `filter` 会返回一个新的接受数组为参数的函数。在第二个版本中，我们传入了数组，并与 \"predicate\" 函数一起来计算结果。\n\nRamda 函数的自动柯里化和 \"函数优先，数据最后\" 的 API 设计理念一起，使得 Ramda 能够非常简单地进行这种风格的函数式组合。\n\n但 Ramda 中柯里化的实现细节是另一篇文章的事情（更新：该文章已经发布了：[Favoring Curry](http://fr.umio.us/favoring-curry/)）。同时，Hugh Jackson 的这篇文章也绝对值得一读：[为什么柯里化有帮助](http://hughfdjackson.com/javascript/why-curry-helps/)。\n\n## 但是，这些东西真能工作吗？\n\n这是我们一直讨论的代码的 JSFiddle 示例：\n\n{% jsfiddle CrossEye/Gk6uu js,html,result %}\n\n这段优雅的代码清楚的表明了使用 Ramda 的好处。\n\n## 使用 Ramda\n\n[可以参考 Ramda 非常不错的文档](http://ramda.cn/docs/)。\n\nRamda 代码本身非常有用，上面提到的技术也非常有帮助。你可以从 [Github 仓库](https://github.com/ramda/ramda) 获取代码，或 [通过 npm 安装 Ramda](https://www.npmjs.org/package/ramda)。\n\n在 Node 中使用：\n\n```js\nnpm install ramda\nvar R = require('ramda')\n```\n\n在浏览器中使用，只需包含下列代码：\n\n```js\n<script src=\"path/to/yourCopyOf/ramda.js\"></script>\n```\n\n或者\n\n```js\n<script src=\"path/to/yourCopyOf/ramda.min.js\"></script>\n```\n\n我们会尽快将其放到 CDN 上。\n\n如果你有任何建议，[欢迎随时跟我们联系](https://github.com/ramda/ramda/issues?state=open)。\n","source":"_posts/Why-Ramda.md","raw":"---\ntitle: Why Ramda\ndate: 2017-06-25 16:26:35\ncategories: 'Ramda'\n---\n\n译者注：本文翻译自 [Scott Sauyet](https://github.com/CrossEye) 的 《[Why Ramda](http://fr.umio.us/why-ramda/)》，转载请与[原作者](https://github.com/CrossEye)或[本人](https://github.com/adispring)联系。下面开始正文。\n\n---\n\n当 [buzzdecafe](http://buzzdecafe.github.io/) 最近将 [Ramda](https://github.com/ramda/ramda) [介绍给](http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/) 大家时，出现了两种截然相反的反应。那些熟悉函数式技术（在 JavaScript 或其他语言中）的人大部分的反应是：\"Cool\"。他们可能对此非常兴奋，也可能觉得只是另一个有潜力的工具而已，但他们都知道它的作用和目的。\n\n另一部分人的反应是：\"Huh?\"\n\n![other-group-reponse](./rbudiharso_tweet-2.png)\n\n对于那些不熟悉函数式编程的人来说，Ramda 似乎没有什么帮助。Ramda 中的大部分功能在类似于 [Underscore](https://github.com/jashkenas/underscore) 和 [Lodash](https://github.com/lodash/lodash) 库中都已经有了。\n\n这些人是对的。如果你希望一直使用之前一直在用的命令式和面向对象的方式进行编程，那么 Ramda 可能没有太多价值。\n\n然而，它提供了一种不同的编码风格，这种编程风格天然适合于函数式编程语言：Ramda 可以让 \"通过函数式组合构建复杂的逻辑\" 变得更简单。注意，任何包含 `compose` 函数的库都可以进行函数式组合；这样做真正的意义是：*\"make it simple(让编程变得简单)\"*。\n\n来看看 Ramda 是如何工作的。\n\n\"TODO lists\" (待办事项列表) 似乎是用于比较 Web 框架的 \"标准样例\"，所以我们也借用它来进行演示。假设需要一个能够删除所有已完成项的 \"TODO list\"。\n\n使用内置的 Array 原型方法，我们可能会这样写：\n\n```js\n// Plain JS\nvar incompleteTasks = tasks.filter(function(task) {\n    return !task.complete;\n});\n```\n\n使用 LoDash，似乎变得简单一些：\n\n```js\n// Lo-Dash\nvar incompleteTasks = _.filter(tasks, {complete: false});\n```\n\n通过上述任一方法，我们都可以得到一个过滤的任务列表。\n\n在 Ramda 中，我们可以这样做：\n\n```js\nvar incomplete = R.filter(R.where({complete: false});\n```\n\n(更新：`where` 函数被[拆分成两部分](https://github.com/ramda/ramda/pull/1036)：[`where`](http://ramdajs.com/docs/#where) 和 [`whereEq`](http://ramdajs.com/docs/#whereEq)，该段代码可能不会像现在这样工作了)。\n\n注意到有什么不同了吗？这里没有提到任务列表。Ramda 代码只给我们函数（没有给数据参数）。\n\n这就是重点所在。\n\n现在我们有了一个函数，可以很容易与其他函数组合，来处理任意我们选择的数据。假设现在有一个函数：`groupByUser`，可以通过用户对待办事项进行分类。我们可以简单地创建一个新函数：\n\n```js\nvar activeByUser = R.compose(groupByUser, incomplete);\n```\n\n用来选择未完成的任务，并对其按用户分类。\n\n如果给它提供数据，这就是一个函数调用。如果不借助 `compose` 手写出来，可能看起来会像这样：\n\n```js\n// (if created by hand)\nvar activeByUser = function(tasks) {\n    return groupByUser(incomplete(tasks));\n};\n```\n\n\"不必手动一步一步地去做\" 是组合的关键所在。并且组合是函数式编程的一项关键技术。让我们看看，如果再进一步的话会发生什么。如果需要使用到期日期来对这些用户的待办事项进行排序，该怎么办呢？\n\n```js\nvar sortUserTasks = R.compose(R.map(R.sortBy(R.prop(\"dueDate\"))), activeByUser);\n```\n\n## 一步到位？\n\n善于观察的读者可能已经注意到了，我们可以组合上述所有需求。由于 `compose` 函数可以接受多个参数，为什么不一次完成上面所有的功能呢？\n\n```js\nvar sortUserTasks = R.compose(\n    R.mapObj(R.sortBy(R.prop('dueDate'))),\n    groupByUser,\n    R.filter(R.where({complete: false})\n);\n```\n\n我的答案是：如果中间函数 `activeByUser` 和 `incomplete` 没有其他的调用，上述方案可能更合理一些。但是这可能会使调试变得更麻烦，而且对代码的可读性也并没有什么帮助。\n\n事实上，可以换个思路。我们在内部使用可重用的复杂模块，这样做可能会更好些：\n\n```js\nvar sortByDate = R.sortBy(R.prop('dueDate'));\nvar sortUserTasks = R.compose(R.mapObj(sortByDate), activeByUser);\n```\n\n现在可以用 `sortByDate` 对任何任务列表，通过到期日期进行排序。（事实上，可以更灵活，它可以对任何符合下面条件的数组进行排序：数组元素为包含可排序的 \"dueDate\" 属性的对象。\n\n但是，等等，如果想要按日期降序排列呢？\n\n```js\nvar sortByDateDescend = R.compose(R.reverse, sortByDate);\nvar sortUserTasks = R.compose(R.mapObj(sortByDateDescend), activeByUser);\n```\n\n如果确定只需要按日期降序排列，可以将所有这些操作都在 `sortByDateDescend` 中进行组合。如果不确定会升序还是降序排列，我个人会将升序和降序方法都保留。\n\n## 数据在哪里？\n\n我们 **仍然** 没有任何数据。这是怎么回事？没有数据的 \"数据处理\" 是...什么呢？是 \"处理\"。接下来恐怕需要你多一些耐心了。当进行函数式编程时，所有能获得只是组成 pipeline （管道）的函数。一个函数将数据提供给下一个，下一个函数将数据提供给下下个，依次类推，直到所需的结果从 pipeline 末端输出。\n\n到目前为止，我们已经创建的函数如下：\n\n```js\nincomplete: [Task] -> [Task]\nsortByDate: [Task] -> [Task]\nsortByDateDescend: [Task] -> [Task]\nactiveByUser: [Task] -> {String: [Task]}\nsortUserTasks: {String: [Task]} -> {String: [Task]}\n```\n\n虽然我们使用了之前的函数来构建 `sortUserTasks` ，但它们单独可能都是有用的。我们可能掩盖了一些东西。我只是让你想象有一个构建 `activeByUser` 的函数 `byUser`，但并没有真正看到过它。那么我们如何构建这个函数呢？\n\n下面是一种方法：\n\n```js\nvar groupByUser = R.partition(R.prop('username'));\n```\n\n`partition` 使用了 Ramda 中的 `reduce`（与 Array.prototype.reduce [类似](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)）。它也被叫做 `foldl`，一个在许多其他函数式语言中使用的名称。我们不会在这里做过多讨论。你可以在 [网上](https://www.google.com/?q=reduce+function+javascript) 获得所有关于 `reduce` 的信息。`partition` 只是使用 `reduce` 将一个列表分成具有相同键值的子列表，子列表通过函数来确定，本例中为 `prop('username')`，它只是简单地从每个数组元素中取出 \"username\" 属性。\n\n（所以，我是否使用 \"闪亮\" 的新函数来分散了你的注意力？我在这里仍然没有提到数据！对不住了，看！一大波 \"闪亮\" 的新函数又来了！）\n\n## 但等等，还有更多（函数）\n\n如果我们愿意，可以继续这样下去。如果想从列表中选出前 5 个元素，可以使用 Ramda 的 `take` 函数。所以想要获取每个用户前 5 个任务，可以这样做：\n\n```js\nvar topFiveUserTasks = R.compose(R.mapObj(R.take(5)), sortUserTasks);\n```\n\n(会有人在这里想到 [Brubeck 和 Desmond](http://en.wikipedia.org/wiki/Take_Five) 吗)？\n\n然后，可以将返回的对象压缩为属性的子集。比如标题和到期日期。用户名在这个数据结构里显然是多余的，我们也可能不想将过多不需要的属性传递给其他系统。\n\n可以使用 Ramda 的 `project` 函数来模拟 SQL 的 `select`：\n\n```js\nvar importantFields = R.project(['title', 'dueDate']);\nvar topDataAllUsers = R.compose(R.mapObj(importantFields), topFiveUserTasks);\n```\n\n我们一路创建的一些函数，看起来可以在 TODO 应用的其他地方复用。其他的一些函数或许只是创建出来放在那里，以供将来组合使用。所以，如果现在回顾一下，我们可能会组合出下面的代码：\n\n```js\nvar incomplete = R.filter(R.where({complete: false}));\nvar sortByDate = R.sortBy(R.prop('dueDate'));\nvar sortByDateDescend = R.compose(R.reverse, sortByDate);\nvar importantFields = R.project(['title', 'dueDate']);\nvar groupByUser = R.partition(R.prop('username'));\nvar activeByUser = R.compose(groupByUser, incomplete);\nvar topDataAllUsers = R.compose(R.mapObj(R.compose(importantFields, \n    R.take(5), sortByDateDescend)), activeByUser);\n```\n\n## 好吧，够了！我可以看一些数据吗？\n\n好的，马上就可以了。\n\n现在是时候将数据传给我们的函数了。但关键是，这些函数都接受相同类型的数据，一个包含 TODO 元素的数组。我们还没有具体描述这些元素的数据结构，但我们知道它至少必须包含下列属性：\n\n* complete: Boolean\n* dueDate: String, formatted YYYY-MM-DD\n* title: String\n* userName: String\n\n所以，如果我们有一个任务数组，该如何使用呢？很简单：\n\n```js\nvar results = topDataAllUsers(tasks);\n```\n\n就这些吗？\n\n所有已经编写的程序，就只有这些？\n\n恐怕是这样。输出会是一个像下面这样的对象：\n\n```js\n{\n    Michael: [\n        {dueDate: '2014-06-22', title: 'Integrate types with main code'},\n        {dueDate: '2014-06-15', title: 'Finish algebraic types'},\n        {dueDate: '2014-06-06', title: 'Types infrastucture'},\n        {dueDate: '2014-05-24', title: 'Separating generators'},\n        {dueDate: '2014-05-17', title: 'Add modulo function'}\n    ],\n    Richard: [\n        {dueDate: '2014-06-22', title: 'API documentation'},\n        {dueDate: '2014-06-15', title: 'Overview documentation'}\n    ],\n    Scott: [\n        {dueDate: '2014-06-22', title: 'Complete build system'},\n        {dueDate: '2014-06-15', title: 'Determine versioning scheme'},\n        {dueDate: '2014-06-09', title: 'Add `mapObj`'},\n        {dueDate: '2014-06-05', title: 'Fix `and`/`or`/`not`'},\n        {dueDate: '2014-06-01', title: 'Fold algebra branch back in'}\n    ]\n}\n```\n\n但这里有件有趣的事情。你可以将相同的任务初始列表传给 `incomplete` ，然后得到一个过滤过的列表：\n\n```js\nvar incompleteTasks = incomplete(tasks);\n```\n\n返回的内容可能是下面这样子：\n\n```js\n[\n    {\n        username: 'Scott',\n        title: 'Add `mapObj`',\n        dueDate: '2014-06-09',\n        complete: false,\n        effort: 'low',\n        priority: 'medium'\n    }, {\n        username: 'Michael',\n        title: 'Finish algebraic types',\n        dueDate: '2014-06-15',\n        complete: true,\n        effort: 'high',\n        priority: 'high'\n    } /*, ... */\n]\n```\n\n当然，你也可以将任务列表传给 `sortByDate`、`sortByDateDescend`、`importantFields`、`byUser` 或者 `activeByUser`。因为它们都处理相似的数据类型：一系列任务的列表。我们可以通过简单的组合创建出大量的工具。\n\n## 新需求\n\n在游戏的最后，你刚刚被告知需要添加一个新特性。你需要过滤出仅属于特定用户的任务，然后对该用户进行与之前相同的过滤、排序和提取子集操作。\n\n这个逻辑当前嵌入到 `topDataAllUser` 里了...，或许我们组合的函数侵入太深。但也很容易重构。通常情况下，最难的是起一个好的名字。\"gloss\" 可能不太好，但已经是深夜了，这是我能想到最好的了：\n\n```js\nvar gloss = R.compose(importantFields, R.take(5), sortByDateDescend);\nvar topData = R.compose(gloss, incomplete);\nvar topDataAllUsers = R.compose(R.mapObj(gloss), activeByUser);\nvar byUser = R.use(R.filter).over(R.propEq(\"username\"));\n```\n\n如果想使用它，可以像下面这样：\n\n```js\nvar results = topData(byUser('Scott', tasks));\n```\n\n## 拜托，我只是想要我的数据！\n\n\"好的\"，你说，\"也许这很酷，但现在我真的只是想要我的数据，我不想要不知猴年马月才能返回给我数据的函数。我还能用 Ramda 吗？\"\n\n当然可以。\n\n让我们回到第一个函数：\n\n```js\nvar incomplete = R.filter(R.where({complete: false}));\n```\n\n如何才能变成会返回数据的东西呢？非常简单：\n\n```js\nvar incompleteTasks = R.filter(R.where({complete: false}), tasks);\n```\n\n所有其他主要的函数也是这样：只需要在调用的最后面添加一个 `tasks` 参数，即可返回数据。\n\n## 刚刚发生了什么？\n\n这是 Ramda 的另一个重要特性。Ramda 所有主要的函数都是自动柯里化的。这意味着，如果你不提供给函数需要的所有参数，不想立即调用函数，我们会返会一个接受剩余参数的新函数。所以，`filter` 的定义既包含数组，也包含了过滤数组元素的 \"predicate\" 函数（判断函数）。在初始版本中，我们没有提供数组值，所以 `filter` 会返回一个新的接受数组为参数的函数。在第二个版本中，我们传入了数组，并与 \"predicate\" 函数一起来计算结果。\n\nRamda 函数的自动柯里化和 \"函数优先，数据最后\" 的 API 设计理念一起，使得 Ramda 能够非常简单地进行这种风格的函数式组合。\n\n但 Ramda 中柯里化的实现细节是另一篇文章的事情（更新：该文章已经发布了：[Favoring Curry](http://fr.umio.us/favoring-curry/)）。同时，Hugh Jackson 的这篇文章也绝对值得一读：[为什么柯里化有帮助](http://hughfdjackson.com/javascript/why-curry-helps/)。\n\n## 但是，这些东西真能工作吗？\n\n这是我们一直讨论的代码的 JSFiddle 示例：\n\n{% jsfiddle CrossEye/Gk6uu js,html,result %}\n\n这段优雅的代码清楚的表明了使用 Ramda 的好处。\n\n## 使用 Ramda\n\n[可以参考 Ramda 非常不错的文档](http://ramda.cn/docs/)。\n\nRamda 代码本身非常有用，上面提到的技术也非常有帮助。你可以从 [Github 仓库](https://github.com/ramda/ramda) 获取代码，或 [通过 npm 安装 Ramda](https://www.npmjs.org/package/ramda)。\n\n在 Node 中使用：\n\n```js\nnpm install ramda\nvar R = require('ramda')\n```\n\n在浏览器中使用，只需包含下列代码：\n\n```js\n<script src=\"path/to/yourCopyOf/ramda.js\"></script>\n```\n\n或者\n\n```js\n<script src=\"path/to/yourCopyOf/ramda.min.js\"></script>\n```\n\n我们会尽快将其放到 CDN 上。\n\n如果你有任何建议，[欢迎随时跟我们联系](https://github.com/ramda/ramda/issues?state=open)。\n","slug":"Why-Ramda","published":1,"updated":"2020-06-06T14:44:04.100Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckb3rfiu8001if6mjgjclx405","content":"<p>译者注：本文翻译自 <a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">Scott Sauyet</a> 的 《<a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">Why Ramda</a>》，转载请与<a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>当 <a href=\"http://buzzdecafe.github.io/\" target=\"_blank\" rel=\"noopener\">buzzdecafe</a> 最近将 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> <a href=\"http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/\" target=\"_blank\" rel=\"noopener\">介绍给</a> 大家时，出现了两种截然相反的反应。那些熟悉函数式技术（在 JavaScript 或其他语言中）的人大部分的反应是：&quot;Cool&quot;。他们可能对此非常兴奋，也可能觉得只是另一个有潜力的工具而已，但他们都知道它的作用和目的。</p>\n<p>另一部分人的反应是：&quot;Huh?&quot;</p>\n<p><img src=\"./rbudiharso_tweet-2.png\" alt=\"other-group-reponse\"></p>\n<p>对于那些不熟悉函数式编程的人来说，Ramda 似乎没有什么帮助。Ramda 中的大部分功能在类似于 <a href=\"https://github.com/jashkenas/underscore\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"noopener\">Lodash</a> 库中都已经有了。</p>\n<p>这些人是对的。如果你希望一直使用之前一直在用的命令式和面向对象的方式进行编程，那么 Ramda 可能没有太多价值。</p>\n<p>然而，它提供了一种不同的编码风格，这种编程风格天然适合于函数式编程语言：Ramda 可以让 &quot;通过函数式组合构建复杂的逻辑&quot; 变得更简单。注意，任何包含 <code>compose</code> 函数的库都可以进行函数式组合；这样做真正的意义是：<em>&quot;make it simple(让编程变得简单)&quot;</em>。</p>\n<p>来看看 Ramda 是如何工作的。</p>\n<p>&quot;TODO lists&quot; (待办事项列表) 似乎是用于比较 Web 框架的 &quot;标准样例&quot;，所以我们也借用它来进行演示。假设需要一个能够删除所有已完成项的 &quot;TODO list&quot;。</p>\n<p>使用内置的 Array 原型方法，我们可能会这样写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Plain JS</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = tasks.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !task.complete;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>使用 LoDash，似乎变得简单一些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lo-Dash</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = _.filter(tasks, &#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>通过上述任一方法，我们都可以得到一个过滤的任务列表。</p>\n<p>在 Ramda 中，我们可以这样做：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incomplete = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>(更新：<code>where</code> 函数被<a href=\"https://github.com/ramda/ramda/pull/1036\" target=\"_blank\" rel=\"noopener\">拆分成两部分</a>：<a href=\"http://ramdajs.com/docs/#where\" target=\"_blank\" rel=\"noopener\"><code>where</code></a> 和 <a href=\"http://ramdajs.com/docs/#whereEq\" target=\"_blank\" rel=\"noopener\"><code>whereEq</code></a>，该段代码可能不会像现在这样工作了)。</p>\n<p>注意到有什么不同了吗？这里没有提到任务列表。Ramda 代码只给我们函数（没有给数据参数）。</p>\n<p>这就是重点所在。</p>\n<p>现在我们有了一个函数，可以很容易与其他函数组合，来处理任意我们选择的数据。假设现在有一个函数：<code>groupByUser</code>，可以通过用户对待办事项进行分类。我们可以简单地创建一个新函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> activeByUser = R.compose(groupByUser, incomplete);</span><br></pre></td></tr></table></figure></p>\n<p>用来选择未完成的任务，并对其按用户分类。</p>\n<p>如果给它提供数据，这就是一个函数调用。如果不借助 <code>compose</code> 手写出来，可能看起来会像这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (if created by hand)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> activeByUser = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> groupByUser(incomplete(tasks));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&quot;不必手动一步一步地去做&quot; 是组合的关键所在。并且组合是函数式编程的一项关键技术。让我们看看，如果再进一步的话会发生什么。如果需要使用到期日期来对这些用户的待办事项进行排序，该怎么办呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(R.map(R.sortBy(R.prop(<span class=\"string\">\"dueDate\"</span>))), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<h2>一步到位？</h2>\n<p>善于观察的读者可能已经注意到了，我们可以组合上述所有需求。由于 <code>compose</code> 函数可以接受多个参数，为什么不一次完成上面所有的功能呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(</span><br><span class=\"line\">    R.mapObj(R.sortBy(R.prop(<span class=\"string\">'dueDate'</span>))),</span><br><span class=\"line\">    groupByUser,</span><br><span class=\"line\">    R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>我的答案是：如果中间函数 <code>activeByUser</code> 和 <code>incomplete</code> 没有其他的调用，上述方案可能更合理一些。但是这可能会使调试变得更麻烦，而且对代码的可读性也并没有什么帮助。</p>\n<p>事实上，可以换个思路。我们在内部使用可重用的复杂模块，这样做可能会更好些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortByDate = R.sortBy(R.prop(<span class=\"string\">'dueDate'</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(R.mapObj(sortByDate), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<p>现在可以用 <code>sortByDate</code> 对任何任务列表，通过到期日期进行排序。（事实上，可以更灵活，它可以对任何符合下面条件的数组进行排序：数组元素为包含可排序的 &quot;dueDate&quot; 属性的对象。</p>\n<p>但是，等等，如果想要按日期降序排列呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortByDateDescend = R.compose(R.reverse, sortByDate);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(R.mapObj(sortByDateDescend), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<p>如果确定只需要按日期降序排列，可以将所有这些操作都在 <code>sortByDateDescend</code> 中进行组合。如果不确定会升序还是降序排列，我个人会将升序和降序方法都保留。</p>\n<h2>数据在哪里？</h2>\n<p>我们 <strong>仍然</strong> 没有任何数据。这是怎么回事？没有数据的 &quot;数据处理&quot; 是...什么呢？是 &quot;处理&quot;。接下来恐怕需要你多一些耐心了。当进行函数式编程时，所有能获得只是组成 pipeline （管道）的函数。一个函数将数据提供给下一个，下一个函数将数据提供给下下个，依次类推，直到所需的结果从 pipeline 末端输出。</p>\n<p>到目前为止，我们已经创建的函数如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">incomplete: [Task] -&gt; [Task]</span><br><span class=\"line\">sortByDate: [Task] -&gt; [Task]</span><br><span class=\"line\">sortByDateDescend: [Task] -&gt; [Task]</span><br><span class=\"line\">activeByUser: [Task] -&gt; &#123;<span class=\"attr\">String</span>: [Task]&#125;</span><br><span class=\"line\">sortUserTasks: &#123;<span class=\"attr\">String</span>: [Task]&#125; -&gt; &#123;<span class=\"attr\">String</span>: [Task]&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然我们使用了之前的函数来构建 <code>sortUserTasks</code> ，但它们单独可能都是有用的。我们可能掩盖了一些东西。我只是让你想象有一个构建 <code>activeByUser</code> 的函数 <code>byUser</code>，但并没有真正看到过它。那么我们如何构建这个函数呢？</p>\n<p>下面是一种方法：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> groupByUser = R.partition(R.prop(<span class=\"string\">'username'</span>));</span><br></pre></td></tr></table></figure></p>\n<p><code>partition</code> 使用了 Ramda 中的 <code>reduce</code>（与 Array.prototype.reduce <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"noopener\">类似</a>）。它也被叫做 <code>foldl</code>，一个在许多其他函数式语言中使用的名称。我们不会在这里做过多讨论。你可以在 <a href=\"https://www.google.com/?q=reduce+function+javascript\" target=\"_blank\" rel=\"noopener\">网上</a> 获得所有关于 <code>reduce</code> 的信息。<code>partition</code> 只是使用 <code>reduce</code> 将一个列表分成具有相同键值的子列表，子列表通过函数来确定，本例中为 <code>prop('username')</code>，它只是简单地从每个数组元素中取出 &quot;username&quot; 属性。</p>\n<p>（所以，我是否使用 &quot;闪亮&quot; 的新函数来分散了你的注意力？我在这里仍然没有提到数据！对不住了，看！一大波 &quot;闪亮&quot; 的新函数又来了！）</p>\n<h2>但等等，还有更多（函数）</h2>\n<p>如果我们愿意，可以继续这样下去。如果想从列表中选出前 5 个元素，可以使用 Ramda 的 <code>take</code> 函数。所以想要获取每个用户前 5 个任务，可以这样做：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> topFiveUserTasks = R.compose(R.mapObj(R.take(<span class=\"number\">5</span>)), sortUserTasks);</span><br></pre></td></tr></table></figure></p>\n<p>(会有人在这里想到 <a href=\"http://en.wikipedia.org/wiki/Take_Five\" target=\"_blank\" rel=\"noopener\">Brubeck 和 Desmond</a> 吗)？</p>\n<p>然后，可以将返回的对象压缩为属性的子集。比如标题和到期日期。用户名在这个数据结构里显然是多余的，我们也可能不想将过多不需要的属性传递给其他系统。</p>\n<p>可以使用 Ramda 的 <code>project</code> 函数来模拟 SQL 的 <code>select</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> importantFields = R.project([<span class=\"string\">'title'</span>, <span class=\"string\">'dueDate'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topDataAllUsers = R.compose(R.mapObj(importantFields), topFiveUserTasks);</span><br></pre></td></tr></table></figure></p>\n<p>我们一路创建的一些函数，看起来可以在 TODO 应用的其他地方复用。其他的一些函数或许只是创建出来放在那里，以供将来组合使用。所以，如果现在回顾一下，我们可能会组合出下面的代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incomplete = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;));</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortByDate = R.sortBy(R.prop(<span class=\"string\">'dueDate'</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortByDateDescend = R.compose(R.reverse, sortByDate);</span><br><span class=\"line\"><span class=\"keyword\">var</span> importantFields = R.project([<span class=\"string\">'title'</span>, <span class=\"string\">'dueDate'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> groupByUser = R.partition(R.prop(<span class=\"string\">'username'</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> activeByUser = R.compose(groupByUser, incomplete);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topDataAllUsers = R.compose(R.mapObj(R.compose(importantFields, </span><br><span class=\"line\">    R.take(<span class=\"number\">5</span>), sortByDateDescend)), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<h2>好吧，够了！我可以看一些数据吗？</h2>\n<p>好的，马上就可以了。</p>\n<p>现在是时候将数据传给我们的函数了。但关键是，这些函数都接受相同类型的数据，一个包含 TODO 元素的数组。我们还没有具体描述这些元素的数据结构，但我们知道它至少必须包含下列属性：</p>\n<ul>\n<li>complete: Boolean</li>\n<li>dueDate: String, formatted YYYY-MM-DD</li>\n<li>title: String</li>\n<li>userName: String</li>\n</ul>\n<p>所以，如果我们有一个任务数组，该如何使用呢？很简单：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> results = topDataAllUsers(tasks);</span><br></pre></td></tr></table></figure></p>\n<p>就这些吗？</p>\n<p>所有已经编写的程序，就只有这些？</p>\n<p>恐怕是这样。输出会是一个像下面这样的对象：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    Michael: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-22'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Integrate types with main code'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-15'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Finish algebraic types'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-06'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Types infrastucture'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-05-24'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Separating generators'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-05-17'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Add modulo function'</span>&#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    Richard: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-22'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'API documentation'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-15'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Overview documentation'</span>&#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    Scott: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-22'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Complete build system'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-15'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Determine versioning scheme'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-09'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Add `mapObj`'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-05'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Fix `and`/`or`/`not`'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-01'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Fold algebra branch back in'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但这里有件有趣的事情。你可以将相同的任务初始列表传给 <code>incomplete</code> ，然后得到一个过滤过的列表：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = incomplete(tasks);</span><br></pre></td></tr></table></figure></p>\n<p>返回的内容可能是下面这样子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'Scott'</span>,</span><br><span class=\"line\">        title: <span class=\"string\">'Add `mapObj`'</span>,</span><br><span class=\"line\">        dueDate: <span class=\"string\">'2014-06-09'</span>,</span><br><span class=\"line\">        complete: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        effort: <span class=\"string\">'low'</span>,</span><br><span class=\"line\">        priority: <span class=\"string\">'medium'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'Michael'</span>,</span><br><span class=\"line\">        title: <span class=\"string\">'Finish algebraic types'</span>,</span><br><span class=\"line\">        dueDate: <span class=\"string\">'2014-06-15'</span>,</span><br><span class=\"line\">        complete: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        effort: <span class=\"string\">'high'</span>,</span><br><span class=\"line\">        priority: <span class=\"string\">'high'</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">/*, ... */</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>当然，你也可以将任务列表传给 <code>sortByDate</code>、<code>sortByDateDescend</code>、<code>importantFields</code>、<code>byUser</code> 或者 <code>activeByUser</code>。因为它们都处理相似的数据类型：一系列任务的列表。我们可以通过简单的组合创建出大量的工具。</p>\n<h2>新需求</h2>\n<p>在游戏的最后，你刚刚被告知需要添加一个新特性。你需要过滤出仅属于特定用户的任务，然后对该用户进行与之前相同的过滤、排序和提取子集操作。</p>\n<p>这个逻辑当前嵌入到 <code>topDataAllUser</code> 里了...，或许我们组合的函数侵入太深。但也很容易重构。通常情况下，最难的是起一个好的名字。&quot;gloss&quot; 可能不太好，但已经是深夜了，这是我能想到最好的了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gloss = R.compose(importantFields, R.take(<span class=\"number\">5</span>), sortByDateDescend);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topData = R.compose(gloss, incomplete);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topDataAllUsers = R.compose(R.mapObj(gloss), activeByUser);</span><br><span class=\"line\"><span class=\"keyword\">var</span> byUser = R.use(R.filter).over(R.propEq(<span class=\"string\">\"username\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>如果想使用它，可以像下面这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> results = topData(byUser(<span class=\"string\">'Scott'</span>, tasks));</span><br></pre></td></tr></table></figure></p>\n<h2>拜托，我只是想要我的数据！</h2>\n<p>&quot;好的&quot;，你说，&quot;也许这很酷，但现在我真的只是想要我的数据，我不想要不知猴年马月才能返回给我数据的函数。我还能用 Ramda 吗？&quot;</p>\n<p>当然可以。</p>\n<p>让我们回到第一个函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incomplete = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>如何才能变成会返回数据的东西呢？非常简单：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;), tasks);</span><br></pre></td></tr></table></figure></p>\n<p>所有其他主要的函数也是这样：只需要在调用的最后面添加一个 <code>tasks</code> 参数，即可返回数据。</p>\n<h2>刚刚发生了什么？</h2>\n<p>这是 Ramda 的另一个重要特性。Ramda 所有主要的函数都是自动柯里化的。这意味着，如果你不提供给函数需要的所有参数，不想立即调用函数，我们会返会一个接受剩余参数的新函数。所以，<code>filter</code> 的定义既包含数组，也包含了过滤数组元素的 &quot;predicate&quot; 函数（判断函数）。在初始版本中，我们没有提供数组值，所以 <code>filter</code> 会返回一个新的接受数组为参数的函数。在第二个版本中，我们传入了数组，并与 &quot;predicate&quot; 函数一起来计算结果。</p>\n<p>Ramda 函数的自动柯里化和 &quot;函数优先，数据最后&quot; 的 API 设计理念一起，使得 Ramda 能够非常简单地进行这种风格的函数式组合。</p>\n<p>但 Ramda 中柯里化的实现细节是另一篇文章的事情（更新：该文章已经发布了：<a href=\"http://fr.umio.us/favoring-curry/\" target=\"_blank\" rel=\"noopener\">Favoring Curry</a>）。同时，Hugh Jackson 的这篇文章也绝对值得一读：<a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">为什么柯里化有帮助</a>。</p>\n<h2>但是，这些东西真能工作吗？</h2>\n<p>这是我们一直讨论的代码的 JSFiddle 示例：</p>\n<p><iframe scrolling=\"no\" width=\"100%\" height=\"300\" src=\"//jsfiddle.net/CrossEye/Gk6uu/embedded/js,html,result/light\" frameborder=\"0\" allowfullscreen></iframe></p>\n<p>这段优雅的代码清楚的表明了使用 Ramda 的好处。</p>\n<h2>使用 Ramda</h2>\n<p><a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">可以参考 Ramda 非常不错的文档</a>。</p>\n<p>Ramda 代码本身非常有用，上面提到的技术也非常有帮助。你可以从 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Github 仓库</a> 获取代码，或 <a href=\"https://www.npmjs.org/package/ramda\" target=\"_blank\" rel=\"noopener\">通过 npm 安装 Ramda</a>。</p>\n<p>在 Node 中使用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install ramda</span><br><span class=\"line\"><span class=\"keyword\">var</span> R = <span class=\"built_in\">require</span>(<span class=\"string\">'ramda'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在浏览器中使用，只需包含下列代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"path/to/yourCopyOf/ramda.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"path/to/yourCopyOf/ramda.min.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们会尽快将其放到 CDN 上。</p>\n<p>如果你有任何建议，<a href=\"https://github.com/ramda/ramda/issues?state=open\" target=\"_blank\" rel=\"noopener\">欢迎随时跟我们联系</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>译者注：本文翻译自 <a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">Scott Sauyet</a> 的 《<a href=\"http://fr.umio.us/why-ramda/\" target=\"_blank\" rel=\"noopener\">Why Ramda</a>》，转载请与<a href=\"https://github.com/CrossEye\" target=\"_blank\" rel=\"noopener\">原作者</a>或<a href=\"https://github.com/adispring\" target=\"_blank\" rel=\"noopener\">本人</a>联系。下面开始正文。</p>\n<hr>\n<p>当 <a href=\"http://buzzdecafe.github.io/\" target=\"_blank\" rel=\"noopener\">buzzdecafe</a> 最近将 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Ramda</a> <a href=\"http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/\" target=\"_blank\" rel=\"noopener\">介绍给</a> 大家时，出现了两种截然相反的反应。那些熟悉函数式技术（在 JavaScript 或其他语言中）的人大部分的反应是：&quot;Cool&quot;。他们可能对此非常兴奋，也可能觉得只是另一个有潜力的工具而已，但他们都知道它的作用和目的。</p>\n<p>另一部分人的反应是：&quot;Huh?&quot;</p>\n<p><img src=\"./rbudiharso_tweet-2.png\" alt=\"other-group-reponse\"></p>\n<p>对于那些不熟悉函数式编程的人来说，Ramda 似乎没有什么帮助。Ramda 中的大部分功能在类似于 <a href=\"https://github.com/jashkenas/underscore\" target=\"_blank\" rel=\"noopener\">Underscore</a> 和 <a href=\"https://github.com/lodash/lodash\" target=\"_blank\" rel=\"noopener\">Lodash</a> 库中都已经有了。</p>\n<p>这些人是对的。如果你希望一直使用之前一直在用的命令式和面向对象的方式进行编程，那么 Ramda 可能没有太多价值。</p>\n<p>然而，它提供了一种不同的编码风格，这种编程风格天然适合于函数式编程语言：Ramda 可以让 &quot;通过函数式组合构建复杂的逻辑&quot; 变得更简单。注意，任何包含 <code>compose</code> 函数的库都可以进行函数式组合；这样做真正的意义是：<em>&quot;make it simple(让编程变得简单)&quot;</em>。</p>\n<p>来看看 Ramda 是如何工作的。</p>\n<p>&quot;TODO lists&quot; (待办事项列表) 似乎是用于比较 Web 框架的 &quot;标准样例&quot;，所以我们也借用它来进行演示。假设需要一个能够删除所有已完成项的 &quot;TODO list&quot;。</p>\n<p>使用内置的 Array 原型方法，我们可能会这样写：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Plain JS</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = tasks.filter(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">task</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !task.complete;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>使用 LoDash，似乎变得简单一些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Lo-Dash</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = _.filter(tasks, &#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>通过上述任一方法，我们都可以得到一个过滤的任务列表。</p>\n<p>在 Ramda 中，我们可以这样做：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incomplete = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>(更新：<code>where</code> 函数被<a href=\"https://github.com/ramda/ramda/pull/1036\" target=\"_blank\" rel=\"noopener\">拆分成两部分</a>：<a href=\"http://ramdajs.com/docs/#where\" target=\"_blank\" rel=\"noopener\"><code>where</code></a> 和 <a href=\"http://ramdajs.com/docs/#whereEq\" target=\"_blank\" rel=\"noopener\"><code>whereEq</code></a>，该段代码可能不会像现在这样工作了)。</p>\n<p>注意到有什么不同了吗？这里没有提到任务列表。Ramda 代码只给我们函数（没有给数据参数）。</p>\n<p>这就是重点所在。</p>\n<p>现在我们有了一个函数，可以很容易与其他函数组合，来处理任意我们选择的数据。假设现在有一个函数：<code>groupByUser</code>，可以通过用户对待办事项进行分类。我们可以简单地创建一个新函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> activeByUser = R.compose(groupByUser, incomplete);</span><br></pre></td></tr></table></figure></p>\n<p>用来选择未完成的任务，并对其按用户分类。</p>\n<p>如果给它提供数据，这就是一个函数调用。如果不借助 <code>compose</code> 手写出来，可能看起来会像这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// (if created by hand)</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> activeByUser = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> groupByUser(incomplete(tasks));</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>&quot;不必手动一步一步地去做&quot; 是组合的关键所在。并且组合是函数式编程的一项关键技术。让我们看看，如果再进一步的话会发生什么。如果需要使用到期日期来对这些用户的待办事项进行排序，该怎么办呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(R.map(R.sortBy(R.prop(<span class=\"string\">\"dueDate\"</span>))), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<h2>一步到位？</h2>\n<p>善于观察的读者可能已经注意到了，我们可以组合上述所有需求。由于 <code>compose</code> 函数可以接受多个参数，为什么不一次完成上面所有的功能呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(</span><br><span class=\"line\">    R.mapObj(R.sortBy(R.prop(<span class=\"string\">'dueDate'</span>))),</span><br><span class=\"line\">    groupByUser,</span><br><span class=\"line\">    R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;)</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></p>\n<p>我的答案是：如果中间函数 <code>activeByUser</code> 和 <code>incomplete</code> 没有其他的调用，上述方案可能更合理一些。但是这可能会使调试变得更麻烦，而且对代码的可读性也并没有什么帮助。</p>\n<p>事实上，可以换个思路。我们在内部使用可重用的复杂模块，这样做可能会更好些：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortByDate = R.sortBy(R.prop(<span class=\"string\">'dueDate'</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(R.mapObj(sortByDate), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<p>现在可以用 <code>sortByDate</code> 对任何任务列表，通过到期日期进行排序。（事实上，可以更灵活，它可以对任何符合下面条件的数组进行排序：数组元素为包含可排序的 &quot;dueDate&quot; 属性的对象。</p>\n<p>但是，等等，如果想要按日期降序排列呢？</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> sortByDateDescend = R.compose(R.reverse, sortByDate);</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortUserTasks = R.compose(R.mapObj(sortByDateDescend), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<p>如果确定只需要按日期降序排列，可以将所有这些操作都在 <code>sortByDateDescend</code> 中进行组合。如果不确定会升序还是降序排列，我个人会将升序和降序方法都保留。</p>\n<h2>数据在哪里？</h2>\n<p>我们 <strong>仍然</strong> 没有任何数据。这是怎么回事？没有数据的 &quot;数据处理&quot; 是...什么呢？是 &quot;处理&quot;。接下来恐怕需要你多一些耐心了。当进行函数式编程时，所有能获得只是组成 pipeline （管道）的函数。一个函数将数据提供给下一个，下一个函数将数据提供给下下个，依次类推，直到所需的结果从 pipeline 末端输出。</p>\n<p>到目前为止，我们已经创建的函数如下：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">incomplete: [Task] -&gt; [Task]</span><br><span class=\"line\">sortByDate: [Task] -&gt; [Task]</span><br><span class=\"line\">sortByDateDescend: [Task] -&gt; [Task]</span><br><span class=\"line\">activeByUser: [Task] -&gt; &#123;<span class=\"attr\">String</span>: [Task]&#125;</span><br><span class=\"line\">sortUserTasks: &#123;<span class=\"attr\">String</span>: [Task]&#125; -&gt; &#123;<span class=\"attr\">String</span>: [Task]&#125;</span><br></pre></td></tr></table></figure></p>\n<p>虽然我们使用了之前的函数来构建 <code>sortUserTasks</code> ，但它们单独可能都是有用的。我们可能掩盖了一些东西。我只是让你想象有一个构建 <code>activeByUser</code> 的函数 <code>byUser</code>，但并没有真正看到过它。那么我们如何构建这个函数呢？</p>\n<p>下面是一种方法：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> groupByUser = R.partition(R.prop(<span class=\"string\">'username'</span>));</span><br></pre></td></tr></table></figure></p>\n<p><code>partition</code> 使用了 Ramda 中的 <code>reduce</code>（与 Array.prototype.reduce <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\" target=\"_blank\" rel=\"noopener\">类似</a>）。它也被叫做 <code>foldl</code>，一个在许多其他函数式语言中使用的名称。我们不会在这里做过多讨论。你可以在 <a href=\"https://www.google.com/?q=reduce+function+javascript\" target=\"_blank\" rel=\"noopener\">网上</a> 获得所有关于 <code>reduce</code> 的信息。<code>partition</code> 只是使用 <code>reduce</code> 将一个列表分成具有相同键值的子列表，子列表通过函数来确定，本例中为 <code>prop('username')</code>，它只是简单地从每个数组元素中取出 &quot;username&quot; 属性。</p>\n<p>（所以，我是否使用 &quot;闪亮&quot; 的新函数来分散了你的注意力？我在这里仍然没有提到数据！对不住了，看！一大波 &quot;闪亮&quot; 的新函数又来了！）</p>\n<h2>但等等，还有更多（函数）</h2>\n<p>如果我们愿意，可以继续这样下去。如果想从列表中选出前 5 个元素，可以使用 Ramda 的 <code>take</code> 函数。所以想要获取每个用户前 5 个任务，可以这样做：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> topFiveUserTasks = R.compose(R.mapObj(R.take(<span class=\"number\">5</span>)), sortUserTasks);</span><br></pre></td></tr></table></figure></p>\n<p>(会有人在这里想到 <a href=\"http://en.wikipedia.org/wiki/Take_Five\" target=\"_blank\" rel=\"noopener\">Brubeck 和 Desmond</a> 吗)？</p>\n<p>然后，可以将返回的对象压缩为属性的子集。比如标题和到期日期。用户名在这个数据结构里显然是多余的，我们也可能不想将过多不需要的属性传递给其他系统。</p>\n<p>可以使用 Ramda 的 <code>project</code> 函数来模拟 SQL 的 <code>select</code>：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> importantFields = R.project([<span class=\"string\">'title'</span>, <span class=\"string\">'dueDate'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topDataAllUsers = R.compose(R.mapObj(importantFields), topFiveUserTasks);</span><br></pre></td></tr></table></figure></p>\n<p>我们一路创建的一些函数，看起来可以在 TODO 应用的其他地方复用。其他的一些函数或许只是创建出来放在那里，以供将来组合使用。所以，如果现在回顾一下，我们可能会组合出下面的代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incomplete = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;));</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortByDate = R.sortBy(R.prop(<span class=\"string\">'dueDate'</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> sortByDateDescend = R.compose(R.reverse, sortByDate);</span><br><span class=\"line\"><span class=\"keyword\">var</span> importantFields = R.project([<span class=\"string\">'title'</span>, <span class=\"string\">'dueDate'</span>]);</span><br><span class=\"line\"><span class=\"keyword\">var</span> groupByUser = R.partition(R.prop(<span class=\"string\">'username'</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> activeByUser = R.compose(groupByUser, incomplete);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topDataAllUsers = R.compose(R.mapObj(R.compose(importantFields, </span><br><span class=\"line\">    R.take(<span class=\"number\">5</span>), sortByDateDescend)), activeByUser);</span><br></pre></td></tr></table></figure></p>\n<h2>好吧，够了！我可以看一些数据吗？</h2>\n<p>好的，马上就可以了。</p>\n<p>现在是时候将数据传给我们的函数了。但关键是，这些函数都接受相同类型的数据，一个包含 TODO 元素的数组。我们还没有具体描述这些元素的数据结构，但我们知道它至少必须包含下列属性：</p>\n<ul>\n<li>complete: Boolean</li>\n<li>dueDate: String, formatted YYYY-MM-DD</li>\n<li>title: String</li>\n<li>userName: String</li>\n</ul>\n<p>所以，如果我们有一个任务数组，该如何使用呢？很简单：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> results = topDataAllUsers(tasks);</span><br></pre></td></tr></table></figure></p>\n<p>就这些吗？</p>\n<p>所有已经编写的程序，就只有这些？</p>\n<p>恐怕是这样。输出会是一个像下面这样的对象：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    Michael: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-22'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Integrate types with main code'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-15'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Finish algebraic types'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-06'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Types infrastucture'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-05-24'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Separating generators'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-05-17'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Add modulo function'</span>&#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    Richard: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-22'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'API documentation'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-15'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Overview documentation'</span>&#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    Scott: [</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-22'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Complete build system'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-15'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Determine versioning scheme'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-09'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Add `mapObj`'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-05'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Fix `and`/`or`/`not`'</span>&#125;,</span><br><span class=\"line\">        &#123;<span class=\"attr\">dueDate</span>: <span class=\"string\">'2014-06-01'</span>, <span class=\"attr\">title</span>: <span class=\"string\">'Fold algebra branch back in'</span>&#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>但这里有件有趣的事情。你可以将相同的任务初始列表传给 <code>incomplete</code> ，然后得到一个过滤过的列表：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = incomplete(tasks);</span><br></pre></td></tr></table></figure></p>\n<p>返回的内容可能是下面这样子：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'Scott'</span>,</span><br><span class=\"line\">        title: <span class=\"string\">'Add `mapObj`'</span>,</span><br><span class=\"line\">        dueDate: <span class=\"string\">'2014-06-09'</span>,</span><br><span class=\"line\">        complete: <span class=\"literal\">false</span>,</span><br><span class=\"line\">        effort: <span class=\"string\">'low'</span>,</span><br><span class=\"line\">        priority: <span class=\"string\">'medium'</span></span><br><span class=\"line\">    &#125;, &#123;</span><br><span class=\"line\">        username: <span class=\"string\">'Michael'</span>,</span><br><span class=\"line\">        title: <span class=\"string\">'Finish algebraic types'</span>,</span><br><span class=\"line\">        dueDate: <span class=\"string\">'2014-06-15'</span>,</span><br><span class=\"line\">        complete: <span class=\"literal\">true</span>,</span><br><span class=\"line\">        effort: <span class=\"string\">'high'</span>,</span><br><span class=\"line\">        priority: <span class=\"string\">'high'</span></span><br><span class=\"line\">    &#125; <span class=\"comment\">/*, ... */</span></span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<p>当然，你也可以将任务列表传给 <code>sortByDate</code>、<code>sortByDateDescend</code>、<code>importantFields</code>、<code>byUser</code> 或者 <code>activeByUser</code>。因为它们都处理相似的数据类型：一系列任务的列表。我们可以通过简单的组合创建出大量的工具。</p>\n<h2>新需求</h2>\n<p>在游戏的最后，你刚刚被告知需要添加一个新特性。你需要过滤出仅属于特定用户的任务，然后对该用户进行与之前相同的过滤、排序和提取子集操作。</p>\n<p>这个逻辑当前嵌入到 <code>topDataAllUser</code> 里了...，或许我们组合的函数侵入太深。但也很容易重构。通常情况下，最难的是起一个好的名字。&quot;gloss&quot; 可能不太好，但已经是深夜了，这是我能想到最好的了：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> gloss = R.compose(importantFields, R.take(<span class=\"number\">5</span>), sortByDateDescend);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topData = R.compose(gloss, incomplete);</span><br><span class=\"line\"><span class=\"keyword\">var</span> topDataAllUsers = R.compose(R.mapObj(gloss), activeByUser);</span><br><span class=\"line\"><span class=\"keyword\">var</span> byUser = R.use(R.filter).over(R.propEq(<span class=\"string\">\"username\"</span>));</span><br></pre></td></tr></table></figure></p>\n<p>如果想使用它，可以像下面这样：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> results = topData(byUser(<span class=\"string\">'Scott'</span>, tasks));</span><br></pre></td></tr></table></figure></p>\n<h2>拜托，我只是想要我的数据！</h2>\n<p>&quot;好的&quot;，你说，&quot;也许这很酷，但现在我真的只是想要我的数据，我不想要不知猴年马月才能返回给我数据的函数。我还能用 Ramda 吗？&quot;</p>\n<p>当然可以。</p>\n<p>让我们回到第一个函数：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incomplete = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;));</span><br></pre></td></tr></table></figure></p>\n<p>如何才能变成会返回数据的东西呢？非常简单：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> incompleteTasks = R.filter(R.where(&#123;<span class=\"attr\">complete</span>: <span class=\"literal\">false</span>&#125;), tasks);</span><br></pre></td></tr></table></figure></p>\n<p>所有其他主要的函数也是这样：只需要在调用的最后面添加一个 <code>tasks</code> 参数，即可返回数据。</p>\n<h2>刚刚发生了什么？</h2>\n<p>这是 Ramda 的另一个重要特性。Ramda 所有主要的函数都是自动柯里化的。这意味着，如果你不提供给函数需要的所有参数，不想立即调用函数，我们会返会一个接受剩余参数的新函数。所以，<code>filter</code> 的定义既包含数组，也包含了过滤数组元素的 &quot;predicate&quot; 函数（判断函数）。在初始版本中，我们没有提供数组值，所以 <code>filter</code> 会返回一个新的接受数组为参数的函数。在第二个版本中，我们传入了数组，并与 &quot;predicate&quot; 函数一起来计算结果。</p>\n<p>Ramda 函数的自动柯里化和 &quot;函数优先，数据最后&quot; 的 API 设计理念一起，使得 Ramda 能够非常简单地进行这种风格的函数式组合。</p>\n<p>但 Ramda 中柯里化的实现细节是另一篇文章的事情（更新：该文章已经发布了：<a href=\"http://fr.umio.us/favoring-curry/\" target=\"_blank\" rel=\"noopener\">Favoring Curry</a>）。同时，Hugh Jackson 的这篇文章也绝对值得一读：<a href=\"http://hughfdjackson.com/javascript/why-curry-helps/\" target=\"_blank\" rel=\"noopener\">为什么柯里化有帮助</a>。</p>\n<h2>但是，这些东西真能工作吗？</h2>\n<p>这是我们一直讨论的代码的 JSFiddle 示例：</p>\n<p><iframe scrolling=\"no\" width=\"100%\" height=\"300\" src=\"//jsfiddle.net/CrossEye/Gk6uu/embedded/js,html,result/light\" frameborder=\"0\" allowfullscreen></iframe></p>\n<p>这段优雅的代码清楚的表明了使用 Ramda 的好处。</p>\n<h2>使用 Ramda</h2>\n<p><a href=\"http://ramda.cn/docs/\" target=\"_blank\" rel=\"noopener\">可以参考 Ramda 非常不错的文档</a>。</p>\n<p>Ramda 代码本身非常有用，上面提到的技术也非常有帮助。你可以从 <a href=\"https://github.com/ramda/ramda\" target=\"_blank\" rel=\"noopener\">Github 仓库</a> 获取代码，或 <a href=\"https://www.npmjs.org/package/ramda\" target=\"_blank\" rel=\"noopener\">通过 npm 安装 Ramda</a>。</p>\n<p>在 Node 中使用：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install ramda</span><br><span class=\"line\"><span class=\"keyword\">var</span> R = <span class=\"built_in\">require</span>(<span class=\"string\">'ramda'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在浏览器中使用，只需包含下列代码：</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"path/to/yourCopyOf/ramda.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>或者</p>\n<p><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"path/to/yourCopyOf/ramda.min.js\"</span>&gt;&lt;<span class=\"regexp\">/script&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>我们会尽快将其放到 CDN 上。</p>\n<p>如果你有任何建议，<a href=\"https://github.com/ramda/ramda/issues?state=open\" target=\"_blank\" rel=\"noopener\">欢迎随时跟我们联系</a>。</p>\n"}],"PostAsset":[{"_id":"source/_posts/Debug-nodejs-in-Spacemacs/open-nodejs-repl.png","slug":"open-nodejs-repl.png","post":"ckb3rfit10001f6mjb9g95wmk","modified":1,"renderable":0},{"_id":"source/_posts/Functions-in-Functional-Programming/functions-in-memoize.png","slug":"functions-in-memoize.png","post":"ckb3rfite0009f6mjfn9vb8f1","modified":1,"renderable":0},{"_id":"source/_posts/Transducers-Explained-Part-1/compose_transducers.png","slug":"compose_transducers.png","post":"ckb3rfiu5001af6mjgoo8vpw1","modified":1,"renderable":0},{"_id":"source/_posts/Transducers-Explained-Part-1/reduce.png","slug":"reduce.png","post":"ckb3rfiu5001af6mjgoo8vpw1","modified":1,"renderable":0},{"_id":"source/_posts/Debug-nodejs-in-Spacemacs/import-lib.png","slug":"import-lib.png","post":"ckb3rfit10001f6mjb9g95wmk","modified":1,"renderable":0},{"_id":"source/_posts/Functions-in-Functional-Programming/closure.png","slug":"closure.png","post":"ckb3rfite0009f6mjfn9vb8f1","modified":1,"renderable":0},{"_id":"source/_posts/Transducers-Explained-Part-1/transduce.png","slug":"transduce.png","post":"ckb3rfiu5001af6mjgoo8vpw1","modified":1,"renderable":0},{"_id":"source/_posts/Ramda-map-filter-reduce-transduce/mapFilterReduce.jpg","post":"ckb3rfits000pf6mjp4ghuvt1","slug":"mapFilterReduce.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Why-Ramda/rbudiharso_tweet-2.png","post":"ckb3rfiu8001if6mjgjclx405","slug":"rbudiharso_tweet-2.png","modified":1,"renderable":1},{"_id":"source/_posts/Fantasy-Land-Specification/dependencies.png","post":"ckb3rfita0005f6mjisyvbiko","slug":"dependencies.png","modified":1,"renderable":1},{"_id":"source/_posts/Fantasy-Land-Specification/logo.png","post":"ckb3rfita0005f6mjisyvbiko","slug":"logo.png","modified":1,"renderable":1},{"_id":"source/_posts/Practical-Ramda-Recursion/fibonacci.jpg","post":"ckb3rfitk000hf6mjsmhvf8lj","slug":"fibonacci.jpg","modified":1,"renderable":1},{"_id":"source/_posts/Practical-Ramda-Recursion/quicksort.png","post":"ckb3rfitk000hf6mjsmhvf8lj","slug":"quicksort.png","modified":1,"renderable":1},{"_id":"source/_posts/Debug-nodejs-in-Spacemacs/eval.png","slug":"eval.png","post":"ckb3rfit10001f6mjb9g95wmk","modified":1,"renderable":0},{"_id":"source/_posts/Functions-in-Functional-Programming/function.png","post":"ckb3rfite0009f6mjfn9vb8f1","slug":"function.png","modified":1,"renderable":1},{"_id":"source/_posts/Functions-in-Functional-Programming/function_composition.png","post":"ckb3rfite0009f6mjfn9vb8f1","slug":"function_composition.png","modified":1,"renderable":1},{"_id":"source/_posts/Functions-in-Functional-Programming/functions_composition.png","post":"ckb3rfite0009f6mjfn9vb8f1","slug":"functions_composition.png","modified":1,"renderable":1},{"_id":"source/_posts/Functions-in-Functional-Programming/pipeline-leaking.png","slug":"pipeline-leaking.png","post":"ckb3rfite0009f6mjfn9vb8f1","modified":1,"renderable":0},{"_id":"source/_posts/Functions-in-Functional-Programming/pipeline.png","slug":"pipeline.png","post":"ckb3rfite0009f6mjfn9vb8f1","modified":1,"renderable":0}],"PostCategory":[{"post_id":"ckb3rfit10001f6mjb9g95wmk","category_id":"ckb3rfit70003f6mj4pb4pjl0","_id":"ckb3rfitf000af6mjeikdrx9f"},{"post_id":"ckb3rfit50002f6mjgxa9lkbt","category_id":"ckb3rfitc0007f6mjuhtqiei6","_id":"ckb3rfitj000ef6mjicj5ruuo"},{"post_id":"ckb3rfit80004f6mj2cgiuxqw","category_id":"ckb3rfitg000bf6mjnfh6gq9g","_id":"ckb3rfitl000if6mjfupiy8c5"},{"post_id":"ckb3rfiti000df6mjzj6b89gi","category_id":"ckb3rfitc0007f6mjuhtqiei6","_id":"ckb3rfitq000lf6mj7tcq6jnb"},{"post_id":"ckb3rfitb0006f6mjzf3ip3ha","category_id":"ckb3rfitj000ff6mj8wy82ziz","_id":"ckb3rfits000of6mj9zlz4spd"},{"post_id":"ckb3rfitc0008f6mj69i7v4sg","category_id":"ckb3rfitj000ff6mj8wy82ziz","_id":"ckb3rfitu000rf6mjem6r0lfr"},{"post_id":"ckb3rfitk000hf6mjsmhvf8lj","category_id":"ckb3rfits000nf6mj66a15cgf","_id":"ckb3rfitx000xf6mj5egfrnr4"},{"post_id":"ckb3rfity000yf6mjf5muppkm","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu20014f6mjepbl9l3m"},{"post_id":"ckb3rfitu000sf6mja06kr3da","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu30017f6mjb8k8ruwz"},{"post_id":"ckb3rfitz0010f6mj2br64yk2","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu40019f6mjkqio4av8"},{"post_id":"ckb3rfiu00012f6mjbylhfco6","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu5001bf6mj9fde8ee4"},{"post_id":"ckb3rfitv000uf6mjqp323z8p","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu6001df6mjanq5dmmz"},{"post_id":"ckb3rfiu10013f6mjwvffcvh5","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu7001ff6mj4ocan19p"},{"post_id":"ckb3rfiu30016f6mjygmycn00","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu8001hf6mjv88dpy71"},{"post_id":"ckb3rfitx000wf6mja3b1v58a","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiu9001jf6mjhtgcu0u2"},{"post_id":"ckb3rfiu40018f6mj6fm3lrg2","category_id":"ckb3rfitw000vf6mjlnn7spyc","_id":"ckb3rfiua001kf6mj9446af94"},{"post_id":"ckb3rfiu7001ef6mj1dwsf4gc","category_id":"ckb3rfitc0007f6mjuhtqiei6","_id":"ckb3rfiua001lf6mjt3zjd6ge"},{"post_id":"ckb3rfiu7001gf6mjl0ac1rc6","category_id":"ckb3rfitc0007f6mjuhtqiei6","_id":"ckb3rfiua001mf6mjkhe2nkr4"},{"post_id":"ckb3rfiu8001if6mjgjclx405","category_id":"ckb3rfitc0007f6mjuhtqiei6","_id":"ckb3rfiua001nf6mjkvlpr365"}],"PostTag":[{"post_id":"ckb3rfitt000qf6mjpx6sa4di","tag_id":"ckb3rfitv000tf6mjwdkc6u0v","_id":"ckb3rfitz000zf6mjn7w1wwzz"}],"Tag":[{"name":"Ramda","_id":"ckb3rfitv000tf6mjwdkc6u0v"}]}}