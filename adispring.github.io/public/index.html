<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="FE@Meituan.com">
<meta property="og:type" content="website">
<meta property="og:title" content="wangzengdi&#39;s Blog">
<meta property="og:url" content="https://adispring.github.io/index.html">
<meta property="og:site_name" content="wangzengdi&#39;s Blog">
<meta property="og:description" content="FE@Meituan.com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wangzengdi&#39;s Blog">
<meta name="twitter:description" content="FE@Meituan.com">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://adispring.github.io/"/>


  <title> wangzengdi's Blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97388892-2', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?fdee4a7147278c4213ba1baf75394f94";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">wangzengdi's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Functional Programming</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/16/The-Philosophy-of-Ramda/" itemprop="url">
                  Ramda 的哲学
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-12-16T21:39:27+08:00" content="2017-12-16">
              2017-12-16
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/16/The-Philosophy-of-Ramda/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/12/16/The-Philosophy-of-Ramda/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="mu-biao">目标</h1>
<p>我们编写 Ramda 的目的是，用比原生 JavaScript 更好的方式进行编程。给定数据如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `projects` 是一个以下形式的对象类型的数组</span></div><div class="line"><span class="comment">//     &#123;codename: 'atlas', due: '2013-09-30', budget: 300000, </span></div><div class="line"><span class="comment">//      completed: '2013-10-15', cost: 325000&#125;,</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// `assignments` 是将工程名映射到员工名的对象类型的数组，如下所示:</span></div><div class="line"><span class="comment">//     &#123;codename: 'atlas', name: 'abby'&#125;,</span></div><div class="line"><span class="comment">//     &#123;codename: 'atlas', name: 'greg'&#125;,</span></div></pre></td></tr></table></figure></p>
<p>我们想按以下形式进行编程：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> employeesByProjectName = R.pipe(</div><div class="line">  R.propEq(<span class="string">'codename'</span>), </div><div class="line">  R.flip(R.filter)(assignments), </div><div class="line">  R.map(R.prop(<span class="string">'name'</span>))</div><div class="line">);</div><div class="line"><span class="keyword">var</span> onTime = R.filter(<span class="function"><span class="params">proj</span> =&gt;</span> proj.completed &lt;= proj.due);</div><div class="line"><span class="keyword">var</span> withinBudget = R.filter(<span class="function"><span class="params">proj</span> =&gt;</span> proj.cost &lt;= proj.budget);</div><div class="line"><span class="keyword">var</span> topProjects = R.converge(R.intersection, [onTime, withinBudget]);</div><div class="line"><span class="keyword">var</span> bonusEligible = R.pipe(</div><div class="line">  topProjects, </div><div class="line">  R.map(R.prop(<span class="string">'codename'</span>)), </div><div class="line">  R.map(employeesByProjectName), </div><div class="line">  R.flatten, </div><div class="line">  R.uniq</div><div class="line">);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(bonusEligible(projects));</div><div class="line"><span class="comment">// Live version at https://codepen.io/adispring/pen/WdQjXL?editors=0012</span></div><div class="line"><span class="comment">// 译者注：原文用的 ramda@0.22.1 版本比较旧了，converge 第二个之后的函数未加中括号</span></div><div class="line"><span class="comment">//         本文采用 ramda@0.25.0</span></div></pre></td></tr></table></figure></p>
<p>这段代码是一段 “函数式” 的 <code>pipeline</code>。它是由模块化、可组合的函数构建而成，这些函数拼接在一起形成长长的管道，然后我们可以从管道入口传入待处理的数据。上面的每个 var 变量声明都代表一个单输入单输出的函数。每个函数的输出结果在管道中继续传递下去。</p>
<p>这些函数对数据进行转换并将转换结果传给下一个函数。需要注意的是，这些函数都不会改变输入参数的值。</p>
<p>Ramda 的目标是让这种风格的编码在 JavaScript 中更容易些。这就是它的目的，我们的设计决策都是由这个目标驱动的。还有一个唯二值得关注的点：简洁（Simplicity）。我们追求的是简洁（Simple），而不是简单（容易，Easy）。如果你没有看过 Rich Hickey 的 &quot;Simple Made Easy&quot;，你应该花点时间看看。简洁，意味着不要将独立的功能点耦合或纠缠到一起。Ramda 努力坚持这个原则。（单一职责原则）</p>
<h1 id="zuo-you-ming">座右铭</h1>
<p>Ramda 自认为是 &quot;一个实用的 JavaScript 函数式编程库&quot;。什么意思呢？</p>
<p>在本文接下来的部分，我们将这句话的解释分成几部分，并在下文中分别讨论每部分在 Ramda 中的含义。</p>
<h1 id="wei-java-script-bian-cheng-ren-yuan-er-she-ji">为 JavaScript 编程人员而设计</h1>
<h2 id="you-xie-liang-ya">有些惊讶？</h2>
<p>Ramda 是为编程人员设计的库。它不是一个学术试验品。它是为一线人员构建系统而准备的，它必须能运行，并且是良好、高效地运行。</p>
<p>我们尽量描述清楚函数的作用，以确保不会因误解而发生意外。不过，我们做的一些事情可能会让很多学术同仁感到惊讶。但只要日常的（工业界）编程人员理解我们，我们就愿意冒这个风险。例如，Ramda 的 <code>is</code> 函数可以用来代替 <code>isArray</code>、<code>isNumber</code>、<code>isFunction</code> 等函数。Ramda 版本的类型判断函数接受一个构造函数和一个对象：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">is(<span class="built_in">Number</span>, <span class="number">42</span>); <span class="comment">//=&gt; true</span></div><div class="line">is(<span class="built_in">Function</span>, <span class="number">42</span>); <span class="comment">//=&gt; false</span></div><div class="line">is(<span class="built_in">Object</span>, &#123;&#125;); <span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure></p>
<p>这也适用于自定义的构造函数。如果 <code>Square</code> 的原型链上包含 <code>Rectangle</code>，则可以这样做：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">is(Rectangle, <span class="keyword">new</span> Square(<span class="number">4</span>)); <span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure></p>
<p>但这也可能引起学术界同仁的疑惑：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">is(<span class="built_in">Object</span>, <span class="number">42</span>); <span class="comment">//=&gt; false</span></div></pre></td></tr></table></figure></p>
<p>现实世界的编程人员知道这是完全正确的。字符串、布尔值和数字是原生类型，但它们不是对象。然而学者们可能会坚持，认为包装过的 Number 类型继承自 Object，类比 Square/Rectangle ，也应该返回 true。当然，他们可以那么认为... 在他们自己的库里。这些函数对一线的编程人员才是最有用的。（译者注：Ramda 作者可能被学术界 Nerd 们的絮叨伤害过...）</p>
<h2 id="ming-ling-shi-shi-xian">命令式实现</h2>
<p>我们并没有非得以函数式的方式实现 Ramda 的函数。许多我们提出的构造，像 folds、maps、filters 只能通过递归进行函数式实现。但由于 JavaScript 并没有对递归进行优化；我们不能用优雅的递归算法来编写这些函数。相反，我们诉诸于丑陋的、命令式的 while 循环。我们来编写令人讨厌的代码，以便（Ramda）用户可以编写更优雅的代码。Ramda 的实现绝不应该被认为是如何编写函数式代码的指导。（译者注：为了效率和实用性的考虑，Ramda 底层实现其实是命令式的）</p>
<p>虽然我们从 Haskell、ML 和 LISP（及其变种的函数式部分）等函数式语言中获得很多灵感，但 Ramda 从不试图实现这些语言的任何部分。</p>
<p>Ramda 也没有试图简单地以函数式的方式重写原生 API。机械的生搬硬套没有任何意义。当我们实现 <code>map</code> 函数时，我们既不用非得遵循 Array.prototype.map 的 ECMAScript 规范，也没有囿于已有的实现。我们可以自由地为我们的库定义每个函数的功能，它是如何工作的，确切的参数顺序，它会不会更改输入参数等（永远不会！），返回什么，以及它会抛出什么类型的错误等。换句话说，API 是我们自己的。我们确实受到了函数式编程的传统的限制，但如果在 JavaScript 中使用某些东西需要做出妥协，我们可以做出任何被认为实用的选择。（译者注：总之，我们对 Ramda 有绝对的掌控权）</p>
<h1 id="zuo-wei-yi-ge-ku">作为一个库</h1>
<p>Ramda 是一个库，一个工具包，或者类比 Underscore ，是一个辅助开发工具。它不是一个决定如何构建应用程序结构的框架（如 React）。相反，它只是一组函数，旨在使之前描述的可组合函数风格的编程更容易一些。这些函数并没有决定你的工作流程。例如，你不必为了使用过滤器而传递 <code>where</code> 函数的结果。</p>
<h2 id="wei-shi-yao-bu-shi-yong">为什么不使用...</h2>
<p>Ramda 不可避免的会与 <a href="http://underscorejs.org/" target="_blank" rel="external">Underscore</a> 和 <a href="http://lodash.com/" target="_blank" rel="external">Lodash</a> 做对比；其所提供的函数在功能和函数名称会有重叠。但是，Ramda 不会成为这些库的替代品。即使有一个神奇的参数顺序调整机制，它仍然不是一个简单的替代品。Ramda 有自身的优势、专注于不同领域。请记住，如果这些库能够很容易地按我们想要的方式进行编程，那么就不需要 Ramda 了。</p>
<p>当我们开始编写该库时，主要的函数式编程库有：</p>
<ul>
<li>
<p>Oliver Steele 的 <a href="http://osteele.com/sources/javascript/functional/" target="_blank" rel="external">Functional Javascript</a>, 这是首次使用令人难以置信的方式，展示真的可以在 JavaScript 中用函数式的方式编程。但它也只是个玩具，用生产环境中不想要的技巧进行Hack。</p>
</li>
<li>
<p>Reg Braithwaite 的 <a href="https://github.com/raganwald/allong.es" target="_blank" rel="external">allong.es</a>，这本书已经出来了，并且这个鲜为人知的库已经可以用了。但这个库自称是 Underscore 或 Lodash 的伴侣，虽然做得很好，但它似乎只是一个支持这本书的最小代码集合，而不是一个完整的库。</p>
</li>
<li>
<p>Michael Fogus 的 <a href="https://github.com/fogus/lemonad" target="_blank" rel="external">Lemonad</a> 是一个具有前瞻性的实验品，也许是这里面最有趣的一个，它的一些函数在其他 JavaScript 库中是没有的。但它似乎只是一个 playground，基于此，该库基本上被废弃了。</p>
</li>
<li>
<p>当然还有一些大块头，比如 Jeremy Ashkenas 的 <a href="http://underscorejs.org/" target="_blank" rel="external">Underscore</a> 和 John-David Dalton 的 <a href="http://lodash.com/" target="_blank" rel="external">Lodash</a>。这些库的广泛使用，显示了大量的 JavaScript 开发人员不再害怕函数式构造。它们非常受欢迎，已经包含了许多我们想要的工具。</p>
</li>
</ul>
<p>那么为什么我们不使用 Underscore/Lodash 呢？答案很简单。对于我们想要的编程形式，它们犯了一些根本性的错误：它们传递参数的顺序是错误的。</p>
<p>这听起来很可笑，甚至无足轻重，但是对于这种编程风格来说确实 <strong>必不可少</strong>。为了构建简单可组合的函数，我们需要能正确协同工作的工具。其中最重要的是自动柯里化。为了能正确地进行柯里化，我们必须确保最经常变化的参数 -- 通常是数据 -- 放到最后。</p>
<p>差别很简单。假设我们有这样一个可用的函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a + b;&#125;;</div></pre></td></tr></table></figure></p>
<p>并且我们想要一个函数，可以计算一篮子水果的总价格，例如：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> basket = [</div><div class="line">    &#123;<span class="attr">item</span>: <span class="string">'apples'</span>,  <span class="attr">per</span>: <span class="number">.95</span>, <span class="attr">count</span>: <span class="number">3</span>, <span class="attr">cost</span>: <span class="number">2.85</span>&#125;,</div><div class="line">    &#123;<span class="attr">item</span>: <span class="string">'peaches'</span>, <span class="attr">per</span>: <span class="number">.80</span>, <span class="attr">count</span>: <span class="number">2</span>, <span class="attr">cost</span>: <span class="number">1.60</span>&#125;,</div><div class="line">    &#123;<span class="attr">item</span>: <span class="string">'plums'</span>,   <span class="attr">per</span>: <span class="number">.55</span>, <span class="attr">count</span>: <span class="number">4</span>, <span class="attr">cost</span>: <span class="number">2.20</span>&#125;</div><div class="line">];</div></pre></td></tr></table></figure></p>
<p>我们想要这样写：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = reduce(add, <span class="number">0</span>);</div></pre></td></tr></table></figure></p>
<p>并且这样使用：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> totalCost = compose(sum, pluck(<span class="string">'cost'</span>));</div></pre></td></tr></table></figure></p>
<p>这就是我们想要的效果。注意看 <code>sum</code> 和 <code>totalCost</code> 是如此的简洁。使用 Underscore 写一个计算总价的函数并不难，但不会如此简洁。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> totalCost = <span class="function"><span class="keyword">function</span>(<span class="params">basket</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sum(_.pluck(basket, <span class="string">'cost'</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>在 Lodash 中可能的实现如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> getCosts = _.partialRight(_.pluck, <span class="string">'cost'</span>);</div><div class="line"><span class="keyword">var</span> totalCost = _.compose(sum, getCosts);</div></pre></td></tr></table></figure></p>
<p>或者跳过中间变量：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> totalCost = _.compose(sum, .partialRight(_.pluck, <span class="string">'cost'</span>));</div></pre></td></tr></table></figure></p>
<p>虽然这已经非常接近我们想要的效果，但是跟 Ramda 版本的相比，还是有差距的：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = R.reduce(add, <span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> total = R.compose(sum, R.pluck(<span class="string">'cost'</span>));</div></pre></td></tr></table></figure></p>
<p>在 Ramda 中实现这种风格的秘诀非常简单：我们将函数参数放在第一位，数据参数放到最后，并且将每个函数都柯里化。</p>
<p>来看一下 <code>pluck</code>。Ramda 有一个 <code>pluck</code> 函数，它和 Underscore 及 Lodash 中的 <code>pluck</code> 函数的功能差不多。这些函数接受一个字符串属性名和一个列表；返回由列表元素的属性值组成的列表。但 Underscore 和 Lodash 要求先提供列表，Ramda 希望最后传入列表。当你加入柯里化时，区别非常明显：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">R.pluck(<span class="string">'cost'</span>); <span class="comment">//=&gt; function :: [Object] -&gt; [costs]</span></div></pre></td></tr></table></figure></p>
<p>通过简单地暂时不传列表参数给 <code>pluck</code>，我们得到一个新函数：接受一个列表，并从新提供的列表中提取 <code>cost</code> 属性值。</p>
<p>重申一下，就是这个简单的区别，将数据参数放到最后的自动柯里化函数让这两种风格变得不同：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> _.reduce(list, add, <span class="number">0</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> total = <span class="function"><span class="keyword">function</span>(<span class="params">basket</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> sum(_.pluck(basket, <span class="string">'cost'</span>));</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = R.reduce(add, <span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> total = R.compose(sum, R.pluck(<span class="string">'cost'</span>));</div></pre></td></tr></table></figure></p>
<p>这就是我们开始编写一个新库的原因。</p>
<h1 id="she-ji-xuan-ze">设计选择</h1>
<p>接下来的问题是我们想要一个什么类型的库。我们当然知道我们想要一个简洁而又不怪异的 API。但是，这里仍然有一个悬而未决的问题：需要怎样确定 API 的适用广度和深度。</p>
<p>API 的广度，仅仅指它想要覆盖多少不同类型的功能。有两百个函数的 API 比只有十个函数的 API 适用范围要广得多。与大多数其他库一样，我们对其广度（适用范围）没有特别的限制。我们添加有用的函数，而不用担心库的规模的增大会导致崩溃。</p>
<p>一个库的深度，可以衡量它的函数们在独立使用时，可以提供多少种的不同的方式。（关于它们如何组合，是另一个完全不同的问题）在这里，我们走向了与 Underscore 及 Lodash 完全不同的方向。因为 JavaScript 不会去检查参数的类型和数量，所以编写根据传入确切参数（参数的类型和数量）而具有多种不同行为的单个函数是相当容易的。Underscore 和 Lodash 使用这种方法让它们的函数更灵活。例如，在 Lodash 中，<code>pluck</code> 不仅可以作用在 list 上，还可以作用在 object 和 string 上。从这个意义上讲，Lodash 是一个相当有深度的 API。Ramda 试图保持相对较浅的深度，原因如下：</p>
<p>Lodash 提供的功能如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.pluck(<span class="string">'abc'</span>, propertyName);</div></pre></td></tr></table></figure></p>
<p>其将字符串拆分成由单字母字符串组成的数组，然后返回从每个字符串中提取的指定属性形成的数组。想找个这样的合适的应用场景是非常困难的：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.pluck(<span class="string">'abc'</span>, <span class="string">'length'</span>); <span class="comment">//=&gt; [1, 1, 1]</span></div></pre></td></tr></table></figure></p>
<p>如果你真的想要一个元素为 <code>1</code> ，且对应字符串中的每个字母的列表，下面这段代码比我的 Ramda 解法要短一些：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map(always(<span class="number">1</span>), split(<span class="string">''</span>, <span class="string">'abc'</span>));</div></pre></td></tr></table></figure></p>
<p>但这貌似没什么用，因为唯一另外一个属性是有意义的：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.pluck(<span class="string">'abc'</span>, <span class="string">'0'</span>); <span class="comment">//=&gt; ['a', 'b', 'c']</span></div></pre></td></tr></table></figure></p>
<p>如果 <code>pluck</code> 不存在，下面这样也是可以的：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">'abc'</span>.split(<span class="string">''</span>); <span class="comment">//=&gt; ['a', 'b', 'c']</span></div></pre></td></tr></table></figure></p>
<p>所以在字符串上操作并没多大用处。之所以将其（字符串）包含进来，可能是因为所有属于 Lodash &quot;集合&quot; 类的函数都应该能同时适用于数组、对象和字符串；这只是一个一致性问题。（令人失望的是，Lodash 没有打算扩展到其他实际的集合中去，比如 Map 和 Set）我们已经理解了 <code>pluck</code> 是如何在数组上工作的。它涵盖的另一种类型是对象，如下所示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flintstones1 = &#123;</div><div class="line">    <span class="attr">A</span>: &#123;<span class="attr">name</span>: <span class="string">'fred'</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</div><div class="line">    <span class="attr">B</span>: &#123;<span class="attr">name</span>: <span class="string">'wilma'</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</div><div class="line">    <span class="attr">C</span>: &#123;<span class="attr">name</span>: <span class="string">'pebbles'</span>, <span class="attr">age</span>: <span class="number">2</span>&#125;</div><div class="line">&#125;;</div><div class="line">_.pluck(flintstones1, <span class="string">'age'</span>); <span class="comment">//=&gt; [30, 28, 2]</span></div></pre></td></tr></table></figure></p>
<p>可以创建一个对象，<code>flintstones2</code> ，且以下结果为 <code>true</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.isEqual(flintstones1, flintstones2); <span class="comment">//=&gt; true</span></div></pre></td></tr></table></figure></p>
<p>但下面结果却为 <code>false</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_.pluck(flintstones1, <span class="string">'age'</span>); == _.pluck(flintstones2, <span class="string">'age'</span>); <span class="comment">//=&gt; false;</span></div></pre></td></tr></table></figure></p>
<p>下面是一种可能的情况：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> flintstones2 = &#123;</div><div class="line">    <span class="attr">B</span>: &#123;<span class="attr">name</span>: <span class="string">'wilma'</span>, <span class="attr">age</span>: <span class="number">28</span>&#125;,</div><div class="line">    <span class="attr">A</span>: &#123;<span class="attr">name</span>: <span class="string">'fred'</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</div><div class="line">    <span class="attr">C</span>: &#123;<span class="attr">name</span>: <span class="string">'pebbles'</span>, <span class="attr">age</span>: <span class="number">2</span>&#125;</div><div class="line">&#125;;</div><div class="line">_.pluck(flintstones2, <span class="string">'age'</span>); <span class="comment">//=&gt; [28, 30, 2]</span></div></pre></td></tr></table></figure></p>
<p>问题在于，<a href="http://www.ecma-international.org/ecma-262/5.1/#sec-12.6.4" target="_blank" rel="external">根据规范</a>，对象 keys 的迭代顺序是依赖于实现的；通常它们按照添加到对象中的顺序进行迭代。。</p>
<p>在写本文时，我提交了一个关于这个问题的 issue。在最好的情况下，只有通过记录问题才能解决问题。但这个问题实在影响深远。如果你想统一列表和对象的行为，你将会不断遇到这个问题，除非你实现一个（非常慢的！）统一的顺序对 Object 属性进行迭代。</p>
<p>在 Ramda 中，<code>pluck</code> 只作用于列表。它接受一个属性名和一个列表，并返回一个相同长度的新列表。仅此而已。这个 API 深度很浅。（译者注：适用范围不太广）。</p>
<p>你可以将其看作特点，也可以看作是缺点。以 Lodash 的 <code>filter</code> 为例: 它接受一个数组、对象或字符串作为第一个集合（参数），然后接受一个函数、对象、字符串或者空作为它的回调，并且还需要一个对象或空作为它的 this 参数。你将一次获得 3 * 4 * 2 = 24 个函数！这要么是一个很大的问题，要么增加了从中找到一个你真正想要的方案的难度，增加了太多复杂性。决定权在于你。</p>
<p>在 Ramda 中，我们认为这种风格会增加不必要的复杂性。我们发现简单的函数签名对于维持简洁是至关重要的。如果我们需要函数既能作用于列表，又能作用于对象，我们会创建各自独立的函数（译者注：一般情况下会这样，但也有特例，比如 <code>map</code>）。如果有一个参数我们偶尔会用到，我们不会创建一个可选参数，而是创建两个函数。尽管这扩大了 API 的规模，但是它们保持了一至的浅度。</p>
<h2 id="api-de-zeng-chang">API 的增长</h2>
<p>有一个我们已经意识到的危险，一个可以用三个字母拼出来的危险：&quot;PHP&quot;。我们不希望我们的 API 变成一个不可持续的、功能不一致的怪物。这是真正的威胁，没有强制性的规范来确定我们应该或不应该包含什么。</p>
<p>我们一直在努力；我们不希望包含一个貌似有用的函数。</p>
<p>为了避免变成 “PHP” 风格的庞然大物，我们专注于几件事情。首先，API 为王。虽然我们想要函数实现尽可能优雅，但我们为了即使是轻微的 API 性能改进，而牺牲了大量优雅的实现。我们试图执行严格的一致性标准。例如：像 <code>somethingBy</code> 这样的 Ramda 函数，以标准的方式看，与 <code>somethingWith</code> 函数是不同的。如 <a href="https://github.com/ramda/ramda/issues/65" target="_blank" rel="external">issue 65</a> 所述，我们</p>
<blockquote>
<p>使用 xxBy 来表示单一属性的比较，无论是对象的自然属性还是合成属性；使用 xxWith 表示更具一般性的函数。</p>
</blockquote>
<p>一些使用这种方式的函数的例子包括max / min / sort / uniq / difference。</p>
<h1 id="han-shu-shi">函数式</h1>
<p>JavaScript 是一门多范式语言。你可以编写简单的命令式代码，面对对象的代码，或函数式代码。原始命令式的代码非常直白、简单。有很多库可以帮助你将 JavaScript 作为面向对象的语言使用。但是将 JavaScript 作为函数式语言使用的库非常少。Ramda 帮忙填补了这个空缺。</p>
<p>如前所述，我们当然不是第一个。其他库通过各种不同方式让人们可以在 JavaScript 中进行函数式编程（FP）。在我看来，将函数式世界与 JavaScript 结合最成功的可能是 <a href="https://github.com/raganwald/allong.es" target="_blank" rel="external">allong.es</a>。但它不是一个流行的库，与 <a href="http://underscorejs.org/" target="_blank" rel="external">Underscore</a> 、 <a href="http://lodash.com/" target="_blank" rel="external">Lodash</a> 这些库不在一个级别上（就流行程度而言）；并且它有一个与 Ramda 不同的目标：它被设计为一种教学工具，一本书的演示库。</p>
<p>Ramda 正在尝试一些不同的东西。它的目标是成为一个能进行日常实际工作的实用的函数式库。</p>
<p>我们从头开始构建这个函数式库，使用了许多其他函数式语言通用的技术，以对 JavaScript 有意义的方式对这些技术进行移植。我们并没有试图弥合与面向对象世界之间的鸿沟，或者复制每一种函数式语言的每一个特性。实际上，我们甚至没有试图复制单一函数式语言的每个特性。它仍然是 JavaScript，甚至还继承了 JavaScript 缺陷。</p>
<h2 id="han-shu-shi-te-xing">函数式特性</h2>
<p>那么，在广阔的函数式编程领域里，哪些部分是我们想要保留的，又有哪些不在我们的考虑范围呢？下面列出了函数式编程的一些主要（不完整）特性：</p>
<ul>
<li>一等函数</li>
<li>高阶函数</li>
<li>词法闭包</li>
<li>引用透明</li>
<li>数据不可变</li>
<li>模式匹配</li>
<li>惰性求值</li>
<li>高效递归（TCO）</li>
<li><a href="https://en.wikipedia.org/w/index.php?title=Homoiconicity&amp;redirect=no" target="_blank" rel="external">同像性（Homoiconic）</a></li>
</ul>
<p>前几个特性都已经内置在 JavaScript 中了。JavaScript 中的函数是一等公民，意味着我们可以像使用字符串、数字或对象等，对其引用或传递。我们还可以将函数作为参数传递给其他函数，并返回全新的函数，所以 JavaScript 中包含高阶函数。因为返回函数可以访问其在创建时的上下文中的所有变量，所以我们也在语言中构建出了词法闭包。</p>
<p>除此之外，上面列出其他的特性都没有自动包含在 JavaScript 中。有的可以轻易实现，有的只能部分或很难实现，有的则超出了语言的当前能力。</p>
<p>Ramda 可以确保在不会导致你的代码出问题的情况下，帮助实现（管理）上面的其他一些特性。例如，Ramda 不会改变你的输入数据。永远也不会！如果使用 <code>append</code> 将元素添加到列表的末尾，则会返回包含添加元素的新列表。你的原始列表保持不变。所以，由于 Ramda 不会尝试强行改变不可变的客户端数据，它可以很容易的与不可变数据一起工作。</p>
<p>另一方面，Ramda 强制要求引用透明。这个概念的意思是：可以在不改变整个程序行为的情况下，将表达式替换为其对应的计算值。对于 Ramda 来说，这意味着 Ramda 不会在应用程序中存储内部状态，也不会引用任何全局变量或者内部状态可以变的闭包。简言之，当你使用相同的值调用 Ramda 函数时，总会得到相同的结果。</p>
<p>在撰写本文时，正在讨论 Ramda 的惰性求值问题。一些库如 <a href="http://danieltao.com/lazy.js/" target="_blank" rel="external">Lazy.js</a> 和 <a href="https://github.com/goatslacker/lz" target="_blank" rel="external">Lz.js</a> ，表明在 JavaScript 中进行惰性求值是可行的。<a href="https://github.com/cognitect-labs/transducers-js" target="_blank" rel="external">Transducer</a> 提供了一种模拟惰性求值的方法。Ramda 正在努力增强自己这方面的能力。但这是一个巨大的改变，并不会很快实现。</p>
<p>Ramda 还会考虑加入一定程度的模式匹配，但不会像 Erlang 或 Haskell 这样的语言中的那么强大或方便。我们并没有看到会改变语言语法的宏，所以我们最多可以做一些类似于 <a href="http://raganwald.com/2014/06/23/multiple-dispatch.html#guarded-functions" target="_blank" rel="external">Reg Braithwaite 所描述的东西</a>。但是这至少在某种程度上讲是一种模式匹配的技术。</p>
<p>其他特性都超出了 Ramda 的能力。虽然有 <a href="https://en.wikipedia.org/wiki/Trampoline_(computing)" target="_blank" rel="external">trampolining</a> 技术可以让你在不使用尾递归优化工具的情况下获得递归的一些好处，但是它们由于侵入性太强而不能被普遍使用。所以 Ramda 内部没有使用太多递归，也没有提供任何帮助来实现有效的递归。好消息是它将会被提到下一版语言规范的计划中去。</p>
<p>然后是 <strong>同像性（homoiconicity）</strong> -- 某些语言（LISP、Prolog）的特性：程序的语法可以用一种在自身语言中易于理解和修改的数据结构表示的。这远远超出了 JavaScript 当前的能力，甚至超出了 Ramda 的梦想。</p>
<h1 id="zu-he-xing">组合性</h1>
<p>Ramda 的目标之一是，允许用户使用小的可组合函数，这是函数式编程的关键。</p>
<p>函数式编程通常涉及一些少量常见的数据结构，以及搭配操作它们的大量函数。这就是 Ramda 的工作原理。</p>
<p>简言之，Ramda 主要进行列表操作。但 JavaScript 没有列表的实现；最接近的模拟是 Array（数组）。这是 Ramda 使用的最基本的数据结构。我们不关心 JavaScript 数组的一些深层次可能的性质。我们忽略稀疏数组。如果你传了一个这样的数组给 Ramda，有可能会得到意想不到的结果。你需要传给 Ramda 以 Array 实现的列表。（如果这对你没有意义，不用担心；这是人们使用 JavaScript 数组的标准方式，你必须非常努力，才能创建出不寻常的情况（译者注：错误的情况））。</p>
<p>许多 Ramda 函数接受列表并且返回列表。这些函数都很容易组合。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// :: [Comment] -&gt; [Number]  </span></div><div class="line"><span class="keyword">var</span> userRatingForComments = R.compose(</div><div class="line">    R.pluck(<span class="string">'rating'</span>),       <span class="comment">// [User] -&gt; [Number]</span></div><div class="line">    R.map(R.propOf(users)),  <span class="comment">// [String] -&gt; [User]</span></div><div class="line">    R.pluck(<span class="string">'username'</span>)      <span class="comment">// [Comment] -&gt; [String]</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>Ramda 还包含 <code>pipe</code> 函数，它跟 <code>compose</code> 功能相同，但顺序是反的；我个人觉得它更可读一些：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// :: [Comment] -&gt; [Number]  </span></div><div class="line"><span class="keyword">var</span> userRatingForComments = R.pipe(</div><div class="line">    R.pluck(<span class="string">'username'</span>),     <span class="comment">// [Comment] -&gt; [String]</span></div><div class="line">    R.map(R.propOf(users)),  <span class="comment">// [String] -&gt; [User]</span></div><div class="line">    R.pluck(<span class="string">'rating'</span>)        <span class="comment">// [User] -&gt; [Number]</span></div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>当然，组合可以作用于任何类型。如果下一个函数接受当前函数返回的类型，那么一切都应该没问题。</p>
<p>为了让其工作，Ramda 的函数必须具有足够小的规模。这与 Unix 的哲学不谋而合：大型的工具应该由小工具构建而成，每个工具做且只做一件事情。Ramda 的函数也是如此。理想情况下，这意味着以这些函数为基础的系统的复杂性只是问题自身固有的复杂性，而不是由库增加的附带的复杂性。</p>
<h2 id="bu-bian-xing">不变性</h2>
<p>需要再次重申，Ramda 函数不会修改输入数据。这是函数式编程的核心原则，也是 Ramda 工作的核心。虽然这些函数可能会改变内部局部变量，但 Ramda 不会改变传递给它的任何数据。</p>
<p>这并不意味着你使用的所有东西都会被复制。Ramda 重用了它所能用到的。因此，在像 <code>assoc</code> 和 <code>assocPath</code> 这样的函数，返回具有特定更新属性的对象的克隆中，原始数据的所有非原生（non-primitive）属性在新对象中将以引用的方式使用。如果你想要一个对象的完全解耦的副本，Ramda 提供了 <code>cloneDeep</code>（译者注：现在 Ramda 只提供 <code>clone</code> 用作深拷贝） 函数。</p>
<p>这种不变性对 Ramda 来说是硬性规定。任何牵扯到变更用户数据的 pull request 都会被拒绝。我们认为这是 Ramda 的主要特征之一。</p>
<h1 id="shi-yong-xing">实用性</h1>
<p>最后，Ramda 的目标是成为一个实用的库。这更难表述，因为实用性就像 “美丽” 一样：总是在旁观者眼中才能反映出来。永远都会有对不符合 Ramda 哲学的功能的要求，在那些提议者心目中，这些功能都是非常实用的。通常这些函数（功能）本身是有用的，但是由于不符合 Ramda 的哲学而被拒绝。</p>
<p>对于 Ramda 而言，实用性意味着一些具体的事情。</p>
<h2 id="ming-ling-shi-shi-xian-1">命令式实现</h2>
<p>首先，Ramda 的实现并未遵循 LISP、ML 或者 Haskell 库中的优雅的编码技术。我们使用丑陋的命令式的循环，而不是优雅的递归代码块。一些 Ramda 的作者曾经在一个叫 <a href="https://github.com/CrossEye/eweda" target="_blank" rel="external">Eweda</a> 的早起的库中走过这条路，代码非常漂亮，但是在解决实际问题上它却失败了。许多列表函数只能处理一千个左右的条目，而且性能也很糟糕。 JavaScript 的设计没有很好的处理递归，大多数当前的引擎不执行任何尾部调用优化。</p>
<p>而 Ramda 的源代码却使用了乱七八糟的丑陋的 <code>while</code> 循环。</p>
<p>这意味着 Ramda 的实现不能作为如何编写功能良好的 JavaScript 的模型（模板）。这太糟糕了。但它是目前的 JavaScript 引擎最实用的一种选择（方案）。</p>
<h2 id="he-li-de-api">合理的 API</h2>
<p>Ramda 还试图就 API 中应该包含什么做出实用的选择。我们并没有试图移植 Clojure、Haskell 或任何其他函数式语言中的任何特定的函数子集，也没有试图模仿更成熟的 JavaScript 库或规范的 API。我们采纳函数的标准是，它们表现出合理的效用。当然，它们也必须与我们的函数式范式相契合才会被考虑，但这还不够；我们必须确信它们将会被用到，并且它们提供了通过当前函数不容易实现的价值。</p>
<p>后者是比较棘手的。有一个平衡的方案，以确定什么情况下语法糖是可以接受的。在之前，我们讨论了 <code>compose</code> 有一个执行顺序相反孪生同胞 <code>pipe</code>。有一种观点认为这是一种浪费，我们不应该把 API 因为这些多余的函数而搞乱。毕竟，</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">R.pipe(fn1, fn2, ..., fnN)</div></pre></td></tr></table></figure></p>
<p>可以重写为如下形式：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">R.apply(R.compose, R.reverse([fn1, fn2, ..., fnN]));</div></pre></td></tr></table></figure></p>
<p>但是，我们确实选择将 <code>pipe</code> 以及其他一些看似多余的函数包含到其中，当它们符合下面的条件时：</p>
<ul>
<li>很有可能会被用到</li>
<li>能更好的表达开发人员的意图</li>
<li>足够简单的实现</li>
</ul>
<h2 id="zheng-ji-qie-yi-zhi-de-api">整洁且一致的 API</h2>
<p>对于整体一致 API 的追求，听起来不像是一个现实的考虑，更像是一个纯粹主义者的目标。但事实上，提供简单而一致的 API 使得 Ramda 更易于使用。例如，一旦你习惯了 Ramda 对参数顺序的设定，你将很少需要查阅文档以确定如何构建你的调用。</p>
<p>另外，Ramda 坚决反对可选参数。这个决定有助于形成非常整洁的 API。一个函数应该做什么以及如何调用，通常是非常直观的。</p>
<h2 id="bing-mei-you-shi-yao-hui-bang-zhu-wo-de-jian-yi">并没有 “什么会帮助我” 的建议</h2>
<p>最后，向某个人解释这个问题通常是最困难的，那就是一个用户对什么才是实用的概念与整个库的实用性实际上可能只有一点点关系。即使提出的函数有助于解决某个难题，如果问题太过狭隘，或者解决方案偏离了我们的基础哲学，那么它也不会被纳入到 Ramda 中。虽然实用性是在旁观者眼中反映出来的，但那些能够纵观整个库的旁观者会有一个宏观的不同的视野，只有那些能够在整体上提升 Ramda 的改变才会被采纳。</p>
<h1 id="jie-lun-sheng-er-bu-tong">结论：生而不同</h1>
<p>Ramda 的诞生是因为，没有任何其他的库能以我们想要的方式工作。我们想要将可以作用于不可变数据的小型可组合函数，组合成简洁的函数式的 pipeline （管道）。当 Ramda 与类似的库相比较时，这涉及到一些似乎颇具争议的决定。我们并不担心这一点。Ramda 为我们工作的很好，似乎也满足了<a href="https://github.com/ramda/ramda/stargazers" target="_blank" rel="external">社区的需求</a>。</p>
<p>我们不再孤单。自从我们开始以来，<a href="https://github.com/nullobject/fkit" target="_blank" rel="external">FKit</a> 也萌发了相似的想法。这是一个不太成熟的库，它的工作方式和 <a href="https://github.com/CrossEye/eweda" target="_blank" rel="external">Eweda</a> 一样，试图在 API 及其实现上同时保持真正的优雅。在我看来，他们很可能会遇到性能瓶颈。但是，我们无能为力，只能祝福他们。</p>
<p>Ramda 正在努力坚持它作为 “JavaScript 开发人员的实用的函数式库” 的座右铭。我们认为我们正在管理和维护 Ramda。但我们也<a href="https://github.com/ramda/ramda/issues" target="_blank" rel="external">很乐意倾听</a> 您的想法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/04/Functions-in-Functional-Programming/" itemprop="url">
                  函数式编程中的“函数们”
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-12-04T08:30:46+08:00" content="2017-12-04">
              2017-12-04
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/12/04/Functions-in-Functional-Programming/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/12/04/Functions-in-Functional-Programming/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>函数式编程中的函数有三种不同的解读方式，分别为纯函数、高阶函数和一等函数。本文分别对这三者的概念、应用和联系进行详解。</p>
<h1 id="chun-han-shu">纯函数</h1>
<p>定义：</p>
<blockquote>
<ol>
<li>相同的输入必定产生相同的输出；</li>
<li>在计算的过程中，不会产生副作用。</li>
</ol>
</blockquote>
<p>满足上述两个条件，我们就说该函数是纯函数。</p>
<p>纯函数也即数学意义上的函数，表达的是数据之间的转换（映射）关系，而非计算步骤的详述。数学函数的定义：</p>
<blockquote>
<p>函数通常由定义域 <em>X</em> 、值域 <em>Y</em> 以及定义域到值域的映射 <em>f</em> （<em>f: X -&gt; Y</em>）组成。</p>
</blockquote>
<p><img src="./function.png" alt="function"></p>
<p>纯函数让我们对写出的函数具有完全的控制能力。纯函数的结果 <strong>必须</strong> 只依赖于输入参数，不受外部环境的影响；同时纯函数在计算结果的过程中，也不会影响（污染）外部环境，即不会产生副作用。</p>
<h2 id="han-shu-zu-he">函数组合</h2>
<p>纯函数定义中的两个条件保证了它（的计算过程）与外界是完全隔离，这也是函数组合的基础。</p>
<p>只有函数组合中的所有函数都是纯函数，我们组合起来的新函数才会是纯函数。我们可以对使用纯函数组合出来的新函数从数学上证明（推导）其正确性，而无需借助大量的单元测试。</p>
<p>只要在函数组合时引入一个非纯函数，整个组合出来的函数将沦为非纯函数。如果将函数组合比作管道的拼接，只要组成管道的任何一小节有泄露或者外部注入，我们便失去了对整条管道的完全控制。</p>
<p><img src="./pipeline-leaking.png" alt="pipeline-leaking"></p>
<p>要想实现函数组合，还需要满足连续性，描述如下：</p>
<p>因为纯函数可以看作定义域到值域映射，待组合的函数中的上一个函数的值域须等于下一个函数的定义域，也即上一个函数的输出（类型）等于下一个的输入（类型）。</p>
<p>假设有两个函数：<em>f: X -&gt; Y</em> 和 <em>g: Y -&gt; Z</em>，只有 <code>codomain(f) = domain(g)</code> 时，<em>f</em> 和 <em>g</em> 才可以组合。</p>
<p><img src="./functions_composition.png" alt="function_composition"></p>
<h2 id="yin-yong-tou-ming-ji-huan-cun">引用透明及缓存</h2>
<p>在不改变整个程序行为的情况下，如果能将其中的一段代码替换为其执行的结果，我们就说这段代码是引用透明的。</p>
<p>因此，执行一段引用透明的代码（函数），对于相同的参数，总是给出相同的结果。我们也称这样的函数（代码）为纯函数。</p>
<p>引用透明的一个典型应用即函数缓存。我们可以将已经执行过的函数输入值缓存起来，下次调用时，若输入值相同，直接跳过计算过程，用缓存结果代替计算结果返回即可。</p>
<p>函数缓存的实现依赖于闭包，而闭包的实现又依赖于高阶函数，高阶函数的实现又依赖于一等函数。我们按照这条依赖链，从里往外依次对它们进行讲解。</p>
<h1 id="yi-deng-han-shu-first-class-functions">一等函数（First Class Functions）</h1>
<p>程序语言会对基本元素的使用方式进行限制，带有最少限制的元素被称为一等公民，其拥有的 “权利” 如下：</p>
<blockquote>
<ul>
<li>可以使用变量命名；</li>
<li>可以提供给函数作为参数；</li>
<li>可以由函数作为结果返回；</li>
<li>可以包含在数据结构中；</li>
</ul>
</blockquote>
<p>乍一看，我们应该首先会想到程序中的基本数据结构（如 number、array、object 等）是一等公民。如果函数也被视为一等公民，我们便可以像使用普通数据一样对其使用变量命名，作为参数或返回值使用，或者将其包含在数据结构中。在这里函数和数据的边界开始变得不再那么分明了。函数被视为一等公民后，其能力和适用范围被大大扩展了。</p>
<p>下面使用 JavaScript 对上面第一条和第四条 “权利” 进行讲解。第二、三条与高阶函数密切相关，将放到下一节的高阶函数中讲解。</p>
<h2 id="shi-yong-bian-liang-ming-ming">使用变量命名</h2>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x</div></pre></td></tr></table></figure></p>
<p>上面代码定义了一个求平方值的函数，并将其赋给了 square 变量。</p>
<h2 id="ke-yi-bao-han-zai-shu-ju-jie-gou-zhong">可以包含在数据结构中</h2>
<p><a href="http://ramda.cn/" target="_blank" rel="external">Ramda</a> 中有一个API：<a href="http://ramda.cn/docs/#evolve" target="_blank" rel="external">evolve</a>，其接受的首个参数便是一个属性值为函数的对象。<a href="http://ramda.cn/docs/#evolve" target="_blank" rel="external">evolve</a> 函数会递归地对 &quot;待处理对象&quot; 的属性进行变换，变换的方式由 transformation 内置函数属性值的对象定义。示例如下（示例中的 <code>R.xxx</code> 都是 <a href="http://ramda.cn/docs/" target="_blank" rel="external">Ramda</a> 中的API，相关API的功能可以参考<a href="http://ramda.cn/docs/" target="_blank" rel="external">Ramda</a>文档）：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> tomato  = &#123;<span class="attr">name</span>: <span class="string">'Tomato'</span>, <span class="attr">data</span>: &#123;<span class="attr">elapsed</span>: <span class="number">100</span>, <span class="attr">remaining</span>: <span class="number">1400</span>&#125;, <span class="attr">id</span>:<span class="number">123</span>&#125;;</div><div class="line"><span class="keyword">var</span> transformations = &#123;</div><div class="line">  <span class="attr">name</span>: R.toUpper,</div><div class="line">  <span class="attr">data</span>: &#123;<span class="attr">elapsed</span>: R.add(<span class="number">1</span>), <span class="attr">remaining</span>: R.add(<span class="number">-1</span>)&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">R.evolve(transformations)(tomato);</div><div class="line"><span class="comment">//=&gt; &#123;name: 'TOMATO', data: &#123;elapsed: 101, remaining: 1399&#125;, id:123&#125;</span></div></pre></td></tr></table></figure></p>
<h1 id="gao-jie-han-shu">高阶函数</h1>
<p>定义：</p>
<blockquote>
<p>使用函数作为输入参数，或者返回结果为函数的函数，被称为高阶函数。</p>
</blockquote>
<p>作为参数或返回值的函数，是一等函数的应用之一。高阶函数以一等函数作为基础，只有支持一等函数的语言才能进行高阶函数编程。</p>
<p>以熟悉的 <a href="http://ramda.cn/docs/#filter" target="_blank" rel="external">filter</a> 函数为例，我们可以用 <a href="http://ramda.cn/docs/#filter" target="_blank" rel="external">filter</a> 对列表中的元素进行过滤，筛选出符合条件的元素。<a href="http://ramda.cn/docs/#filter" target="_blank" rel="external">filter</a> 的类型签名和示例代码如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">filter :: (a → <span class="built_in">Boolean</span>) → [a] → [a]</div></pre></td></tr></table></figure></p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">n</span> =&gt;</span> n % <span class="number">2</span> === <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> filterEven = R.filter(isEven);</div><div class="line"></div><div class="line">filterEven([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]); <span class="comment">//=&gt; [2, 4]</span></div></pre></td></tr></table></figure></p>
<p><a href="http://ramda.cn/docs/#filter" target="_blank" rel="external">filter</a> 接受一个判断函数（判断输入值是否为偶数）<code>isEven</code>，返回一个过滤出偶数的函数 <code>filterEven</code>。</p>
<h1 id="bi-bao">闭包</h1>
<p>定义：</p>
<blockquote>
<p>闭包是由函数及该函数捕获的其上下文中的自由变量组成的记录</p>
</blockquote>
<p>举例讲：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> xIn = x;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">addInner</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> xIn + y;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">const</span> inc = add(<span class="number">1</span>);</div><div class="line">inc(<span class="number">8</span>); <span class="comment">//=&gt; 9;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> plus2 = add(<span class="number">2</span>);</div><div class="line">plus2(<span class="number">8</span>); <span class="comment">//=&gt; 10;</span></div></pre></td></tr></table></figure></p>
<p>上述代码中返回的函数 <code>addInner</code> 及由其捕获的在其上下文中定义的自由变量 <code>xIn</code>，便组成了一个闭包。</p>
<p><img src="./closure.png" alt="closure"></p>
<p>上述代码中最外层的 <code>add</code> 函数是一个高阶函数，其返回值为一等函数 <code>addInner</code>。</p>
<p>其实 <code>add</code> 函数的参数 <code>x</code> 也是 <code>addInner</code> 上下文的一部分，所以 'xIn' 也就没有存在的必要了，<code>add</code> 代码优化如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">addInner</span>(<span class="params">y</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> x + y;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>借助于箭头函数，我们可以进一步优化 <code>add</code> 的实现：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> add = <span class="function"><span class="params">x</span> =&gt;</span> y =&gt; x + y</div></pre></td></tr></table></figure></p>
<p>是不是非常简洁？由此我们可以一窥函数式编程强大的表达能力。</p>
<p>闭包主要用来做数据缓存，而数据缓存应用非常广泛：包括函数工厂模式、模拟拥有私有变量的对象、函数缓存、还有大名鼎鼎的柯里化。</p>
<p>其实上述代码中 <code>add</code> 函数便是柯里化形式的函数。</p>
<p>上述代码中的 <code>const inc = add(1);</code> 和 <code>const plus2 = add(2);</code> 是一种函数工厂模式，通过向 <code>add</code> 函数传入不同的参数，便会产生功能不同的函数。函数工厂可以提高函数的抽象和复用能力。</p>
<p>例如我们有一个如下形式的 Ajax 请求函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ajax = <span class="function"><span class="params">method</span> =&gt;</span> type =&gt; <span class="function"><span class="params">query</span> =&gt;</span> &#123; ... &#125;;</div><div class="line"></div><div class="line"><span class="keyword">const</span> get = ajax(<span class="string">'GET'</span>);</div><div class="line"><span class="keyword">const</span> post = ajax(<span class="string">'POST'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> getJson = get(<span class="string">'json'</span>);</div><div class="line"><span class="keyword">const</span> getHtml = ajax(<span class="string">'GET'</span>)(<span class="string">'text/html'</span>) = get(<span class="string">'text/html'</span>);</div></pre></td></tr></table></figure></p>
<p>我们抽象出了最一般的 <code>ajax</code> 请求函数，在具体应用时，我们用能通过函数工厂生产出作用不同的函数。</p>
<p>通过上面几个小节，我们讲解了纯函数（数学意义上的函数）、一等函数、高阶函数，还有闭包。</p>
<p>下面通过一个集上述所有概念于一身的 <strong>函数缓存</strong> ，来结束函数式编程中的 “函数们” 的论述。</p>
<h1 id="han-shu-huan-cun-memoize">函数缓存 memoize</h1>
<p>函数实现：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> memoize = <span class="function"><span class="params">pureFunc</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> cache = &#123;&#125;;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">const</span> argStr = <span class="built_in">JSON</span>.stringify(<span class="built_in">arguments</span>);</div><div class="line">    cache[argStr] = cache[argStr] || pureFunc.apply(pureFunc, <span class="built_in">arguments</span>);</div><div class="line">    <span class="keyword">return</span> cache[argStr];</div><div class="line">  &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><code>memoize</code> 的功能是对传入函数 <code>pureFunc</code> 进行缓存，返回缓存版本的 <code>pureFunc</code>。当我们使用参数调用缓存的函数时，缓存的函数会到 <code>cache</code> 中查找该参数是否被缓存过，如果有缓存，则不需要再次计算，直接返回已缓存值，否则对本次输入的参数进行计算，缓存计算的结果以备后用，然后将结果返回。</p>
<p><code>memoize</code> 只有对纯函数的缓存才有意义。因为纯函数是引用透明的，其输出只依赖于输入，并且计算过程不会影响外部环境。</p>
<p>举一个极端的例子，假如我们有一个随机数字生成函数 <code>random()</code>, 如果对其进行了缓存：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> memoizedRandom = memoize(random);</div></pre></td></tr></table></figure></p>
<p><code>memoizedRandom</code> 除了第一次生成一个随机值外，随后的调用都返回第一次缓存的值，这样就失去了 <code>random</code> 的意义。再假如，我们对终端字符输入函数 <code>getchar()</code> 进行了缓存，每次调用都会是第一次获取的字母。</p>
<p><code>memoize</code> 内部实现了一个闭包的创建。返回的缓存函数和自由变量 <code>cache</code> 共同构成了一个闭包。自由变量 <code>cached</code> 用于对已经计算过的数据（参数）的缓存。而闭包本身是由高阶函数和一等函数实现的。</p>
<p><img src="./functions-in-memoize.png" alt="functions-in-memoize"></p>
<h1 id="zong-jie">总结</h1>
<p>本文对函数式编程中的 “函数们” 做了详细解释：纯函数、一等函数、高阶函数，并展示了它们的应用。其中纯函数是函数组合的基础；一等函数是高阶函数的实现基础，一等函数和高阶函数又是闭包的实现基础。</p>
<p>最后通过函数缓存函数 <code>memoize</code> 将纯函数、一等函数、高阶函数和闭包联系了起来，用函数式编程中的 “函数们” （函数式三镖客）的一次 “联合行动” 结束本文。</p>
<h1 id="can-kao-wen-dang">参考文档</h1>
<p><a href="http://www.mathsisfun.com/sets/function.html" target="_blank" rel="external">What is a Function?</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">Functional Programming</a>.</p>
<p><a href="https://en.wikipedia.org/wiki/Referential_transparency" target="_blank" rel="external">Referential Transparency</a>.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/11/Practical-Ramda-Recursion/" itemprop="url">
                  Practical Ramda: Recursion
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-11-11T00:10:07+08:00" content="2017-11-11">
              2017-11-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Practical-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Practical Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/11/11/Practical-Ramda-Recursion/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/11/11/Practical-Ramda-Recursion/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文首先介绍了递归的定义、实质、满足条件等，然后利用 Ramda API 和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="external">Spread &amp; Rest</a> 操作符对递归进行实例讲解。</p>
<h1 id="di-gui-de-li-lun-ji-chu">递归的理论基础</h1>
<p>递归的定义：一种直接或者间接调用自身的过程。</p>
<p>递归的实质：将待求解问题分解成规模缩小的同类子问题，然后递归调用方法来表示问题的解。是一个不断将问题拆分然后组合的过程。</p>
<p>递归的过程：“能进则进，不进则退”。</p>
<p>递归问题需满足的条件：</p>
<ol>
<li>一个（或多个）基本情景 -- 一个不使用递归而产生结果的终止情景；</li>
<li>一组可以将所有其他情景归约至基本情景的规则。</li>
</ol>
<p>递归的条件归结为：一个终止条件和一组归约的规则。</p>
<p>递归能让我们写出非常简洁、直观的代码，但简洁并不等于简单（容易）。递归是一种从总体到局部的思维过程，与传统的命令式的思维方式差异较大。命令式思维要求显示地提供详细的求解步骤，而递归（或者函数式）要求用概括性的语言对问题进行描述，问题的描述本身就是编程的整个过程，这要求我们具有很强的抽象思维和逻辑推理能力。</p>
<p>递归的编程模式：</p>
<ol>
<li>定义终止条件；</li>
<li>编写递归的归约规则。</li>
</ol>
<p>但如果语言中实现了惰性求值，也可以不定义终止条件，比如递归生成无限长的序列。</p>
<p>以上便是递归的理论解释，下面我们通过一些实例对递归进行实际演示。</p>
<h1 id="di-gui-de-shi-jian">递归的实践</h1>
<p>递归能够很好地处理列表和树形数据结构的很多问题。很多时候，我们解决问题的模式就是对不断缩小的列表或树反复做同一件事情。实际上，列表和树本身的构造也可以看做递归的过程。</p>
<p>列表可以看作有列表首元素（头部）和其余元素（尾部）的组合，如下所示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = R.prepend(<span class="number">1</span>, R.prepend(<span class="number">2</span>, R.prepend(<span class="number">3</span>, []))); <span class="comment">// =&gt; [1, 2, 3]</span></div><div class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, ...[<span class="number">2</span>, ...[<span class="number">3</span>, ...[]]]];</div></pre></td></tr></table></figure></p>
<p>本文中我们使用 ramda 和 expect npm库进行演示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> R = <span class="built_in">require</span>(<span class="string">'ramda'</span>);</div><div class="line"><span class="keyword">const</span> expect = <span class="built_in">require</span>(<span class="string">'expect'</span>);</div></pre></td></tr></table></figure></p>
<h2 id="kuai-su-pai-xu">快速排序</h2>
<p>下面以经典的快速排序为例开始递归算法的演示。快排的定义为：所有小于头部的元素（它们也需要排序）在先，大于头部的元素（它们也需要排序）在后，终止条件为空数组。</p>
<p>首先我们用模式匹配 <a href="http://ramda.cn/docs/#cond" target="_blank" rel="external">R.cond</a> 的方式来进行递归排序。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quickSort = R.cond(</div><div class="line">  [R.isEmpty, R.always([])],</div><div class="line">  [</div><div class="line">    R.T,</div><div class="line">    xs =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> head = R.head(xs);</div><div class="line">    <span class="keyword">const</span> tail = R.tail(xs);</div><div class="line">    <span class="keyword">return</span> R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail)</div><div class="line">     .concat(head)</div><div class="line">     .concat(R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail));</div><div class="line">  &#125;]</div><div class="line">);</div><div class="line"></div><div class="line">expect(quickSort([<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>])).toEqual([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]);</div></pre></td></tr></table></figure></p>
<p>快排的过程如下所示（借用 <a href="http://learnyouahaskell.com/recursion" target="_blank" rel="external">Learn You a Haskell for Great Good!</a> 的图)：</p>
<p><img src="./quicksort.png" alt="quicksort"></p>
<p>如果只有一个 <code>if-else</code> 对，我们也可以使用 <a href="http://ramda.cn/docs/#ifElse" target="_blank" rel="external">R.ifElse</a> 来代替 <a href="http://ramda.cn/docs/#cond" target="_blank" rel="external">R.cond</a>。另外，我们还可以用 <a href="http://ramda.cn/docs/#when" target="_blank" rel="external">R.when</a> 和 <a href="http://ramda.cn/docs/#unless" target="_blank" rel="external">R.unless</a> 来进一步简化 <a href="http://ramda.cn/docs/#ifElse" target="_blank" rel="external">R.ifElse</a>。</p>
<p>使用 Ramda API 的递归规则还是有些冗长，我们可以使用 ES6 中的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="external">Spread &amp; Rest</a> 操作符和 <a href="http://ramda.cn/docs/#unless" target="_blank" rel="external">R.unless</a> 对列表的头部元素和其他尾部元素的提取和组合进行简化，如下所示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> quickSort = R.unless(</div><div class="line">  R.isEmpty,</div><div class="line">  ([head, ...tail]) =&gt; [</div><div class="line">    ...R.compose(quickSort, R.filter(R.lte(R.__, head)))(tail),</div><div class="line">    head,</div><div class="line">    ...R.compose(quickSort, R.filter(R.gte(R.__, head)))(tail),</div><div class="line">  ]</div><div class="line">);</div><div class="line"></div><div class="line">expect(quickSort([<span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>])).toEqual([<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>]);</div></pre></td></tr></table></figure></p>
<h2 id="fei-bo-na-qi-xu-lie">斐波那契序列</h2>
<p>下面展示的是斐波那契序列, 斐波那契序列的数学表达式如下所示：</p>
<ul>
<li>f(0) = 0</li>
<li>f(1) = 1</li>
<li>f(n) = f(n-1) + f(n-2)</li>
</ul>
<p>以序列元素值为半径的斐波那契螺旋线如下所示：</p>
<p><img src="./fibonacci.jpg" alt="fibonacci"></p>
<p>代码实现如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fib = <span class="function"><span class="params">n</span> =&gt;</span> R.unless(</div><div class="line">  R.contains(R.__, [<span class="number">0</span>, <span class="number">1</span>]),</div><div class="line">  () =&gt; fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</div><div class="line">)(n);</div><div class="line"></div><div class="line">expect(fib(<span class="number">6</span>)).toEqual(<span class="number">8</span>);</div></pre></td></tr></table></figure></p>
<h2 id="map-filter-reduce">map、filter、reduce</h2>
<p><a href="http://ramda.cn/docs/#map" target="_blank" rel="external">map</a>、<a href="http://ramda.cn/docs/#filter" target="_blank" rel="external">filter</a>、<a href="http://ramda.cn/docs/#reduce" target="_blank" rel="external">reduce</a> 作为函数式编程中处理列表的三个基本函数，在底层实现或者演示时，一般会采用命令式的 for 循环迭代来实现，既然列表本身可以看作递归结构，我们就用递归来尝试实现函数式编程中处理列表的 &quot;三镖客&quot;。</p>
<p>首先以 <code>map</code> 为例，从命令式 for 循环实现开始，然后是递归实现，并在对递归实现的优化中展示函数式编程（或者说 Ramda 库）灵活、多变而又优雅的编程方式，体会什么才是真正的编程之美。</p>
<p>map 的 <a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch7.html" target="_blank" rel="external">Hindley-Milner</a> 类型签名如下所示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map :: Functor f =&gt; (a → b) → f a → f b</div></pre></td></tr></table></figure></p>
<p>其实 <code>map</code> 是 <a href="https://en.wikipedia.org/wiki/Functor" target="_blank" rel="external">Functor</a> 的一个函数，Functor 是具体范畴之间的映射（态射），关于范畴、Functor、态射等函数式的概念不在本次的讨论范围之内，感兴趣的同学可以自己查看相关资料。在这里，可以将 Functor 看做是列表（列表是 Functor 的一个实例），<code>map</code> 看作不同类型列表之间的映射，将源列表中的元素进行转换，生成一个包含映射后元素的新列表。</p>
<p><code>map</code> 列表形式的类型签名如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map :: (a → b) → [a] → [b]</div></pre></td></tr></table></figure></p>
<p><code>map</code> 命令式实现：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = <span class="function">(<span class="params">fn, list</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">var</span> newList = [];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</div><div class="line">    newList[i] = fn(list[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> newList;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">expect(map(R.multiply(<span class="number">2</span>), R.range(<span class="number">1</span>, <span class="number">5</span>))).toEqual([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>]);</div></pre></td></tr></table></figure></p>
<p><code>map</code> 递归实现1，三目运算符版：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mapR = <span class="function">(<span class="params">fn, list</span>) =&gt;</span></div><div class="line">  (R.isEmpty(list) ? list : R.prepend(fn(R.head(list)), mapR(fn, R.tail(list))));</div></pre></td></tr></table></figure></p>
<p><code>map</code> 递归实现2，模式匹配（<a href="http://ramda.cn/docs/#cond" target="_blank" rel="external">R.cond</a>）版：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mapR2 = <span class="function">(<span class="params">fn, list</span>) =&gt;</span> R.cond([</div><div class="line">  [R.isEmpty, R.identity],</div><div class="line">  [R.T, R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR2(fn, R.tail(xs))])],</div><div class="line">])(list);</div></pre></td></tr></table></figure></p>
<p><code>map</code> 递归实现3，unless（<a href="http://ramda.cn/docs/#unless" target="_blank" rel="external">R.unless</a>）版：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mapR3 = <span class="function">(<span class="params">fn, list</span>) =&gt;</span> R.unless(</div><div class="line">  R.isEmpty,</div><div class="line">  R.converge(R.prepend, [R.compose(fn, R.head), xs =&gt; mapR3(fn, R.tail(xs))])</div><div class="line">)(list);</div></pre></td></tr></table></figure></p>
<p><code>map</code> 递归实现4，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="external">Spread Operator</a>  + unless 版：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> mapR5 = <span class="function">(<span class="params">fn, xs</span>) =&gt;</span> R.unless(</div><div class="line">  R.isEmpty,</div><div class="line">  ([head, ...tail]) =&gt; [fn(head), ...mapR5(fn, tail)]</div><div class="line">)(xs);</div></pre></td></tr></table></figure></p>
<p>总结一下上述命令式、递归实现以及递归的优化实现的特点。</p>
<p>命令式实现需要显式写出内部的每步实现步骤，包括如何获取、变换和组合元素等；还使用了 mutable 的数据，包括全局的结果列表 <code>newList</code> 和 迭代索引 <code>i</code>。命令式的好处是符合正常的思维方式，但缺点是引入了较多冗余的 &quot;噪声&quot;，比如 for 循环、全局变量 <code>newList</code> 和 <code>i</code> 都是辅助项，这些辅助项稍微增多，代码复杂度会显著上升，真正有用的信息便会淹没在了这些 &quot;噪声&quot; 里面。</p>
<p>反观递归式（函数式）的实现（如 <code>map</code> 的 <code>Spead Operator</code> + <code>unless</code> 版实现），我们只需要通过对问题的描述，便得到功能的实现。而描述的过程看似简单，实则内含了对问题本质的抽象和逻辑分析，对人们的思维能力要求更高。</p>
<p>再讲一下 <code>Spead Operator</code> 语法糖。很多人不屑于用语法糖，态度往往是：这不就是 xxx 的语法糖吗？没什么大不了的啊。但语法上的便利其实也是很重要的一方面，因为我们想要表达的思想是要由语法来承载的。</p>
<p>这里引用《函数式编程思维》中的一段话：</p>
<blockquote>
<p>我跟 Martin Fowler 在巴塞罗那的一辆出租车上有过一次记忆深刻的讨论，我们聊的是 Smalltalk 的衰落和 Java 的兴盛。Fowler 在这两种语言上都有很深厚的积累，他说，起初 他觉得从 Smalltalk 到 Java 的变化只是一些语法上的不便，结果却发现被阻碍的还有原先 语言所承载的思维方式。在语法处处掣肘下塑造出来的抽象，很难配合我们的思维过程而 不产生无谓的摩擦。</p>
</blockquote>
<p>下面对 <code>filter</code> 和 <code>reduce</code> 的递归实现做一个展示。</p>
<p><code>filter</code> 的递归实现如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> filterR = <span class="function">(<span class="params">pred, list</span>) =&gt;</span></div><div class="line">  R.isEmpty(list) ? list : pred(R.head(list)) ? R.prepend(R.head(list), filterR(pred, R.tail(list))) : filterR(pred, R.tail(list));</div><div class="line"></div><div class="line"><span class="keyword">var</span> filterR2 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.cond([</div><div class="line">  [R.isEmpty, R.identity],</div><div class="line">  [R.compose(pred, R.head), R.converge(R.prepend, [R.head, xs =&gt; filterR2(pred, R.tail(xs))])],</div><div class="line">  [R.T, xs =&gt; filterR2(pred, R.tail(xs))],</div><div class="line">])(list);</div><div class="line"></div><div class="line"><span class="keyword">var</span> filterR3 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.unless(</div><div class="line">  R.isEmpty,</div><div class="line">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</div><div class="line">)(list);</div><div class="line"></div><div class="line"><span class="keyword">var</span> filterR3 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.unless(</div><div class="line">  R.isEmpty,</div><div class="line">  R.converge(R.concat, [R.compose(R.ifElse(pred, R.of, R.always([])), R.head), xs =&gt; filterR3(pred, R.tail(xs))])</div><div class="line">)(list);</div><div class="line"></div><div class="line"><span class="keyword">var</span> filterR4 = <span class="function">(<span class="params">pred, list</span>) =&gt;</span> R.unless(</div><div class="line">  R.isEmpty,</div><div class="line">  ([head, ...tail]) =&gt; [...(pred(head) ? [head] : []), ...filterR4(pred, tail)]</div><div class="line">)(list);</div><div class="line"></div><div class="line">expect(filterR(<span class="function"><span class="params">a</span> =&gt;</span> a % <span class="number">2</span>, R.range(<span class="number">1</span>, <span class="number">10</span>))).toEqual([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]);</div></pre></td></tr></table></figure></p>
<p>reduce 的递归实现如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reduceR = <span class="function">(<span class="params">fn, acc, list</span>) =&gt;</span></div><div class="line">  (R.isEmpty(list) ? acc : reduceR(fn, fn(acc, R.head(list)), R.tail(list)));</div><div class="line"></div><div class="line"><span class="keyword">var</span> reduceR2 = <span class="function">(<span class="params">fn, acc, list</span>) =&gt;</span> R.cond([</div><div class="line">  [R.isEmpty, () =&gt; acc],</div><div class="line">  [R.T, xs =&gt; reduceR2(fn, fn(acc, R.head(xs)), R.tail(xs))],</div><div class="line">])(list);</div><div class="line"></div><div class="line"><span class="keyword">var</span> reduceR3 = <span class="function">(<span class="params">fn, acc, list</span>) =&gt;</span> R.ifElse(</div><div class="line">  R.isEmpty,</div><div class="line">  () =&gt; acc,</div><div class="line">  xs =&gt; reduceR3(fn, fn(acc, R.head(xs)), R.tail(xs))</div><div class="line">)(list);</div><div class="line"></div><div class="line">expect(reduceR(R.add, <span class="number">0</span>, R.range(<span class="number">1</span>, <span class="number">5</span>))).toEqual(<span class="number">10</span>);</div></pre></td></tr></table></figure></p>
<h1 id="zong-jie">总结</h1>
<p>本文从递归的定义、实质等基本理论开始，然后是递归的一些实例，其中大量运用了 <a href="http://ramda.cn" target="_blank" rel="external">ramda</a> 函数式编程库中的 API，既是对递归的演示，也是对 ramda API 的实践展示。展示了递归和函数式在编程时的强悍的表达能力和对极致简约的追求。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/21/What-Function-Should-I-Use/" itemprop="url">
                  Ramda 函数简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-10-21T07:25:36+08:00" content="2017-10-21">
              2017-10-21
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/21/What-Function-Should-I-Use/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/10/21/What-Function-Should-I-Use/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Ramda API 已经快到 300 个了，对每个 API 按类型分别进行简介，当作 Ramda 的一份 CheatSheet 。</p>
<h1 id="lie-biao">列表</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">列表转换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#map" target="_blank" rel="external">map</a></td>
</tr>
<tr>
<td style="text-align:left">列表过滤：过滤出符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#filter" target="_blank" rel="external">filter</a></td>
</tr>
<tr>
<td style="text-align:left">列表过滤：过滤掉符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reject" target="_blank" rel="external">reject</a></td>
</tr>
<tr>
<td style="text-align:left">列表折叠：从左向右对所有元素依次归约（折叠）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduce" target="_blank" rel="external">reduce</a></td>
</tr>
<tr>
<td style="text-align:left">列表折叠：从右向左对所有元素依次归约（折叠）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduceRight" target="_blank" rel="external">reduceRight</a></td>
</tr>
<tr>
<td style="text-align:left">列表折叠(增强版)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#transduce" target="_blank" rel="external">transduce</a></td>
</tr>
<tr>
<td style="text-align:left">列表去重</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uniq" target="_blank" rel="external">uniq</a></td>
</tr>
<tr>
<td style="text-align:left">列表去重：对处理后的元素做相等性判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uniqBy" target="_blank" rel="external">uniqBy</a></td>
</tr>
<tr>
<td style="text-align:left">列表去重：通过断言函数（predicate）判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uniqWith" target="_blank" rel="external">uniqWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表排序</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#sort" target="_blank" rel="external">sort</a></td>
</tr>
<tr>
<td style="text-align:left">列表翻转</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reverse" target="_blank" rel="external">reverse</a></td>
</tr>
<tr>
<td style="text-align:left">列表拼接</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#concat" target="_blank" rel="external">concat</a></td>
</tr>
<tr>
<td style="text-align:left">列表长度</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#length" target="_blank" rel="external">length</a></td>
</tr>
<tr>
<td style="text-align:left">列表表头拼接元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#prepend" target="_blank" rel="external">prepend</a></td>
</tr>
<tr>
<td style="text-align:left">列表表尾拼接元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#append" target="_blank" rel="external">append</a></td>
</tr>
<tr>
<td style="text-align:left">更新指定索引处的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#adjust" target="_blank" rel="external">adjust</a></td>
</tr>
<tr>
<td style="text-align:left">替换指定索引处的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#update" target="_blank" rel="external">update</a></td>
</tr>
<tr>
<td style="text-align:left">将列表元素转换为其指定的属性值，等价于 R.map(R.prop)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pluck" target="_blank" rel="external">pluck</a></td>
</tr>
<tr>
<td style="text-align:left">为列表迭代函数添加两个参数：索引和整个列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#addIndex" target="_blank" rel="external">addIndex</a></td>
</tr>
<tr>
<td style="text-align:left">取出特定索引范围内的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#slice" target="_blank" rel="external">slice</a></td>
</tr>
<tr>
<td style="text-align:left">将列表通过分隔符拼接成字符串</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#join" target="_blank" rel="external">join</a></td>
</tr>
<tr>
<td style="text-align:left">取出第 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#nth" target="_blank" rel="external">nth</a></td>
</tr>
<tr>
<td style="text-align:left">取出前 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#take" target="_blank" rel="external">take</a></td>
</tr>
<tr>
<td style="text-align:left">取出后 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#takeLast" target="_blank" rel="external">takeLast</a></td>
</tr>
<tr>
<td style="text-align:left">从前往后取出满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#takeWhile" target="_blank" rel="external">takeWhile</a></td>
</tr>
<tr>
<td style="text-align:left">从后向前取出满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#takeLastWhile" target="_blank" rel="external">takeLastWhile</a></td>
</tr>
<tr>
<td style="text-align:left">删除前 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#drop" target="_blank" rel="external">drop</a></td>
</tr>
<tr>
<td style="text-align:left">删除后 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dropLast" target="_blank" rel="external">dropLast</a></td>
</tr>
<tr>
<td style="text-align:left">从前往后删除满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dropWhile" target="_blank" rel="external">dropWhile</a></td>
</tr>
<tr>
<td style="text-align:left">从后向前删除满足条件的元素，直至不满足条件的首个元素止</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dropLastWhile" target="_blank" rel="external">dropLastWhile</a></td>
</tr>
<tr>
<td style="text-align:left">取出首个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#head" target="_blank" rel="external">head</a></td>
</tr>
<tr>
<td style="text-align:left">取出末尾元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#taillast" target="_blank" rel="external">last</a></td>
</tr>
<tr>
<td style="text-align:left">取出前 length - 1 个元素（删除末尾元素）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#init" target="_blank" rel="external">init</a></td>
</tr>
<tr>
<td style="text-align:left">取出后 length - 1 个元素（删除首个元素）</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#tail" target="_blank" rel="external">tail</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∈xs ∩ a∉ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#difference" target="_blank" rel="external">difference</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∉xs ∩ a∈ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#without" target="_blank" rel="external">without</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：根据条件计算第一个列表与第二个列表的差集</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#differenceWith" target="_blank" rel="external">differenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifference" target="_blank" rel="external">symmetricDifference</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifferenceWith" target="_blank" rel="external">symmetricDifferenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：{xs ∩ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#intersection" target="_blank" rel="external">intersection</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#innerJoin" target="_blank" rel="external">innerJoin</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：{xs ∪ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#union" target="_blank" rel="external">union</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：根据条件判断两元素是否重复</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unionWith" target="_blank" rel="external">unionWith</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中首个满足条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#find" target="_blank" rel="external">find</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中首个满足条件的元素的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#findIndex" target="_blank" rel="external">findIndex</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中最后一个满足条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#findLast" target="_blank" rel="external">findLast</a></td>
</tr>
<tr>
<td style="text-align:left">查找列表中最后一个满足条件的元素的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#findLastIndex" target="_blank" rel="external">findLastIndex</a></td>
</tr>
<tr>
<td style="text-align:left">查找给定元素在列表中首次出现时的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#indexOf" target="_blank" rel="external">indexOf</a></td>
</tr>
<tr>
<td style="text-align:left">查找给定元素在列表中末次出现时的索引</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lastIndexOf" target="_blank" rel="external">lastIndexOf</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断元素是否包含在列表中</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#contains" target="_blank" rel="external">contains</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断是否列表中所有元素都满足条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#all" target="_blank" rel="external">all</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断是否列表中所有元素都不满足条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#none" target="_blank" rel="external">none</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断是否列表中存在满足条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#any" target="_blank" rel="external">any</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断列表是否以给定的值开头</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#startsWith" target="_blank" rel="external">startsWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表判断：判断列表是否以给定的值结尾</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#endsWith" target="_blank" rel="external">endsWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表分组：按是否符合条件，将元素分为两组</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#partition" target="_blank" rel="external">partition</a></td>
</tr>
<tr>
<td style="text-align:left">列表分组：对列表中元素按指定规则分组</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#groupBy" target="_blank" rel="external">groupBy</a></td>
</tr>
<tr>
<td style="text-align:left">列表分段：对列表中元素按指定规则分段</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#groupWith" target="_blank" rel="external">groupWith</a></td>
</tr>
<tr>
<td style="text-align:left">列表分组：对列表中元素按指定规则分组折叠</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduceBy" target="_blank" rel="external">reduceBy</a></td>
</tr>
<tr>
<td style="text-align:left">列表分割：在指定索引处</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#splitAt" target="_blank" rel="external">splitAt</a></td>
</tr>
<tr>
<td style="text-align:left">列表分割：每隔 N 个元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#splitEvery" target="_blank" rel="external">splitEvery</a></td>
</tr>
<tr>
<td style="text-align:left">列表分割：按条件分割</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#splitWhen" target="_blank" rel="external">splitWhen</a></td>
</tr>
<tr>
<td style="text-align:left">对两个列表相同位置的元素进行组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#zip" target="_blank" rel="external">zip</a></td>
</tr>
<tr>
<td style="text-align:left">对两个列表相同位置的元素进行键值对组合，fromPairs ∘ zip</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#zipObj" target="_blank" rel="external">zipObj</a></td>
</tr>
<tr>
<td style="text-align:left">对两个列表相同位置的元素按规则进行组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#zipWith" target="_blank" rel="external">zipWith</a></td>
</tr>
<tr>
<td style="text-align:left">由一系列键值对列表创建对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#fromPairs" target="_blank" rel="external">fromPairs</a></td>
</tr>
<tr>
<td style="text-align:left">列表彻底扁平化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#flatten" target="_blank" rel="external">flatten</a></td>
</tr>
<tr>
<td style="text-align:left">列表单层扁平化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unnest" target="_blank" rel="external">unnest</a></td>
</tr>
<tr>
<td style="text-align:left">先对列表内元素做 Kleisli 映射，再做扁平化，flatMap，&gt;&gt;=</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#chain" target="_blank" rel="external">chain</a></td>
</tr>
<tr>
<td style="text-align:left">函子间的自然变化？</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#sequence" target="_blank" rel="external">sequence</a></td>
</tr>
<tr>
<td style="text-align:left">列表插入</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#insert" target="_blank" rel="external">insert</a></td>
</tr>
<tr>
<td style="text-align:left">将子列表插入列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#insertAll" target="_blank" rel="external">insertAll</a></td>
</tr>
<tr>
<td style="text-align:left">在列表元素之间插入分割元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#intersperse" target="_blank" rel="external">intersperse</a></td>
</tr>
<tr>
<td style="text-align:left">列表转换 + 折叠？</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#into" target="_blank" rel="external">into</a></td>
</tr>
<tr>
<td style="text-align:left">将 reduce 的迭代过程记录下来</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mapAccum" target="_blank" rel="external">mapAccum</a></td>
</tr>
<tr>
<td style="text-align:left">将 reduceRight 的迭代过程记录下来</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mapAccumRight" target="_blank" rel="external">mapAccumRight</a></td>
</tr>
<tr>
<td style="text-align:left">合并多个对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeAll" target="_blank" rel="external">mergeAll</a></td>
</tr>
<tr>
<td style="text-align:left">由两个参数组成列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pair" target="_blank" rel="external">pair</a></td>
</tr>
<tr>
<td style="text-align:left">从 reduce 或 transduce 中提前退出迭代时的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduced" target="_blank" rel="external">reduced</a></td>
</tr>
<tr>
<td style="text-align:left">可以提前退出的 reduce 迭代</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#reduceWhile" target="_blank" rel="external">reduceWhile</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：生成左闭右开的升序数字列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#range" target="_blank" rel="external">range</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：生成含有 N 个同一元素的列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#repeat" target="_blank" rel="external">repeat</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：函数执行 N 次，生成 N 元列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#times" target="_blank" rel="external">times</a></td>
</tr>
<tr>
<td style="text-align:left">列表生成：通过迭代函数生成列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unfold" target="_blank" rel="external">unfold</a></td>
</tr>
<tr>
<td style="text-align:left">二维列表行列式转换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#transpose" target="_blank" rel="external">transpose</a></td>
</tr>
<tr>
<td style="text-align:left">二维列表生成</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#xprod" target="_blank" rel="external">xprod</a></td>
</tr>
</tbody>
</table>
<h1 id="han-shu">函数</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">函数组合：纵向，从右往左</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#compose" target="_blank" rel="external">compose</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：纵向，从左往右</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pipe" target="_blank" rel="external">pipe</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：纵向</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#o" target="_blank" rel="external">o</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：横向</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#converge" target="_blank" rel="external">converge</a></td>
</tr>
<tr>
<td style="text-align:left">函数组合：横向</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#useWith" target="_blank" rel="external">useWith</a></td>
</tr>
<tr>
<td style="text-align:left">Kleisili 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#composeK" target="_blank" rel="external">composeK</a></td>
</tr>
<tr>
<td style="text-align:left">Kleisili 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pipeK" target="_blank" rel="external">pipeK</a></td>
</tr>
<tr>
<td style="text-align:left">Promise 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#composeP" target="_blank" rel="external">composeP</a></td>
</tr>
<tr>
<td style="text-align:left">Promise 函数组合</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pipeP" target="_blank" rel="external">pipeP</a></td>
</tr>
<tr>
<td style="text-align:left">单位函数：输出等于输入</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#identity" target="_blank" rel="external">identity</a></td>
</tr>
<tr>
<td style="text-align:left">函数柯里化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#curry" target="_blank" rel="external">curry</a></td>
</tr>
<tr>
<td style="text-align:left">N 元函数柯里化</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#curryN" target="_blank" rel="external">curryN</a></td>
</tr>
<tr>
<td style="text-align:left">将柯里化函数 转为 N 元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#uncurryN" target="_blank" rel="external">uncurryN</a></td>
</tr>
<tr>
<td style="text-align:left">柯里化函数的参数占位符</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#__" target="_blank" rel="external">__</a></td>
</tr>
<tr>
<td style="text-align:left">参数部分调用：从左往右</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#partial" target="_blank" rel="external">partial</a></td>
</tr>
<tr>
<td style="text-align:left">参数部分调用：从右往左</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#partialRight" target="_blank" rel="external">partialRight</a></td>
</tr>
<tr>
<td style="text-align:left">函数缓存</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#memoize" target="_blank" rel="external">memoize</a></td>
</tr>
<tr>
<td style="text-align:left">函数缓存：可以自定义缓存键值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#memoizeWith" target="_blank" rel="external">memoizeWith</a></td>
</tr>
<tr>
<td style="text-align:left">只执行一次的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#once" target="_blank" rel="external">once</a></td>
</tr>
<tr>
<td style="text-align:left">创建返回恒定值的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#always" target="_blank" rel="external">always</a></td>
</tr>
<tr>
<td style="text-align:left">恒定返回 <code>true</code> 的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#T" target="_blank" rel="external">T</a></td>
</tr>
<tr>
<td style="text-align:left">恒定返回 <code>false</code>  的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#F" target="_blank" rel="external">F</a></td>
</tr>
<tr>
<td style="text-align:left">Applicative Functor 的 ap 方法，&lt;*&gt;</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#ap" target="_blank" rel="external">ap</a></td>
</tr>
<tr>
<td style="text-align:left">将函数作用于参数列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#apply" target="_blank" rel="external">apply</a></td>
</tr>
<tr>
<td style="text-align:left">将接受 <strong>单列表参数</strong> 的函数转为接受 <strong>普通参数列表</strong> 的函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unapply" target="_blank" rel="external">unapply</a></td>
</tr>
<tr>
<td style="text-align:left">将首个参数（函数）作用于其余参数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#call" target="_blank" rel="external">call</a></td>
</tr>
<tr>
<td style="text-align:left">绑定函数上下文</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#bind" target="_blank" rel="external">bind</a></td>
</tr>
<tr>
<td style="text-align:left">利用属性值为函数的对象生成同构对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#applySpec" target="_blank" rel="external">applySpec</a></td>
</tr>
<tr>
<td style="text-align:left">将函数列表作用于参数列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#juxt" target="_blank" rel="external">juxt</a></td>
</tr>
<tr>
<td style="text-align:left">将给定值传给给定函数，CPS: flip($)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#applyTo" target="_blank" rel="external">applyTo</a></td>
</tr>
<tr>
<td style="text-align:left">比较函数，一般用于排序</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#comparator" target="_blank" rel="external">comparator</a></td>
</tr>
<tr>
<td style="text-align:left">升序比较函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#ascend" target="_blank" rel="external">ascend</a></td>
</tr>
<tr>
<td style="text-align:left">降序比较函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#descend" target="_blank" rel="external">descend</a></td>
</tr>
<tr>
<td style="text-align:left">将函数封装为 N 元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#nArg" target="_blank" rel="external">nArg</a></td>
</tr>
<tr>
<td style="text-align:left">将函数封装为一元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unary" target="_blank" rel="external">unary</a></td>
</tr>
<tr>
<td style="text-align:left">将函数封装为二元函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#binary" target="_blank" rel="external">binary</a></td>
</tr>
<tr>
<td style="text-align:left">提取第 N 个参数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#nthArg" target="_blank" rel="external">nthArg</a></td>
</tr>
<tr>
<td style="text-align:left">将构造函数封装为普通函数，创建实例时，不需要 new 操作符</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#construct" target="_blank" rel="external">construct</a></td>
</tr>
<tr>
<td style="text-align:left">将构造函数封装为 N 元普通函数，创建实例时，不需要 new 操作符</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#constructN" target="_blank" rel="external">constructN</a></td>
</tr>
<tr>
<td style="text-align:left">通过函数名调用函数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#invoker" target="_blank" rel="external">invoker</a></td>
</tr>
<tr>
<td style="text-align:left">创建相应类型的空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#empty" target="_blank" rel="external">empty</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否为空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isEmpty" target="_blank" rel="external">isEmpty</a></td>
</tr>
<tr>
<td style="text-align:left">交换函数前两个参数的位置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#flip" target="_blank" rel="external">flip</a></td>
</tr>
<tr>
<td style="text-align:left">函数提升</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lift" target="_blank" rel="external">lift</a></td>
</tr>
<tr>
<td style="text-align:left">N 元函数提升</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#liftN" target="_blank" rel="external">liftN</a></td>
</tr>
<tr>
<td style="text-align:left">生成单元素列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#of" target="_blank" rel="external">of</a></td>
</tr>
<tr>
<td style="text-align:left">输出等于输入，但产生副作用的函数，一般用于调试</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#tap" target="_blank" rel="external">tap</a></td>
</tr>
<tr>
<td style="text-align:left">异常捕获</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#tryCatch" target="_blank" rel="external">tryCatch</a></td>
</tr>
</tbody>
</table>
<h1 id="dui-xiang">对象</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">属性设置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#assoc" target="_blank" rel="external">assoc</a></td>
</tr>
<tr>
<td style="text-align:left">属性按路径设置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#assocPath" target="_blank" rel="external">assocPath</a></td>
</tr>
<tr>
<td style="text-align:left">属性删除</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dissoc" target="_blank" rel="external">dissoc</a></td>
</tr>
<tr>
<td style="text-align:left">属性按路径删除</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#disscoPath" target="_blank" rel="external">disscoPath</a></td>
</tr>
<tr>
<td style="text-align:left">获取属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#prop" target="_blank" rel="external">prop</a></td>
</tr>
<tr>
<td style="text-align:left">获取属性值，带有默认值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propOr" target="_blank" rel="external">propOr</a></td>
</tr>
<tr>
<td style="text-align:left">获取路径上的属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#path" target="_blank" rel="external">path</a></td>
</tr>
<tr>
<td style="text-align:left">获取路径上的属性值，带有默认值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pathOr" target="_blank" rel="external">pathOr</a></td>
</tr>
<tr>
<td style="text-align:left">判断属性是否满足给定的条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propSatisfies" target="_blank" rel="external">propSatisfies</a></td>
</tr>
<tr>
<td style="text-align:left">判断属性是否与给定值相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propEq" target="_blank" rel="external">propEq</a></td>
</tr>
<tr>
<td style="text-align:left">判断两个对象指定的属性值是否相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#eqProps" target="_blank" rel="external">eqProps</a></td>
</tr>
<tr>
<td style="text-align:left">判断路径上的属性值是否满足给定的条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pathSatisfies" target="_blank" rel="external">pathSatisfies</a></td>
</tr>
<tr>
<td style="text-align:left">判断路径上的属性值是否与给定值相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pathEq" target="_blank" rel="external">pathEq</a></td>
</tr>
<tr>
<td style="text-align:left">获取属性值组成的列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#props" target="_blank" rel="external">props</a></td>
</tr>
<tr>
<td style="text-align:left">判断属性是否为给定类型</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propIs" target="_blank" rel="external">propIs</a></td>
</tr>
<tr>
<td style="text-align:left">判断多个属性是否同时满足给定的条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#where" target="_blank" rel="external">where</a></td>
</tr>
<tr>
<td style="text-align:left">判断多个属性是否等于给定对应属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#whereEq" target="_blank" rel="external">whereEq</a></td>
</tr>
<tr>
<td style="text-align:left">删除多个属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#omit" target="_blank" rel="external">omit</a></td>
</tr>
<tr>
<td style="text-align:left">提取多个属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pick" target="_blank" rel="external">pick</a></td>
</tr>
<tr>
<td style="text-align:left">提取多个属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pickAll" target="_blank" rel="external">pickAll</a></td>
</tr>
<tr>
<td style="text-align:left">对列表中元素提取多个属性，模拟 SQL 的 <code>select</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#project" target="_blank" rel="external">project</a></td>
</tr>
<tr>
<td style="text-align:left">提取键值满足条件的属性</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#pickBy" target="_blank" rel="external">pickBy</a></td>
</tr>
<tr>
<td style="text-align:left">对特定属性进行特定变换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#evolve" target="_blank" rel="external">evolve</a></td>
</tr>
<tr>
<td style="text-align:left">是否包含指定的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#has" target="_blank" rel="external">has</a></td>
</tr>
<tr>
<td style="text-align:left">是否包含指定的键：包括原型链上的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#hasIn" target="_blank" rel="external">hasIn</a></td>
</tr>
<tr>
<td style="text-align:left">键值对换位</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#invertObj" target="_blank" rel="external">invertObj</a></td>
</tr>
<tr>
<td style="text-align:left">键值对换位：将值放入数组中</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#invert" target="_blank" rel="external">invert</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#keys" target="_blank" rel="external">keys</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的键：包括原型链上的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#keysIn" target="_blank" rel="external">keysIn</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#values" target="_blank" rel="external">values</a></td>
</tr>
<tr>
<td style="text-align:left">取出所有的值：包括原型链上的值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#valuesIn" target="_blank" rel="external">valuesIn</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：包括属性的 getter 和 setter</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lens" target="_blank" rel="external">lens</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：指定索引的透镜</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lensIndex" target="_blank" rel="external">lensIndex</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：指定路径的透镜</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lensPath" target="_blank" rel="external">lensPath</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：指定属性的透镜</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lensProp" target="_blank" rel="external">lensProp</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：对被 <code>lens</code> 聚焦的属性做变换</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#over" target="_blank" rel="external">over</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：对被 <code>lens</code> 聚焦的属性进行设置</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#set" target="_blank" rel="external">set</a></td>
</tr>
<tr>
<td style="text-align:left">透镜：读取被 <code>lens</code> 聚焦的属性值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#view" target="_blank" rel="external">view</a></td>
</tr>
<tr>
<td style="text-align:left"><code>Object</code> 版 <code>map</code>，转换函数参数：(value, key, obj)</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mapObjIndexed" target="_blank" rel="external">mapObjIndexed</a></td>
</tr>
<tr>
<td style="text-align:left">对象合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#merge" target="_blank" rel="external">merge</a></td>
</tr>
<tr>
<td style="text-align:left">对象合并：对重复的属性值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeWith" target="_blank" rel="external">mergeWith</a></td>
</tr>
<tr>
<td style="text-align:left">对象合并：对重复的属性值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeWithKey" target="_blank" rel="external">mergeWithKey</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：以左侧对象属性为主</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepLeft" target="_blank" rel="external">mergeDeepLeft</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：以右侧对象属性为主</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepRight" target="_blank" rel="external">mergeDeepRight</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepWith" target="_blank" rel="external">mergeDeepWith</a></td>
</tr>
<tr>
<td style="text-align:left">对象深递归合并：对重复的非对象类型的值按给定规则合并</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mergeDeepWithKey" target="_blank" rel="external">mergeDeepWithKey</a></td>
</tr>
<tr>
<td style="text-align:left">创建包含单个键值对的对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#objOf" target="_blank" rel="external">objOf</a></td>
</tr>
<tr>
<td style="text-align:left">将对象键值对转换为元素为键值二元组的列表</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#toPairs" target="_blank" rel="external">toPairs</a></td>
</tr>
<tr>
<td style="text-align:left">将对象键值对转换为元素为键值二元组的列表:包括原型链上的键</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#toPairsIn" target="_blank" rel="external">toPairsIn</a></td>
</tr>
<tr>
<td style="text-align:left">将二元组的列表转换为对象</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#fromPairs" target="_blank" rel="external">fromPairs</a></td>
</tr>
</tbody>
</table>
<h1 id="luo-ji-yun-suan">逻辑运算</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">判断是否满足所有条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#allPass" target="_blank" rel="external">allPass</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否满足任一条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#anyPass" target="_blank" rel="external">anyPass</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否同时满足两个条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#both" target="_blank" rel="external">both</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否满足两个条件中的任意一个</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#either" target="_blank" rel="external">either</a></td>
</tr>
<tr>
<td style="text-align:left">逻辑与操作</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#and" target="_blank" rel="external">and</a></td>
</tr>
<tr>
<td style="text-align:left">逻辑或操作</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#or" target="_blank" rel="external">or</a></td>
</tr>
<tr>
<td style="text-align:left">模式匹配，相当于多个 <code>if/else</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#cond" target="_blank" rel="external">cond</a></td>
</tr>
<tr>
<td style="text-align:left">单个 <code>if/else</code>，<code>cond</code> 的特例</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#ifElse" target="_blank" rel="external">ifElse</a></td>
</tr>
<tr>
<td style="text-align:left">满足条件，则执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#when" target="_blank" rel="external">when</a></td>
</tr>
<tr>
<td style="text-align:left">不满足条件时，执行处理函数，否则原样返回输入值，<code>ifElse</code> 的特例</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unless" target="_blank" rel="external">unless</a></td>
</tr>
<tr>
<td style="text-align:left">逻辑非操作，参数为布尔值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#not" target="_blank" rel="external">not</a></td>
</tr>
<tr>
<td style="text-align:left">对函数返回值取反</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#complement" target="_blank" rel="external">complement</a></td>
</tr>
<tr>
<td style="text-align:left">添加默认值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#defaultTo" target="_blank" rel="external">defaultTo</a></td>
</tr>
<tr>
<td style="text-align:left">一直计算，直到满足给定条件</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#until" target="_blank" rel="external">until</a></td>
</tr>
<tr>
<td style="text-align:left">判断给定值是否为该类型的空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isEmpty" target="_blank" rel="external">isEmpty</a></td>
</tr>
<tr>
<td style="text-align:left">判断给定值是否为 <code>null</code> 或 <code>undefined</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isNil" target="_blank" rel="external">isNil</a></td>
</tr>
<tr>
<td style="text-align:left">返回给定值所属类型的空值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#empty" target="_blank" rel="external">empty</a></td>
</tr>
</tbody>
</table>
<h1 id="guan-xi-yun-suan">关系运算</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">等于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#equals" target="_blank" rel="external">equals</a></td>
</tr>
<tr>
<td style="text-align:left">完全相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#identical" target="_blank" rel="external">identical</a></td>
</tr>
<tr>
<td style="text-align:left">通过规则判断是否相等</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#eqBy" target="_blank" rel="external">eqBy</a></td>
</tr>
<tr>
<td style="text-align:left">大于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#gt" target="_blank" rel="external">gt</a></td>
</tr>
<tr>
<td style="text-align:left">大于等于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#gte" target="_blank" rel="external">gte</a></td>
</tr>
<tr>
<td style="text-align:left">小于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lt" target="_blank" rel="external">lt</a></td>
</tr>
<tr>
<td style="text-align:left">小于等于</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#lte" target="_blank" rel="external">lte</a></td>
</tr>
<tr>
<td style="text-align:left">限定有序数据类型的范围</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#clamp" target="_blank" rel="external">clamp</a></td>
</tr>
<tr>
<td style="text-align:left">求两个数的较大值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#max" target="_blank" rel="external">max</a></td>
</tr>
<tr>
<td style="text-align:left">按规则求两个数的较大值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#maxBy" target="_blank" rel="external">maxBy</a></td>
</tr>
<tr>
<td style="text-align:left">求两个数的较小值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#min" target="_blank" rel="external">min</a></td>
</tr>
<tr>
<td style="text-align:left">按规则求两个数的较小值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#minBy" target="_blank" rel="external">minBy</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∈xs ∩ a∉ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#difference" target="_blank" rel="external">difference</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：{a∣a∉xs ∩ a∈ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#without" target="_blank" rel="external">without</a></td>
</tr>
<tr>
<td style="text-align:left">求差集：根据条件计算第一个列表与第二个列表的差集</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#differenceWith" target="_blank" rel="external">differenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：{(xs ∪ ys) - (xs ∩ ys)}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifference" target="_blank" rel="external">symmetricDifference</a></td>
</tr>
<tr>
<td style="text-align:left">求对称差集：根据条件计算所有不属于两个列表交集的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#symmetricDifferenceWith" target="_blank" rel="external">symmetricDifferenceWith</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：{xs ∩ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#intersection" target="_blank" rel="external">intersection</a></td>
</tr>
<tr>
<td style="text-align:left">求交集：从 xs 中挑选出在 ys 中符合条件的元素</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#innerJoin" target="_blank" rel="external">innerJoin</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：{xs ∪ ys}</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#union" target="_blank" rel="external">union</a></td>
</tr>
<tr>
<td style="text-align:left">求并集：根据条件判断两元素是否重复</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#unionWith" target="_blank" rel="external">unionWith</a></td>
</tr>
</tbody>
</table>
<h1 id="shu-xue-yun-suan">数学运算</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">加</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#add" target="_blank" rel="external">add</a></td>
</tr>
<tr>
<td style="text-align:left">减</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#subtract" target="_blank" rel="external">subtract</a></td>
</tr>
<tr>
<td style="text-align:left">乘</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#multiply" target="_blank" rel="external">multiply</a></td>
</tr>
<tr>
<td style="text-align:left">除</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#divide" target="_blank" rel="external">divide</a></td>
</tr>
<tr>
<td style="text-align:left">加1</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#inc" target="_blank" rel="external">inc</a></td>
</tr>
<tr>
<td style="text-align:left">减1</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#dec" target="_blank" rel="external">dec</a></td>
</tr>
<tr>
<td style="text-align:left">取反</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#negate" target="_blank" rel="external">negate</a></td>
</tr>
<tr>
<td style="text-align:left">列表累加和</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#sum" target="_blank" rel="external">sum</a></td>
</tr>
<tr>
<td style="text-align:left">列表累乘积</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#product" target="_blank" rel="external">product</a></td>
</tr>
<tr>
<td style="text-align:left">列表平均值</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mean" target="_blank" rel="external">mean</a></td>
</tr>
<tr>
<td style="text-align:left">列表中位数</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#median" target="_blank" rel="external">median</a></td>
</tr>
<tr>
<td style="text-align:left">取模：算术</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#mathMod" target="_blank" rel="external">mathMod</a></td>
</tr>
<tr>
<td style="text-align:left">取模：JS</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#modulo" target="_blank" rel="external">modulo</a></td>
</tr>
</tbody>
</table>
<h1 id="lei-xing-cao-zuo">类型操作</h1>
<table>
<thead>
<tr>
<th style="text-align:left">Action</th>
<th style="text-align:left">Function</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">类型判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#is" target="_blank" rel="external">is</a></td>
</tr>
<tr>
<td style="text-align:left">类型描述</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#type" target="_blank" rel="external">type</a></td>
</tr>
<tr>
<td style="text-align:left">属性类型判断</td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#propIs" target="_blank" rel="external">propIs</a></td>
</tr>
<tr>
<td style="text-align:left">判断是否为 <code>null</code> 或 <code>undefined</code></td>
<td style="text-align:left"><a href="http://ramda.cn/docs/#isNil" target="_blank" rel="external">isNil</a></td>
</tr>
</tbody>
</table>
<h1 id="can-kao-zi-liao">参考资料</h1>
<p>关于 <code>Applicative Functor</code>，及其操作符 <a href="%5Bap%5D(http://ramda.cn/docs/#ap)">R.ap</a> (haskell 中的 <code>&lt;*&gt;</code>) 和 <a href="http://ramda.cn/docs/#lift" target="_blank" rel="external">lift</a> (haskell 中的 <code>&lt;$&gt;</code>) 的论述可参考下列资料：</p>
<ol>
<li>《Learn You A Haskell For Great Good》的 <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" target="_blank" rel="external">Applicative 章节</a>，函数 <code>(-&gt;) r</code> 也是 Applicative，需要深入理解。</li>
</ol>
<p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="type">Function</span> :: ((-&gt;) r)</div><div class="line"><span class="type">Function</span> a = ((-&gt;) r) a </div><div class="line">           = r -&gt; a</div><div class="line"></div><div class="line">;; <span class="type">Functor</span>、<span class="type">Applicative</span>、<span class="type">Monad</span> 的类定义</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span>  </div><div class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b  </div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span>  </div><div class="line">    pure :: a -&gt; f a  </div><div class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  </div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">class</span> <span class="type">Monad</span> m <span class="keyword">where</span>  </div><div class="line">    return :: a -&gt; m a  </div><div class="line">  </div><div class="line">    (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b  </div><div class="line">  </div><div class="line">    (&gt;&gt;) :: m a -&gt; m b -&gt; m b  </div><div class="line">    x &gt;&gt; y = x &gt;&gt;= \_ -&gt; y  </div><div class="line">  </div><div class="line">    fail :: <span class="type">String</span> -&gt; m a  </div><div class="line">    fail msg = error msg  </div><div class="line"></div><div class="line">;; 作为<span class="type">Functor</span>、<span class="type">Applicative</span>、<span class="type">Monad</span> 的实例的 <span class="type">Function</span> 的定义，可以对比上面的类定义查看</div><div class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> ((-&gt;) r) <span class="keyword">where</span></span></div><div class="line">    fmap = (.)</div><div class="line"></div><div class="line"><span class="title">fmap</span> :: (a -&gt; b) -&gt; (c -&gt; a) -&gt; (c -&gt; b)</div><div class="line"></div><div class="line"><span class="title">f</span> :: a -&gt; b</div><div class="line"></div><div class="line"><span class="title">g</span> :: c -&gt; a</div><div class="line"><span class="title">h</span> :: c -&gt; b</div><div class="line"></div><div class="line"><span class="title">const</span> h = fmap(f, g) = map(f, g) = compose(f, g)</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Applicative</span> ((-&gt;) r) <span class="keyword">where</span></div><div class="line">    pure x = (\_ -&gt; x)</div><div class="line">    f &lt;*&gt; g = \x -&gt; f x (g x)</div><div class="line"></div><div class="line"><span class="title">f</span> &lt;*&gt; g = (r-&gt;(a-&gt;b)) -&gt; (r-&gt;a) -&gt; (r-&gt;b)</div><div class="line">        = (r-&gt;a-&gt;b) -&gt; (r-&gt;a) -&gt; r -&gt; b</div><div class="line"><span class="class"></span></div><div class="line"><span class="keyword">instance</span> <span class="type">Monad</span> ((-&gt;) r) <span class="keyword">where</span></div><div class="line">    return x = \_ -&gt; x</div><div class="line">    h &gt;&gt;= f = \w -&gt; f (h w) w</div></pre></td></tr></table></figure></p>
<ol start="2">
<li>
<p><a href="https://github.com/MostlyAdequate/mostly-adequate-guide" target="_blank" rel="external">《JS 函数式编程指南》</a>：</p>
<ol>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html" target="_blank" rel="external">第 10 章: Applicative Functor</a></li>
<li><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch10.html#lift" target="_blank" rel="external">第 10 章: Applicative Functor lift</a></li>
</ol>
</li>
<li>
<p>stackoverflow: function as Functor/Applicative Functor/Monad：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/10294272/confused-about-function-as-instance-of-functor-in-haskell" target="_blank" rel="external">confused about function as instance of Functor in haskell</a></li>
<li><a href="https://stackoverflow.com/questions/11810889/functions-as-applicative-functors-haskell-lyah" target="_blank" rel="external">functions as applicative functors (Haskell / LYAH)</a></li>
<li><a href="https://stackoverflow.com/questions/13080014/function-as-an-instance-of-monad" target="_blank" rel="external">Function as an Instance of Monad</a></li>
</ol>
</li>
<li>
<p><a href="http://www.tomharding.me/2017/04/15/functions-as-functors/" target="_blank" rel="external">Functions as Functors</a></p>
</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/10/15/Haskell-Type-and-TypeClass/" itemprop="url">
                  Haskell: Type and TypeClass
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-10-15T11:52:43+08:00" content="2017-10-15">
              2017-10-15
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Haskell/" itemprop="url" rel="index">
                    <span itemprop="name">Haskell</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/10/15/Haskell-Type-and-TypeClass/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/10/15/Haskell-Type-and-TypeClass/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>What are typeclasses?</p>
<p>Typeclasses define a set of functions that can have different implementations depending on the type of data they are given.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/09/29/Functional-Programming-Abstract-and-Composition/" itemprop="url">
                  Functional Programming: Abstract and Composition
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-09-29T10:10:16+08:00" content="2017-09-29">
              2017-09-29
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Functional-Programming/" itemprop="url" rel="index">
                    <span itemprop="name">Functional Programming</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/09/29/Functional-Programming-Abstract-and-Composition/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/09/29/Functional-Programming-Abstract-and-Composition/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/29/Product-Softwares-in-nix/" itemprop="url">
                  Product Softwares in *nix
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-07-29T07:57:42+08:00" content="2017-07-29">
              2017-07-29
            </time>
          </span>

          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/29/Product-Softwares-in-nix/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/29/Product-Softwares-in-nix/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>总结一些在 *nix 操作系统中常用的软件</p>
<h2 id="a-href-https-github-com-syl-20-bnr-spacemacs-spacemacs-a"><a href="https://github.com/syl20bnr/spacemacs" target="_blank" rel="external">Spacemacs</a></h2>
<ul>
<li><a href="http://orgmode.org/" target="_blank" rel="external">org-mode</a></li>
</ul>
<h2 id="a-href-https-github-com-robbyrussell-oh-my-zsh-oh-my-zsh-a"><a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">oh-my-zsh</a></h2>
<ul>
<li><a href="https://github.com/wting/autojump" target="_blank" rel="external">autojump</a></li>
</ul>
<h2 id="a-href-https-github-com-tmux-tmux-tmux-a"><a href="https://github.com/tmux/tmux" target="_blank" rel="external">tmux</a></h2>
<h2 id="a-href-https-github-com-mooz-percol-percol-a"><a href="https://github.com/mooz/percol" target="_blank" rel="external">percol</a></h2>
<h2 id="a-href-https-nodejs-org-en-nodejs-a"><a href="https://nodejs.org/en/" target="_blank" rel="external">Nodejs</a></h2>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/22/Debug-nodejs-in-Spacemacs/" itemprop="url">
                  Debug Nodejs in Spacemacs
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-07-22T15:04:44+08:00" content="2017-07-22">
              2017-07-22
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Emacs/" itemprop="url" rel="index">
                    <span itemprop="name">Emacs</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/07/22/Debug-nodejs-in-Spacemacs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/07/22/Debug-nodejs-in-Spacemacs/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在调试代码时，往往会开两个窗口进行操作，一个用来编写代码（代码文件如 <code>index.js</code>），另一个用来调试（如运行 <code>node index.js</code>），这样会频繁的在编辑器和调试窗口之间切换；而且使用 node cli 会运行整个文件，而往往我们只想看文件中的部分内容。</p>
<p>nodejs-repl 库相当于在编辑器和 repl 之间做了桥接，类似于 tmux。</p>
<p>这里有两条命令比较重要：</p>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nodejs-repl-send-region ;; 用于将选中的区域发送至 repl 中，但不求值，在引入库时比较有用</div><div class="line">nodejs-repl-send-last-sexp ;; 将当前行光标前面的内容发送至 repl，并进行运算</div></pre></td></tr></table></figure></p>
<p>具体步骤：</p>
<h2 id="yi-pei-zhi">一、配置</h2>
<ol>
<li>
<p>在 <code>~/.spacemacs</code> <code>dotspacemacs-additional-packages '(nodejs-repl)</code> 中添加 <code>nodejs-repl</code></p>
</li>
<li>
<p>在 <code>dotspacemacs/user-config ()</code> 中添加快捷键</p>
</li>
</ol>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(add-hook &apos;js-mode-hook</div><div class="line">          (lambda ()</div><div class="line">            (define-key js-mode-map (kbd &quot;C-x C-e&quot;) &apos;nodejs-repl-send-last-sexp)</div><div class="line">            (define-key js-mode-map (kbd &quot;C-c C-r&quot;) &apos;nodejs-repl-send-region)</div><div class="line">            (define-key js-mode-map (kbd &quot;C-c C-l&quot;) &apos;nodejs-repl-load-file)</div><div class="line">            (define-key js-mode-map (kbd &quot;C-c C-z&quot;) &apos;nodejs-repl-switch-to-repl)))</div></pre></td></tr></table></figure></p>
<ol start="3">
<li>运行 <code>M-m f e R</code>，安装 nodejs-repl</li>
</ol>
<h2 id="er-diao-shi">二、调试</h2>
<ol>
<li>使用 emacs 打开待调试文件；使用 <code>M-x</code> 运行命令 <code>nodejs-repl</code>，便会在编辑窗口相同 frame 里打开 nodejs 的 repl：</li>
</ol>
<p><img src="./open-nodejs-repl.png" alt="open-nodejs-repl"></p>
<ol start="2">
<li>选中文中的第三方库，使用 <code>nodejs-repl-send-region</code> 命令将其引入 repl 中。（注意，不能使用 <code>nodejs-repl-send-last-sexp</code>！）</li>
</ol>
<p><img src="./import-lib.png" alt="import-lib"></p>
<ol start="3">
<li>对于需要调试的代码行，运行 <code>nodejs-repl-send-last-sexp</code> ，便会将代码加入 repl 中，并进行运算：</li>
</ol>
<p><img src="./eval.png" alt="eval"></p>
<h2 id="san-todo">三、TODO</h2>
<ol>
<li>快捷键配置在 js2-mode 中只能部分起作用，js-mode 中都可以。需要研究一下 emacs 快捷键配置和优先级。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/28/Why-Curry-Helps/" itemprop="url">
                  为什么柯里化有帮助
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-28T23:26:34+08:00" content="2017-06-28">
              2017-06-28
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/28/Why-Curry-Helps/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/28/Why-Curry-Helps/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 <a href="https://hughfdjackson.com/" target="_blank" rel="external">Hugh FD Jackson</a> 的 《<a href="https://hughfdjackson.com/javascript/why-curry-helps/" target="_blank" rel="external">Why Curry Helps</a>》，转载请与<a href="https://hughfdjackson.com/" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>程序员的梦想是编写代码，并能够非常容易地对其进行复用。还要有强表达力，因为你书写的方式就是在表达你想要的东西，并且它应该被复用，因为... 好吧，你正在复用。你还想要什么呢？</p>
<p><a href="https://npmjs.org/package/curry" target="_blank" rel="external">curry</a> 可以帮忙。</p>
<h2 id="shi-yao-shi-ke-li-hua-wei-shi-yao-ta-ru-ci-de-mei-wei">什么是柯里化，为什么它如此的美味？</h2>
<p>JavaScript 中正常的函数调用如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; <span class="keyword">return</span> a + b &#125;</div><div class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">//= 3</span></div></pre></td></tr></table></figure></p>
<p>一个函数接受多个参数，并返回一个值。我可以使用少于指定数量的参数调用它（可能得到奇怪的结果），或者多于指定的数量（超出的部分一般会被忽略）。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'IGNORE ME'</span>) <span class="comment">//= 3</span></div><div class="line">add(<span class="number">1</span>) <span class="comment">//= NaN</span></div></pre></td></tr></table></figure></p>
<p>一个柯里化的函数需要借用一系列单参数函数来处理它的多个参数。例如，柯里化的加法会是这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> curry = <span class="built_in">require</span>(<span class="string">'curry'</span>)</div><div class="line"><span class="keyword">var</span> add = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123; <span class="keyword">return</span> a + b &#125;)</div><div class="line"><span class="keyword">var</span> add100 = add(<span class="number">100</span>)</div><div class="line">add100(<span class="number">1</span>) <span class="comment">//= 101</span></div></pre></td></tr></table></figure></p>
<p>接受多个参数的柯里化函数将被写成如下形式：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum3 = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>)</span>&#123; <span class="keyword">return</span> a + b + c &#125;)</div><div class="line">sum3(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>) <span class="comment">//= 6</span></div></pre></td></tr></table></figure></p>
<p>由于这在 JavaScript 语法中很丑，<a href="https://npmjs.org/package/curry" target="_blank" rel="external">curry</a> 允许你一次调用多个参数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum3 = curry(<span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>)</span>&#123; <span class="keyword">return</span> a + b + c &#125;)</div><div class="line">sum3(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">//= 6</span></div><div class="line">sum3(<span class="number">1</span>)(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">//= 6</span></div><div class="line">sum3(<span class="number">1</span>, <span class="number">2</span>)(<span class="number">3</span>) <span class="comment">//= 6</span></div></pre></td></tr></table></figure></p>
<h2 id="suo-yi-ni">所以呢？</h2>
<p>如果你还未习惯这样一门语言：柯里化函数是其日常工作一部分（如 <a href="http://learnyouahaskell.com/" target="_blank" rel="external">Haskell</a>），那么它给我们带来的好处可能不太明显。在我看来，有两点非常重要：</p>
<ul>
<li>小的模块可以轻松地配置和复用，不杂乱。</li>
<li>从头至尾都使用函数。</li>
</ul>
<h3 id="xiao-mo-kuai">小模块</h3>
<p>我们来看一个明显的例子；映射一个集合来获取它的成员的 ids：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> objects = [&#123; <span class="attr">id</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">2</span> &#125;, &#123; <span class="attr">id</span>: <span class="number">3</span> &#125;]</div><div class="line">objects.map(<span class="function"><span class="keyword">function</span>(<span class="params">o</span>)</span>&#123; <span class="keyword">return</span> o.id &#125;)</div></pre></td></tr></table></figure></p>
<p>如果你正想搞清楚第二行的真正逻辑，我来跟你解释一下吧：</p>
<blockquote>
<p>MAP over OBJECTS to get IDS (对Objects进行映射，来获得对应的ID)</p>
</blockquote>
<p>有很多种实现这种操作的方式；可以函数定义的形式实现。我们来理一理：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> get = curry(<span class="function"><span class="keyword">function</span>(<span class="params">property, object</span>)</span>&#123; <span class="keyword">return</span> object[property] &#125;)</div><div class="line">objects.map(get(<span class="string">'id'</span>)) <span class="comment">//= [1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<p>现在我们正在探讨这个操作的真正逻辑 - 映射这些对象，获取它们的 ids 。BAM。我们在 <code>get</code> 函数中真正创建的是一个 <strong>可以部分配置的函数</strong>。</p>
<p>如果想复用 '从对象列表中获取ids' 这个功能，该怎么办呢？我们先用一种笨的方法实现：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getIDs = <span class="function"><span class="keyword">function</span>(<span class="params">objects</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> objects.map(get(<span class="string">'id'</span>))</div><div class="line">&#125;</div><div class="line">getIDs(objects) <span class="comment">//= [1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<p>Hrm，我们似乎从高雅和简洁的方式回到了混乱的方式。可以做些什么呢？Ah，如果 <code>map</code> 可以先部分配置一个函数，而不同时调用集合，会怎样呢？</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> map = curry(<span class="function"><span class="keyword">function</span>(<span class="params">fn, value</span>)</span>&#123; <span class="keyword">return</span> value.map(fn) &#125;)</div><div class="line"><span class="keyword">var</span> getIDs = map(get(<span class="string">'id'</span>))</div><div class="line"></div><div class="line">getIDs(objects) <span class="comment">//= [1, 2, 3]</span></div></pre></td></tr></table></figure></p>
<p>我们开始看到，如果基本的构建块是柯里化函数，我们可以轻松地从中创建新的功能。更令人兴奋的是，代码读起来也很像你所工作领域（语言、环境）的逻辑。</p>
<h2 id="quan-shi-han-shu">全是函数</h2>
<p>这种方法的另一个优点是它鼓励创建函数，而不是方法。虽然方法很好 - 允许多态，可读性也不错 - 但它们并不总是能拿来干活的工具，比如大量的异步代码。</p>
<p>在这个示例中，我们从服务器获取一些数据，并对其进行处理。数据看起来像是这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"user"</span>: <span class="string">"hughfdjackson"</span>,</div><div class="line">    <span class="string">"posts"</span>: [</div><div class="line">        &#123; <span class="string">"title"</span>: <span class="string">"why curry?"</span>, <span class="string">"contents"</span>: <span class="string">"..."</span> &#125;,</div><div class="line">        &#123; <span class="string">"title"</span>: <span class="string">"prototypes: the short(est possible) story"</span>, <span class="string">"contents"</span>: <span class="string">"..."</span> &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你的任务是提取每个用户的帖子的标签。赶紧来试一下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">fetchFromServer()</div><div class="line">    .then(<span class="built_in">JSON</span>.parse)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123; <span class="keyword">return</span> data.posts &#125;)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span>(<span class="params">posts</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> posts.map(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123; <span class="keyword">return</span> post.title &#125;)</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p>
<p>好吧，这不公平，你在催我。（另外，我代表你写了这段代码 - 可能你会更有优雅地解决它，但我好像离题了...）。</p>
<p>由于 Promises 链（或者，如果你喜欢，也可以用回调）需要与函数一起 <em>工作</em>，你不能轻易地映射从服务器获取的值，而无需首先显式地将其包裹在代码块中。（需要显式的写出参数）</p>
<p>再来一次，这次使用已经定义好的工具：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">fetchFromServer()</div><div class="line">    .then(<span class="built_in">JSON</span>.parse)</div><div class="line">    .then(get(<span class="string">'posts'</span>))</div><div class="line">    .then(map(get(<span class="string">'title'</span>)))</div></pre></td></tr></table></figure></p>
<p>这具有很强的逻辑性、表达力；如果不使用柯里化函数，我们几乎不可能轻易的将其实现。</p>
<h2 id="zong-jie-tl-dr">总结（tl;dr）</h2>
<p><a href="https://npmjs.org/package/curry" target="_blank" rel="external">curry</a> 赋予你一种强大的表达能力。</p>
<p>我建议你下载下来，玩一会儿。如果你已经熟悉了这个概念，我觉得你可以直接找到合适的 API。如果没有的话，建议你和你的同事一起研究一下吧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/27/Favoring-Curry/" itemprop="url">
                  爱上柯里化 (Favoring Curry)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-27T07:49:41+08:00" content="2017-06-27">
              2017-06-27
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/27/Favoring-Curry/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/27/Favoring-Curry/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 <a href="https://github.com/CrossEye" target="_blank" rel="external">Scott Sauyet</a> 的 《<a href="http://fr.umio.us/favoring-curry/" target="_blank" rel="external">Favoring Curry</a>》，转载请与<a href="https://github.com/CrossEye" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>我<a href="http://fr.umio.us/why-ramda/" target="_blank" rel="external">最近一篇</a> 关于 <a href="https://github.com/ramda/ramda" target="_blank" rel="external">Ramda</a> 函数式组合的文章阐述了一个重要的话题。为了使用 Ramda 函数做这种组合，需要这些函数是柯里化的。</p>
<p>Curry，咖喱？某种辛辣的食物？是什么呢？又在哪里？</p>
<p>实际上，<code>curry</code> 是为纪念 Haskell Curry 而命名的，他是第一个研究这种技术的人。（是的，人们还用他的姓氏--Haskell--作为一门函数式编程语言；不仅如此，Curry 的中间名字以 'B' 开头，代表 <a href="http://en.wikipedia.org/wiki/Brainfuck" target="_blank" rel="external">Brainf*ck</a></p>
<p>柯里化将多参数函数转化一个新函数：当接受部分参数时，返回等待接受剩余参数的新函数。</p>
<p>原始函数看起来像是这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// uncurried version</span></div><div class="line"><span class="keyword">var</span> formatName1 = <span class="function"><span class="keyword">function</span>(<span class="params">first, middle, last</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + <span class="string">' '</span> + middle + <span class="string">' '</span> + last;</div><div class="line">&#125;;</div><div class="line">formatName1(<span class="string">'John'</span>, <span class="string">'Paul'</span>, <span class="string">'Jones'</span>);</div><div class="line"><span class="comment">//=&gt; 'John Paul Jones' // (Ah, but the musician or the admiral?)</span></div><div class="line">formatName1(<span class="string">'John'</span>, <span class="string">'Paul'</span>);</div><div class="line"><span class="comment">//=&gt; 'John Paul undefined');</span></div></pre></td></tr></table></figure></p>
<p>但柯里化后的函数更有用：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// curried version</span></div><div class="line"><span class="keyword">var</span> formatNames2 = R.curry(<span class="function"><span class="keyword">function</span>(<span class="params">first, middle, last</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> first + <span class="string">' '</span> + middle + <span class="string">' '</span> + last;</div><div class="line">&#125;);</div><div class="line">formatNames2(<span class="string">'John'</span>, <span class="string">'Paul'</span>, <span class="string">'Jones'</span>);</div><div class="line"><span class="comment">//=&gt; 'John Paul Jones' // (definitely the musician!)</span></div><div class="line"><span class="keyword">var</span> jp = formatNames2(<span class="string">'John'</span>, <span class="string">'Paul'</span>); <span class="comment">//=&gt; returns a function</span></div><div class="line">jp(<span class="string">'Jones'</span>); <span class="comment">//=&gt; 'John Paul Jones' (maybe this one's the admiral)</span></div><div class="line">jp(<span class="string">'Stevens'</span>); <span class="comment">//=&gt; 'John Paul Stevens' (the Supreme Court Justice)</span></div><div class="line">jp(<span class="string">'Pontiff'</span>); <span class="comment">//=&gt; 'John Paul Pontiff' (ok, so I cheated.)</span></div><div class="line">jp(<span class="string">'Ziller'</span>); <span class="comment">//=&gt; 'John Paul Ziller' (magician, a wee bit fictional)</span></div><div class="line">jp(<span class="string">'Georgeandringo'</span>); <span class="comment">//=&gt; 'John Paul Georgeandringo' (rockers)</span></div></pre></td></tr></table></figure></p>
<p>或这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="string">'Jones'</span>, <span class="string">'Stevens'</span>, <span class="string">'Ziller'</span>].map(jp);</div><div class="line"><span class="comment">//=&gt; ['John Paul Jones', 'John Paul Stevens', 'John Paul Ziller']</span></div></pre></td></tr></table></figure></p>
<p>你也可以分多次传入参数，像这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> james = formatNames2(<span class="string">'James'</span>); <span class="comment">//=&gt; returns a function</span></div><div class="line">james(<span class="string">'Byron'</span>, <span class="string">'Dean'</span>); <span class="comment">//=&gt; 'James Byron Dean' (rebel)</span></div><div class="line"><span class="keyword">var</span> je = james(<span class="string">'Earl'</span>); also returns a <span class="function"><span class="keyword">function</span></span></div><div class="line"><span class="title">je</span>(<span class="params"><span class="string">'Carter'</span></span>); //=&gt; '<span class="title">James</span> <span class="title">Earl</span> <span class="title">Carter</span>' (<span class="params">president</span>)</div><div class="line"><span class="title">je</span>(<span class="params"><span class="string">'Jones'</span></span>); //=&gt; '<span class="title">James</span> <span class="title">Earl</span> <span class="title">Jones</span>' (<span class="params">actor, Vader</span>)</div></pre></td></tr></table></figure></p>
<p>（有些人会坚持认为我们正在做的应该叫作 &quot;部分应用(partial application)&quot;，&quot;柯里化&quot; 的返回函数应该每次只接受一个参数，每次函数处理完单个参数后返回一个新的接受单参数的函数，直到所有必需的参数都已传入。他们可以坚持他们的观点，无所谓）</p>
<h2 id="hao-wu-liao-a-ta-neng-wei-wo-zuo-shi-yao-ni">好无聊啊...! 它能为我做什么呢？</h2>
<p>这里有一个稍有意义的示例。如果想计算一个数字集合的总和，可以这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Plain JS:</span></div><div class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;<span class="keyword">return</span> a + b;&#125;;</div><div class="line"><span class="keyword">var</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line"><span class="keyword">var</span> sum = numbers.reduce(add, <span class="number">0</span>); <span class="comment">//=&gt; 15</span></div></pre></td></tr></table></figure></p>
<p>而若想编写一个通用的计算数字列表总和的函数，可以这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = <span class="function"><span class="keyword">function</span>(<span class="params">list</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> list.reduce(add, <span class="number">0</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">var</span> sum = total(numbers); <span class="comment">//=&gt; 15</span></div></pre></td></tr></table></figure></p>
<p>在 Ramda 中，<code>total</code> 和 <code>sum</code> 和上面的定义非常相似。可以这样定义 <code>sum</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = R.reduce(add, <span class="number">0</span>, numbers); <span class="comment">//=&gt; 15</span></div></pre></td></tr></table></figure></p>
<p>但由于 <code>reduce</code> 是柯里化函数，当跳过最后一个参数时，就类似于 <code>total</code> 的定义了：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// In Ramda:</span></div><div class="line"><span class="keyword">var</span> total = R.reduce(add, <span class="number">0</span>);  <span class="comment">// returns a function</span></div></pre></td></tr></table></figure></p>
<p>上面将会获得一个可以调用的函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sum = total(numbers); <span class="comment">//=&gt; 15</span></div></pre></td></tr></table></figure></p>
<p>再次注意，函数的定义和将函数作用于数据是多么的相似：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> total = R.reduce(add, <span class="number">0</span>); <span class="comment">//=&gt; function:: [Number] -&gt; Number</span></div><div class="line"><span class="keyword">var</span> sum =   R.reduce(add, <span class="number">0</span>, numbers); <span class="comment">//=&gt; 15</span></div></pre></td></tr></table></figure></p>
<h2 id="wo-bu-guan-xin-zhe-xie-wo-you-bu-shi-shu-xue-guai-li-shu">我不关心这些，我又不是数学怪黎叔</h2>
<p>那么你做 web 开发吗？huh？会对服务器发起 AJAX 请求吗？使用的是 <a href="http://promises-aplus.github.io/promises-spec/" target="_blank" rel="external">Promises</a> 吗？必须要操作返回的数据，对其进行过滤，取子集等？或者你做 server 端开发？会异步查询一个 no-SQL 数据库，并操作这些结果？</p>
<p>我最好的建议是，去看看 Hugh FD Jackson 的文章：<a href="http://hughfdjackson.com/javascript/why-curry-helps/" target="_blank" rel="external">为什么柯里化有帮助</a>。它是我读过的这方面最好的文章。如果你想要看视频，花上半个小时看一下 Dr. Boolean 的视频：<a href="http://www.youtube.com/watch?v=m3svKOdZijA" target="_blank" rel="external">Hey Underscore, 你错了</a>。（不要被标题吓到，他没有花太多时间批评那个库）</p>
<p>一定要看看这些材料！它们比我解释的更好；你已经察觉到我有多么的啰嗦、夸夸其谈、冗长甚至愚笨。如果你已经看了上面的材料，可以跳过本文剩余小节了。它们解释的已经够清楚了。</p>
<p>我已经警告过你了哦。</p>
<hr>
<p>假设我们希望得到一些这样的数据：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line">    <span class="attr">result</span>: <span class="string">"SUCCESS"</span>,</div><div class="line">    <span class="attr">interfaceVersion</span>: <span class="string">"1.0.3"</span>,</div><div class="line">    <span class="attr">requested</span>: <span class="string">"10/17/2013 15:31:20"</span>,</div><div class="line">    <span class="attr">lastUpdated</span>: <span class="string">"10/16/2013 10:52:39"</span>,</div><div class="line">    <span class="attr">tasks</span>: [</div><div class="line">        &#123;<span class="attr">id</span>: <span class="number">104</span>, <span class="attr">complete</span>: <span class="literal">false</span>,            <span class="attr">priority</span>: <span class="string">"high"</span>,</div><div class="line">                  <span class="attr">dueDate</span>: <span class="string">"2013-11-29"</span>,      <span class="attr">username</span>: <span class="string">"Scott"</span>,</div><div class="line">                  <span class="attr">title</span>: <span class="string">"Do something"</span>,      <span class="attr">created</span>: <span class="string">"9/22/2013"</span>&#125;,</div><div class="line">        &#123;<span class="attr">id</span>: <span class="number">105</span>, <span class="attr">complete</span>: <span class="literal">false</span>,            <span class="attr">priority</span>: <span class="string">"medium"</span>,</div><div class="line">                  <span class="attr">dueDate</span>: <span class="string">"2013-11-22"</span>,      <span class="attr">username</span>: <span class="string">"Lena"</span>,</div><div class="line">                  <span class="attr">title</span>: <span class="string">"Do something else"</span>, <span class="attr">created</span>: <span class="string">"9/22/2013"</span>&#125;,</div><div class="line">        &#123;<span class="attr">id</span>: <span class="number">107</span>, <span class="attr">complete</span>: <span class="literal">true</span>,             <span class="attr">priority</span>: <span class="string">"high"</span>,</div><div class="line">                  <span class="attr">dueDate</span>: <span class="string">"2013-11-22"</span>,      <span class="attr">username</span>: <span class="string">"Mike"</span>,</div><div class="line">                  <span class="attr">title</span>: <span class="string">"Fix the foo"</span>,       <span class="attr">created</span>: <span class="string">"9/22/2013"</span>&#125;,</div><div class="line">        &#123;<span class="attr">id</span>: <span class="number">108</span>, <span class="attr">complete</span>: <span class="literal">false</span>,            <span class="attr">priority</span>: <span class="string">"low"</span>,</div><div class="line">                  <span class="attr">dueDate</span>: <span class="string">"2013-11-15"</span>,      <span class="attr">username</span>: <span class="string">"Punam"</span>,</div><div class="line">                  <span class="attr">title</span>: <span class="string">"Adjust the bar"</span>,    <span class="attr">created</span>: <span class="string">"9/25/2013"</span>&#125;,</div><div class="line">        &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">complete</span>: <span class="literal">false</span>,            <span class="attr">priority</span>: <span class="string">"medium"</span>,</div><div class="line">                  <span class="attr">dueDate</span>: <span class="string">"2013-11-15"</span>,      <span class="attr">username</span>: <span class="string">"Scott"</span>,</div><div class="line">                  <span class="attr">title</span>: <span class="string">"Rename everything"</span>, <span class="attr">created</span>: <span class="string">"10/2/2013"</span>&#125;,</div><div class="line">        &#123;<span class="attr">id</span>: <span class="number">112</span>, <span class="attr">complete</span>: <span class="literal">true</span>,             <span class="attr">priority</span>: <span class="string">"high"</span>,</div><div class="line">                  <span class="attr">dueDate</span>: <span class="string">"2013-11-27"</span>,      <span class="attr">username</span>: <span class="string">"Lena"</span>,</div><div class="line">                  <span class="attr">title</span>: <span class="string">"Alter all quuxes"</span>,  <span class="attr">created</span>: <span class="string">"10/5/2013"</span>&#125;</div><div class="line">        <span class="comment">// , ...</span></div><div class="line">    ]</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>我们需要一个函数 <code>getIncompleteTaskSummaries</code>，接受成员名字（<code>memebername</code>）为参数，然后从服务器（或其他地方）获取数据，挑选出该成员未完成的任务，返回它们的 id、优先级、标题和到期日期，并按到期日期排序。实际上，它返回一个用来解析出这个有序列表的 Promise。</p>
<p>如果向 <code>getIncompleteTaskSummaries</code> 传入 &quot;Scott&quot;，它可能会返回：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">title</span>: <span class="string">"Rename everything"</span>, </div><div class="line">        <span class="attr">dueDate</span>: <span class="string">"2013-11-15"</span>, <span class="attr">priority</span>: <span class="string">"medium"</span>&#125;,</div><div class="line">    &#123;<span class="attr">id</span>: <span class="number">104</span>, <span class="attr">title</span>: <span class="string">"Do something"</span>, </div><div class="line">        <span class="attr">dueDate</span>: <span class="string">"2013-11-29"</span>, <span class="attr">priority</span>: <span class="string">"high"</span>&#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>好的，这就开始吧。下面这段代码是否看着很熟悉？</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">getIncompleteTaskSummaries = <span class="function"><span class="keyword">function</span>(<span class="params">membername</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fetchData()</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> data.tasks;</div><div class="line">        &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> results = [];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = tasks.length; i &lt; len; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (tasks[i].username == membername) &#123;</div><div class="line">                    results.push(tasks[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> results = [];</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = tasks.length; i &lt; len; i++) &#123;</div><div class="line">                <span class="keyword">if</span> (!tasks[i].complete) &#123;</div><div class="line">                    results.push(tasks[i]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">            <span class="keyword">var</span> results = [], task;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = tasks.length; i &lt; len; i++) &#123;</div><div class="line">                task = tasks[i];</div><div class="line">                results.push(&#123;</div><div class="line">                    <span class="attr">id</span>: task.id,</div><div class="line">                    <span class="attr">dueDate</span>: task.dueDate,</div><div class="line">                    <span class="attr">title</span>: task.title,</div><div class="line">                    <span class="attr">priority</span>: task.priority</div><div class="line">                &#125;)</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> results;</div><div class="line">        &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">            tasks.sort(<span class="function"><span class="keyword">function</span>(<span class="params">first, second</span>) </span>&#123;</div><div class="line">                <span class="keyword">var</span> a = first.dueDate, b = second.dueDate;</div><div class="line">                <span class="keyword">return</span> a &lt; b ? <span class="number">-1</span> : a &gt; b ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">            &#125;);</div><div class="line">            <span class="keyword">return</span> tasks;</div><div class="line">        &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>下面的代码是否更好些呢？</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getIncompleteTaskSummaries = <span class="function"><span class="keyword">function</span>(<span class="params">membername</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fetchData()</div><div class="line">        .then(R.get(<span class="string">'tasks'</span>))</div><div class="line">        .then(R.filter(R.propEq(<span class="string">'username'</span>, membername)))</div><div class="line">        .then(R.reject(R.propEq(<span class="string">'complete'</span>, <span class="literal">true</span>)))</div><div class="line">        .then(R.map(R.pick([<span class="string">'id'</span>, <span class="string">'dueDate'</span>, <span class="string">'title'</span>, <span class="string">'priority'</span>])))</div><div class="line">        .then(R.sortBy(R.get(<span class="string">'dueDate'</span>)));</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果是的话，那么柯里化会更适合你。所有上面代码块中提及的 Ramda 函数都是柯里化的。（事实上，绝大多数 Ramda 的多参数函数都是柯里化的，除了极个别的几个之外）在很多情形下，柯里化是使代码能更容易组合成这么简洁优雅的模块的原因之一。</p>
<p>让我们看看发生了什么。</p>
<p><code>get</code> （也称为 <code>prop</code>）定义如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ramda.get = curry(<span class="function"><span class="keyword">function</span>(<span class="params">name, obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj[name];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>但是，当调用上面的代码时，我们只提供第一个参数：<code>name</code>。正如之前讨论的，这意味着我们会返回一个新函数，等待第一个 <code>then</code> 传入 <code>obj</code> 参数给它，这就意味着下面的代码：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.then(R.get(<span class="string">'task'</span>))</div></pre></td></tr></table></figure></p>
<p>可以看做是下面代码的缩写：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> data.tasks;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>接下来是 <code>propEq</code>，定义如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ramda.propEq = curry(<span class="function"><span class="keyword">function</span>(<span class="params">name, val, obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj[name] === val;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>所以当使用参数 <code>username</code> 和 <code>membername</code> 调用它时，柯里化返给我们一个新函数，等价于：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj[<span class="string">'username'</span>] === membername;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其中 <code>membername</code> 的值绑定到了传递给我们的值上面。</p>
<p>然后将该函数传给 <code>filter</code>。</p>
<p>Ramda 的 <code>filter</code> 的工作原理很像原生的 <code>Array.prototype.filter</code> ，但类型签名为：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ramda.filter = curry(<span class="function"><span class="keyword">function</span>(<span class="params">predicate, list</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>所以，我们又进行柯里化了，只传入 &quot;predicate&quot; 函数（谓词），而没有一同传入从上一步输出的任务列表。（我已经告诉过你，所有的东西都是柯里化的，对吧？）</p>
<p><code>propEq('complete', true) -&gt; reject</code> 与 <code>propEq('username', membername) -&gt; filter</code> 做了相似的事情。<code>reject</code> 和 <code>filter</code> 功能类似，除了它们的输出结果是相反的。它只保留使 predicate 函数返回 false 的元素。</p>
<p>好了，你还在看吗？我的食指开始发酸了。（真的要学习盲打了！）不需要我来解释最后两行了吧？真的吗？你确定？好吧！好吧！那我再解释一下。</p>
<p>接下来我们看看：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">R.pick([<span class="string">'id'</span>, <span class="string">'dueDate'</span>, <span class="string">'title'</span>, <span class="string">'priority'</span>])</div></pre></td></tr></table></figure></p>
<p><code>pick</code> 接受属性名称列表和一个对象，返回从原对象提取指定属性集的新对象。你看，我们又使用了柯里化。由于只传递了属性名称列表，我们得到了一个函数：一旦我们提供一个对象，就会返回一个相同类型的新对象。该函数被传给 <code>R.map</code>。与 <code>filter</code> 类似，它与原生 <code>Array.prototype.map</code> 功能基本相同，但签名如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ramda.map = curry(<span class="function"><span class="keyword">function</span>(<span class="params">fn, list</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);</div></pre></td></tr></table></figure></p>
<p>不得不告诉你，这个函数也是柯里化的，因为我们只提供给它 <code>pick</code> 返回的函数（也是柯里化的！），而没有提供列表。<code>then</code> 将使用任务列表调用它。</p>
<p>好的，还记得小时候坐在教室，等待上课结束的情形吗？手里时钟的分针像是卡住了，另一只手正伸向桌洞里的糖果；老师却还在一遍一遍地重复相同的事情。还记得吗？然后那一刻终于到了，可能是结束前的最后两分钟，结束的时刻已经在眼前了：谢天谢地！下面是最后一个例子：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.then(R.sortBy(R.get(<span class="string">'dueDate'</span>)));</div></pre></td></tr></table></figure></p>
<p>之前已经提到过 <code>get</code>。这也是柯里化的，它会返回一个函数：输入对象，输出该对象的 <code>dueDate</code> 属性值。我们将其传给 <code>sortBy</code>，它接受这样的函数和一个列表，并根据函数返回的值对列表中的元素进行排序。但等等，我们没有列表，对吧？当然没有。我们又在做柯里化。但当调用 <code>then</code> 时，它会接收到列表，将列表中的每个对象传给 <code>get</code>，并根据结果进行排序。</p>
<h2 id="na-yao-ke-li-hua-you-duo-zhong-yao-ni">那么，柯里化有多重要呢？</h2>
<p>这个例子展示了 Ramda 的一些实用函数和 Ramda 的柯里化特性。或许柯里化并没有那么重要。我们不加柯里化重写一遍：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getIncompleteTaskSummaries = <span class="function"><span class="keyword">function</span>(<span class="params">membername</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fetchData()</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> R.get(<span class="string">'tasks'</span>, data)</div><div class="line">        &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> R.filter(<span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> R.propEq(<span class="string">'username'</span>, membername, task)</div><div class="line">            &#125;, tasks)</div><div class="line">         &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> R.reject(<span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> R.propEq(<span class="string">'complete'</span>, <span class="literal">true</span>, task);</div><div class="line">            &#125;, tasks)</div><div class="line">        &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> R.map(<span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> R.pick([<span class="string">'id'</span>, <span class="string">'dueDate'</span>, <span class="string">'title'</span>, <span class="string">'priority'</span>], task);</div><div class="line">            &#125;, tasks);</div><div class="line">        &#125;)</div><div class="line">        .then(<span class="function"><span class="keyword">function</span>(<span class="params">abbreviatedTasks</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> R.sortBy(<span class="function"><span class="keyword">function</span>(<span class="params">abbrTask</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> R.get(<span class="string">'dueDate'</span>, abbrTask);</div><div class="line">            &#125;, abbreviatedTasks);</div><div class="line">        &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>上面是等价的程序。它仍然比原来的代码好一些。Ramda 实用的函数... 确实比较实用，即使没有柯里化。但我不认为它的可读性有下面的好：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getIncompleteTaskSummaries = <span class="function"><span class="keyword">function</span>(<span class="params">membername</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> fetchData()</div><div class="line">        .then(R.get(<span class="string">'tasks'</span>))</div><div class="line">        .then(R.filter(R.propEq(<span class="string">'username'</span>, membername)))</div><div class="line">        .then(R.reject(R.propEq(<span class="string">'complete'</span>, <span class="literal">true</span>)))</div><div class="line">        .then(R.map(R.pick([<span class="string">'id'</span>, <span class="string">'dueDate'</span>, <span class="string">'title'</span>, <span class="string">'priority'</span>])))</div><div class="line">        .then(R.sortBy(R.get(<span class="string">'dueDate'</span>)));</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这就是我们柯里化的原因。</p>
<hr>
<p>课程结束了。</p>
<p>我警告过你的。</p>
<p>下一次，当我让你去看别人的东西而不是我的的时候，你会注意了吧。现在不读我的文章可能已经来不及了，但是他们的作品真的很棒，强烈推荐大家看一下：</p>
<ul>
<li><a href="http://hughfdjackson.com/javascript/why-curry-helps/" target="_blank" rel="external">为什么柯里化有帮助</a> ，Hugh FD Jackson</li>
<li><a href="http://www.youtube.com/watch?v=m3svKOdZijA" target="_blank" rel="external">嗨 Underscore，你做错了</a> ，Dr. Boolean, aka Brian Lonsdorf</li>
</ul>
<p>这里还有一篇我今天刚看到的新的文章。不知它是否会经的其时间的考验，但现在看来值得一读：</p>
<ul>
<li><a href="http://bahmutov.calepin.co/put-callback-first-for-elegance.html" target="_blank" rel="external">将回调放在首位，代码会更优雅</a> ，Gleb Bahmutov</li>
</ul>
<h2 id="yi-dian-bu-tai-hao-de-xiao-mi-mi">一点不太好的小秘密</h2>
<p>柯里化尽管非常强大，但单独使用并不足以让你的代码变得 &quot;那么&quot; 优雅。</p>
<p>应该有三个重要的组成部分：</p>
<ul>
<li>
<p><a href="http://fr.umio.us/why-ramda/" target="_blank" rel="external">上次</a> 我讨论了 <strong>函数式组合</strong>。它可以轻松地将你所有好的想法组合在一起，而不必使用大量丑陋的胶水代码将它们聚合在一起。</p>
</li>
<li>
<p><strong>柯里化</strong> 同样很有用，因为它很好的支持了组合，而且消除了大量的样板代码，正如上面所示。</p>
</li>
<li>
<p>很多能操作有用数据结构（如对象类型的数组）的 <strong>实用函数</strong> 。</p>
</li>
</ul>
<p><a href="https://github.com/ramda/ramda" target="_blank" rel="external">Ramda</a> 的目标之一便是：在一个简单的包里面提供所有这些功能。</p>
<h2 id="zhi-xie">致谢</h2>
<p><a href="http://buzzdecafe.github.io/" target="_blank" rel="external">buzzdecafe</a> 帮助编辑了本文和上一篇文章，并且这次还起了一个完美标题。谢谢，Mike！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="wangzengdi" />
          <p class="site-author-name" itemprop="name">wangzengdi</p>
          <p class="site-description motion-element" itemprop="description">FE@Meituan.com</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">27</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/adispring" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangzengdi</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'adispring';
      var disqus_identifier = 'index.html';
      var disqus_title = "";
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  




  
  

  

  

  

  


</body>
</html>
