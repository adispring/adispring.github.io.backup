<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
    
  
  <link href="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






  

<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.2" />






<meta name="description" content="FE@Meituan.com">
<meta property="og:type" content="website">
<meta property="og:title" content="wangzengdi&#39;s Blog">
<meta property="og:url" content="https://adispring.github.io/page/2/index.html">
<meta property="og:site_name" content="wangzengdi&#39;s Blog">
<meta property="og:description" content="FE@Meituan.com">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wangzengdi&#39;s Blog">
<meta name="twitter:description" content="FE@Meituan.com">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://adispring.github.io/page/2/"/>


  <title> wangzengdi's Blog </title>
</head>

<body itemscope itemtype="//schema.org/WebPage" lang="en">

  


<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97388892-2', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?fdee4a7147278c4213ba1baf75394f94";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="//schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">wangzengdi's Blog</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Functional Programming</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/25/Why-Ramda/" itemprop="url">
                  Why Ramda
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-25T16:26:35+08:00" content="2017-06-25">
              2017-06-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/25/Why-Ramda/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/25/Why-Ramda/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 <a href="https://github.com/CrossEye" target="_blank" rel="external">Scott Sauyet</a> 的 《<a href="http://fr.umio.us/why-ramda/" target="_blank" rel="external">Why Ramda</a>》，转载请与<a href="https://github.com/CrossEye" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>当 <a href="http://buzzdecafe.github.io/" target="_blank" rel="external">buzzdecafe</a> 最近将 <a href="https://github.com/ramda/ramda" target="_blank" rel="external">Ramda</a> <a href="http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/" target="_blank" rel="external">介绍给</a> 大家时，出现了两种截然相反的反应。那些熟悉函数式技术（在 JavaScript 或其他语言中）的人大部分的反应是：&quot;Cool&quot;。他们可能对此非常兴奋，也可能觉得只是另一个有潜力的工具而已，但他们都知道它的作用和目的。</p>
<p>另一部分人的反应是：&quot;Huh?&quot;</p>
<p><img src="./rbudiharso_tweet-2.png" alt="other-group-reponse"></p>
<p>对于那些不熟悉函数式编程的人来说，Ramda 似乎没有什么帮助。Ramda 中的大部分功能在类似于 <a href="https://github.com/jashkenas/underscore" target="_blank" rel="external">Underscore</a> 和 <a href="https://github.com/lodash/lodash" target="_blank" rel="external">Lodash</a> 库中都已经有了。</p>
<p>这些人是对的。如果你希望一直使用之前一直在用的命令式和面向对象的方式进行编程，那么 Ramda 可能没有太多价值。</p>
<p>然而，它提供了一种不同的编码风格，这种编程风格天然适合于函数式编程语言：Ramda 可以让 &quot;通过函数式组合构建复杂的逻辑&quot; 变得更简单。注意，任何包含 <code>compose</code> 函数的库都可以进行函数式组合；这样做真正的意义是：<em>&quot;make it simple(让编程变得简单)&quot;</em>。</p>
<p>来看看 Ramda 是如何工作的。</p>
<p>&quot;TODO lists&quot; (待办事项列表) 似乎是用于比较 Web 框架的 &quot;标准样例&quot;，所以我们也借用它来进行演示。假设需要一个能够删除所有已完成项的 &quot;TODO list&quot;。</p>
<p>使用内置的 Array 原型方法，我们可能会这样写：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Plain JS</span></div><div class="line"><span class="keyword">var</span> incompleteTasks = tasks.filter(<span class="function"><span class="keyword">function</span>(<span class="params">task</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> !task.complete;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>使用 LoDash，似乎变得简单一些：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Lo-Dash</span></div><div class="line"><span class="keyword">var</span> incompleteTasks = _.filter(tasks, &#123;<span class="attr">complete</span>: <span class="literal">false</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>通过上述任一方法，我们都可以得到一个过滤的任务列表。</p>
<p>在 Ramda 中，我们可以这样做：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> incomplete = R.filter(R.where(&#123;<span class="attr">complete</span>: <span class="literal">false</span>&#125;);</div></pre></td></tr></table></figure></p>
<p>(更新：<code>where</code> 函数被<a href="https://github.com/ramda/ramda/pull/1036" target="_blank" rel="external">拆分成两部分</a>：<a href="http://ramdajs.com/docs/#where" target="_blank" rel="external"><code>where</code></a> 和 <a href="http://ramdajs.com/docs/#whereEq" target="_blank" rel="external"><code>whereEq</code></a>，该段代码可能不会像现在这样工作了)。</p>
<p>注意到有什么不同了吗？这里没有提到任务列表。Ramda 代码只给我们函数（没有给数据参数）。</p>
<p>这就是重点所在。</p>
<p>现在我们有了一个函数，可以很容易与其他函数组合，来处理任意我们选择的数据。假设现在有一个函数：<code>groupByUser</code>，可以通过用户对待办事项进行分类。我们可以简单地创建一个新函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> activeByUser = R.compose(groupByUser, incomplete);</div></pre></td></tr></table></figure></p>
<p>用来选择未完成的任务，并对其按用户分类。</p>
<p>如果给它提供数据，这就是一个函数调用。如果不借助 <code>compose</code> 手写出来，可能看起来会像这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// (if created by hand)</span></div><div class="line"><span class="keyword">var</span> activeByUser = <span class="function"><span class="keyword">function</span>(<span class="params">tasks</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> groupByUser(incomplete(tasks));</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>&quot;不必手动一步一步地去做&quot; 是组合的关键所在。并且组合是函数式编程的一项关键技术。让我们看看，如果再进一步的话会发生什么。如果需要使用到期日期来对这些用户的待办事项进行排序，该怎么办呢？</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sortUserTasks = R.compose(R.map(R.sortBy(R.prop(<span class="string">"dueDate"</span>))), activeByUser);</div></pre></td></tr></table></figure></p>
<h2 id="yi-bu-dao-wei">一步到位？</h2>
<p>善于观察的读者可能已经注意到了，我们可以组合上述所有需求。由于 <code>compose</code> 函数可以接受多个参数，为什么不一次完成上面所有的功能呢？</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sortUserTasks = R.compose(</div><div class="line">    R.mapObj(R.sortBy(R.prop(<span class="string">'dueDate'</span>))),</div><div class="line">    groupByUser,</div><div class="line">    R.filter(R.where(&#123;<span class="attr">complete</span>: <span class="literal">false</span>&#125;)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>我的答案是：如果中间函数 <code>activeByUser</code> 和 <code>incomplete</code> 没有其他的调用，上述方案可能更合理一些。但是这可能会使调试变得更麻烦，而且对代码的可读性也并没有什么帮助。</p>
<p>事实上，可以换个思路。我们在内部使用可重用的复杂模块，这样做可能会更好些：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sortByDate = R.sortBy(R.prop(<span class="string">'dueDate'</span>));</div><div class="line"><span class="keyword">var</span> sortUserTasks = R.compose(R.mapObj(sortByDate), activeByUser);</div></pre></td></tr></table></figure></p>
<p>现在可以用 <code>sortByDate</code> 对任何任务列表，通过到期日期进行排序。（事实上，可以更灵活，它可以对任何符合下面条件的数组进行排序：数组元素为包含可排序的 &quot;dueDate&quot; 属性的对象。</p>
<p>但是，等等，如果想要按日期降序排列呢？</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> sortByDateDescend = R.compose(R.reverse, sortByDate);</div><div class="line"><span class="keyword">var</span> sortUserTasks = R.compose(R.mapObj(sortByDateDescend), activeByUser);</div></pre></td></tr></table></figure></p>
<p>如果确定只需要按日期降序排列，可以将所有这些操作都在 <code>sortByDateDescend</code> 中进行组合。如果不确定会升序还是降序排列，我个人会将升序和降序方法都保留。</p>
<h2 id="shu-ju-zai-na-li">数据在哪里？</h2>
<p>我们 <strong>仍然</strong> 没有任何数据。这是怎么回事？没有数据的 &quot;数据处理&quot; 是...什么呢？是 &quot;处理&quot;。接下来恐怕需要你多一些耐心了。当进行函数式编程时，所有能获得只是组成 pipeline （管道）的函数。一个函数将数据提供给下一个，下一个函数将数据提供给下下个，依次类推，直到所需的结果从 pipeline 末端输出。</p>
<p>到目前为止，我们已经创建的函数如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">incomplete: [Task] -&gt; [Task]</div><div class="line">sortByDate: [Task] -&gt; [Task]</div><div class="line">sortByDateDescend: [Task] -&gt; [Task]</div><div class="line">activeByUser: [Task] -&gt; &#123;<span class="attr">String</span>: [Task]&#125;</div><div class="line">sortUserTasks: &#123;<span class="attr">String</span>: [Task]&#125; -&gt; &#123;<span class="attr">String</span>: [Task]&#125;</div></pre></td></tr></table></figure></p>
<p>虽然我们使用了之前的函数来构建 <code>sortUserTasks</code> ，但它们单独可能都是有用的。我们可能掩盖了一些东西。我只是让你想象有一个构建 <code>activeByUser</code> 的函数 <code>byUser</code>，但并没有真正看到过它。那么我们如何构建这个函数呢？</p>
<p>下面是一种方法：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> groupByUser = R.partition(R.prop(<span class="string">'username'</span>));</div></pre></td></tr></table></figure></p>
<p><code>partition</code> 使用了 Ramda 中的 <code>reduce</code>（与 Array.prototype.reduce <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce" target="_blank" rel="external">类似</a>）。它也被叫做 <code>foldl</code>，一个在许多其他函数式语言中使用的名称。我们不会在这里做过多讨论。你可以在 <a href="https://www.google.com/?q=reduce+function+javascript" target="_blank" rel="external">网上</a> 获得所有关于 <code>reduce</code> 的信息。<code>partition</code> 只是使用 <code>reduce</code> 将一个列表分成具有相同键值的子列表，子列表通过函数来确定，本例中为 <code>prop('username')</code>，它只是简单地从每个数组元素中取出 &quot;username&quot; 属性。</p>
<p>（所以，我是否使用 &quot;闪亮&quot; 的新函数来分散了你的注意力？我在这里仍然没有提到数据！对不住了，看！一大波 &quot;闪亮&quot; 的新函数又来了！）</p>
<h2 id="dan-deng-deng-huan-you-geng-duo-han-shu">但等等，还有更多（函数）</h2>
<p>如果我们愿意，可以继续这样下去。如果想从列表中选出前 5 个元素，可以使用 Ramda 的 <code>take</code> 函数。所以想要获取每个用户前 5 个任务，可以这样做：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> topFiveUserTasks = R.compose(R.mapObj(R.take(<span class="number">5</span>)), sortUserTasks);</div></pre></td></tr></table></figure></p>
<p>(会有人在这里想到 <a href="http://en.wikipedia.org/wiki/Take_Five" target="_blank" rel="external">Brubeck 和 Desmond</a> 吗)？</p>
<p>然后，可以将返回的对象压缩为属性的子集。比如标题和到期日期。用户名在这个数据结构里显然是多余的，我们也可能不想将过多不需要的属性传递给其他系统。</p>
<p>可以使用 Ramda 的 <code>project</code> 函数来模拟 SQL 的 <code>select</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> importantFields = R.project([<span class="string">'title'</span>, <span class="string">'dueDate'</span>]);</div><div class="line"><span class="keyword">var</span> topDataAllUsers = R.compose(R.mapObj(importantFields), topFiveUserTasks);</div></pre></td></tr></table></figure></p>
<p>我们一路创建的一些函数，看起来可以在 TODO 应用的其他地方复用。其他的一些函数或许只是创建出来放在那里，以供将来组合使用。所以，如果现在回顾一下，我们可能会组合出下面的代码：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> incomplete = R.filter(R.where(&#123;<span class="attr">complete</span>: <span class="literal">false</span>&#125;));</div><div class="line"><span class="keyword">var</span> sortByDate = R.sortBy(R.prop(<span class="string">'dueDate'</span>));</div><div class="line"><span class="keyword">var</span> sortByDateDescend = R.compose(R.reverse, sortByDate);</div><div class="line"><span class="keyword">var</span> importantFields = R.project([<span class="string">'title'</span>, <span class="string">'dueDate'</span>]);</div><div class="line"><span class="keyword">var</span> groupByUser = R.partition(R.prop(<span class="string">'username'</span>));</div><div class="line"><span class="keyword">var</span> activeByUser = R.compose(groupByUser, incomplete);</div><div class="line"><span class="keyword">var</span> topDataAllUsers = R.compose(R.mapObj(R.compose(importantFields, </div><div class="line">    R.take(<span class="number">5</span>), sortByDateDescend)), activeByUser);</div></pre></td></tr></table></figure></p>
<h2 id="hao-ba-gou-liao-wo-ke-yi-kan-yi-xie-shu-ju-ma">好吧，够了！我可以看一些数据吗？</h2>
<p>好的，马上就可以了。</p>
<p>现在是时候将数据传给我们的函数了。但关键是，这些函数都接受相同类型的数据，一个包含 TODO 元素的数组。我们还没有具体描述这些元素的数据结构，但我们知道它至少必须包含下列属性：</p>
<ul>
<li>complete: Boolean</li>
<li>dueDate: String, formatted YYYY-MM-DD</li>
<li>title: String</li>
<li>userName: String</li>
</ul>
<p>所以，如果我们有一个任务数组，该如何使用呢？很简单：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> results = topDataAllUsers(tasks);</div></pre></td></tr></table></figure></p>
<p>就这些吗？</p>
<p>所有已经编写的程序，就只有这些？</p>
<p>恐怕是这样。输出会是一个像下面这样的对象：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="attr">Michael</span>: [</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-22'</span>, <span class="attr">title</span>: <span class="string">'Integrate types with main code'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-15'</span>, <span class="attr">title</span>: <span class="string">'Finish algebraic types'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-06'</span>, <span class="attr">title</span>: <span class="string">'Types infrastucture'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-05-24'</span>, <span class="attr">title</span>: <span class="string">'Separating generators'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-05-17'</span>, <span class="attr">title</span>: <span class="string">'Add modulo function'</span>&#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">Richard</span>: [</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-22'</span>, <span class="attr">title</span>: <span class="string">'API documentation'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-15'</span>, <span class="attr">title</span>: <span class="string">'Overview documentation'</span>&#125;</div><div class="line">    ],</div><div class="line">    <span class="attr">Scott</span>: [</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-22'</span>, <span class="attr">title</span>: <span class="string">'Complete build system'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-15'</span>, <span class="attr">title</span>: <span class="string">'Determine versioning scheme'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-09'</span>, <span class="attr">title</span>: <span class="string">'Add `mapObj`'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-05'</span>, <span class="attr">title</span>: <span class="string">'Fix `and`/`or`/`not`'</span>&#125;,</div><div class="line">        &#123;<span class="attr">dueDate</span>: <span class="string">'2014-06-01'</span>, <span class="attr">title</span>: <span class="string">'Fold algebra branch back in'</span>&#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但这里有件有趣的事情。你可以将相同的任务初始列表传给 <code>incomplete</code> ，然后得到一个过滤过的列表：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> incompleteTasks = incomplete(tasks);</div></pre></td></tr></table></figure></p>
<p>返回的内容可能是下面这样子：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[</div><div class="line">    &#123;</div><div class="line">        <span class="attr">username</span>: <span class="string">'Scott'</span>,</div><div class="line">        <span class="attr">title</span>: <span class="string">'Add `mapObj`'</span>,</div><div class="line">        <span class="attr">dueDate</span>: <span class="string">'2014-06-09'</span>,</div><div class="line">        <span class="attr">complete</span>: <span class="literal">false</span>,</div><div class="line">        <span class="attr">effort</span>: <span class="string">'low'</span>,</div><div class="line">        <span class="attr">priority</span>: <span class="string">'medium'</span></div><div class="line">    &#125;, &#123;</div><div class="line">        <span class="attr">username</span>: <span class="string">'Michael'</span>,</div><div class="line">        <span class="attr">title</span>: <span class="string">'Finish algebraic types'</span>,</div><div class="line">        <span class="attr">dueDate</span>: <span class="string">'2014-06-15'</span>,</div><div class="line">        <span class="attr">complete</span>: <span class="literal">true</span>,</div><div class="line">        <span class="attr">effort</span>: <span class="string">'high'</span>,</div><div class="line">        <span class="attr">priority</span>: <span class="string">'high'</span></div><div class="line">    &#125; <span class="comment">/*, ... */</span></div><div class="line">]</div></pre></td></tr></table></figure></p>
<p>当然，你也可以将任务列表传给 <code>sortByDate</code>、<code>sortByDateDescend</code>、<code>importantFields</code>、<code>byUser</code> 或者 <code>activeByUser</code>。因为它们都处理相似的数据类型：一系列任务的列表。我们可以通过简单的组合创建出大量的工具。</p>
<h2 id="xin-xu-qiu">新需求</h2>
<p>在游戏的最后，你刚刚被告知需要添加一个新特性。你需要过滤出仅属于特定用户的任务，然后对该用户进行与之前相同的过滤、排序和提取子集操作。</p>
<p>这个逻辑当前嵌入到 <code>topDataAllUser</code> 里了...，或许我们组合的函数侵入太深。但也很容易重构。通常情况下，最难的是起一个好的名字。&quot;gloss&quot; 可能不太好，但已经是深夜了，这是我能想到最好的了：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gloss = R.compose(importantFields, R.take(<span class="number">5</span>), sortByDateDescend);</div><div class="line"><span class="keyword">var</span> topData = R.compose(gloss, incomplete);</div><div class="line"><span class="keyword">var</span> topDataAllUsers = R.compose(R.mapObj(gloss), activeByUser);</div><div class="line"><span class="keyword">var</span> byUser = R.use(R.filter).over(R.propEq(<span class="string">"username"</span>));</div></pre></td></tr></table></figure></p>
<p>如果想使用它，可以像下面这样：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> results = topData(byUser(<span class="string">'Scott'</span>, tasks));</div></pre></td></tr></table></figure></p>
<h2 id="bai-tuo-wo-zhi-shi-xiang-yao-wo-de-shu-ju">拜托，我只是想要我的数据！</h2>
<p>&quot;好的&quot;，你说，&quot;也许这很酷，但现在我真的只是想要我的数据，我不想要不知猴年马月才能返回给我数据的函数。我还能用 Ramda 吗？&quot;</p>
<p>当然可以。</p>
<p>让我们回到第一个函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> incomplete = R.filter(R.where(&#123;<span class="attr">complete</span>: <span class="literal">false</span>&#125;));</div></pre></td></tr></table></figure></p>
<p>如何才能变成会返回数据的东西呢？非常简单：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> incompleteTasks = R.filter(R.where(&#123;<span class="attr">complete</span>: <span class="literal">false</span>&#125;), tasks);</div></pre></td></tr></table></figure></p>
<p>所有其他主要的函数也是这样：只需要在调用的最后面添加一个 <code>tasks</code> 参数，即可返回数据。</p>
<h2 id="gang-gang-fa-sheng-liao-shi-yao">刚刚发生了什么？</h2>
<p>这是 Ramda 的另一个重要特性。Ramda 所有主要的函数都是自动柯里化的。这意味着，如果你不提供给函数需要的所有参数，不想立即调用函数，我们会返会一个接受剩余参数的新函数。所以，<code>filter</code> 的定义既包含数组，也包含了过滤数组元素的 &quot;predicate&quot; 函数（判断函数）。在初始版本中，我们没有提供数组值，所以 <code>filter</code> 会返回一个新的接受数组为参数的函数。在第二个版本中，我们传入了数组，并与 &quot;predicate&quot; 函数一起来计算结果。</p>
<p>Ramda 函数的自动柯里化和 &quot;函数优先，数据最后&quot; 的 API 设计理念一起，使得 Ramda 能够非常简单地进行这种风格的函数式组合。</p>
<p>但 Ramda 中柯里化的实现细节是另一篇文章的事情（更新：该文章已经发布了：<a href="http://fr.umio.us/favoring-curry/" target="_blank" rel="external">Favoring Curry</a>）。同时，Hugh Jackson 的这篇文章也绝对值得一读：<a href="http://hughfdjackson.com/javascript/why-curry-helps/" target="_blank" rel="external">为什么柯里化有帮助</a>。</p>
<h2 id="dan-shi-zhe-xie-dong-xi-zhen-neng-gong-zuo-ma">但是，这些东西真能工作吗？</h2>
<p>这是我们一直讨论的代码的 JSFiddle 示例：</p>
<p><iframe scrolling="no" width="100%" height="300" src="//jsfiddle.net/CrossEye/Gk6uu/embedded/js,html,result/light" frameborder="0" allowfullscreen></iframe></p>
<p>这段优雅的代码清楚的表明了使用 Ramda 的好处。</p>
<h2 id="shi-yong-ramda">使用 Ramda</h2>
<p><a href="http://ramda.cn/docs/" target="_blank" rel="external">可以参考 Ramda 非常不错的文档</a>。</p>
<p>Ramda 代码本身非常有用，上面提到的技术也非常有帮助。你可以从 <a href="https://github.com/ramda/ramda" target="_blank" rel="external">Github 仓库</a> 获取代码，或 <a href="https://www.npmjs.org/package/ramda" target="_blank" rel="external">通过 npm 安装 Ramda</a>。</p>
<p>在 Node 中使用：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">npm install ramda</div><div class="line"><span class="keyword">var</span> R = <span class="built_in">require</span>(<span class="string">'ramda'</span>)</div></pre></td></tr></table></figure></p>
<p>在浏览器中使用，只需包含下列代码：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"path/to/yourCopyOf/ramda.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>或者</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=<span class="string">"path/to/yourCopyOf/ramda.min.js"</span>&gt;&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>我们会尽快将其放到 CDN 上。</p>
<p>如果你有任何建议，<a href="https://github.com/ramda/ramda/issues?state=open" target="_blank" rel="external">欢迎随时跟我们联系</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/25/Introducing-Ramda/" itemprop="url">
                  Ramda 简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-25T14:49:18+08:00" content="2017-06-25">
              2017-06-25
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/25/Introducing-Ramda/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/25/Introducing-Ramda/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 <a href="https://github.com/buzzdecafe" target="_blank" rel="external">Michael Hurley</a> 的 《<a href="http://buzzdecafe.github.io/code/2014/05/16/introducing-ramda/" target="_blank" rel="external">Introducing Ramda</a>》，转载请与<a href="https://github.com/buzzdecafe" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>在过去一年的时间里，我的同事 Scott Sauyet 和我一直在编写 <a href="https://github.com/ramda/ramda" target="_blank" rel="external">Ramda</a> ：&quot;一个实用的 JavaScript 函数式编程库&quot;。当我们为 Frontend Masters 注册 &quot;使用 JavaScript 进行核心函数式编程&quot; 工作室时，惊讶地发现，他们选择 Ramda 来说明他们的示例。这件事给了我们信心，我们认为现在是宣布 Ramda 到来的时候了。</p>
<p>现在已经存在一些优秀的函数式库，如 <a href="https://github.com/jashkenas/underscore" target="_blank" rel="external">Underscore</a> 和 <a href="https://github.com/lodash/lodash" target="_blank" rel="external">Lodash</a>。Ramda 包含了所有你想要的列表操作函数，像 <code>map</code>、<code>filter</code>、<code>reduce</code> 和 <code>find</code> 等。但 Ramda 跟 Underscore 和 Lodash 有很大的区别。Ramda 的主要特性如下：</p>
<ul>
<li><strong>Ramda 先接受函数参数，最后接受数据参数。</strong> <a href="http://www.youtube.com/watch?v=m3svKOdZijA" target="_blank" rel="external">Brian Lonsdorf 解释了为什么这样的参数顺序很重要</a>。简言之，柯里化和 &quot;函数优先&quot; 这两者相结合，使开发者在最终传入数据之前，能够以非常少的代码（通常为 &quot;point-free&quot; 风格，也即无参数风格）来组合函数。例如，以下面代码为例：</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Underscore/Lodash style:</span></div><div class="line"><span class="keyword">var</span> validUsersNamedBuzz = <span class="function"><span class="keyword">function</span>(<span class="params">users</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> _.filter(users, <span class="function"><span class="keyword">function</span>(<span class="params">user</span>) </span>&#123; </div><div class="line">    <span class="keyword">return</span> user.name === <span class="string">'Buzz'</span> &amp;&amp; _.isEmpty(user.errors); </div><div class="line">  &#125;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>现在可以这么写：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Ramda style:</span></div><div class="line"><span class="keyword">var</span> validUsersNamedBuzz = R.filter(R.where(&#123;<span class="attr">name</span>: <span class="string">'Buzz'</span>, <span class="attr">errors</span>: R.isEmpty&#125;));</div></pre></td></tr></table></figure></p>
<ul>
<li><strong>Ramda 的函数是自动柯里化的</strong> 。当你需要对 Underscore 或 Lodash 中的函数进行手动柯里化（或部分柯里化）时，Ramda 在内部已经替你完成这项工作了。实际上，Ramda 中所有的多元（多参数）函数都默认是柯里化的。例如：</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// `prop` takes two arguments. If I just give it one, I get a function back</span></div><div class="line"><span class="keyword">var</span> moo = R.prop(<span class="string">'moo'</span>);</div><div class="line"><span class="comment">// when I call that function with one argument, I get the result.</span></div><div class="line"><span class="keyword">var</span> value = moo(&#123;<span class="attr">moo</span>: <span class="string">'cow'</span>&#125;); <span class="comment">// =&gt; 'cow'</span></div></pre></td></tr></table></figure></p>
<p>这种自动柯里化使得 &quot;通过组合函数来创建新函数&quot; 变得非常容易。因为 API 都是函数优先、数据最后（先传函数，最后传数据参数），你可以不断地组合函数，直到创建出需要的新函数，然后将数据传入其中。（Hugh Jackson 发表了一遍描述这种风格优点的 <a href="http://hughfdjackson.com/javascript/why-curry-helps/" target="_blank" rel="external">非常优秀的文章</a>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// take an object with an `amount` property</span></div><div class="line"><span class="comment">// add one to it</span></div><div class="line"><span class="comment">// find its remainder when divided by 7</span></div><div class="line"><span class="keyword">var</span> amtAdd1Mod7 = R.compose(R.moduloBy(<span class="number">7</span>), R.add(<span class="number">1</span>), R.prop(<span class="string">'amount'</span>));</div><div class="line"></div><div class="line"><span class="comment">// we can use that as is:</span></div><div class="line">amtAdd1Mod7(&#123;<span class="attr">amount</span>: <span class="number">17</span>&#125;); <span class="comment">// =&gt; 4</span></div><div class="line">amtAdd1Mod7(&#123;<span class="attr">amount</span>: <span class="number">987</span>&#125;); <span class="comment">// =&gt; 1</span></div><div class="line">amtAdd1Mod7(&#123;<span class="attr">amount</span>: <span class="number">68</span>&#125;); <span class="comment">// =&gt; 6</span></div><div class="line"><span class="comment">// etc. </span></div><div class="line"></div><div class="line"><span class="comment">// But we can also use our composed function on a list of objects, e.g. to `map`:</span></div><div class="line"><span class="keyword">var</span> amountObjects = [</div><div class="line">  &#123;<span class="attr">amount</span>: <span class="number">903</span>&#125;, &#123;<span class="attr">amount</span>: <span class="number">2875654</span>&#125;, &#123;<span class="attr">amount</span>: <span class="number">6</span>&#125;</div><div class="line">]</div><div class="line">R.map(amtAdd1Mod7, amountObjects); <span class="comment">// =&gt; [1, 6, 0]</span></div><div class="line"></div><div class="line"><span class="comment">// of course, `map` is also curried, so you can generate a new function </span></div><div class="line"><span class="comment">// using `amtAdd1Mod7` that will wait for a list of "amountObjects" to </span></div><div class="line"><span class="comment">// get passed in:</span></div><div class="line"><span class="keyword">var</span> amountsToValue = map(amtAdd1Mod7);</div><div class="line">amountsToValue(amountObjects); <span class="comment">// =&gt; [1, 6, 0]</span></div></pre></td></tr></table></figure></p>
<p><a href="https://www.npmjs.org/package/ramda" target="_blank" rel="external">Ramda 提供了 npm 包</a>，可以下载下来尝试一下。如果你对 Ramda 库有什么想法或改进建议，<a href="https://github.com/CrossEye/ramda/issues" target="_blank" rel="external">请联系我们</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/18/Thinking-in-Ramda-Wrap-Up/" itemprop="url">
                  Thinking in Ramda: 概要总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-18T10:17:35+08:00" content="2017-06-18">
              2017-06-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/18/Thinking-in-Ramda-Wrap-Up/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/18/Thinking-in-Ramda-Wrap-Up/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/07/19/thinking-in-ramda-wrap-up/" target="_blank" rel="external">Thinking in Ramda: Wrap-Up</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的总结篇。</p>
<p>在过去的八篇文章中，我们一直在讨论 <a href="http://ramda.cn/" target="_blank" rel="external">Ramda JavsScipt 库</a>，它提供了一系列以函数式、声明式和数据不变性方式工作的函数。</p>
<p>在这个系列中，我们了解了蕴含在 Ramda API 背后的一些指导原则：</p>
<ul>
<li>
<p>数据放在最后：几乎所有的函数都将数据参数作为最后一个参数。</p>
</li>
<li>
<p>柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。</p>
</li>
</ul>
<p>这两个原则使我们能编写出非常清晰的函数式代码，可以将基本的构建模块组合成更强大的操作。</p>
<h2 id="zong-jie">总结</h2>
<p>作为参考，一下是本系列文章的简单概要。</p>
<ul>
<li>
<p><a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="external">入门</a>：介绍了函数、纯函数和数据不变性思想。作为入门，展示了一些集合迭代函数，如：<code>map</code>、<code>filter</code> 和 <code>reduce</code> 等。</p>
</li>
<li>
<p><a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="external">函数组合</a>：演示了可以使用工具（如 <code>both</code>、<code>either</code>、<code>pipe</code> 和 <code>compose</code>）以多种方式组合函数。</p>
</li>
<li>
<p><a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="external">部分应用(Partial Application)</a>：演示了一种非常有用的函数延时调用方式：可以先向函数传入部分参数，以后根据需要将其余参数传入。借助 <code>partial</code> 和 <code>curry</code> 可以实现部分应用。我们还学习了 <code>flip</code> 和占位符（<code>__</code>）。</p>
</li>
<li>
<p><a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="external">声明式编程</a>：介绍了命令式和函数式编程之间的区别。学习了如何使用 Ramda 的声明式函数代替算术、比较、逻辑和条件运算符。</p>
</li>
<li>
<p><a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="external">无参数风格编程(Pointfree Style)</a>：介绍了 pointfree 风格的思想，也被称为 &quot;tatic&quot; 式编程。在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。</p>
</li>
<li>
<p><a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="external">数据不变性和对象</a>：该节让我们回到了声明式编程的思想，展示了读取、更新、删除和转换对象属性所需的工具。</p>
</li>
<li>
<p><a href="https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" target="_blank" rel="external">数据不变性和数组</a>：继续上一节的主题，展示了数据不变性在数组中的应用。</p>
</li>
<li>
<p><a href="https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/" target="_blank" rel="external">透镜(Lenses)</a>：引入了透镜的概念，该结构允许我们把重点聚焦在较大的数据结构的一小部分上。借助 <code>view</code>、<code>set</code> 和 <code>over</code> 函数，可以对较大数据结构的小部分被关注数据进行读取、更新和变换操作。</p>
</li>
</ul>
<h2 id="hou-xu">后续</h2>
<p>该系列文章并未覆盖到 Ramda 所有部分。特别是，我们没有讨论处理字符串的函数，也没有讨论一些更高阶的概念，如 <a href="http://ramda.cn/docs/#transduce" target="_blank" rel="external">transducers</a>。</p>
<p>要了解更多 Ramda 的作用，我建议仔细阅读 <a href="http://ramda.cn/docs/" target="_blank" rel="external">官方文档</a>，那里有大量的信息。所有的函数都按照它们处理数据的类型进行了分类，尽管有一些重叠。比如，有几个处理数组的函数可以用于处理字符串，<code>map</code> 可以作用于数组和对象两种类型。</p>
<p>如果你对更高级的函数式主题感兴趣，可以参考一下资料：</p>
<ul>
<li>
<p>Transducers：这里有一篇 <a href="http://simplectic.com/blog/2015/ramda-transducers-logs/" target="_blank" rel="external">使用 transducers 解析日志</a> 的介绍性文章。（译者也翻译了该系列两篇文章：<a href="https://adispring.coding.me/2016/10/24/Transducers-Explained-Part-1/" target="_blank" rel="external">《Transducers Explained: Part 1 中文》</a> 和 <a href="https://adispring.coding.me/2016/11/01/Transducers-Explained-Pipelines/" target="_blank" rel="external">《Transducers Explained: Pipelines 中文》</a>）。</p>
</li>
<li>
<p>代数数据类型：如果你已经阅读了很多关于函数式编程的知识，应该听过代数类型和相关术语，如 &quot;Functor&quot;、&quot;Applicative&quot; 和 &quot;Monad&quot;。如果有兴趣深入了解这方面的思想，及其在 Ramda 中的实现和应用，可以查看 <a href="https://github.com/ramda/ramda-fantasy" target="_blank" rel="external">ramda-fantasy</a> 项目，该项目实现了符合 <a href="https://github.com/fantasyland/fantasy-land" target="_blank" rel="external">Fantasy Land 规范</a> （又称为 JavaScript 代数规范）的一些数据类型。</p>
</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/18/Thinking-in-Ramda-Lenses/" itemprop="url">
                  Thinking in Ramda: 透镜（Lenses）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-18T07:27:42+08:00" content="2017-06-18">
              2017-06-18
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/18/Thinking-in-Ramda-Lenses/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/18/Thinking-in-Ramda-Lenses/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/07/12/thinking-in-ramda-lenses/" target="_blank" rel="external">Thinking in Ramda: Lenses</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的第八篇。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="external">第六节</a>  和 <a href="https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" target="_blank" rel="external">第七节</a> 中，我们学习了如何以声明式和不变式来读取、更新和转换对象的属性和数组的元素。</p>
<p>Ramda 提供了一个更通用的工具：透镜（lens），来进行这些操作。</p>
<h2 id="shi-yao-shi-tou-jing">什么是透镜？</h2>
<p>透镜将 &quot;getter&quot; 和 &quot;setter&quot; 函数组合为一个单一模块。Ramda 提供了一系列配合透镜一起工作的函数。</p>
<p>可以将透镜视为对某些较大数据结构的特定部分的聚焦、关注。</p>
<h2 id="ru-he-chuang-jian-tou-jing">如何创建透镜</h2>
<p>在 Ramda 中，最常见的创建透镜的方法是 <code>lens</code> 函数。<code>lens</code> 接受一个 &quot;getter&quot; 函数和一个 &quot;setter&quot; 函数，然后返回一个新透镜。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">'Randy'</span>,</div><div class="line">  <span class="attr">socialMedia</span>: &#123;</div><div class="line">    <span class="attr">github</span>: <span class="string">'randycoulman'</span>,</div><div class="line">    <span class="attr">twitter</span>: <span class="string">'@randycoulman'</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="keyword">const</span> nameLens = lens(prop(<span class="string">'name'</span>), assoc(<span class="string">'name'</span>))</div><div class="line"><span class="keyword">const</span> twitterLens = lens(</div><div class="line">  path([<span class="string">'socialMedia'</span>, <span class="string">'twitter'</span>]),</div><div class="line">  assocPath([<span class="string">'socialMedia'</span>, <span class="string">'twitter'</span>])</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>这里使用 <code>prop</code> 和 <code>path</code> 作为 &quot;getter&quot; 方法；<code>assoc</code> 和 <code>assocPath</code> 作为 &quot;setter&quot; 方法。</p>
<p>注意，上面实现不得不重复传递属性和路径参数给 &quot;getter&quot; 和 &quot;setter&quot; 方法。幸运的是，Ramda 为最常见类型的透镜提供了便捷方法：<code>lensProp</code>、<code>lensPath</code> 和 <code>lensIndex</code>。</p>
<ul>
<li><code>LensProp</code>：创建关注对象某一属性的透镜。</li>
<li><code>lensPath</code>: 创建关注对象某一嵌套属性的透镜。</li>
<li><code>lensIndex</code>: 创建关注数组某一索引的透镜。</li>
</ul>
<p>可以用 <code>lensProp</code> 和 <code>lensPath</code> 来重写上述示例：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nameLens = lensProp(<span class="string">'name'</span>)</div><div class="line"><span class="keyword">const</span> twitterLens = lensPath([<span class="string">'socialMedia'</span>, <span class="string">'twitter'</span>])</div></pre></td></tr></table></figure></p>
<p>这样便摆脱了向 &quot;getter&quot; 和 &quot;setter&quot; 重复输入两次相同参数的烦扰，变得简洁多了。在实际工作中，我发现我几乎从来不需要使用通用的 <code>lens</code> 函数。</p>
<h2 id="wo-neng-yong-ta-zuo-shi-yao-ni">我能用它做什么呢？</h2>
<p>我们创建了一些透镜，可以用它们做些什么呢？</p>
<p>Ramda 提供了三个配合透镜一起使用的的函数：</p>
<ul>
<li><code>view</code>：读取透镜的值。</li>
<li><code>set</code>：更新透镜的值。</li>
<li><code>over</code>：将变换函数作用于透镜。</li>
</ul>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">view(nameLens, person) <span class="comment">// =&gt; 'Randy'</span></div><div class="line"> </div><div class="line">set(twitterLens, <span class="string">'@randy'</span>, person)</div><div class="line"><span class="comment">// =&gt; &#123;</span></div><div class="line"><span class="comment">//   name: 'Randy',</span></div><div class="line"><span class="comment">//   socialMedia: &#123;</span></div><div class="line"><span class="comment">//     github: 'randycoulman',</span></div><div class="line"><span class="comment">//     twitter: '@randy'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div><div class="line"> </div><div class="line">over(nameLens, toUpper, person)</div><div class="line"><span class="comment">// =&gt; &#123;</span></div><div class="line"><span class="comment">//   name: 'RANDY',</span></div><div class="line"><span class="comment">//   socialMedia: &#123;</span></div><div class="line"><span class="comment">//     github: 'randycoulman',</span></div><div class="line"><span class="comment">//     twitter: '@randycoulman'</span></div><div class="line"><span class="comment">//   &#125;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure></p>
<p>注意，<code>set</code> 和 <code>over</code> 会按指定的方式对被透镜关注的属性进行修改，并返回整个新的对象。</p>
<h2 id="jie-lun">结论</h2>
<p>如果想从复杂数据结构的操作中抽象出简单、通用的方法，透镜可以提供很多帮助。我们只需暴露透镜；而不需要暴露整个数据结构、或者为每个可访问属性都提供 &quot;setter&quot;、&quot;getter&quot; 和 变换方法。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>我们现在已经了解了许多 Ramda 提供的方法，已经足以应对大部分编程需要。<a href="https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Wrap-Up/" target="_blank" rel="external">总结</a> 将回顾整个系列的内容，并会提到一些可能需要自己进一步探索的其他主题。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" itemprop="url">
                  Thinking in Ramda: 数据不变性和数组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-17T22:21:48+08:00" content="2017-06-17">
              2017-06-17
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/07/05/thinking-in-ramda-immutability-and-arrays/" target="_blank" rel="external">Thinking in Ramda: Immutability and Arrays</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的第七篇。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="external">第六节</a> 中，讨论了以函数式和数据不变性（immutable）的方式来处理 JavaScript 对象。</p>
<p>本节将继续用相同的方式讨论数组。</p>
<h2 id="du-qu-shu-zu-yuan-su">读取数组元素</h2>
<p>在 <a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="external">第六节</a> 中，展示了许多读取对象属性的 Ramda 函数，包括 <code>prop</code>、<code>pick</code> 和 <code>has</code>。Ramda 有更多的方法来读取数组的元素。</p>
<p>数组中与 <code>prop</code> 类似的是 <code>nth</code>；与 <code>pick</code> 类似的是 <code>slice</code>，跟 <code>has</code> 类似的是 <code>contains</code>。来看一些例子。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</div><div class="line"> </div><div class="line">nth(<span class="number">3</span>, numbers) <span class="comment">// =&gt; 40  (0-based indexing)</span></div><div class="line"> </div><div class="line">nth(<span class="number">-2</span>, numbers) <span class="comment">// =&gt; 50 (negative numbers start from the right)</span></div><div class="line"> </div><div class="line">slice(<span class="number">2</span>, <span class="number">5</span>, numbers) <span class="comment">// =&gt; [30, 40, 50] (see below)</span></div><div class="line"> </div><div class="line">contains(<span class="number">20</span>, numbers) <span class="comment">// =&gt; true</span></div></pre></td></tr></table></figure></p>
<p><code>slice</code> 接受两个索引，返回从第 1 个索引开始（以 0 为起始）到第 2 个索引结束（不包含）的所有元素组成的子数组。</p>
<p>经常会访问首个（<code>nth(0)</code>）和最后一个（<code>nth(-1)</code>）元素，所以 Ramda 为这两种特殊情形提供的便捷方法：<code>head</code> 和 <code>last</code>。还提供了访问除首个元素之外的所有元素的函数：<code>tail</code>，除最后一个元素之外的所有元素的方法：<code>init</code>，前 <code>N</code> 个元素：<code>take(N)</code>，后 <code>N</code> 个元素：<code>takeLast(N)</code>。来看看这些函数的实例。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</div><div class="line"> </div><div class="line">head(numbers) <span class="comment">// =&gt; 10</span></div><div class="line">tail(numbers) <span class="comment">// =&gt; [20, 30, 40, 50, 60]</span></div><div class="line"> </div><div class="line">last(numbers) <span class="comment">// =&gt; 60</span></div><div class="line">init(numbers) <span class="comment">// =&gt; [10, 20, 30, 40, 50]</span></div><div class="line"> </div><div class="line">take(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [10, 20, 30]</span></div><div class="line">takeLast(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [40, 50, 60]</span></div></pre></td></tr></table></figure></p>
<h2 id="zeng-shan-gai-shu-zu-yuan-su">增、删、改数组元素</h2>
<p>对于对象，我们已经学了对其属性进行增、删、改的函数：<code>assoc</code>、<code>dissoc</code>、<code>evolve</code> 等。</p>
<p>但数组是有序数据结构，有好多函数与 <code>assoc</code> 类似。最常用的是 <code>insert</code> 和 <code>update</code>，Ramda 还提供了 <code>append</code> 和 <code>prepend</code> 来在数组头部或尾部添加元素。<code>insert</code>、<code>append</code> 和 <code>prepend</code> 会给数组添加新元素；<code>update</code> 使用新值替换已有元素。</p>
<p>正如一般函数式库应该具备的，所有这些函数都返回修改后的新数组，原有数组保持不变。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</div><div class="line"> </div><div class="line">insert(<span class="number">3</span>, <span class="number">35</span>, numbers) <span class="comment">// =&gt; [10, 20, 30, 35, 40, 50, 60]</span></div><div class="line"> </div><div class="line">append(<span class="number">70</span>, numbers) <span class="comment">// =&gt; [10, 20, 30, 40, 50, 60, 70]</span></div><div class="line"> </div><div class="line">prepend(<span class="number">0</span>, numbers) <span class="comment">// =&gt; [0, 10, 20, 30, 40, 50, 60]</span></div><div class="line"> </div><div class="line">update(<span class="number">1</span>, <span class="number">15</span>, numbers) <span class="comment">// =&gt; [10, 15, 30, 40, 50, 60]</span></div></pre></td></tr></table></figure></p>
<p>为了将两个对象合并为一个，我们学习了 <code>merge</code>；Ramda 为数组合并提供了 <code>concat</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</div><div class="line"> </div><div class="line">concat(numbers, [<span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]) <span class="comment">// =&gt; [10, 20, 30, 40, 50, 60, 70, 80, 90]</span></div></pre></td></tr></table></figure></p>
<p>注意，第二个数组添加到第一个数组之后。当单独使用 <code>concat</code> 时，可以很好的工作；但类似于 <code>merge</code>，在 pipeline 中可能并不像预期的那样工作。可以为在 pipeline 中使用定义一个辅助函数 <code>concatAfter</code>：<code>const concatAfter = flip(concat)</code>。</p>
<p>Ramda 还提供了几个删除元素的函数。<code>remove</code> 删除指定索引处的元素，<code>without</code> 通过值删除元素。还有常用到的删除前 <code>N</code> 或 后 <code>N</code> 个元素的函数：<code>drop</code> 和 <code>dropLast</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</div><div class="line"> </div><div class="line">remove(<span class="number">2</span>, <span class="number">3</span>, numbers) <span class="comment">// =&gt; [10, 20, 60]</span></div><div class="line"> </div><div class="line">without([<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>], numbers) <span class="comment">// =&gt; [10, 20, 60]</span></div><div class="line"> </div><div class="line">drop(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [40, 50, 60]</span></div><div class="line"> </div><div class="line">dropLast(<span class="number">3</span>, numbers) <span class="comment">// =&gt; [10, 20, 30]</span></div></pre></td></tr></table></figure></p>
<p>注意，<code>remove</code> 接受一个索引和一个删除元素的数量，而 <code>slice</code> 接受两个索引。如果你不知道这种不一致，可能会造成使用上的困扰。</p>
<h2 id="bian-huan-yuan-su">变换元素</h2>
<p>与对象一样，我们可能希望通过将函数应用于元素的原始值来更新数组元素。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</div><div class="line"> </div><div class="line">update(<span class="number">2</span>, multiply(<span class="number">10</span>, nth(<span class="number">2</span>, numbers)), numbers) <span class="comment">// =&gt; [10, 20, 300, 40, 50, 60]</span></div></pre></td></tr></table></figure></p>
<p>为了简化这个常见的用例， Ramda 提供了 <code>adjust</code>，其工作方式类似于操作对象的 <code>evolve</code>。与 <code>evolve</code> 不同的是， <code>adjust</code> 只能作用于数组的单个元素。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> numbers = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</div><div class="line"> </div><div class="line">adjust(multiply(<span class="number">10</span>), <span class="number">2</span>, numbers)</div></pre></td></tr></table></figure></p>
<p>注意，与 <code>update</code> 相比，<code>adjust</code> 将前两个参数的位置交换了一下。这可能会引起困扰，但当进行部分应用时，这样做还是很有道理的。你可能会先提供一个调整函数，比如 <code>adjust(multiply(10))</code> ，然后再决定要调整的索引和数组。</p>
<h2 id="jie-lun">结论</h2>
<p>我们现在有了以声明式和不变式操作对象和数组的一系列方法。这允许我们在不改变已有数据的情况下，从较小的、函数式的构建模块来构建程序，通过对函数进行组合来实现我们想要的功能。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>我们学习了读取、更新和转换对象属性和数组元素的方法。Ramda 提供了更通用的进行这些操作的工具：lens（透镜）。<a href="https://adispring.coding.me/2017/06/18/Thinking-in-Ramda-Lenses/" target="_blank" rel="external">Lenses</a> 向我们演示了它们的工作原理和方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" itemprop="url">
                  Thinking in Ramda: 数据不变性和对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-16T23:00:08+08:00" content="2017-06-16">
              2017-06-16
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/28/thinking-in-ramda-immutability-and-objects/" target="_blank" rel="external">Thinking in Ramda: Immutability and Objects</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的第六篇。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="external">第五节</a> 中，我们讨论了如何以 &quot;pointfree&quot; 或 &quot;tacit&quot; 风格来编写函数：函数的参数不会显式的出现。</p>
<p>那时候，因为缺少一些工具，我们还无法将所有的函数转换为 &quot;pointfree&quot; 的风格。现在我们就来学习这些工具。</p>
<h2 id="du-qu-dui-xiang-shu-xing">读取对象属性</h2>
<p>再来回顾一下 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="external">第五节</a> 已经重构过的 &quot;合格选民&quot; 的例子：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</div></pre></td></tr></table></figure></p>
<p>如上所示，我们已经将 <code>isCitizen</code> 和 <code>isEligibleToVote</code> 变为 &quot;pointfree&quot; 风格的了，但前三个函数还没有 &quot;pointfree&quot; 化。</p>
<p>正如 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="external">第四节</a> 所学，可以使用 <code>equals</code> 和 <code>gte</code> 来让函数更 &quot;声明式&quot; 一些。我们就此开始：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(person.age, <span class="number">18</span>)</div></pre></td></tr></table></figure></p>
<p>为了让这些函数变为 &quot;pointfree&quot; 的，需要一种方法来使构建出来的函数的 <code>person</code> 参数排在参数列表的最后。问题是，我们需要访问 <code>person</code> 的属性，现有唯一的方法却是命令式的。</p>
<h2 id="prop">prop</h2>
<p>幸运的是， Ramda 为我们提供了访问对象属性的辅助函数：<code>prop</code>。</p>
<p>使用 <code>prop</code>，可以将 <code>person.birthCountry</code> 转换为 <code>prop('birthCountry', person)</code>。现在来试试。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(prop(<span class="string">'birthCountry'</span>, person), OUR_COUNTRY)</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>, person))</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(prop(<span class="string">'age'</span>, person), <span class="number">18</span>)</div></pre></td></tr></table></figure></p>
<p>哇！现在看起来更糟了，还需要继续重构。首先，需要交换传递给 <code>equals</code> 的参数的顺序，这样可以将 <code>prop</code> 放到最后。<code>equals</code> 在任意顺序下都能正常工作。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(OUR_COUNTRY, prop(<span class="string">'birthCountry'</span>, person))</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>, person))</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(prop(<span class="string">'age'</span>, person), <span class="number">18</span>)</div></pre></td></tr></table></figure></p>
<p>接下来，使用 <code>equals</code> 和 <code>gte</code> 的柯里化特性来创建新函数，新函数可以作用于 <code>prop</code> 输出的结果上。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class="string">'birthCountry'</span>, person))</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>, person))</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(__, <span class="number">18</span>)(prop(<span class="string">'age'</span>, person))</div></pre></td></tr></table></figure></p>
<p>还是不太好，还需要继续优化。我们继续利用柯里化的特性来优化 <code>prop</code> 的调用。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(OUR_COUNTRY)(prop(<span class="string">'birthCountry'</span>)(person))</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(prop(<span class="string">'naturalizationDate'</span>)(person))</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(__, <span class="number">18</span>)(prop(<span class="string">'age'</span>)(person))</div></pre></td></tr></table></figure></p>
<p>又变糟了。但现在我们看到了一种熟悉的模式，所有的三个函数都具有相同的形式：<code>g(f(person))</code>。由 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions" target="_blank" rel="external">第二节</a> 可知，这等价于 <code>compose(g, f)(person)</code>。</p>
<p>我们来利用这一点。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> compose(equals(OUR_COUNTRY), prop(<span class="string">'birthCountry'</span>))(person)</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> compose(<span class="built_in">Boolean</span>, prop(<span class="string">'naturalizationDate'</span>))(person)</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> compose(gte(__, <span class="number">18</span>), prop(<span class="string">'age'</span>))(person)</div></pre></td></tr></table></figure></p>
<p>现在好一些了，三个函数的形式变成了 <code>person =&gt; f(person)</code>。由 <a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style" target="_blank" rel="external">第五节</a> 可知，现在可以将这三个函数写成 &quot;pointfree&quot; 的了。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = compose(equals(OUR_COUNTRY), prop(<span class="string">'birthCountry'</span>))</div><div class="line"><span class="keyword">const</span> wasNaturalized = compose(<span class="built_in">Boolean</span>, prop(<span class="string">'naturalizationDate'</span>))</div><div class="line"><span class="keyword">const</span> isOver18 = compose(gte(__, <span class="number">18</span>), prop(<span class="string">'age'</span>))</div></pre></td></tr></table></figure></p>
<p>未重构前，并不能明显看出我们的方法是在做两件事情。它们都先访问对象的属性，然后对该属性的值进行一些操作。重构为 &quot;pointfree&quot; 风格后，程序的表意变得清晰了许多。</p>
<p>我们来展示更多 Ramda 处理对象的函数。</p>
<h2 id="pick">pick</h2>
<p><code>prop</code> 用来读取并返回对象的单个属性，而 <code>pick</code> 读取对象的多个属性，然后返回有这些属性组成的新对象。</p>
<p>例如，如果想同时获取一个人的名字和年龄，可以使用：<code>pick(['name', 'age'], person)</code>。</p>
<h2 id="has">has</h2>
<p>在不读取属性值的情况下，想知道对象中是否包含该属性，可以使用 <code>has</code> 来检测对象是否拥有该属性，如 <code>has('name' ,person)</code>；还可以使用 <code>hasIn</code> 来检测原型链上的属性。</p>
<h2 id="path">path</h2>
<p><code>prop</code> 用来读取对象的属性，<code>path</code> 可以读取对象的嵌套属性。例如，我们可以从更深层的结构中访问邮编：<code>path(['address', 'zipCode'], person)</code>。</p>
<p>注意，<code>path</code> 容错性更强。如果路径上的任意属性为 <code>null</code> 或 <code>undefined</code>，则 <code>path</code> 返回 <code>undefined</code>，而 <code>prop</code> 会引发错误。</p>
<h2 id="prop-or-path-or">propOr / pathOr</h2>
<p><code>propOr</code> 和 <code>pathOr</code> 像是 <code>prop</code>/<code>path</code> 与 <code>defaultTo</code> 的组合。如果在目标对象中找不到属性或路径的值，它们允许你提供默认值。</p>
<p>例如，当我们不知道某人的姓名时，可以提供一个占位符：<code>propOr('&lt;Unnamed&gt;', 'name', person)</code>。注意，与 <code>prop</code> 不同，如果 <code>person</code> 为 <code>null</code> 或 <code>undefined</code> 时，<code>propOr</code> 不会引发错误，而是会返回一个默认值。</p>
<h2 id="keys-values">keys / values</h2>
<p><code>keys</code> 返回一个包含对象中所有属性名称的数组。<code>values</code> 返回这些属性的值组成的数组。当与 <a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8" target="_blank" rel="external">第一节</a> 中提到集合迭代函数结合使用时，这两个函数会非常有用。</p>
<h2 id="dui-shu-xing-zeng-shan-gai-cha">对属性增、删、改、查</h2>
<p>现在已经有很多对对象进行声明式读取的函数，但如果想要进行更改操作呢？</p>
<p>由于数据不变性很重要，我们不想直接更改对象。相反，我们想要更改后形成的新对象。</p>
<p>Ramda 再次为我们提供了很多辅助函数。</p>
<h2 id="assoc-assoc-path">assoc / assocPath</h2>
<p>在命令式编程时，可以使用赋值操作符设置或更改一个人的名字：<code>person.name = 'New name'</code>。</p>
<p>在函数式、数据不变的世界里，可以使用 <code>assoc</code> 来代替：<code>const updatedPerson = assoc('name', 'New name', person)</code>。</p>
<p><code>assoc</code> 返回一个添加或修改属性的新对象，原对象保持不变。</p>
<p>还有用于更新嵌套属性的方法：<code>assocPath</code>：<code>const updatedPerson = assocPath(['address', 'zipcode'], '97504', person)</code>。</p>
<h2 id="dissoc-dissoc-path-omit">dissoc / dissocPath / omit</h2>
<p>如何删除属性呢？我们可能想删除 <code>person.age</code> 。在 Ramda 中，可以使用 <code>dissoc</code>：<code>const updatedPerson = dissoc('age', person)</code>。</p>
<p><code>dissocPath</code> 类似于 <code>dissoc</code>，但可以作用于对象的嵌套属性：<code>dissocPath(['address', 'zipCode'], person)</code>。</p>
<p>还有一个 <code>omit</code>，用于一次删除多个属性。<code>const updatedPerson = omit(['age', 'birthCountry'], person)</code>。</p>
<p>注意，<code>pick</code> 与 <code>omit</code> 的操作很像，两者是互补的关系。它们能辅助实现白名单（使用 <code>pick</code> 保留想要的属性集）和黑名单（使用 <code>omit</code> 删除不想要的属性集）的功能。</p>
<h2 id="shu-xing-zhuan-huan">属性转换</h2>
<p>我们现在已经知道如何利用声明式和数据不变性的方式来处理对象。我们来写一个函数：<code>celebrateBirthday</code>，在生日当前更新他的年龄。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> nextAge = compose(inc, prop(<span class="string">'age'</span>))</div><div class="line"><span class="keyword">const</span> celebrateBirthday = <span class="function"><span class="params">person</span> =&gt;</span> assoc(<span class="string">'age'</span>, nextAge(person), person)</div></pre></td></tr></table></figure></p>
<p>这是一种很常见的模式。如上所示，我们并不想用给定的新值覆盖已有属性值，而是想通过函数作用于属性的旧值来对其进行转换。</p>
<p>就目前已知的方法，我尚未找到一种以更少重复代码和 pointfree 的形式来优化该段代码的方式。</p>
<p>Ramda 使用 <code>evolve</code> 方法再次拯救了我们。我在 <a href="http://randycoulman.com/blog/2016/02/16/using-ramda-with-redux/" target="_blank" rel="external">之前的文章</a> 中也提到过 <code>evolve</code>。</p>
<p><code>evolve</code> 接受一个对象，其中包含对每个需要转换属性的转换函数。我们来使用 <code>evolve</code> 来重构 <code>celebrateBirthday</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> celebrateBirthday = evolve(&#123; <span class="attr">age</span>: inc &#125;)</div></pre></td></tr></table></figure></p>
<p>这段代码通过将 <code>evolve</code> 参数对象属性对应的函数作用于被变换对象相同属性值上，来转换已有对象的属性。本例中使用 <code>inc</code> 对 <code>person</code> 的 <code>age</code> 属性进行加 1 操作，并返回 <code>age</code> 更新后的新 <code>person</code> 对象。</p>
<p><code>evolve</code> 可以一次转换多个属性，还可以进行嵌套转换。&quot;转换函数对象&quot;（包含转换函数的对象）与被转换对象具有基本相同的结构，<code>evolve</code> 会递归地遍历这两个对象，然后将转换函数作用于对应的属性值上。</p>
<p>注意，<code>evolve</code> 不会添加新属性，如果为目标对象不存在的属性指定转换函数，<code>evolve</code> 会将其忽略。</p>
<p><code>evolve</code> 已经很快成为我编程时的主力。</p>
<h2 id="he-bing-dui-xiang">合并对象</h2>
<p>有时，需要合并两个对象。一种常见的情形是当使用含有 &quot;options&quot; 配置项的函数时，常常需要将这些配置项与一组默认配置项进行组合。Ramda 为此提供了 <code>merge</code> 方法。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">a, b, options = &#123;&#125;</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> defaultOptions = &#123; <span class="attr">value</span>: <span class="number">42</span>, <span class="attr">local</span>: <span class="literal">true</span> &#125;</div><div class="line">  <span class="keyword">const</span> finalOptions = merge(defaultOptions, options)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>merge</code> 返回一个包含两个对象的所有属性和值的新对象。如果两个对象具有相同的属性，则采用第二个对象参数的属性值。</p>
<p>在单独使用 <code>merge</code> 时，采用第二个参数的属性值作为最终值是非常有用的；但在 pipeline 中可能没什么用。在 pipeline 中，通常会对一个对象进行一系列转换，其中一个转换是合并一些新的属性值到对象中。这种情况，可能需要第一个参数中的属性值作为最终值。</p>
<p>如果只是在 pipeline 中简单地使用 <code>merge(newValues)</code>，可能不会得到你想要的结果。</p>
<p>对于这种情况，我通常会定义一个辅助函数 <code>reverseMerge</code>：<code>const reverseMerge = flip(merge)</code>。回想一下，<code>flip</code> 会翻转函数前两个参数的位置。</p>
<p><code>merge</code> 执行的是浅合并。如果被合并的对象存在属性值为对象的属性，子对象并不会继续嵌套合并。如果想递归地进行 &quot;深合并&quot;，可以使用 Ramda 的 <code>mergeDeep</code> 系列函数。（译者注：作者在写这篇文章时，Ramda 还没有 <code>mergeDeep</code> 系列函数，<code>mergeDeep</code> 系列函数是在 v0.24.0 中加入的）</p>
<p>注意，<code>merge</code> 只接受两个参数。如果想要将多个对象合并为一个对象，可以使用 <code>mergeAll</code>，它接受一个需要被合并对象的数组作为参数。</p>
<h2 id="jie-lun">结论</h2>
<p>本文展示了 Ramda 中一系列很好的以声明式和数据不变方式处理对象的方法。我们现在可以对对象进行增、删、改、查，而不会改变原有的对象。并且也可以在组合函数时使用这些方法来做这些事情。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>现在可以以 Immutable 的方式处理对象，那么数组呢？<a href="https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" target="_blank" rel="external">数据不变性和数组</a> 将演示对数组的处理。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" itemprop="url">
                  Thinking in Ramda: 无参数风格编程 (Pointfree Style)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-13T21:27:05+08:00" content="2017-06-13">
              2017-06-13
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/13/Thinking-in-Ramda-Pointfree-Style/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/13/Thinking-in-Ramda-Pointfree-Style/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/" target="_blank" rel="external">Thinking in Ramda: Pointfree Style</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的第五篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="external">第四节</a>中，我们讨论了如何用声明式编程（告诉计算机做什么，我们想要什么）代替命令式编程（告诉计算机该怎么做，详细的执行步骤）来编写代码。</p>
<p>你可能已经注意到了，我们编写的几个函数（如 <code>forever21</code>、<code>alwaysDrivingAge</code>、<code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于该参数。</p>
<p>这是函数式编程里非常常见的一种模式，Ramda 同样提供了优化这种模式的方法。</p>
<h2 id="pointfree-feng-ge-wu-can-shu-feng-ge">Pointfree 风格（无参数风格）</h2>
<p>我们在 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="external">第三节</a> 中讨论了 Ramda 的两个指导原则：</p>
<ul>
<li>将数据放到参数列表的最后面。</li>
<li>柯里化所有的东西。</li>
</ul>
<p>这两个原则衍生出了一种被函数式程序员称为 &quot;pointfree&quot; 的风格。我喜欢将 pointfree 的代码看作：&quot;数据？什么数据？这里没有数据！&quot;</p>
<p>有一篇很好的博客：<a href="http://fr.umio.us/why-ramda/" target="_blank" rel="external">Why Ramda?</a>，展示了 pointfree 风格 真得不错。具体来说，它有一些有趣的标题，例如：&quot;数据在哪里？&quot;，&quot;好了，已经有了！&quot;，&quot;那么我可以看看数据吗？&quot; 和 &quot;拜托，我只是想要我的数据&quot;。</p>
<p>我们还没有使用需要的工具来让所有的例子都变成完全 &quot;pointfree&quot; 的，现在就开始吧。</p>
<p>再看一下 <code>forever21</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(gte(__, <span class="number">21</span>), always(<span class="number">21</span>), inc)(age)</div></pre></td></tr></table></figure></p>
<p>注意，参数 <code>age</code> 出现了两次：一次在参数列表中；一次在函数的最后面：我们将由 <code>ifElse</code> 返回的新函数作用于 <code>age</code>。</p>
<p>在使用 Ramda 编程时稍加留意，就会发现很多这种模式的代码。这也意味着，总应该有一种方法将这些函数转成 &quot;pointfree&quot; 风格。</p>
<p>我们来看看这会是什么样子：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> forever21 = ifElse(gte(__, <span class="number">21</span>), always(<span class="number">21</span>), inc)</div></pre></td></tr></table></figure></p>
<p>嘭~~！我们刚刚让 <code>age</code> 消失了。这就是 Pointfree 风格。注意，这两个版本所做的事情完全一样。我们仍然返回一个接受年龄的函数，但并未显示的指定 <code>age</code> 参数。</p>
<p>可以对 <code>alwaysDrivingAge</code> 和 <code>water</code> 进行相同的处理。</p>
<p>原来的 <code>alwaysDrivingAge</code> 如下所示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lt(__, <span class="number">16</span>), always(<span class="number">16</span>), identity)(age)</div></pre></td></tr></table></figure></p>
<p>可以使用相同的方法使其变为 pointfree 的。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> alwaysDrivingAge = when(lt(__, <span class="number">16</span>), always(<span class="number">16</span>))</div></pre></td></tr></table></figure></p>
<p>下面是 <code>water</code> 原来的形式：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> water = <span class="function"><span class="params">temperature</span> =&gt;</span> cond([</div><div class="line">  [equals(<span class="number">0</span>),   always(<span class="string">'water freezes at 0°C'</span>)],</div><div class="line">  [equals(<span class="number">100</span>), always(<span class="string">'water boils at 100°C'</span>)],</div><div class="line">  [T,           temp =&gt; <span class="string">`nothing special happens at <span class="subst">$&#123;temp&#125;</span>°C`</span>]</div><div class="line">])(temperature)</div></pre></td></tr></table></figure></p>
<p>现在将其变为 pointfree 风格的：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> water = cond([</div><div class="line">  [equals(<span class="number">0</span>),   always(<span class="string">'water freezes at 0°C'</span>)],</div><div class="line">  [equals(<span class="number">100</span>), always(<span class="string">'water boils at 100°C'</span>)],</div><div class="line">  [T,           temp =&gt; <span class="string">`nothing special happens at <span class="subst">$&#123;temp&#125;</span>°C`</span>]</div><div class="line">])</div></pre></td></tr></table></figure></p>
<h2 id="duo-yuan-han-shu-duo-can-shu-han-shu">多元函数（多参数函数）</h2>
<p>如果函数接受多个参数会怎样呢？回顾一下 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="external">第三节</a> 中的例子：<code>titlesForYear</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> titlesForYear = curry(<span class="function">(<span class="params">year, books</span>) =&gt;</span></div><div class="line">  pipe(</div><div class="line">    filter(publishedInYear(year)),</div><div class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</div><div class="line">  )(books)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>注意，<code>books</code> 出现了两次：一次作为参数列表的最后一个参数（最后一个数据！）；一次出现在函数最后，当我们将其传入 pipeline 的时候。这跟我们之前看到参数为 <code>age</code> 的模式类似，所以可以对它进行相同的转换：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function"><span class="params">year</span> =&gt;</span></div><div class="line">  pipe(</div><div class="line">    filter(publishedInYear(year)),</div><div class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</div><div class="line">  )</div></pre></td></tr></table></figure></p>
<p>可以了！我们现在有了一个 pointfree 版本的 <code>titlesFroYear</code>。</p>
<p>其实，这种情况下，我可能不会刻意追求 pointfree 风格，因为就像之前文章讨论过的：JavaScript 在调用一系列单参数函数方面并不方便。</p>
<p>在 pipeline 中使用 <code>titleForYear</code> 是很方便，如我们可以很轻松的调用 <code>titlesForYear(2012)</code>，但当想要单独使用它时，我们就不得不回到之前文章里看到的形式 <code>)(</code>，对我而言，并不值得做出这种妥协（没必要为了 pointfree 而 pointfree）。</p>
<p>但只要有如上形式的单参数函数（或者可能以后会被重构），我几乎总是写成 pointfree 风格的。</p>
<h2 id="zhong-gou-wei-pointfree-feng-ge-de-dai-ma">重构为 pointfree 风格的代码</h2>
<p>有时我们的代码不会遵循这种模式。我们可能会在同一函数内多次对数据进行操作。</p>
<p>在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="external">第二节</a> 的几个例子中便是这种情形。我们使用诸如 <code>both</code>、<code>either</code>、<code>pipe</code>、<code>compose</code> 来重构代码。一旦我们这样做了，便会很容易让函数转换为 pointfree 风格的。</p>
<p>我们来回顾一下 <code>isEligibleToVote</code> 这个例子，代码如下：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> isCitizen = <span class="function"><span class="params">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> isEligibleToVote = <span class="function"><span class="params">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</div></pre></td></tr></table></figure></p>
<p>先从 <code>isCitizen</code> 开始。它接受一个 <code>person</code>, 然后将两个函数作用于该 <code>person</code>，将结果使用 <code>||</code> 组合起来。正如在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="external">第二节</a> 中学到的，可以使用 <code>either</code> 将两个函数组合成一个新函数，然后将该组合函数作用于该 <code>person</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isCitizen = <span class="function"><span class="params">person</span> =&gt;</span> either(wasBornInCountry, wasNaturalized)(person)</div></pre></td></tr></table></figure></p>
<p>可以使用 <code>both</code> 对 <code>isEligibleToVote</code> 做类似的处理。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isEligibleToVote = <span class="function"><span class="params">person</span> =&gt;</span> both(isOver18, isCitizen)(person)</div></pre></td></tr></table></figure></p>
<p>现在我们已经完成了这些重构，可以看到，这两个函数都遵循上面提到的模式：<code>person</code> 出现了两次，一次作为函数参数；一次放到最后，将组合函数作用其上。现在可以将它们重构为 pointfree 风格的代码：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</div></pre></td></tr></table></figure></p>
<h2 id="wei-shi-yao-yao-zhe-yao-zuo">为什么要这么做？</h2>
<p>Pointfree 风格需要一定的时间才能习惯。可能并不需要所有的地方都没有参数。有时候知道某些 Ramda 函数需要多少参数，也是很重要的。</p>
<p>但是，一旦习惯了这种方式，它将变得非常强大：可以以非常有趣的方式将很多小的 pointfree 函数组合起来。</p>
<p>Pointfree 风格的优点是什么呢？人们可能会认为，这只不过是为了让函数式编程赢得 &quot;优点徽章&quot; 的学术活动而已（实际上并没有什么用处）。然而，我认为还是有一些优点的，即使需要花一些时间来习惯这种方式也是值得的：</p>
<ul>
<li>它让编程更简单、精练。这并不总是一件好事，但大部分情况下是这样的。</li>
<li>它让算法更清晰。通过只关注正在组合的函数，我们可以在没有参数的干扰下，更好地了解发生了什么。</li>
<li>它促使我们更专注于正在做的转换的本身，而不是正被转换的数据。</li>
<li>它可以帮助我们将函数视为可以作用于不同数据的通用构建模块，而非对特定类型数据的操作。如果给数据一个名字，我们的思想便会被<a href="https://en.wikipedia.org/wiki/Anchoring" target="_blank" rel="external">禁锢</a>在：&quot;需要在哪里使用我们的函数&quot;；如果去掉参数，便会使我们更有创造力。</li>
</ul>
<h2 id="jie-lun">结论</h2>
<p>Pointfree 风格也被成为 <a href="https://en.wikipedia.org/wiki/Tacit_programming" target="_blank" rel="external">tacit 式编程</a>(隐含式编程)，可以使代码更清晰、更易于理解。通过代码重构将所有的转换组合成单一函数，我们最终会得到可以在更多地方使用的更小的构建块（函数）。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>在当前示例中，我们尚未将所有代码都重构为 pointfree 的风格。还有一些代码是命令式的。大部分这种代码是处理对象和数组的。</p>
<p>我们需要找到声明式的方式来处理对象和数组。Immutability (不变性) 怎么样？我们如何以 &quot;不变&quot; (immutable) 的方式来操作对象和数组呢？</p>
<p>本系列的下一节，<a href="https://adispring.coding.me/2017/06/16/Thinking-in-Ramda-Immutability-and-Objects/" target="_blank" rel="external">数据不变性和对象</a> 将讨论如何以函数式和 immutable 的方式来处理对象。紧随其后的章节：<a href="https://adispring.coding.me/2017/06/17/Thinking-in-Ramda-Immutability-and-Arrays/" target="_blank" rel="external">数据不变性和数组</a> 对数组也是相同的处理方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" itemprop="url">
                  Thinking in Ramda: 声明式编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-11T20:27:38+08:00" content="2017-06-11">
              2017-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/11/Thinking-in-Ramda-Declarative-Programming/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/11/Thinking-in-Ramda-Declarative-Programming/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/14/thinking-in-ramda-declarative-programming/" target="_blank" rel="external">Thinking in Ramda: Declarative Programming</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的第四篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="external">第三节</a>中，讨论了使用 &quot;部分应用&quot; 和 &quot;柯里化&quot; 技术来组合多元（多参数）函数。</p>
<p>当我们开始编写小的函数式构建块并组合它们时，发现必须写好多函数来包裹 JavaScript 操作符，比如算术、比较、逻辑操作符和控制流。这可能比较乏味，但 Ramda 将我们拉了回来，让事情变得有趣起来。</p>
<p>开始之前，先介绍一些背景知识。</p>
<h2 id="ming-ling-shi-vs-sheng-ming-shi">命令式 vs 声明式</h2>
<p>存在很多编程语言分类的方式，如静态语言和动态语言，解释型语言和编译型语言，底层和高层语言等等。</p>
<p>另一种划分的方式是命令式编程和声明式编程。</p>
<p>简单地说，命令式编程中，程序员需要告诉计算机怎么做来完成任务。命令式编程带给我们每天会用到的大量的基本结构：控制流（<code>if</code>-<code>then</code>-<code>else</code> 语句和循环），算术运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>），比较运算符（<code>===</code>、<code>&gt;</code>、<code>&lt;</code> 等），和逻辑运算符（<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>）。</p>
<p>而声明式编程，程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。</p>
<p>其中一种经典的声明式编程语言是 Prolog。在 Prolog 中，程序是由一组 &quot;facts&quot; (谓词) 和 一组 &quot;rules&quot; (规则) 组成。可以通过提问来启动程序。Prolog 的推理机使用 facts 和 rules 来回答问题。</p>
<p>函数式编程被认为是声明式编程的一个子集。在一段函数式程序中，我们定义函数，然后通过组合这些函数告诉计算机做什么。</p>
<p>即使在声明式程序中，也需要做一些命令式程序中的工作。控制流，算术、比较和逻辑操作仍然是必须使用的基本构建块。但我们需要找到一种声明式的方式来描述这些基本构建块。</p>
<h2 id="sheng-ming-shi-ti-huan">声明式替换</h2>
<p>由于我们使用 JavaScript （一种命令式语言）编程，所以在编写 &quot;普通&quot; JavaScript 代码时，使用标准的命令式结构也是正常的。</p>
<p>但当使用 &quot;pipeline&quot; 或类似的结构编写函数式变换时，命令式的结构并不能很好的工作。</p>
<h2 id="suan-zhu">算术</h2>
<p>在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="external">第二节</a> ，我们实现了一系列算术变换来演示 &quot;pipeline&quot;：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b</div><div class="line"><span class="keyword">const</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></div><div class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x</div><div class="line"> </div><div class="line"><span class="keyword">const</span> operate = pipe(</div><div class="line">  multiply,</div><div class="line">  addOne,</div><div class="line">  square</div><div class="line">)</div><div class="line"> </div><div class="line">operate(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></div></pre></td></tr></table></figure></p>
<p>注意我们是如何编写函数来实现我们想要的基本构建块的。</p>
<p>Ramda 提供了 <code>add</code>、<code>subtract</code>、<code>multiply</code> 和 <code>divide</code> 函数来替代标准的算术运算符。所以我们可以使用 Ramda 的 <code>multiply</code> 来代替我们自己实现的乘法，可以利用 Ramda 的柯里化 <code>add</code> 函数的优势来取代我们的 <code>addOne</code>，也可以利用 <code>multiply</code> 来编写 <code>square</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> multiply(x, x)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> operate = pipe(</div><div class="line">  multiply,</div><div class="line">  add(<span class="number">1</span>),</div><div class="line">  square</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p><code>add(1)</code> 与增量运算符（<code>++</code>）非常相似，但 <code>++</code> 修改了被操作的值，因此它是 &quot;mutation&quot; 的。正如在 <a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="external">第一节</a> 中所讲，Immutability 是函数式编程的核心原则，所以我们不想使用 <code>++</code> 或 <code>--</code>。</p>
<p>可以使用 <code>add(1)</code> 和 <code>subtract(1)</code> 来做递增和递减操作，但由于这两个操作非常常用，所以 Ramda 专门提供了 <code>inc</code> 和 <code>dec</code>。</p>
<p>所以可以进一步简化我们的 &quot;pipeline&quot;：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> multiply(x, x)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> operate = pipe(</div><div class="line">  multiply,</div><div class="line">  inc,</div><div class="line">  square</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p><code>subtract</code> 是二元操作符 <code>-</code> 的替代，但还有一个表示取反的一元操作符 <code>-</code>。我们可以使用 <code>multiply(-1)</code>，但 Ramda 也提供了 <code>negate</code> 来实现相同的功能。</p>
<h2 id="comparison-bi-jiao">Comparison (比较)</h2>
<p>还是在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="external">第二节</a>，我们写了一些函数来确定一个人是否有资格投票。该代码的最终版本如下所示：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</div></pre></td></tr></table></figure></p>
<p>注意，上面的一些函数使用了标准比较运算符（<code>===</code> 和 <code>&gt;=</code>）。正如你现在所怀疑的，Ramda 也提供了这些运算符的替代。</p>
<p>我们来修改一下代码：使用 <code>equals</code> 代替 <code>===</code>，使用 <code>gte</code> 替代 <code>&gt;=</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> equals(person.birthCountry, OUR_COUNTRY)</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> gte(person.age, <span class="number">18</span>)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</div></pre></td></tr></table></figure></p>
<p>Ramda 还提供了其他比较运算符的替代：<code>gt</code> 对应 <code>&gt;</code>，<code>lt</code> 对应 <code>&lt;</code>，<code>lte</code> 对应 <code>&lt;=</code>。</p>
<p>注意，这些函数保持正常的参数顺序（<code>gt</code> 表示第一个参数是否大于第二个参数）。这在单独使用时没有问题，但在组合函数时，可能会让人产生困惑。这些函数似乎违反了 Ramda 的 &quot;待处理数据放在最后&quot; 的原则，所以我们在 pipeline 或类似的情况下使用它们时，要格外小心。这时，<code>flip</code> 和 占位符 (<code>__</code>) 就派上了用场。</p>
<p>除了 <code>equals</code>，还有一个 <code>identical</code>，可以用来判断两个值是否引用了同一块内存。</p>
<p><code>===</code> 还有一些其他的用途：可以检测字符串或数组是否为空（<code>str === ''</code> 或 <code>arr.length === 0</code>），也可以检查变量是否为 <code>null</code> 或 <code>undefined</code>。Ramda 为这两种情况提供了方便的判断函数：<code>isEmpty</code> 和 <code>isNil</code>。</p>
<h2 id="logic-luo-ji">Logic (逻辑)</h2>
<p>在 <a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="external">第二节</a> 中（参见上面的相关代码）。我们使用 <code>both</code> 和 <code>either</code> 来代替 <code>&amp;&amp;</code> 和 <code>||</code> 运算符。我们还提到使用 <code>complement</code> 代替 <code>!</code>。</p>
<p>当组合的函数作用于同一份输入值时，这些组合函数帮助很大。上述示例中，<code>wasBornInCountry</code>、<code>wasNaturalized</code> 和 <code>isOver18</code> 都作用于同一个人上。</p>
<p>但有时我们需要将 <code>&amp;&amp;</code>、<code>||</code> 和 <code>!</code> 作用于不同的数值。对于这些情况， Ramda 提供了 <code>and</code>、<code>or</code> 和 <code>not</code> 函数。我以下列方式进行分类：<code>and</code>、<code>or</code> 和 <code>not</code> 用于处理数值；<code>both</code>、<code>either</code> 和 <code>complement</code> 用于处理函数。</p>
<p>经常用 <code>||</code> 来提供默认值。例如，我们可能会编写如下代码：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> lineWidth = settings.lineWidth || <span class="number">80</span></div></pre></td></tr></table></figure></p>
<p>这是一个常见的用法，大部分情况下都能正常工作，但依赖于 JavaScript 对 &quot;falsy&quot; 值的定义。假设 <code>0</code> 是一个合法的设置选项呢？由于 <code>0</code> 是 &quot;falsy&quot; 值，所以我们最终会得到的行宽为 80 。</p>
<p>我们可以使用上面刚学到的 <code>isNil</code> 函数，但 Ramda 提供了一个更好的选择：<code>defaultTo</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> lineWidth = defaultTo(<span class="number">80</span>, settings.lineWidth)</div></pre></td></tr></table></figure></p>
<p><code>defaultTo</code> 检查第二个参数是否为空（<code>isNil</code>）。如果非空，则返回该值；否则返回第一个值。</p>
<h2 id="conditionals-tiao-jian">Conditionals (条件)</h2>
<p>控制流在函数式编程中不是必要的，但偶尔也会有些用处。在 <a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="external">第一节</a> 中讨论的集合迭代函数在大部分情况下都可以很好的取代循环，但 &quot;条件&quot; 仍然非常重要。</p>
<h2 id="if-else">ifElse</h2>
<p>我们来写一个函数，<code>forever21</code>，接受一个年龄，并返回下一个年龄。但正如名字所示，一旦成长到 21 岁，就一直保持这样。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> age &gt;= <span class="number">21</span> ? <span class="number">21</span> : age + <span class="number">1</span></div></pre></td></tr></table></figure></p>
<p>注意，条件（<code>age &gt;= 21</code>）和第二个分支（<code>age + 1</code>）都可以写作 <code>age</code> 的函数。第一个分支（<code>21</code>）也可以重写成一个常量函数（<code>() =&gt; 21</code>）。现在我们有三个接受（或忽略）<code>age</code> 为参数的函数。</p>
<p>现在可以使用 Ramda 的 <code>ifElse</code> 函数了，这是一个相当于 <code>if...then...else</code> 或 <code>?:</code> 的函数。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(gte(__, <span class="number">21</span>), () =&gt; <span class="number">21</span>, inc)(age)</div></pre></td></tr></table></figure></p>
<p>如上所示，比较函数在进行组合时，可能并不是以我们想要的形式进行工作。所以在这里被迫引入了占位符（<code>__</code>）。我们也可以使用 <code>lte</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lte(<span class="number">21</span>), () =&gt; <span class="number">21</span>, inc)(age)</div></pre></td></tr></table></figure></p>
<p>在这种情况下，我们不得不读作：&quot;21岁小于或等于给定年龄&quot;。但这样可读性很低、比较乱，所以我坚持使用占位符版本的函数。</p>
<h2 id="constants-chang-liang">constants (常量)</h2>
<p>常量函数在这种情形下非常有用。你可能已经想到了，Ramda 为我们提供了一些便捷的方法。本例中，这个方法是 <code>always</code>。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> forever21 = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(gte(__, <span class="number">21</span>), always(<span class="number">21</span>), inc)(age)</div></pre></td></tr></table></figure></p>
<p>Ramda 还提供了 <code>T</code> 和 <code>F</code>，作为 <code>always(true) 和 always(false)</code> 的缩写。</p>
<h2 id="identity-heng-deng">identity (恒等)</h2>
<p>再来写一个函数：<code>alwaysDrivingAge</code>。该函数接受一个年龄，如果 <code>gte</code> 16，则将该年龄返回；但如果小于 16，则返回 16。这样任何人都可以伪造他们的驾驶年龄了，即使他们还没有达到。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lt(__, <span class="number">16</span>), always(<span class="number">16</span>), a =&gt; a)(age)</div></pre></td></tr></table></figure></p>
<p>条件中的第二个分支（<code>a =&gt; a</code>）是函数式编程中的另一种常见的模式。它被称为恒等函数。也即，输出永远等于输入的函数。</p>
<p>正如你所想的，Ramda 为我们提供了 <code>identity</code> 函数。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> ifElse(lt(__, <span class="number">16</span>), always(<span class="number">16</span>), identity)(age)</div></pre></td></tr></table></figure></p>
<p><code>identity</code> 可以接受多个参数，但总是返回首个参数。如果想要返回除首个参数之外的参数，可以使用更通用的 <code>nthArg</code> 函数。但 <code>nthArg</code> 不如 <code>identity</code> 用的频繁。</p>
<h2 id="when-he-unless">when 和 unless</h2>
<p>在 <code>ifElse</code> 代码中，其中一个条件分支为 <code>identity</code> 也很常见。所以 Ramda 也提供了便捷的方法。</p>
<p>如果像上例所示，第二个分支是 <code>identity</code>，可以用 <code>when</code> 代替 <code>ifElse</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> when(lt(__, <span class="number">16</span>), always(<span class="number">16</span>))(age)</div></pre></td></tr></table></figure></p>
<p>如果第一个条件分支是 <code>identity</code>，可以用 <code>unless</code>。借助 <code>gte(__, 16)</code> 来翻转一下我们的条件，便可以使用 <code>unless</code> 了。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> alwaysDrivingAge = <span class="function"><span class="params">age</span> =&gt;</span> unless(gte(__, <span class="number">16</span>), always(<span class="number">16</span>))(age)</div></pre></td></tr></table></figure></p>
<h2 id="cond">cond</h2>
<p>Ramda 还提供了 <code>cond</code> 函数，来代替 <code>switch</code> 语句或链式的 <code>if...then...else</code> 语句。</p>
<p>这里采用 Ramda 文档中的例子来展示 <code>cond</code> 的用法：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> water = <span class="function"><span class="params">temperature</span> =&gt;</span> cond([</div><div class="line">  [equals(<span class="number">0</span>),   always(<span class="string">'water freezes at 0°C'</span>)],</div><div class="line">  [equals(<span class="number">100</span>), always(<span class="string">'water boils at 100°C'</span>)],</div><div class="line">  [T,           temp =&gt; <span class="string">`nothing special happens at <span class="subst">$&#123;temp&#125;</span>°C`</span>]</div><div class="line">])(temperature)</div></pre></td></tr></table></figure></p>
<p>我目前还不需要在 Ramda 代码中使用 <code>cond</code>。但我很多年前编写过 Common Lisp 代码，所以 <code>cond</code> 函数感觉就像是位老朋友。</p>
<h2 id="jie-lun">结论</h2>
<p>本节中展示了很多将命令式代码转为函数声明式代码的 Ramda 函数。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>你可能已经注意到了，最后我们编写的几个函数（<code>forever21</code>、<code>alwaysDrivingAge</code> 和 <code>water</code>）都接受一个参数，构建一个新函数，然后将该函数作用于参数。</p>
<p>这也是一种常见的模式，并且 Ramda 照例提供了一些简化这些代码的便捷方法。下一节中，<a href="https://adispring.coding.me/2017/06/13/Thinking-in-Ramda-Pointfree-Style/" target="_blank" rel="external">Pointfree Style</a> 将演示如何简化符合这种模式的代码。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/11/Thinking-in-Ramda-Partial-Application/" itemprop="url">
                  Thinking in Ramda: 部分应用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-11T06:01:57+08:00" content="2017-06-11">
              2017-06-11
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/11/Thinking-in-Ramda-Partial-Application/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/11/Thinking-in-Ramda-Partial-Application/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/06/07/thinking-in-ramda-partial-application/" target="_blank" rel="external">Thinking in Ramda: Partial Application</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的第三篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/10/Thinking-in-Ramda-Combining-Functions/" target="_blank" rel="external">第二节</a>中，讨论了各种函数组合的方式。最后，演示了 <code>compose</code> 和 <code>pipe</code>， 可以以 &quot;pipeline&quot; （管道）的形式对一系列函数进行调用。</p>
<p>在上篇文章中，简单的函数链式调用（&quot;pipeline&quot;）时，其中的被调用函数都是一元的（除了首个函数）。但如果要使用多元函数呢？</p>
<p>例如，假设有一个书籍对象的集合，我们想要找到特定年份出版的所有图书的标题。可以使用 Ramda 的集合迭代函数完成该需求：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = <span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> selected = filter(<span class="function"><span class="params">book</span> =&gt;</span> publishedInYear(book, year), books)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果能将 <code>filter</code> 和 <code>map</code> 组合成 &quot;pipeline&quot; 就好了，但我们并不知道该如何处理，因为 <code>filter</code> 和 <code>map</code> 都是二元函数。</p>
<p>如果不需要在 <code>filter</code> 中使用箭头函数会更好些。先来解决这个问题，并借此展示一些制作 &quot;pipeline&quot; 的知识。</p>
<h2 id="gao-jie-han-shu">高阶函数</h2>
<p>在本系列文章的<a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="external">第一篇</a>中，我们将函数视为 &quot;一等结构&quot;。一等函数可以作为参数传递给其他函数，也可以作为其他函数的返回值。我们一直在使用前者，但还没有见过后者（函数作为其他函数的返回值）。</p>
<p>获取或返回其他函数的函数称为 &quot;高阶函数&quot;。</p>
<p>在上面的示例中，我们传递了一个箭头函数给 <code>filter</code>：<code>book =&gt; publishedInYear(book, year)</code>，但我们想去掉箭头函数。为了做到这点，需要一个函数：输入一本书，若该书是在指定年份出版的则返回 <code>true</code>。但还需要一个指定的年份，让该操作更加灵活。</p>
<p>为了解决这个问题，可以将 <code>publishedInYear</code> 变为返回另一个函数的函数。我将使用普通的语法来实现该函数，以便能够清晰地展示其内部具体实现，然后使用箭头函数实现一个更短版本的函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Full function version:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">publishedInYear</span>(<span class="params">year</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">book</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> book.year === year</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="comment">// Arrow function version:</span></div><div class="line"><span class="keyword">const</span> publishedInYear = <span class="function"><span class="params">year</span> =&gt;</span> book =&gt; book.year === year</div></pre></td></tr></table></figure></p>
<p>利用新实现的 <code>publishedInYear</code>，可以重写 <code>filter</code> 调用，从而消除箭头函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = <span class="function"><span class="params">year</span> =&gt;</span> book =&gt; book.year === year</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(year), books)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在，当调用 <code>filter</code> 时，<code>publishedInYear(year)</code> 会立即调用，并返回一个接受 <code>book</code> 为参数的函数，这正是 <code>filter</code> 需要的。</p>
<h2 id="bu-fen-ying-yong-han-shu">部分应用函数</h2>
<p>可以按上面的方式重写任何多参数函数。但我们不可能拥有所有我们想要的函数的源码；另外，很多情况下，我们可能还是希望以普通的方式调用多参数函数。</p>
<p>例如，在其他一些代码中，只是想检查一本书是否是在指定年份出版的，我们可能想要 <code>publishedInYear(book, 2012)</code>，但现在不能再那么做了。相反，我们必须要用这种方式：<code>publishedInYear(book)(2012)</code>。这样做降低了代码的可读性，也很烦人。</p>
<p>幸运的是，Ramda 提供了两个函数：<code>partial</code> 和 <code>partialRight</code>，来帮我们解决这个问题。</p>
<p>这两个函数可以让我们不必一次传递所有需要的参数，也可以调用函数。它们都返回一个接受剩余参数的新函数，当所有参数都传入后，才会真正调用被包裹的原函数。</p>
<p><code>partial</code> 和 <code>partialRight</code> 的区别在于参数传递的顺序：<code>partial</code> 先传递原函数左侧的参数，而 <code>partialRight</code> 先传递右侧的参数。</p>
<p>回到刚开始的例子，使用上面的一个函数来代替原来对 <code>publishedInYear</code> 的重写。由于刚开始我们只需要最右侧的参数：<code>year</code>，所以需要使用 <code>partialRight</code>.</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = <span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> selected = filter(partialRight(publishedInYear, [year]), books)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 <code>pubilshedInYear</code> 原本参数的顺序为 <code>(year, book)</code> ，而非 <code>(book, year)</code> ，则需要用 <code>partial</code> 代替 <code>partialRight</code>。</p>
<p>注意，为被 <code>partial</code> 和 <code>partialRight</code> 包裹的函数提供的参数必须包裹在数组中，即使只有一个参数。我不会告诉你我已经忘记了多少次，导致出现令人困惑的错误信息：</p>
<p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">First argument to _arity must be a non-negative <span class="built_in">integer</span> no greater than ten</div></pre></td></tr></table></figure></p>
<h2 id="ke-li-hua-curry">柯里化(Curry)</h2>
<p>如果到处使用 <code>partial</code> 和 <code>partialRight</code> 的话，会让代码变得冗长乏味；但是，将多元函数以一系列一元函数的形式调用同样不好。</p>
<p>幸运的是，Ramda 给我们提供了一个解决方案：<code>curry</code>。</p>
<p><a href="https://en.wikipedia.org/wiki/Currying" target="_blank" rel="external">Currying（柯里化）</a> 是函数式编程的另一个核心概念。从技术角度讲，一个柯里化了的函数是一系列高阶一元函数，这也是我刚刚抱怨过的。在纯函数式语言中，柯里化函数在调用时，语法上看起来和调用多个参数没有什么区别。</p>
<p>但由于 Ramda 是一个 JavaScript 库，而 JavaScript 并没有很好的语法来支持一系列一元函数的调用，所以作者对传统柯里化的定义放宽了一些。</p>
<p>在 Ramda 中，一个柯里化的函数只能用其参数的子集来调用，它会返回一个接受其余参数的新函数。当使用它的所有参数调用，真正的原函数将被调用。</p>
<p>柯里化的函数在下列两种情况下工作的都很好：</p>
<ol>
<li>可以按正常情况下使用所有参数调用它，它可以像普通函数一样正常工作；</li>
<li>也可以使用部分参数来调用它，这时它会像使用 <code>partial</code> 一样工作。</li>
</ol>
<p>注意，这种灵活性带来了一些性能上的损失，因为 <code>curry</code> 需要搞清楚函数的调用方式，然后确定该做什么。一般来说，我只有需要在多个地方对同一个函数使用 <code>partial</code> 的时候，才会对函数进行柯里化。</p>
<p>接下来写一个柯里化版本的 <code>publishedInYear</code> 函数。注意，<code>curry</code> 会像 <code>partial</code> 一样工作；并且没有 <code>partialRight</code> 版本的 <code>curry</code> 函数。对这方面后续会有更多讨论，但现在我们需要将 <code>publishedInYear</code> 的参数翻转一下，以便让参数 <code>year</code> 在最前面。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(year), books)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在可以只使用参数 <code>year</code> 来调用 <code>publishedInYear</code>，并返回一个新函数，该函数接受参数 <code>book</code> 并执行原函数。但是，仍然可以按普通方式对它调用：<code>publishedInYear(2012, book)</code>，不需要写烦人的语法 <code>)(</code>。所以，柯里化的函数在两种情况下都能很好地工作。</p>
<h2 id="can-shu-de-shun-xu">参数的顺序</h2>
<p>注意，为了让 <code>curry</code> 工作，我们不得不对参数的顺序进行翻转。这在函数式编程中非常常见，所以几乎所有的 Ramda 函数都将待处理的数据放到参数列表的最后面。</p>
<p>你可以将先期传入的参数看作对操作的配置。所以，对于 <code>publishedInYear</code>，参数 <code>year</code> 作为配置（需要查找的年份），而参数 <code>book</code> 作为被处理的数据（被查找的对象）。</p>
<p>我们已经在集合迭代函数中见过这样的例子。它们都将集合作为最后一个参数，这样可以使这种风格的编程更容易些。</p>
<h2 id="shun-xu-cuo-wu-de-can-shu">顺序错误的参数</h2>
<p>如果不改变 <code>publishedInYear</code> 的顺序，还可以继续使用柯里化特性的优势吗？</p>
<p>当然可以了，Ramda 提供了几个选择。</p>
<h2 id="flip">flip</h2>
<p>第一个选择是 <code>flip</code>。<code>flip</code> 接受一个多元函数（元数 &gt;= 2），返回一个元数相同的新函数，但前 2 个参数的顺序调换了。它主要用于二元函数，但也可以用于一般函数。</p>
<p>使用 <code>flip</code>，我们可以恢复 <code>publishedInYear</code> 参数的初始的顺序：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> selected = filter(flip(publishedInYear)(year), books)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>多数情况下，我更喜欢使用方便的参数顺序，但如果用到不能自己掌控的函数，<code>flip</code> 是一个好的选择。</p>
<h2 id="placeholder-zhan-wei-fu">placeholder (占位符)</h2>
<p>更通用的选择是使用 &quot;placeholder&quot; 参数（<code>__</code>）</p>
<p>假设有一个三元柯里化的函数，并且我们想传入第一个和最后一个参数，中间参数后续再传，应该怎么办呢？我们可以使用 &quot;占位符&quot; 作为中间参数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> threeArgs = curry(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> middleArgumentLater = threeArgs(<span class="string">'value for a'</span>, __, <span class="string">'value for c'</span>)</div></pre></td></tr></table></figure></p>
<p>可以在函数调用中多次使用 &quot;占位符&quot;。例如，如果只想传递中间参数呢？</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> threeArgs = curry(<span class="function">(<span class="params">a, b, c</span>) =&gt;</span> &#123; <span class="comment">/* ... */</span> &#125;)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> middleArgumentOnly = threeArgs(__, <span class="string">'value for b'</span>, __)</div></pre></td></tr></table></figure></p>
<p>也可以使用 &quot;占位符&quot; 代替 <code>flip</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">book, year</span>) =&gt;</span> book.year === year)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(__, year), books)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我觉得这个版本的可读性更好，但如果需要频繁使用参数顺序翻转的 <code>publishedInYear</code>，我可能会使用 <code>flip</code> 定义一个辅助函数，然后在任何用到它的地方使用辅助函数。在后续文章中会看到一些示例。</p>
<p>注意， <code>__</code> 仅适用于柯里化的函数，而 <code>partial</code>、<code>partialRight</code> 和 <code>flip</code> 适用于任何函数。如果需要对某个普通函数使用 <code>__</code>，可以先用 <code>curry</code> 将其包裹起来。</p>
<h2 id="lai-zuo-yi-tiao-guan-dao-pipeline">来做一条管道（pipeline）</h2>
<p>现在看看能否将我们的 <code>filter</code> 和 <code>map</code> 调用放入 &quot;pipeline&quot; (管道)中？下面是代码当前的状态，使用了方便的参数顺序的 <code>publishedInYear</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> selected = filter(publishedInYear(year), books)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> map(<span class="function"><span class="params">book</span> =&gt;</span> book.title, selected)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在上一节中，我们了解了 <code>pipe</code> 和 <code>compose</code>，但我们还需要另一部分信息，以便能够使用上面所学的知识。</p>
<p>缺少的信息是：几乎所有的 Ramda 函数都是默认柯里化的，包括 <code>filter</code> 和 <code>map</code>。所以 <code>filter(publishedInYear(year))</code> 是完全合法的，它会返回一个新函数，该函数等待我们传递 <code>books</code> 给它，<code>map(book =&gt; book.title)</code> 也是如此。</p>
<p>现在可以编写 &quot;pipeline&quot; 了：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = <span class="function">(<span class="params">books, year</span>) =&gt;</span></div><div class="line">  pipe(</div><div class="line">    filter(publishedInYear(year)),</div><div class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</div><div class="line">  )(books)</div></pre></td></tr></table></figure></p>
<p>我们来更进一步，将 <code>titlesForYear</code> 的参数顺序也调换一下，这样更符合 Ramda 中待处理数据放在最后的约定。也可以将该函数进行柯里化，以便其在后续的 &quot;pipeline&quot; 中使用。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> publishedInYear = curry(<span class="function">(<span class="params">year, book</span>) =&gt;</span> book.year === year)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> titlesForYear = curry(<span class="function">(<span class="params">year, books</span>) =&gt;</span></div><div class="line">  pipe(</div><div class="line">    filter(publishedInYear(year)),</div><div class="line">    map(<span class="function"><span class="params">book</span> =&gt;</span> book.title)</div><div class="line">  )(books)</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h2 id="jie-lun">结论</h2>
<p>本文可能是这个系列中讲解最深的一篇。部分应用和柯里化可能需要花一些时间和精力来熟悉和掌握。但一旦学会，他们会以一种强大的方式将数据处理变得更加函数式。</p>
<p>它们引导你通过创建包含许多小而简单代码块的 &quot;pipeline&quot; 的方式，来构建数据处理程序。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>为了以函数式的方式编写代码，我们需要用 &quot;声明式&quot; 的思维代替 &quot;命令式&quot; 思维。要做到这点，需要找到一种函数式的方式来表示命令式的结构。<a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Declarative-Programming/" target="_blank" rel="external">声明式编程</a> 将会讨论这些想法。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="//schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/06/10/Thinking-in-Ramda-Combining-Functions/" itemprop="url">
                  Thinking in Ramda: 函数组合
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2017-06-10T15:38:05+08:00" content="2017-06-10">
              2017-06-10
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Thinking-in-Ramda/" itemprop="url" rel="index">
                    <span itemprop="name">Thinking in Ramda</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2017/06/10/Thinking-in-Ramda-Combining-Functions/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2017/06/10/Thinking-in-Ramda-Combining-Functions/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>译者注：本文翻译自 Randy Coulman 的 《<a href="http://randycoulman.com/blog/2016/05/31/thinking-in-ramda-combining-functions/" target="_blank" rel="external">Thinking in Ramda: Combining Functions</a>》，转载请与<a href="https://github.com/randycoulman" target="_blank" rel="external">原作者</a>或<a href="https://github.com/adispring" target="_blank" rel="external">本人</a>联系。下面开始正文。</p>
<hr>
<p>本文是函数式编程系列文章：<a href="https://adispring.coding.me/categories/Thinking-in-Ramda/" target="_blank" rel="external">Thinking in Ramda</a> 的第二篇。</p>
<p>在<a href="https://adispring.coding.me/2017/06/09/Thinking-in-Ramda-%E5%85%A5%E9%97%A8/" target="_blank" rel="external">第一节</a>中，介绍了 Ramda 和函数式编程的一些基本思想，如函数、纯函数和数据不变性。并介绍了如何入门：可以从集合迭代函数（如 <code>forEach</code>、<code>map</code>、<code>reduce</code>）开始。</p>
<h2 id="jian-dan-zu-he">简单组合</h2>
<p>一旦熟悉了可以将函数传递给其他函数，你可能会开始找将多个函数组合在一起的场景。</p>
<p>Ramda 为简单的函数组合提供了一些函数。我们来看看。</p>
<h2 id="complement">Complement</h2>
<p>在上一节，我们使用 <code>find</code> 来查找列表中的首个偶数。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></div><div class="line">find(isEven, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">//=&gt; 2</span></div></pre></td></tr></table></figure></p>
<p>如果想找首个奇数呢？我们可以随手写一个 <code>isOdd</code> 函数并使用它。但我们知道任何非偶整数都是奇数，所以可以重用 <code>isEven</code> 函数。</p>
<p>Ramda 提供了一个更高阶的函数：<code>complement</code>，给它传入一个函数，返回一个新的函数：当原函数返回 &quot;假值&quot; 时，新函数返回 <code>true</code>；原函数返回 &quot;真值&quot; 时，新函数返回 <code>false</code>，即新函数是原函数的补函数。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></div><div class="line"> </div><div class="line">find(complement(isEven), [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// --&gt; 1</span></div></pre></td></tr></table></figure></p>
<p>更进一步，可以给 <code>complement</code> 过的函数起个名字，这样新函数便可以复用：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isEven = <span class="function"><span class="params">x</span> =&gt;</span> x % <span class="number">2</span> === <span class="number">0</span></div><div class="line"><span class="keyword">const</span> isOdd = complement(isEven)</div><div class="line"> </div><div class="line">find(isOdd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]) <span class="comment">// --&gt; 1</span></div></pre></td></tr></table></figure></p>
<p>注意，<code>complement</code> 以函数的方式实现了逻辑非操作（<code>!</code>， not）的功能。</p>
<p><code>Both/Either</code></p>
<p>假设我们正在开发一个投票系统，给定一个人，我们希望能够确定其是否有资格投票。根据现有知识，一个人必须年满 18 岁并且是本国公民，才有资格投票。成为公民的条件：在本国出生，或者后来加入该国国籍。</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> wasBornInCountry = <span class="function"><span class="params">person</span> =&gt;</span> person.birthCountry === OUR_COUNTRY</div><div class="line"><span class="keyword">const</span> wasNaturalized = <span class="function"><span class="params">person</span> =&gt;</span> <span class="built_in">Boolean</span>(person.naturalizationDate)</div><div class="line"><span class="keyword">const</span> isOver18 = <span class="function"><span class="params">person</span> =&gt;</span> person.age &gt;= <span class="number">18</span></div><div class="line"> </div><div class="line"><span class="keyword">const</span> isCitizen = <span class="function"><span class="params">person</span> =&gt;</span> wasBornInCountry(person) || wasNaturalized(person)</div><div class="line"> </div><div class="line"><span class="keyword">const</span> isEligibleToVote = <span class="function"><span class="params">person</span> =&gt;</span> isOver18(person) &amp;&amp; isCitizen(person)</div></pre></td></tr></table></figure></p>
<p>上面代码实现了我们的需求，但 Ramda 提供了一些方便的函数，以帮助我们精简代码。</p>
<p><code>both</code> 接受两个函数，返回一个新函数：当两个传入函数都返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>
<p><code>either</code> 接受两个函数，返回一个新函数：当两个传入函数任意一个返回 <code>truthy</code> 值时，新函数返回 <code>true</code>，否则返回 <code>false</code></p>
<p>我们可以使用这两个函数来简化 <code>isCitizen</code> 和 <code>isEligibleToVote</code>。
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> isCitizen = either(wasBornInCountry, wasNaturalized)</div><div class="line"><span class="keyword">const</span> isEligibleToVote = both(isOver18, isCitizen)</div></pre></td></tr></table></figure></p>
<p>注意，<code>both</code> 以函数的方式实现了逻辑与（<code>&amp;&amp;</code>）的功能，<code>either</code> 实现了逻辑或（<code>||</code>）的功能。</p>
<p>Ramda 还提供了 <code>allPass</code> 和 <code>anyPass</code>，接受由任意多个函数组成的数组作为参数。如名称所示，<code>allPass</code> 类似于 <code>both</code>，而 <code>anyPass</code> 类似于 <code>either</code>。</p>
<h2 id="pipelines-guan-dao">Pipelines(管道)</h2>
<p>有时我们需要以 pipeline 的方式将多个函数依次作用于某些数据。例如，接受两个数字，将它们相乘，加 1 ，然后平方。我们可以这样写：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> multiply = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a * b</div><div class="line"><span class="keyword">const</span> addOne = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span></div><div class="line"><span class="keyword">const</span> square = <span class="function"><span class="params">x</span> =&gt;</span> x * x</div><div class="line"> </div><div class="line"><span class="keyword">const</span> operate = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> product = multiply(x, y)</div><div class="line">  <span class="keyword">const</span> incremented = addOne(product)</div><div class="line">  <span class="keyword">const</span> squared = square(incremented)</div><div class="line"> </div><div class="line">  <span class="keyword">return</span> squared</div><div class="line">&#125;</div><div class="line"> </div><div class="line">operate(<span class="number">3</span>, <span class="number">4</span>) <span class="comment">// =&gt; ((3 * 4) + 1)^2 =&gt; (12 + 1)^2 =&gt; 13^2 =&gt; 169</span></div></pre></td></tr></table></figure></p>
<p>注意，每次操作是对上次操作的结果进行处理。</p>
<h2 id="pipe">pipe</h2>
<p>Ramda 提供了 <code>pipe</code> 函数：接受一系列函数，并返回一个新函数。</p>
<p>新函数的元数与第一个传入函数的元数相同（元数：接受参数的个数），然后顺次通过 &quot;管道&quot; 中的函数对输入参数进行处理。它将第一个函数作用于参数，返回结果作为下一个函数的入参，依次进行下去。&quot;管道&quot; 中最后一个函数的结果作为 <code>pipe</code> 调用的最终结果。</p>
<p>注意，除首个函数外，其余的函数都是一元函数。</p>
<p>了解这些后，我们可以使用 <code>pipe</code> 来简化我们的 <code>operate</code> 函数：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> operate = pipe(</div><div class="line">  multiply,</div><div class="line">  addOne,</div><div class="line">  square</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>当调用 <code>operate(3, 4)</code> 时，<code>pipe</code> 将 <code>3</code> 和 <code>4</code> 传给 <code>multiply</code> 函数，输出 <code>12</code>，然后将 <code>12</code> 传给 <code>addOne</code>，返回 <code>13</code>，然后将 <code>13</code> 传给 <code>square</code>，返回 <code>169</code>，并将 <code>169</code> 作为最终 <code>operate</code> 的最终结果返回。</p>
<h2 id="compose">compose</h2>
<p>另一种编写原始 <code>operate</code> 函数的方式是内联所有暂时变量：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> operate = <span class="function">(<span class="params">x, y</span>) =&gt;</span> square(addOne(multiply(x, y)))</div></pre></td></tr></table></figure></p>
<p>这样更紧凑，但也更不便于阅读。然而这种形式可以使用 Ramda 的 <code>compose</code> 函数进行重写。</p>
<p><code>compose</code> 的工作方式跟 <code>pipe</code> 基本相同，除了其调用函数的顺序是从右到左，而不是从左到右。下面使用 <code>compose</code> 来重写 <code>operate</code>：</p>
<p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> operate = compose(</div><div class="line">  square,</div><div class="line">  addOne,</div><div class="line">  multiply</div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>这与上面的 <code>pipe</code> 几乎一样，除了函数的顺序是相反的。实际上，Ramda 中的 <code>compose</code> 函数的内部是用 <code>pipe</code> 实现的。</p>
<p>我一直这样思考 <code>compose</code> 的工作方式：<code>compose(f, g)(value)</code> 等价于 <code>f(g(value))</code>。</p>
<p>注意，与 <code>pipe</code> 类似，<code>compose</code> 中的函数除最后一个外，其余都是一元函数。</p>
<h2 id="compose-huan-shi-pipe">compose 还是 pipe？</h2>
<p>具有命令式编程背景的人可能觉得 <code>pipe</code> 更容易理解，因为可以按照从左往右的顺序进行阅读。但 <code>compose</code> 更容易对如上所示的嵌套函数进行转换。</p>
<p>我也不太清楚什么时候该用 <code>compose</code>，什么时候该用 <code>pipe</code>。由于它们在 Ramda 中基本等价，所以选择用哪个可能并不重要。只要根据自己的情况选择合适的即可。</p>
<h2 id="jie-lun">结论</h2>
<p>通过特定的方式进行函数组合，我们已经可以开始编写更强的函数了。</p>
<h2 id="xia-yi-jie">下一节</h2>
<p>你可能已经注意到了，在进行函数组合时，我们多数情况下都可以省略函数参数。只有在最终调用组合好的函数时，才传入参数。</p>
<p>这在函数式编程中非常常见，我们将在下一节 <a href="https://adispring.coding.me/2017/06/11/Thinking-in-Ramda-Partial-Application/" target="_blank" rel="external"><code>Partial Application</code> (部分应用)</a>进行更多详细介绍。我们还会讨论如何组合多元（多参数）函数。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="//schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="wangzengdi" />
          <p class="site-author-name" itemprop="name">wangzengdi</p>
          <p class="site-description motion-element" itemprop="description">FE@Meituan.com</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">27</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">6</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/adispring" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
          
        </div>

        
        

        
        

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wangzengdi</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/jquery.lazyload/1.9.3/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/velocity/1.2.3/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdn.jsdelivr.net/fancybox/2.1.5/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.2"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.2"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'adispring';
      var disqus_identifier = 'page/2/index.html';
      var disqus_title = "";
      var disqus_url = '';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
    </script>
  




  
  

  

  

  

  


</body>
</html>
